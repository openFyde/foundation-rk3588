Index: src/media/gpu/sandbox/hardware_video_decoding_sandbox_hook_linux.cc
===================================================================
--- src.orig/media/gpu/sandbox/hardware_video_decoding_sandbox_hook_linux.cc
+++ src/media/gpu/sandbox/hardware_video_decoding_sandbox_hook_linux.cc
@@ -7,6 +7,7 @@
 #include <dlfcn.h>
 #include <sys/stat.h>
 
+#include "base/types/cxx23_to_underlying.h"
 #include "base/process/process_metrics.h"
 #include "base/strings/stringprintf.h"
 #include "media/gpu/buildflags.h"
@@ -134,11 +135,14 @@ bool HardwareVideoDecodingPreSandboxHook
     std::vector<BrokerFilePermission>& permissions) {
 #if BUILDFLAG(USE_V4L2_CODEC)
   command_set.set(sandbox::syscall_broker::COMMAND_OPEN);
+  command_set.set(sandbox::syscall_broker::COMMAND_STAT);
+  command_set.set(sandbox::syscall_broker::COMMAND_READLINK);
+  command_set.set(sandbox::syscall_broker::COMMAND_INOTIFY_ADD_WATCH);
 
   // TODO(b/210759684): we should open the render node for minigbm before
   // entering the sandbox so that we can remove this permission.
   AllowAccessToRenderNodes(permissions, /*include_sys_dev_char=*/false,
-                           /*read_write=*/false);
+                           /*read_write=*/true);
 
   // Device nodes for V4L2 video decode accelerator drivers.
   // We do not use a FileEnumerator because the device files may not exist yet
@@ -167,6 +171,32 @@ bool HardwareVideoDecodingPreSandboxHook
   // platforms that need it.
   static const char kDevImageProc0Path[] = "/dev/image-proc0";
   permissions.push_back(BrokerFilePermission::ReadWrite(kDevImageProc0Path));
+  permissions.push_back(BrokerFilePermission::ReadOnly("/proc/device-tree/compatible"));
+  permissions.push_back(BrokerFilePermission::ReadWrite("/dev/mpp_service"));
+  permissions.push_back(BrokerFilePermission::ReadOnly("/etc/localtime"));
+  permissions.push_back(BrokerFilePermission::ReadWrite("/dev/rga"));
+  permissions.push_back(BrokerFilePermission::ReadWrite("/var/log/libv4l2.log"));
+  constexpr unsigned int kFlags = RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE;
+#if defined(__aarch64__)
+  if (nullptr == dlopen("/usr/lib64/libv4l/plugins/libv4l-encplugin.so", kFlags)) {
+    LOG(ERROR) << "dlopen(libv4l-encplugin.so) failed with error: " << dlerror();
+    return false;
+  }
+  if (nullptr == dlopen("/usr/lib64/libv4l2.so", kFlags)) {
+    LOG(ERROR) << "dlopen(libv4l2.so) failed with error: " << dlerror();
+    return false;
+  }
+#else
+  if (nullptr == dlopen("/usr/lib/libv4l/plugins/libv4l-encplugin.so", kFlags)) {
+    LOG(ERROR) << "dlopen(libv4l-encplugin.so) failed with error: " << dlerror();
+    return false;
+  }
+  if (nullptr == dlopen("/usr/lib/libv4l2.so", kFlags)) {
+    LOG(ERROR) << "dlopen(libv4l2.so) failed with error: " << dlerror();
+    return false;
+  }
+#endif  // defined(__aarch64__)
+  LOG(INFO) << "success to load libv4l2.so";
   return true;
 #else
   NOTREACHED_NORETURN();
@@ -209,6 +239,7 @@ bool HardwareVideoDecodingPreSandboxHook
   std::vector<BrokerFilePermission> permissions;
 
   bool result_for_platform_policy;
+  LOG(INFO) << "policy type:" << base::to_underlying(policy_type);
   switch (policy_type) {
     case PolicyType::kVaapiOnIntel:
       result_for_platform_policy =
Index: src/media/gpu/sandbox/hardware_video_encoding_sandbox_hook_linux.cc
===================================================================
--- src.orig/media/gpu/sandbox/hardware_video_encoding_sandbox_hook_linux.cc
+++ src/media/gpu/sandbox/hardware_video_encoding_sandbox_hook_linux.cc
@@ -29,6 +29,9 @@ bool HardwareVideoEncodingPreSandboxHook
 
 #if BUILDFLAG(USE_V4L2_CODEC)
   command_set.set(sandbox::syscall_broker::COMMAND_OPEN);
+  command_set.set(sandbox::syscall_broker::COMMAND_STAT);
+  command_set.set(sandbox::syscall_broker::COMMAND_READLINK);
+  command_set.set(sandbox::syscall_broker::COMMAND_INOTIFY_ADD_WATCH);
 
   // Device nodes for V4L2 video encode accelerator drivers.
   // We do not use a FileEnumerator because the device files may not exist
@@ -50,6 +53,33 @@ bool HardwareVideoEncodingPreSandboxHook
   // permission to only platforms that need it.
   static const char kDevImageProc0Path[] = "/dev/image-proc0";
   permissions.push_back(BrokerFilePermission::ReadWrite(kDevImageProc0Path));
+  permissions.push_back(BrokerFilePermission::ReadOnly("/proc/device-tree/compatible"));
+  permissions.push_back(BrokerFilePermission::ReadWrite("/dev/mpp_service"));
+  permissions.push_back(BrokerFilePermission::ReadWrite("/dev/rga"));
+  permissions.push_back(BrokerFilePermission::ReadWrite("/dev/dri/renderD128"));
+  permissions.push_back(BrokerFilePermission::ReadOnly("/etc/localtime"));
+  permissions.push_back(BrokerFilePermission::ReadWrite("/var/log/libv4l2.log"));
+  constexpr unsigned int kFlags = RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE;
+#if defined(__aarch64__)
+  if (nullptr == dlopen("/usr/lib64/libv4l/plugins/libv4l-encplugin.so", kFlags)) {
+    LOG(ERROR) << "dlopen(libv4l-encplugin.so) failed with error: " << dlerror();
+    return false;
+  }
+  if (nullptr == dlopen("/usr/lib64/libv4l2.so", kFlags)) {
+    LOG(ERROR) << "dlopen(libv4l2.so) failed with error: " << dlerror();
+    return false;
+  }
+#else
+  if (nullptr == dlopen("/usr/lib/libv4l/plugins/libv4l-encplugin.so", kFlags)) {
+    LOG(ERROR) << "dlopen(libv4l-encplugin.so) failed with error: " << dlerror();
+    return false;
+  }
+  if (nullptr == dlopen("/usr/lib/libv4l2.so", kFlags)) {
+    LOG(ERROR) << "dlopen(libv4l2.so) failed with error: " << dlerror();
+    return false;
+  }
+#endif  // defined(__aarch64__)
+  LOG(INFO) << "success to load libv4l2.so";
 #elif BUILDFLAG(USE_VAAPI)
   command_set.set(sandbox::syscall_broker::COMMAND_OPEN);
   command_set.set(sandbox::syscall_broker::COMMAND_STAT);
Index: src/media/gpu/v4l2/BUILD.gn
===================================================================
--- src.orig/media/gpu/v4l2/BUILD.gn
+++ src/media/gpu/v4l2/BUILD.gn
@@ -8,10 +8,18 @@ import("//build/config/ui.gni")
 import("//media/gpu/args.gni")
 import("//media/media_options.gni")
 import("//testing/test.gni")
+import("//tools/generate_stubs/rules.gni")
 import("//ui/gl/features.gni")
 
 assert(use_v4l2_codec)
 
+generate_stubs("libv4l2_stubs") {
+  extra_header = "v4l2_stub_header.fragment"
+  sigs = [ "v4l2.sig" ]
+  output_name = "v4l2_stubs"
+  deps = [ "//base" ]
+}
+
 source_set("v4l2") {
   defines = [ "MEDIA_GPU_IMPLEMENTATION" ]
   sources = [
@@ -113,6 +121,7 @@ source_set("v4l2") {
   public_deps = [ "//ui/gl" ]
 
   deps = [
+    ":libv4l2_stubs",
     ":v4l2_status",
     "//base",
     "//build/config/linux/libdrm",
Index: src/media/gpu/v4l2/v4l2.sig
===================================================================
--- src.orig/media/gpu/v4l2/v4l2.sig
+++ src/media/gpu/v4l2/v4l2.sig
@@ -8,3 +8,5 @@
 LIBV4L_PUBLIC int v4l2_close(int fd);
 LIBV4L_PUBLIC int v4l2_ioctl(int fd, unsigned long int request, ...);
 LIBV4L_PUBLIC int v4l2_fd_open(int fd, int v4l2_flags);
+LIBV4L_PUBLIC void *v4l2_mmap(void *start, size_t length, int prot, int flags, int fd, int64_t offset);
+LIBV4L_PUBLIC int v4l2_munmap(void *_start, size_t length);
Index: src/media/gpu/v4l2/v4l2_device.cc
===================================================================
--- src.orig/media/gpu/v4l2/v4l2_device.cc
+++ src/media/gpu/v4l2/v4l2_device.cc
@@ -34,6 +34,13 @@
 #include "media/gpu/v4l2/v4l2_queue.h"
 #include "media/gpu/v4l2/v4l2_utils.h"
 #include "ui/gl/egl_util.h"
+#include "media/gpu/v4l2/v4l2_stubs.h"
+#include "third_party/v4l-utils/lib/include/libv4l2.h"
+
+using media_gpu_v4l2::InitializeStubs;
+using media_gpu_v4l2::IsV4l2Initialized;
+using media_gpu_v4l2::kModuleV4l2;
+using media_gpu_v4l2::StubPathMap;
 
 namespace media {
 
@@ -56,7 +63,7 @@ uint32_t V4L2PixFmtToDrmFormat(uint32_t
       return DRM_FORMAT_ARGB8888;
 
     default:
-      DVLOGF(1) << "Unrecognized format " << FourccToString(format);
+      VLOGF(1) << "Unrecognized format " << FourccToString(format);
       return 0;
   }
 }
@@ -79,6 +86,12 @@ class V4L2QueueFactory {
 };
 
 V4L2Device::V4L2Device() {
+  StubPathMap paths;
+  if (!IsV4l2Initialized()) {
+    paths[kModuleV4l2].push_back(V4L2Device::kLibV4l2Path);
+    if (!InitializeStubs(paths))
+      LOG(ERROR) << "failed to init v4l2 lib.";
+  }
   DETACH_FROM_SEQUENCE(client_sequence_checker_);
 }
 
@@ -121,7 +134,7 @@ void V4L2Device::OnQueueDestroyed(v4l2_b
 }
 
 bool V4L2Device::Open(Type type, uint32_t v4l2_pixfmt) {
-  DVLOGF(3);
+  VLOGF(3);
   std::string path = GetDevicePathFor(type, v4l2_pixfmt);
 
   if (path.empty()) {
@@ -187,7 +200,7 @@ int32_t V4L2Device::VideoCodecProfileToV
     case H264PROFILE_MULTIVIEWHIGH:
       return V4L2_MPEG_VIDEO_H264_PROFILE_MULTIVIEW_HIGH;
     default:
-      DVLOGF(1) << "Add more cases as needed";
+      VLOGF(1) << "Add more cases as needed";
       return -1;
   }
 }
@@ -228,7 +241,7 @@ int32_t V4L2Device::H264LevelIdcToV4L2H2
     case 51:
       return V4L2_MPEG_VIDEO_H264_LEVEL_5_1;
     default:
-      DVLOGF(1) << "Unrecognized level_idc: " << static_cast<int>(level_idc);
+      VLOGF(1) << "Unrecognized level_idc: " << static_cast<int>(level_idc);
       return -1;
   }
 }
@@ -323,7 +336,7 @@ gfx::Size V4L2Device::AllocatedSizeFromV
 
 int V4L2Device::Ioctl(int request, void* arg) {
   DCHECK(device_fd_.is_valid());
-  return HANDLE_EINTR(ioctl(device_fd_.get(), request, arg));
+  return HANDLE_EINTR(v4l2_ioctl(device_fd_.get(), request, arg));
 }
 
 bool V4L2Device::Poll(bool poll_device, bool* event_pending) {
@@ -357,11 +370,11 @@ void* V4L2Device::Mmap(void* addr,
                        int flags,
                        unsigned int offset) {
   DCHECK(device_fd_.is_valid());
-  return mmap(addr, len, prot, flags, device_fd_.get(), offset);
+  return v4l2_mmap(addr, len, prot, flags, device_fd_.get(), offset);
 }
 
 void V4L2Device::Munmap(void* addr, unsigned int len) {
-  munmap(addr, len);
+  v4l2_munmap(addr, len);
 }
 
 bool V4L2Device::SetDevicePollInterrupt() {
@@ -567,7 +580,7 @@ V4L2Device::EnumerateSupportedDecodeProf
       profile.profile = video_codec_profile;
       profiles.push_back(profile);
 
-      DVLOGF(3) << "Found decoder profile " << GetProfileName(profile.profile)
+      VLOGF(3) << "Found decoder profile " << GetProfileName(profile.profile)
                 << ", resolutions: " << profile.min_resolution.ToString() << " "
                 << profile.max_resolution.ToString();
     }
@@ -837,14 +850,28 @@ bool V4L2Device::SetGOPLength(uint32_t g
 
 bool V4L2Device::OpenDevicePath(const std::string& path) {
   DCHECK(!device_fd_.is_valid());
-
+  if (!IsV4l2Initialized()) {
+    VLOGF(3) << "V4l2plugin is null.";
+    return false;
+  };
   device_fd_.reset(
       HANDLE_EINTR(open(path.c_str(), O_RDWR | O_NONBLOCK | O_CLOEXEC)));
+  if (!device_fd_.is_valid())
+    return false;
+
+  if (HANDLE_EINTR(v4l2_fd_open(device_fd_.get(), V4L2_DISABLE_CONVERSION)) !=
+          -1) {
+    VLOGF(3) << "Using libv4l2 for " << path;
+  } else {
+    VLOGF(3) << "Failed to open libv4l2 for " << path;
+  }
   return device_fd_.is_valid();
 }
 
 void V4L2Device::CloseDevice() {
-  DVLOGF(3);
+  VLOGF(3);
+  if (device_fd_.is_valid())
+    v4l2_close(device_fd_.release());
   device_fd_.reset();
 }
 
@@ -903,7 +930,7 @@ void V4L2Device::EnumerateDevicesForType
         base::BindRepeating(&V4L2Device::Ioctl, this), buf_type);
 
     if (!supported_pixelformats.empty()) {
-      DVLOGF(3) << "Found device: " << path;
+      VLOGF(3) << "Found device: " << path;
       devices.push_back(std::make_pair(path, supported_pixelformats));
     }
 
Index: src/media/gpu/v4l2/v4l2_device.h
===================================================================
--- src.orig/media/gpu/v4l2/v4l2_device.h
+++ src/media/gpu/v4l2/v4l2_device.h
@@ -96,6 +96,12 @@ class MEDIA_GPU_EXPORT V4L2Device
 
   V4L2Device();
 
+  inline static constexpr char kLibV4l2Path[] =
+#if defined(__aarch64__)
+      "/usr/lib64/libv4l2.so";
+#else
+      "/usr/lib/libv4l2.so";
+#endif
   // Open a V4L2 device of |type| for use with |v4l2_pixfmt|.
   // Return true on success.
   // The device will be closed in the destructor.
Index: src/sandbox/policy/linux/bpf_cros_arm_gpu_policy_linux.cc
===================================================================
--- src.orig/sandbox/policy/linux/bpf_cros_arm_gpu_policy_linux.cc
+++ src/sandbox/policy/linux/bpf_cros_arm_gpu_policy_linux.cc
@@ -42,6 +42,9 @@ ResultExpr CrosArmGpuProcessPolicy::Eval
 #endif  // defined(__arm__) || defined(__aarch64__)
 
   switch (sysno) {
+#if defined(__aarch64__)
+    case __NR_mmap:
+#endif
 #if defined(__arm__) || defined(__aarch64__)
     // ARM GPU sandbox is started earlier so we need to allow networking
     // in the sandbox.
@@ -50,8 +53,47 @@ ResultExpr CrosArmGpuProcessPolicy::Eval
     case __NR_getsockname:
     case __NR_sched_setaffinity:
     case __NR_sched_setscheduler:
+      return Allow();
     case __NR_sysinfo:
     case __NR_uname:
+    case __NR_ioctl:
+    case __NR_madvise:
+    case __NR_futex:
+      return Allow();
+    case __NR_process_vm_readv:
+    case __NR_clock_nanosleep:
+    case __NR_munmap:
+    case __NR_rt_sigprocmask:
+      return Allow();
+    case __NR_getpid:
+    case __NR_sendto:
+    case __NR_gettid:
+    case __NR_faccessat:
+      return Allow();
+    case __NR_fstatfs:
+    case __NR_set_robust_list:
+    case __NR_rseq:
+    case __NR_brk:
+    case __NR_clone:
+      return Allow();
+    case __NR_exit:
+    case __NR_lseek:
+    case __NR_fcntl:
+    case __NR_write:
+    case __NR_execve:
+      return Allow();
+    case __NR_set_tid_address:
+    case __NR_prlimit64:
+    case __NR_getrandom:
+    case __NR_rt_sigaction:
+      return Allow();
+    case __NR_exit_group:
+    case __NR_restart_syscall:
+    case __NR_rt_sigreturn:
+#if defined(__arm__)
+    // Only available on ARM 32bit devices
+    case __NR_mmap2:
+#endif
       return Allow();
     // Allow only AF_UNIX for |domain|.
     case __NR_socket:
Index: src/sandbox/policy/linux/bpf_hardware_video_decoding_policy_linux.cc
===================================================================
--- src.orig/sandbox/policy/linux/bpf_hardware_video_decoding_policy_linux.cc
+++ src/sandbox/policy/linux/bpf_hardware_video_decoding_policy_linux.cc
@@ -132,8 +132,57 @@ ResultExpr HardwareVideoDecodingProcessP
     return CrashSIGSYS();
   }
 
-  if (system_call_number == __NR_ioctl)
-    return Allow();
+  switch (system_call_number) {
+    case __NR_ioctl:
+    case __NR_madvise:
+    case __NR_futex:
+    case __NR_process_vm_readv:
+#if defined(__aarch64__)
+    case __NR_mmap:
+		case __NR_connect:
+    case __NR_getpeername:
+    case __NR_getsockname:
+    case __NR_sched_setaffinity:
+    case __NR_sched_setscheduler:
+      return Allow();
+    case __NR_sysinfo:
+    case __NR_uname:
+      return Allow();
+    case __NR_clock_nanosleep:
+    case __NR_munmap:
+    case __NR_rt_sigprocmask:
+      return Allow();
+    case __NR_getpid:
+    case __NR_sendto:
+    case __NR_newfstatat:
+    case __NR_gettid:
+    case __NR_faccessat:
+      return Allow();
+    case __NR_fstatfs:
+    case __NR_set_robust_list:
+    case __NR_rseq:
+    case __NR_brk:
+    case __NR_clone:
+      return Allow();
+    case __NR_exit:
+    case __NR_lseek:
+    case __NR_fcntl:
+    case __NR_write:
+    case __NR_execve:
+      return Allow();
+    case __NR_set_tid_address:
+    case __NR_prlimit64:
+    case __NR_getrandom:
+    case __NR_rt_sigaction:
+      return Allow();
+    case __NR_exit_group:
+    case __NR_restart_syscall:
+    case __NR_rt_sigreturn:
+#elif defined(__arm__)
+    case __NR_mmap2:
+#endif
+      return Allow();
+  }
 
   if (system_call_number == __NR_sched_setaffinity) {
     return RestrictSchedTarget(GetPolicyPid(), system_call_number);
Index: src/content/common/gpu_pre_sandbox_hook_linux.cc
===================================================================
--- src.orig/content/common/gpu_pre_sandbox_hook_linux.cc
+++ src/content/common/gpu_pre_sandbox_hook_linux.cc
@@ -94,11 +94,15 @@ static const char kLibGlesPath[] = "/usr
 static const char kLibEglPath[] = "/usr/lib64/libEGL.so.1";
 static const char kLibMaliPath[] = "/usr/lib64/libmali.so";
 static const char kLibTegraPath[] = "/usr/lib64/libtegrav4l2.so";
+static const char kLibV4l2Path[] = "/usr/lib64/libv4l2.so";
+static const char kLibRkmppPath[] = "/usr/lib64/libv4l/plugins/libv4l-encplugin.so";
 #else
 static const char kLibGlesPath[] = "/usr/lib/libGLESv2.so.2";
 static const char kLibEglPath[] = "/usr/lib/libEGL.so.1";
 static const char kLibMaliPath[] = "/usr/lib/libmali.so";
 static const char kLibTegraPath[] = "/usr/lib/libtegrav4l2.so";
+static const char kLibV4l2Path[] = "/usr/lib/libv4l2.so";
+static const char kLibRkmppPath[] = "/usr/lib/libv4l/plugins/libv4l-encplugin.so";
 #endif
 
 constexpr int dlopen_flag = RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE;
@@ -192,6 +196,14 @@ void AddV4L2GpuPermissions(
     permissions->push_back(
         BrokerFilePermission::ReadWrite(kAmlogicAvcEncoderPath));
   }
+
+  permissions->push_back(BrokerFilePermission::ReadOnly("/proc/device-tree/compatible"));
+  permissions->push_back(BrokerFilePermission::ReadWrite("/dev/mpp_service"));
+  permissions->push_back(BrokerFilePermission::ReadOnly("/etc/localtime"));
+  permissions->push_back(BrokerFilePermission::ReadWrite("/dev/rga"));
+  permissions->push_back(BrokerFilePermission::ReadWrite("/var/log/libv4l2.log"));
+  permissions->push_back(BrokerFilePermission::ReadOnly(kLibRkmppPath));
+  permissions->push_back(BrokerFilePermission::ReadOnly(kLibV4l2Path));
 }
 
 void AddArmMaliGpuPermissions(std::vector<BrokerFilePermission>* permissions) {
@@ -648,6 +660,11 @@ void LoadChromecastV4L2Libraries() {
   }
 }
 
+void LoadV4l2LibPlugInLibraries() {
+  dlopen(kLibV4l2Path, dlopen_flag);
+  dlopen(kLibRkmppPath, dlopen_flag);
+}
+
 bool LoadLibrariesForGpu(
     const sandbox::policy::SandboxSeccompBPF::Options& options) {
   LoadVulkanLibraries();
@@ -659,6 +676,9 @@ bool LoadLibrariesForGpu(
       if (!LoadAmdGpuLibraries())
         return false;
     }
+    if (UseV4L2Codec(options)) {
+      LoadV4l2LibPlugInLibraries();
+    }
   } else {
     if (UseChromecastSandboxAllowlist() && IsArchitectureArm()) {
       if (UseV4L2Codec(options)) {
Index: src/media/gpu/v4l2/v4l2_utils.cc
===================================================================
--- src.orig/media/gpu/v4l2/v4l2_utils.cc
+++ src/media/gpu/v4l2/v4l2_utils.cc
@@ -30,6 +30,9 @@
 #include "media/gpu/macros.h"
 #include "media/media_buildflags.h"
 #include "ui/gfx/geometry/size.h"
+#include "media/gpu/v4l2/v4l2_stubs.h"
+#include "third_party/v4l-utils/lib/include/libv4l2.h"
+#include "media/gpu/v4l2/v4l2_device.h"
 
 // This has not been accepted upstream.
 #ifndef V4L2_PIX_FMT_AV1
@@ -45,8 +48,34 @@
   std::make_pair(codec##_##suffix, codec)
 
 namespace {
+using media_gpu_v4l2::InitializeStubs;
+using media_gpu_v4l2::kModuleV4l2;
+using media_gpu_v4l2::StubPathMap;
+using media_gpu_v4l2::IsV4l2Initialized;
+using media::V4L2Device;
+
 int HandledIoctl(int fd, int request, void* arg) {
-  return HANDLE_EINTR(ioctl(fd, request, arg));
+  return HANDLE_EINTR(v4l2_ioctl(fd, request, arg));
+}
+bool InitV4l2Plugin() {
+	StubPathMap paths;
+	paths[kModuleV4l2].push_back(V4L2Device::kLibV4l2Path);
+	return InitializeStubs(paths);
+}
+
+bool OpenDevice(int fd) {
+  if (!IsV4l2Initialized() && !InitV4l2Plugin()) {
+    VLOG(2) << "Failed to init plugin";
+    return false;
+  }
+  if (HANDLE_EINTR(v4l2_fd_open(fd, V4L2_DISABLE_CONVERSION)) ==
+          -1)
+    return false;
+  return true;
+}
+
+void CloseDevice(int fd) {
+  v4l2_close(fd);
 }
 }  // namespace
 namespace media {
@@ -507,6 +536,10 @@ std::optional<SupportedVideoDecoderConfi
     PLOG(ERROR) << "Could not open " << kVideoDeviceDriverPath;
     return std::nullopt;
   }
+  if (!OpenDevice(device_fd.get())) {
+    LOG(ERROR) << "Failed to open libv4l2 device";
+    return std::nullopt;
+  }
 
   std::vector<uint32_t> v4l2_codecs = EnumerateSupportedPixFmts(
       base::BindRepeating(&HandledIoctl, device_fd.get()),
@@ -541,7 +574,7 @@ std::optional<SupportedVideoDecoderConfi
               << config.coded_size_max.ToString() << ")";
   }
 #endif
-
+  CloseDevice(device_fd.get());
   return supported_media_configs;
 }
 
@@ -552,6 +585,10 @@ bool IsV4L2DecoderStateful() {
   if (!device_fd.is_valid()) {
     return false;
   }
+	if (!OpenDevice(device_fd.get())) {
+    LOG(ERROR) << "Failed to open libv4l2 device";
+    return false;
+  }
 
   std::vector<uint32_t> v4l2_codecs = EnumerateSupportedPixFmts(
       base::BindRepeating(&HandledIoctl, device_fd.get()),
@@ -566,6 +603,7 @@ bool IsV4L2DecoderStateful() {
       V4L2_PIX_FMT_VP8,
       V4L2_PIX_FMT_VP9,
   };
+	CloseDevice(device_fd.get());
 
   return std::find_first_of(v4l2_codecs.begin(), v4l2_codecs.end(),
                             kSupportedStatefulInputCodecs.begin(),
Index: src/media/gpu/v4l2/v4l2_queue.cc
===================================================================
--- src.orig/media/gpu/v4l2/v4l2_queue.cc
+++ src/media/gpu/v4l2/v4l2_queue.cc
@@ -18,6 +18,7 @@
 #include "media/gpu/chromeos/platform_video_frame_utils.h"
 #include "media/gpu/chromeos/video_frame_resource.h"
 #include "media/gpu/macros.h"
+#include "third_party/v4l-utils/lib/include/libv4l2.h"
 
 namespace media {
 
@@ -253,7 +254,7 @@ V4L2Buffer::~V4L2Buffer() {
   if (v4l2_buffer_.memory == V4L2_MEMORY_MMAP) {
     for (size_t i = 0; i < plane_mappings_.size(); i++) {
       if (plane_mappings_[i] != nullptr) {
-        munmap(plane_mappings_[i], v4l2_buffer_.m.planes[i].length);
+        v4l2_munmap(plane_mappings_[i], v4l2_buffer_.m.planes[i].length);
       }
     }
   }
@@ -750,7 +751,8 @@ bool V4L2WritableBufferRef::QueueDMABuf(
 
   size_t num_planes = self.PlanesCount();
   for (size_t i = 0; i < num_planes; i++) {
-    self.buffer_data_->v4l2_buffer_.m.planes[i].m.fd = planes[i].fd.get();
+    self.buffer_data_->v4l2_buffer_.m.planes[i].m.fd = frame->GetDmabufFd(i);
+    VLOGF(3) << "planes fd:" << planes[i].fd.get() << " frame dma:" << frame->GetDmabufFd(i);
   }
 
   return std::move(self).DoQueue(request_ref, std::move(frame));
Index: src/media/gpu/v4l2/v4l2_stateful_video_decoder.cc
===================================================================
--- src.orig/media/gpu/v4l2/v4l2_stateful_video_decoder.cc
+++ src/media/gpu/v4l2/v4l2_stateful_video_decoder.cc
@@ -32,12 +32,22 @@
 #include "media/video/h264_parser.h"
 #include "ui/gfx/geometry/size.h"
 
+#include "media/gpu/v4l2/v4l2_stubs.h"
+#include "media/gpu/v4l2/v4l2_device.h"
+#include "third_party/v4l-utils/lib/include/libv4l2.h"
+
 namespace {
+using media_gpu_v4l2::InitializeStubs;
+using media_gpu_v4l2::kModuleV4l2;
+using media_gpu_v4l2::StubPathMap;
+using media_gpu_v4l2::IsV4l2Initialized;
+using media::V4L2Device;
+
 // Numerical value of ioctl() OK return value;
 constexpr int kIoctlOk = 0;
 
 int HandledIoctl(int fd, int request, void* arg) {
-  return HANDLE_EINTR(ioctl(fd, request, arg));
+  return HANDLE_EINTR(v4l2_ioctl(fd, request, arg));
 }
 
 void* Mmap(int fd,
@@ -46,7 +56,28 @@ void* Mmap(int fd,
            int prot,
            int flags,
            unsigned int offset) {
-  return mmap(addr, len, prot, flags, fd, offset);
+  return v4l2_mmap(addr, len, prot, flags, fd, offset);
+}
+
+bool InitV4l2Plugin() {
+  StubPathMap paths;
+  paths[kModuleV4l2].push_back(V4L2Device::kLibV4l2Path);
+  return InitializeStubs(paths);
+}
+
+bool OpenDevice(int fd) {
+  if (!IsV4l2Initialized() && !InitV4l2Plugin()) {
+    VLOG(2) << "Failed to init v4l2plugin";
+    return false;
+  }
+  if (HANDLE_EINTR(v4l2_fd_open(fd, V4L2_DISABLE_CONVERSION)) ==
+          -1)
+    return false;
+  return true;
+}
+
+void CloseDevice(int fd) {
+  v4l2_close(fd);
 }
 
 // This method blocks waiting for an event from either |device_fd| or
@@ -310,7 +341,7 @@ void V4L2StatefulVideoDecoder::Initializ
     constexpr char kVideoDeviceDriverPath[] = "/dev/video-dec0";
     device_fd_.reset(HANDLE_EINTR(
         open(kVideoDeviceDriverPath, O_RDWR | O_NONBLOCK | O_CLOEXEC)));
-    if (!device_fd_.is_valid()) {
+    if (!device_fd_.is_valid() && !OpenDevice(device_fd_.get())) {
       std::move(init_cb).Run(DecoderStatus::Codes::kFailedToCreateDecoder);
       return;
     }
@@ -557,6 +588,8 @@ void V4L2StatefulVideoDecoder::Reset(bas
 
   OUTPUT_queue_.reset();
   CAPTURE_queue_.reset();
+  if (device_fd_.is_valid())
+		CloseDevice(device_fd_.get());
   device_fd_.reset();
 
   event_task_runner_.reset();
@@ -1169,7 +1202,7 @@ int V4L2StatefulVideoDecoder::GetMaxNumD
   constexpr char kVideoDeviceDriverPath[] = "/dev/video-dec0";
   base::ScopedFD device_fd(HANDLE_EINTR(
       open(kVideoDeviceDriverPath, O_RDWR | O_NONBLOCK | O_CLOEXEC)));
-  if (!device_fd.is_valid()) {
+  if (!device_fd.is_valid() && !OpenDevice(device_fd.get())) {
     return std::numeric_limits<int>::max();
   }
   struct v4l2_capability caps = {};
@@ -1185,6 +1218,7 @@ int V4L2StatefulVideoDecoder::GetMaxNumD
   // to 15 with e.g. Qualcomm SC7180.
   // [1] https://source.chromium.org/chromium/chromium/src/+/main:media/gpu/v4l2/legacy/v4l2_video_decode_accelerator.h;l=449-454;drc=83195d4d1e1a4e54f148ddc80d0edcf5daa755ff
   // [2] https://source.chromium.org/chromium/chromium/src/+/main:media/gpu/v4l2/v4l2_video_decoder.h;l=183-189;drc=90fa47c897b589bc4857fb7ccafab46a4be2e2ae
+	CloseDevice(device_fd.get());
   return is_mtk8173 ? 10 : 15;
 }
 
