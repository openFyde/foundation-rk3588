Index: src/media/gpu/sandbox/hardware_video_decoding_sandbox_hook_linux.cc
===================================================================
--- src.orig/media/gpu/sandbox/hardware_video_decoding_sandbox_hook_linux.cc
+++ src/media/gpu/sandbox/hardware_video_decoding_sandbox_hook_linux.cc
@@ -7,6 +7,7 @@
 #include <dlfcn.h>
 #include <sys/stat.h>
 
+#include "base/types/cxx23_to_underlying.h"
 #include "base/process/process_metrics.h"
 #include "base/strings/stringprintf.h"
 #include "media/gpu/buildflags.h"
@@ -146,11 +147,14 @@ bool HardwareVideoDecodingPreSandboxHook
     std::vector<BrokerFilePermission>& permissions) {
 #if BUILDFLAG(USE_V4L2_CODEC)
   command_set.set(sandbox::syscall_broker::COMMAND_OPEN);
+  command_set.set(sandbox::syscall_broker::COMMAND_STAT);
+  command_set.set(sandbox::syscall_broker::COMMAND_READLINK);
+  command_set.set(sandbox::syscall_broker::COMMAND_INOTIFY_ADD_WATCH);
 
   // TODO(b/210759684): we should open the render node for minigbm before
   // entering the sandbox so that we can remove this permission.
   AllowAccessToRenderNodes(permissions, /*include_sys_dev_char=*/false,
-                           /*read_write=*/false);
+                           /*read_write=*/true);
 
   // Device nodes for V4L2 video decode accelerator drivers.
   // We do not use a FileEnumerator because the device files may not exist yet
@@ -183,6 +187,32 @@ bool HardwareVideoDecodingPreSandboxHook
   // Files needed for protected DMA allocations.
   static const char kDmaHeapPath[] = "/dev/dma_heap/restricted_mtk_cma";
   permissions.push_back(BrokerFilePermission::ReadWrite(kDmaHeapPath));
+  permissions.push_back(BrokerFilePermission::ReadOnly("/proc/device-tree/compatible"));
+  permissions.push_back(BrokerFilePermission::ReadWrite("/dev/mpp_service"));
+  permissions.push_back(BrokerFilePermission::ReadOnly("/etc/localtime"));
+  permissions.push_back(BrokerFilePermission::ReadWrite("/dev/rga"));
+  permissions.push_back(BrokerFilePermission::ReadWrite("/var/log/libv4l2.log"));
+  constexpr unsigned int kFlags = RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE;
+#if defined(__aarch64__)
+  if (nullptr == dlopen("/usr/lib64/libv4l/plugins/libv4l-encplugin.so", kFlags)) {
+    LOG(ERROR) << "dlopen(libv4l-encplugin.so) failed with error: " << dlerror();
+    return false;
+  }
+  if (nullptr == dlopen("/usr/lib64/libv4l2.so", kFlags)) {
+    LOG(ERROR) << "dlopen(libv4l2.so) failed with error: " << dlerror();
+    return false;
+  }
+#else
+  if (nullptr == dlopen("/usr/lib/libv4l/plugins/libv4l-encplugin.so", kFlags)) {
+    LOG(ERROR) << "dlopen(libv4l-encplugin.so) failed with error: " << dlerror();
+    return false;
+  }
+  if (nullptr == dlopen("/usr/lib/libv4l2.so", kFlags)) {
+    LOG(ERROR) << "dlopen(libv4l2.so) failed with error: " << dlerror();
+    return false;
+  }
+#endif  // defined(__aarch64__)
+  LOG(INFO) << "success to load libv4l2.so";
   return true;
 #else
   NOTREACHED();
@@ -225,6 +255,7 @@ bool HardwareVideoDecodingPreSandboxHook
   std::vector<BrokerFilePermission> permissions;
 
   bool result_for_platform_policy;
+  LOG(INFO) << "policy type:" << base::to_underlying(policy_type);
   switch (policy_type) {
     case PolicyType::kVaapiOnIntel:
       result_for_platform_policy =
Index: src/media/gpu/sandbox/hardware_video_encoding_sandbox_hook_linux.cc
===================================================================
--- src.orig/media/gpu/sandbox/hardware_video_encoding_sandbox_hook_linux.cc
+++ src/media/gpu/sandbox/hardware_video_encoding_sandbox_hook_linux.cc
@@ -29,6 +29,9 @@ bool HardwareVideoEncodingPreSandboxHook
 
 #if BUILDFLAG(USE_V4L2_CODEC)
   command_set.set(sandbox::syscall_broker::COMMAND_OPEN);
+  command_set.set(sandbox::syscall_broker::COMMAND_STAT);
+  command_set.set(sandbox::syscall_broker::COMMAND_READLINK);
+  command_set.set(sandbox::syscall_broker::COMMAND_INOTIFY_ADD_WATCH);
 
   // Device nodes for V4L2 video encode accelerator drivers.
   // We do not use a FileEnumerator because the device files may not exist
@@ -50,6 +53,33 @@ bool HardwareVideoEncodingPreSandboxHook
   // permission to only platforms that need it.
   static const char kDevImageProc0Path[] = "/dev/image-proc0";
   permissions.push_back(BrokerFilePermission::ReadWrite(kDevImageProc0Path));
+  permissions.push_back(BrokerFilePermission::ReadOnly("/proc/device-tree/compatible"));
+  permissions.push_back(BrokerFilePermission::ReadWrite("/dev/mpp_service"));
+  permissions.push_back(BrokerFilePermission::ReadWrite("/dev/rga"));
+  permissions.push_back(BrokerFilePermission::ReadWrite("/dev/dri/renderD128"));
+  permissions.push_back(BrokerFilePermission::ReadOnly("/etc/localtime"));
+  permissions.push_back(BrokerFilePermission::ReadWrite("/var/log/libv4l2.log"));
+  constexpr unsigned int kFlags = RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE;
+#if defined(__aarch64__)
+  if (nullptr == dlopen("/usr/lib64/libv4l/plugins/libv4l-encplugin.so", kFlags)) {
+    LOG(ERROR) << "dlopen(libv4l-encplugin.so) failed with error: " << dlerror();
+    return false;
+  }
+  if (nullptr == dlopen("/usr/lib64/libv4l2.so", kFlags)) {
+    LOG(ERROR) << "dlopen(libv4l2.so) failed with error: " << dlerror();
+    return false;
+  }
+#else
+  if (nullptr == dlopen("/usr/lib/libv4l/plugins/libv4l-encplugin.so", kFlags)) {
+    LOG(ERROR) << "dlopen(libv4l-encplugin.so) failed with error: " << dlerror();
+    return false;
+  }
+  if (nullptr == dlopen("/usr/lib/libv4l2.so", kFlags)) {
+    LOG(ERROR) << "dlopen(libv4l2.so) failed with error: " << dlerror();
+    return false;
+  }
+#endif  // defined(__aarch64__)
+  LOG(INFO) << "success to load libv4l2.so";
 #elif BUILDFLAG(USE_VAAPI)
   command_set.set(sandbox::syscall_broker::COMMAND_OPEN);
   command_set.set(sandbox::syscall_broker::COMMAND_STAT);
Index: src/media/gpu/v4l2/BUILD.gn
===================================================================
--- src.orig/media/gpu/v4l2/BUILD.gn
+++ src/media/gpu/v4l2/BUILD.gn
@@ -8,10 +8,18 @@ import("//build/config/ui.gni")
 import("//media/gpu/args.gni")
 import("//media/media_options.gni")
 import("//testing/test.gni")
+import("//tools/generate_stubs/rules.gni")
 import("//ui/gl/features.gni")
 
 assert(use_v4l2_codec)
 
+generate_stubs("libv4l2_stubs") {
+  extra_header = "v4l2_stub_header.fragment"
+  sigs = [ "v4l2.sig" ]
+  output_name = "v4l2_stubs"
+  deps = [ "//base" ]
+}
+
 source_set("v4l2") {
   defines = [ "MEDIA_GPU_IMPLEMENTATION" ]
   sources = [
@@ -93,6 +101,7 @@ source_set("v4l2") {
   public_deps = [ "//ui/gl" ]
 
   deps = [
+    ":libv4l2_stubs",
     ":v4l2_status",
     "//base",
     "//build/config/linux/libdrm",
Index: src/media/gpu/v4l2/v4l2.sig
===================================================================
--- src.orig/media/gpu/v4l2/v4l2.sig
+++ src/media/gpu/v4l2/v4l2.sig
@@ -8,3 +8,5 @@
 LIBV4L_PUBLIC int v4l2_close(int fd);
 LIBV4L_PUBLIC int v4l2_ioctl(int fd, unsigned long int request, ...);
 LIBV4L_PUBLIC int v4l2_fd_open(int fd, int v4l2_flags);
+LIBV4L_PUBLIC void *v4l2_mmap(void *start, size_t length, int prot, int flags, int fd, int64_t offset);
+LIBV4L_PUBLIC int v4l2_munmap(void *_start, size_t length);
Index: src/media/gpu/v4l2/v4l2_device.cc
===================================================================
--- src.orig/media/gpu/v4l2/v4l2_device.cc
+++ src/media/gpu/v4l2/v4l2_device.cc
@@ -33,6 +33,13 @@
 #include "media/gpu/macros.h"
 #include "media/gpu/v4l2/v4l2_queue.h"
 #include "media/gpu/v4l2/v4l2_utils.h"
+#include "media/gpu/v4l2/v4l2_stubs.h"
+#include "third_party/v4l-utils/lib/include/libv4l2.h"
+
+using media_gpu_v4l2::InitializeStubs;
+using media_gpu_v4l2::IsV4l2Initialized;
+using media_gpu_v4l2::kModuleV4l2;
+using media_gpu_v4l2::StubPathMap;
 
 namespace media {
 
@@ -55,7 +62,7 @@ uint32_t V4L2PixFmtToDrmFormat(uint32_t
       return DRM_FORMAT_ARGB8888;
 
     default:
-      DVLOGF(1) << "Unrecognized format " << FourccToString(format);
+      VLOGF(1) << "Unrecognized format " << FourccToString(format);
       return 0;
   }
 }
@@ -78,6 +85,12 @@ class V4L2QueueFactory {
 };
 
 V4L2Device::V4L2Device() {
+  StubPathMap paths;
+  if (!IsV4l2Initialized()) {
+    paths[kModuleV4l2].push_back(V4L2Device::kLibV4l2Path);
+    if (!InitializeStubs(paths))
+      LOG(ERROR) << "failed to init v4l2 lib.";
+  }
   DETACH_FROM_SEQUENCE(client_sequence_checker_);
 }
 
@@ -120,7 +133,7 @@ void V4L2Device::OnQueueDestroyed(v4l2_b
 }
 
 bool V4L2Device::Open(Type type, uint32_t v4l2_pixfmt) {
-  DVLOGF(3);
+  VLOGF(3);
   std::string path = GetDevicePathFor(type, v4l2_pixfmt);
 
   if (path.empty()) {
@@ -186,7 +199,7 @@ int32_t V4L2Device::VideoCodecProfileToV
     case H264PROFILE_MULTIVIEWHIGH:
       return V4L2_MPEG_VIDEO_H264_PROFILE_MULTIVIEW_HIGH;
     default:
-      DVLOGF(1) << "Add more cases as needed";
+      VLOGF(1) << "Add more cases as needed";
       return -1;
   }
 }
@@ -227,7 +240,7 @@ int32_t V4L2Device::H264LevelIdcToV4L2H2
     case 51:
       return V4L2_MPEG_VIDEO_H264_LEVEL_5_1;
     default:
-      DVLOGF(1) << "Unrecognized level_idc: " << static_cast<int>(level_idc);
+      VLOGF(1) << "Unrecognized level_idc: " << static_cast<int>(level_idc);
       return -1;
   }
 }
@@ -322,7 +335,7 @@ gfx::Size V4L2Device::AllocatedSizeFromV
 
 int V4L2Device::Ioctl(int request, void* arg) {
   DCHECK(device_fd_.is_valid());
-  return HANDLE_EINTR(ioctl(device_fd_.get(), request, arg));
+  return HANDLE_EINTR(v4l2_ioctl(device_fd_.get(), request, arg));
 }
 
 bool V4L2Device::Poll(bool poll_device, bool* event_pending) {
@@ -356,11 +369,11 @@ void* V4L2Device::Mmap(void* addr,
                        int flags,
                        unsigned int offset) {
   DCHECK(device_fd_.is_valid());
-  return mmap(addr, len, prot, flags, device_fd_.get(), offset);
+  return v4l2_mmap(addr, len, prot, flags, device_fd_.get(), offset);
 }
 
 void V4L2Device::Munmap(void* addr, unsigned int len) {
-  munmap(addr, len);
+  v4l2_munmap(addr, len);
 }
 
 bool V4L2Device::SetDevicePollInterrupt() {
@@ -566,7 +579,7 @@ V4L2Device::EnumerateSupportedDecodeProf
       profile.profile = video_codec_profile;
       profiles.push_back(profile);
 
-      DVLOGF(3) << "Found decoder profile " << GetProfileName(profile.profile)
+      VLOGF(3) << "Found decoder profile " << GetProfileName(profile.profile)
                 << ", resolutions: " << profile.min_resolution.ToString() << " "
                 << profile.max_resolution.ToString();
     }
@@ -844,14 +857,28 @@ bool V4L2Device::SetGOPLength(uint32_t g
 
 bool V4L2Device::OpenDevicePath(const std::string& path) {
   DCHECK(!device_fd_.is_valid());
-
+  if (!IsV4l2Initialized()) {
+    VLOGF(3) << "V4l2plugin is null.";
+    return false;
+  };
   device_fd_.reset(
       HANDLE_EINTR(open(path.c_str(), O_RDWR | O_NONBLOCK | O_CLOEXEC)));
+  if (!device_fd_.is_valid())
+    return false;
+
+  if (HANDLE_EINTR(v4l2_fd_open(device_fd_.get(), V4L2_DISABLE_CONVERSION)) !=
+          -1) {
+    VLOGF(3) << "Using libv4l2 for " << path;
+  } else {
+    VLOGF(3) << "Failed to open libv4l2 for " << path;
+  }
   return device_fd_.is_valid();
 }
 
 void V4L2Device::CloseDevice() {
-  DVLOGF(3);
+  VLOGF(3);
+  if (device_fd_.is_valid())
+    v4l2_close(device_fd_.release());
   device_fd_.reset();
 }
 
@@ -927,7 +954,7 @@ void V4L2Device::EnumerateDevicesForType
         base::BindRepeating(&V4L2Device::Ioctl, this), buf_type);
 
     if (!supported_pixelformats.empty()) {
-      DVLOGF(3) << "Found device: " << path;
+      VLOGF(3) << "Found device: " << path;
       devices.push_back(std::make_pair(path, supported_pixelformats));
     }
 
Index: src/media/gpu/v4l2/v4l2_device.h
===================================================================
--- src.orig/media/gpu/v4l2/v4l2_device.h
+++ src/media/gpu/v4l2/v4l2_device.h
@@ -95,6 +95,12 @@ class MEDIA_GPU_EXPORT V4L2Device
 
   V4L2Device();
 
+  inline static constexpr char kLibV4l2Path[] =
+#if defined(__aarch64__)
+      "/usr/lib64/libv4l2.so";
+#else
+      "/usr/lib/libv4l2.so";
+#endif
   // Open a V4L2 device of |type| for use with |v4l2_pixfmt|.
   // Return true on success.
   // The device will be closed in the destructor.
Index: src/sandbox/policy/linux/bpf_cros_arm_gpu_policy_linux.cc
===================================================================
--- src.orig/sandbox/policy/linux/bpf_cros_arm_gpu_policy_linux.cc
+++ src/sandbox/policy/linux/bpf_cros_arm_gpu_policy_linux.cc
@@ -42,6 +42,9 @@ ResultExpr CrosArmGpuProcessPolicy::Eval
 #endif  // defined(__arm__) || defined(__aarch64__)
 
   switch (sysno) {
+#if defined(__aarch64__)
+    case __NR_mmap:
+#endif
 #if defined(__arm__) || defined(__aarch64__)
     // ARM GPU sandbox is started earlier so we need to allow networking
     // in the sandbox.
@@ -50,8 +53,47 @@ ResultExpr CrosArmGpuProcessPolicy::Eval
     case __NR_getsockname:
     case __NR_sched_setaffinity:
     case __NR_sched_setscheduler:
+      return Allow();
     case __NR_sysinfo:
     case __NR_uname:
+    case __NR_ioctl:
+    case __NR_madvise:
+    case __NR_futex:
+      return Allow();
+    case __NR_process_vm_readv:
+    case __NR_clock_nanosleep:
+    case __NR_munmap:
+    case __NR_rt_sigprocmask:
+      return Allow();
+    case __NR_getpid:
+    case __NR_sendto:
+    case __NR_gettid:
+    case __NR_faccessat:
+      return Allow();
+    case __NR_fstatfs:
+    case __NR_set_robust_list:
+    case __NR_rseq:
+    case __NR_brk:
+    case __NR_clone:
+      return Allow();
+    case __NR_exit:
+    case __NR_lseek:
+    case __NR_fcntl:
+    case __NR_write:
+    case __NR_execve:
+      return Allow();
+    case __NR_set_tid_address:
+    case __NR_prlimit64:
+    case __NR_getrandom:
+    case __NR_rt_sigaction:
+      return Allow();
+    case __NR_exit_group:
+    case __NR_restart_syscall:
+    case __NR_rt_sigreturn:
+#if defined(__arm__)
+    // Only available on ARM 32bit devices
+    case __NR_mmap2:
+#endif
       return Allow();
     // Allow only AF_UNIX for |domain|.
     case __NR_socket:
Index: src/sandbox/policy/linux/bpf_hardware_video_decoding_policy_linux.cc
===================================================================
--- src.orig/sandbox/policy/linux/bpf_hardware_video_decoding_policy_linux.cc
+++ src/sandbox/policy/linux/bpf_hardware_video_decoding_policy_linux.cc
@@ -132,8 +132,57 @@ ResultExpr HardwareVideoDecodingProcessP
     return CrashSIGSYS();
   }
 
-  if (system_call_number == __NR_ioctl)
-    return Allow();
+  switch (system_call_number) {
+    case __NR_ioctl:
+    case __NR_madvise:
+    case __NR_futex:
+    case __NR_process_vm_readv:
+#if defined(__aarch64__)
+    case __NR_mmap:
+		case __NR_connect:
+    case __NR_getpeername:
+    case __NR_getsockname:
+    case __NR_sched_setaffinity:
+    case __NR_sched_setscheduler:
+      return Allow();
+    case __NR_sysinfo:
+    case __NR_uname:
+      return Allow();
+    case __NR_clock_nanosleep:
+    case __NR_munmap:
+    case __NR_rt_sigprocmask:
+      return Allow();
+    case __NR_getpid:
+    case __NR_sendto:
+    case __NR_newfstatat:
+    case __NR_gettid:
+    case __NR_faccessat:
+      return Allow();
+    case __NR_fstatfs:
+    case __NR_set_robust_list:
+    case __NR_rseq:
+    case __NR_brk:
+    case __NR_clone:
+      return Allow();
+    case __NR_exit:
+    case __NR_lseek:
+    case __NR_fcntl:
+    case __NR_write:
+    case __NR_execve:
+      return Allow();
+    case __NR_set_tid_address:
+    case __NR_prlimit64:
+    case __NR_getrandom:
+    case __NR_rt_sigaction:
+      return Allow();
+    case __NR_exit_group:
+    case __NR_restart_syscall:
+    case __NR_rt_sigreturn:
+#elif defined(__arm__)
+    case __NR_mmap2:
+#endif
+      return Allow();
+  }
 
   if (system_call_number == __NR_sched_setaffinity) {
     return RestrictSchedTarget(GetPolicyPid(), system_call_number);
Index: src/content/common/gpu_pre_sandbox_hook_linux.cc
===================================================================
--- src.orig/content/common/gpu_pre_sandbox_hook_linux.cc
+++ src/content/common/gpu_pre_sandbox_hook_linux.cc
@@ -99,11 +99,15 @@ static const char kLibGlesPath[] = "/usr
 static const char kLibEglPath[] = "/usr/lib64/libEGL.so.1";
 static const char kLibMaliPath[] = "/usr/lib64/libmali.so";
 static const char kLibTegraPath[] = "/usr/lib64/libtegrav4l2.so";
+static const char kLibV4l2Path[] = "/usr/lib64/libv4l2.so";
+static const char kLibRkmppPath[] = "/usr/lib64/libv4l/plugins/libv4l-encplugin.so";
 #else
 static const char kLibGlesPath[] = "/usr/lib/libGLESv2.so.2";
 static const char kLibEglPath[] = "/usr/lib/libEGL.so.1";
 static const char kLibMaliPath[] = "/usr/lib/libmali.so";
 static const char kLibTegraPath[] = "/usr/lib/libtegrav4l2.so";
+static const char kLibV4l2Path[] = "/usr/lib/libv4l2.so";
+static const char kLibRkmppPath[] = "/usr/lib/libv4l/plugins/libv4l-encplugin.so";
 #endif
 
 constexpr int dlopen_flag = RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE;
@@ -197,6 +201,14 @@ void AddV4L2GpuPermissions(
     permissions->push_back(
         BrokerFilePermission::ReadWrite(kAmlogicAvcEncoderPath));
   }
+
+  permissions->push_back(BrokerFilePermission::ReadOnly("/proc/device-tree/compatible"));
+  permissions->push_back(BrokerFilePermission::ReadWrite("/dev/mpp_service"));
+  permissions->push_back(BrokerFilePermission::ReadOnly("/etc/localtime"));
+  permissions->push_back(BrokerFilePermission::ReadWrite("/dev/rga"));
+  permissions->push_back(BrokerFilePermission::ReadWrite("/var/log/libv4l2.log"));
+  permissions->push_back(BrokerFilePermission::ReadOnly(kLibRkmppPath));
+  permissions->push_back(BrokerFilePermission::ReadOnly(kLibV4l2Path));
 }
 
 void AddArmMaliGpuPermissions(std::vector<BrokerFilePermission>* permissions) {
@@ -660,6 +672,11 @@ void LoadChromecastV4L2Libraries() {
   }
 }
 
+void LoadV4l2LibPlugInLibraries() {
+  dlopen(kLibV4l2Path, dlopen_flag);
+  dlopen(kLibRkmppPath, dlopen_flag);
+}
+
 bool LoadLibrariesForGpu(
     const sandbox::policy::SandboxSeccompBPF::Options& options) {
   LoadVulkanLibraries();
@@ -671,6 +688,9 @@ bool LoadLibrariesForGpu(
       if (!LoadAmdGpuLibraries())
         return false;
     }
+    if (UseV4L2Codec(options)) {
+      LoadV4l2LibPlugInLibraries();
+    }
   } else {
     if (UseChromecastSandboxAllowlist() && IsArchitectureArm()) {
       if (UseV4L2Codec(options)) {
Index: src/media/gpu/v4l2/v4l2_utils.cc
===================================================================
--- src.orig/media/gpu/v4l2/v4l2_utils.cc
+++ src/media/gpu/v4l2/v4l2_utils.cc
@@ -32,6 +32,9 @@
 #include "media/gpu/macros.h"
 #include "media/media_buildflags.h"
 #include "ui/gfx/geometry/size.h"
+#include "media/gpu/v4l2/v4l2_stubs.h"
+#include "third_party/v4l-utils/lib/include/libv4l2.h"
+#include "media/gpu/v4l2/v4l2_device.h"
 
 // This has not been accepted upstream.
 #ifndef V4L2_PIX_FMT_AV1
@@ -47,10 +50,36 @@
   std::make_pair(codec##_##suffix, codec)
 
 namespace {
+using media_gpu_v4l2::InitializeStubs;
+using media_gpu_v4l2::kModuleV4l2;
+using media_gpu_v4l2::StubPathMap;
+using media_gpu_v4l2::IsV4l2Initialized;
+using media::V4L2Device;
+
 int HandledIoctl(int fd, int request, void* arg) {
-  return HANDLE_EINTR(ioctl(fd, request, arg));
+  return HANDLE_EINTR(v4l2_ioctl(fd, request, arg));
+}
+bool InitV4l2Plugin() {
+	StubPathMap paths;
+	paths[kModuleV4l2].push_back(V4L2Device::kLibV4l2Path);
+	return InitializeStubs(paths);
+}
+
+bool OpenDevice(int fd) {
+  if (!IsV4l2Initialized() && !InitV4l2Plugin()) {
+    VLOG(2) << "Failed to init plugin";
+    return false;
+  }
+  if (HANDLE_EINTR(v4l2_fd_open(fd, V4L2_DISABLE_CONVERSION)) ==
+          -1)
+    return false;
+  return true;
 }
 
+void CloseDevice(int fd) {
+  v4l2_close(fd);
+}
+#if 0
 std::string GetDriverName(const media::IoctlAsCallback& ioctl_cb) {
   struct v4l2_capability caps;
   memset(&caps, 0, sizeof(caps));
@@ -62,6 +91,7 @@ std::string GetDriverName(const media::I
 
   return std::string(reinterpret_cast<const char*>(caps.driver));
 }
+#endif
 }  // namespace
 namespace media {
 
@@ -586,12 +616,17 @@ std::optional<SupportedVideoDecoderConfi
 #endif
 
   for (const auto& path : candidate_paths) {
+ #if 0
     base::ScopedFD device_fd(
         HANDLE_EINTR(open(path.c_str(), O_RDWR | O_NONBLOCK | O_CLOEXEC)));
     if (!device_fd.is_valid()) {
       PLOG(WARNING) << "Could not open " << path;
       continue;
     }
+    if (!OpenDevice(device_fd.get())) {
+      LOG(ERROR) << "Failed to open libv4l2 device";
+      continue;
+    }
 
     std::vector<uint32_t> v4l2_codecs = EnumerateSupportedPixFmts(
         base::BindRepeating(&HandledIoctl, device_fd.get()),
@@ -619,6 +654,47 @@ std::optional<SupportedVideoDecoderConfi
             /*require_encrypted=*/false));
       }
     }
+    CloseDevice(device_fd.get());
+#else
+    int fd = HANDLE_EINTR(open(path.c_str(), O_RDWR | O_NONBLOCK | O_CLOEXEC));
+    if (fd < 0) {
+      PLOG(WARNING) << "Could not open " << path;
+      continue;
+    }
+    if (!OpenDevice(fd)) {
+      LOG(ERROR) << "Failed to open libv4l2 device";
+      continue;
+    }
+
+    std::vector<uint32_t> v4l2_codecs = EnumerateSupportedPixFmts(
+        base::BindRepeating(&HandledIoctl, fd),
+        V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
+
+    for (const uint32_t v4l2_codec : v4l2_codecs) {
+      const std::vector<VideoCodecProfile> media_codec_profiles =
+          EnumerateSupportedProfilesForV4L2Codec(
+              base::BindRepeating(&HandledIoctl, fd), v4l2_codec);
+
+      gfx::Size min_coded_size;
+      gfx::Size max_coded_size;
+      GetSupportedResolution(
+          base::BindRepeating(&HandledIoctl, fd), v4l2_codec,
+          &min_coded_size, &max_coded_size);
+
+      for (const auto& profile : media_codec_profiles) {
+        supported_media_configs.emplace_back(SupportedVideoDecoderConfig(
+            profile, profile, min_coded_size, max_coded_size,
+#if BUILDFLAG(USE_CHROMEOS_PROTECTED_MEDIA)
+            /*allow_encrypted=*/true,
+#else
+            /*allow_encrypted=*/false,
+#endif
+            /*require_encrypted=*/false));
+      }
+    }
+    CloseDevice(fd);
+		HANDLE_EINTR(close(fd));
+#endif
   }
 
 #if DCHECK_IS_ON()
@@ -628,17 +704,21 @@ std::optional<SupportedVideoDecoderConfi
               << config.coded_size_max.ToString() << ")";
   }
 #endif
-
   return supported_media_configs;
 }
 
 bool IsV4L2DecoderStateful() {
+#if 0
   constexpr char kVideoDeviceDriverPath[] = "/dev/video-dec0";
   base::ScopedFD device_fd(HANDLE_EINTR(
       open(kVideoDeviceDriverPath, O_RDWR | O_NONBLOCK | O_CLOEXEC)));
   if (!device_fd.is_valid()) {
     return false;
   }
+	if (!OpenDevice(device_fd.get())) {
+    LOG(ERROR) << "Failed to open libv4l2 device";
+    return false;
+  }
 
   std::vector<uint32_t> v4l2_codecs = EnumerateSupportedPixFmts(
       base::BindRepeating(&HandledIoctl, device_fd.get()),
@@ -653,14 +733,19 @@ bool IsV4L2DecoderStateful() {
       V4L2_PIX_FMT_VP8,
       V4L2_PIX_FMT_VP9,
   };
+	CloseDevice(device_fd.get());
 
   return std::find_first_of(v4l2_codecs.begin(), v4l2_codecs.end(),
                             kSupportedStatefulInputCodecs.begin(),
                             kSupportedStatefulInputCodecs.end()) !=
          v4l2_codecs.end();
+#else
+  return true;
+#endif
 }
 
 bool IsVislDriver() {
+#if 0
   constexpr char kVideoDeviceDriverPath[] = "/dev/video-dec0";
   base::ScopedFD device_fd(HANDLE_EINTR(
       open(kVideoDeviceDriverPath, O_RDWR | O_NONBLOCK | O_CLOEXEC)));
@@ -672,6 +757,9 @@ bool IsVislDriver() {
       GetDriverName(base::BindRepeating(&HandledIoctl, device_fd.get()));
 
   return v4l2_driver_name.compare("visl") == 0;
+#else
+  return false;
+#endif
 }
 
 #ifndef NDEBUG
Index: src/media/gpu/v4l2/v4l2_queue.cc
===================================================================
--- src.orig/media/gpu/v4l2/v4l2_queue.cc
+++ src/media/gpu/v4l2/v4l2_queue.cc
@@ -19,6 +19,7 @@
 #include "media/gpu/chromeos/native_pixmap_frame_resource.h"
 #include "media/gpu/chromeos/platform_video_frame_utils.h"
 #include "media/gpu/macros.h"
+#include "third_party/v4l-utils/lib/include/libv4l2.h"
 
 namespace media {
 
@@ -254,7 +255,7 @@ V4L2Buffer::~V4L2Buffer() {
   if (v4l2_buffer_.memory == V4L2_MEMORY_MMAP) {
     for (size_t i = 0; i < plane_mappings_.size(); i++) {
       if (plane_mappings_[i] != nullptr) {
-        munmap(plane_mappings_[i], v4l2_buffer_.m.planes[i].length);
+        v4l2_munmap(plane_mappings_[i], v4l2_buffer_.m.planes[i].length);
       }
     }
   }
@@ -750,7 +751,8 @@ bool V4L2WritableBufferRef::QueueDMABuf(
 
   size_t num_planes = self.PlanesCount();
   for (size_t i = 0; i < num_planes; i++) {
-    self.buffer_data_->v4l2_buffer_.m.planes[i].m.fd = planes[i].fd.get();
+    self.buffer_data_->v4l2_buffer_.m.planes[i].m.fd = frame->GetDmabufFd(i);
+    VLOGF(3) << "planes fd:" << planes[i].fd.get() << " frame dma:" << frame->GetDmabufFd(i);
   }
 
   return std::move(self).DoQueue(request_ref, std::move(frame));
Index: src/media/gpu/v4l2/v4l2_stateful_video_decoder.cc
===================================================================
--- src.orig/media/gpu/v4l2/v4l2_stateful_video_decoder.cc
+++ src/media/gpu/v4l2/v4l2_stateful_video_decoder.cc
@@ -32,12 +32,22 @@
 #include "third_party/abseil-cpp/absl/cleanup/cleanup.h"
 #include "ui/gfx/geometry/size.h"
 
+#include "media/gpu/v4l2/v4l2_stubs.h"
+#include "media/gpu/v4l2/v4l2_device.h"
+#include "third_party/v4l-utils/lib/include/libv4l2.h"
+
 namespace {
+using media_gpu_v4l2::InitializeStubs;
+using media_gpu_v4l2::kModuleV4l2;
+using media_gpu_v4l2::StubPathMap;
+using media_gpu_v4l2::IsV4l2Initialized;
+using media::V4L2Device;
+
 // Numerical value of ioctl() OK return value;
 constexpr int kIoctlOk = 0;
 
 int HandledIoctl(int fd, int request, void* arg) {
-  return HANDLE_EINTR(ioctl(fd, request, arg));
+  return HANDLE_EINTR(v4l2_ioctl(fd, request, arg));
 }
 
 void* Mmap(int fd,
@@ -46,7 +56,28 @@ void* Mmap(int fd,
            int prot,
            int flags,
            unsigned int offset) {
-  return mmap(addr, len, prot, flags, fd, offset);
+  return v4l2_mmap(addr, len, prot, flags, fd, offset);
+}
+
+bool InitV4l2Plugin() {
+  StubPathMap paths;
+  paths[kModuleV4l2].push_back(V4L2Device::kLibV4l2Path);
+  return InitializeStubs(paths);
+}
+
+bool OpenDevice(int fd) {
+  if (!IsV4l2Initialized() && !InitV4l2Plugin()) {
+    VLOG(2) << "Failed to init v4l2plugin";
+    return false;
+  }
+  if (HANDLE_EINTR(v4l2_fd_open(fd, V4L2_DISABLE_CONVERSION)) ==
+          -1)
+    return false;
+  return true;
+}
+
+void CloseDevice(int fd) {
+  v4l2_close(fd);
 }
 
 // This method blocks waiting for an event from either |device_fd| or
@@ -270,7 +301,7 @@ void V4L2StatefulVideoDecoder::Initializ
                                           const WaitingCB& /*waiting_cb*/) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   DCHECK(config.IsValidConfig());
-  DVLOGF(1) << config.AsHumanReadableString();
+  VLOGF(1) << config.AsHumanReadableString();
 
   if (config.is_encrypted() || !!cdm_context) {
     std::move(init_cb).Run(DecoderStatus::Codes::kUnsupportedEncryptionMode);
@@ -311,7 +342,7 @@ void V4L2StatefulVideoDecoder::Initializ
     constexpr char kVideoDeviceDriverPath[] = "/dev/video-dec0";
     device_fd_.reset(HANDLE_EINTR(
         open(kVideoDeviceDriverPath, O_RDWR | O_NONBLOCK | O_CLOEXEC)));
-    if (!device_fd_.is_valid()) {
+    if (!device_fd_.is_valid() || !OpenDevice(device_fd_.get())) {
       std::move(init_cb).Run(DecoderStatus::Codes::kFailedToCreateDecoder);
       return;
     }
@@ -422,7 +453,7 @@ void V4L2StatefulVideoDecoder::Initializ
   struct v4l2_event_subscription sub = {.type = V4L2_EVENT_SOURCE_CHANGE};
   if (HandledIoctl(device_fd_.get(), VIDIOC_SUBSCRIBE_EVENT, &sub) !=
       kIoctlOk) {
-    PLOG(ERROR) << "Failed to subscribe to V4L2_EVENT_SOURCE_CHANGE";
+    LOG(ERROR) << "Failed to subscribe to V4L2_EVENT_SOURCE_CHANGE";
     std::move(init_cb).Run(DecoderStatus::Codes::kFailedToCreateDecoder);
     return;
   }
@@ -434,6 +465,7 @@ void V4L2StatefulVideoDecoder::Initializ
   }
 
   std::move(init_cb).Run(DecoderStatus::Codes::kOk);
+  VLOGF(1) << "to the end";
 }
 
 void V4L2StatefulVideoDecoder::Decode(scoped_refptr<DecoderBuffer> buffer,
@@ -569,6 +601,8 @@ void V4L2StatefulVideoDecoder::Reset(bas
 
   OUTPUT_queue_.reset();
   CAPTURE_queue_.reset();
+  if (device_fd_.is_valid())
+		CloseDevice(device_fd_.get());
   device_fd_.reset();
 
   event_task_runner_.reset();
@@ -607,7 +641,7 @@ bool V4L2StatefulVideoDecoder::IsPlatfor
 
 void V4L2StatefulVideoDecoder::ApplyResolutionChange() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  DVLOGF(2);
+  VLOGF(2);
   // It's possible that we have been Reset()ed in the interval between receiving
   // the resolution change event in WaitOnceForEvents() (in a background thread)
   // and arriving here from our |client_|. Check if that's the case.
@@ -687,6 +721,7 @@ bool V4L2StatefulVideoDecoder::Initializ
 
   const auto v4l2_format_or_error = CAPTURE_queue_->GetFormat();
   if (!v4l2_format_or_error.first || v4l2_format_or_error.second != kIoctlOk) {
+    LOG(ERROR) << "faild to get capture queue v4l2 format";
     return false;
   }
   const struct v4l2_format v4l2_format = *(v4l2_format_or_error.first);
@@ -901,6 +936,7 @@ void V4L2StatefulVideoDecoder::TryAndDeq
   DCHECK(CAPTURE_queue_) << "|CAPTURE_queue_| must be created at this point";
 
   const v4l2_memory queue_type = CAPTURE_queue_->GetMemoryType();
+  VLOG(1) << "mem type:" << (int) queue_type;
   DCHECK(queue_type == V4L2_MEMORY_MMAP || queue_type == V4L2_MEMORY_DMABUF);
   const bool use_v4l2_allocated_buffers = !client_->GetVideoFramePool();
   DCHECK((queue_type == V4L2_MEMORY_MMAP && use_v4l2_allocated_buffers) ||
@@ -1182,13 +1218,14 @@ bool V4L2StatefulVideoDecoder::IsInitial
 
 // static
 int V4L2StatefulVideoDecoder::GetMaxNumDecoderInstances() {
+#if 0
   if (!base::FeatureList::IsEnabled(media::kLimitConcurrentDecoderInstances)) {
     return std::numeric_limits<int>::max();
   }
   constexpr char kVideoDeviceDriverPath[] = "/dev/video-dec0";
   base::ScopedFD device_fd(HANDLE_EINTR(
       open(kVideoDeviceDriverPath, O_RDWR | O_NONBLOCK | O_CLOEXEC)));
-  if (!device_fd.is_valid()) {
+  if (!device_fd.is_valid() && !OpenDevice(device_fd.get())) {
     return std::numeric_limits<int>::max();
   }
   struct v4l2_capability caps = {};
@@ -1204,7 +1241,11 @@ int V4L2StatefulVideoDecoder::GetMaxNumD
   // to 15 with e.g. Qualcomm SC7180.
   // [1] https://source.chromium.org/chromium/chromium/src/+/main:media/gpu/v4l2/legacy/v4l2_video_decode_accelerator.h;l=449-454;drc=83195d4d1e1a4e54f148ddc80d0edcf5daa755ff
   // [2] https://source.chromium.org/chromium/chromium/src/+/main:media/gpu/v4l2/v4l2_video_decoder.h;l=183-189;drc=90fa47c897b589bc4857fb7ccafab46a4be2e2ae
+	CloseDevice(device_fd.get());
   return is_mtk8173 ? 10 : 15;
+#else
+  return 8;
+#endif
 }
 
 std::vector<std::pair<scoped_refptr<DecoderBuffer>, VideoDecoder::DecodeCB>>
