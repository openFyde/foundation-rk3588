Index: src/media/gpu/v4l2/v4l2.sig
===================================================================
--- src.orig/media/gpu/v4l2/v4l2.sig
+++ src/media/gpu/v4l2/v4l2.sig
@@ -8,3 +8,5 @@
 LIBV4L_PUBLIC int v4l2_close(int fd);
 LIBV4L_PUBLIC int v4l2_ioctl(int fd, unsigned long int request, ...);
 LIBV4L_PUBLIC int v4l2_fd_open(int fd, int v4l2_flags);
+LIBV4L_PUBLIC void *v4l2_mmap(void *start, size_t length, int prot, int flags, int fd, int64_t offset);
+LIBV4L_PUBLIC int v4l2_munmap(void *_start, size_t length);
Index: src/sandbox/policy/linux/bpf_cros_arm_gpu_policy_linux.cc
===================================================================
--- src.orig/sandbox/policy/linux/bpf_cros_arm_gpu_policy_linux.cc
+++ src/sandbox/policy/linux/bpf_cros_arm_gpu_policy_linux.cc
@@ -42,6 +42,9 @@ ResultExpr CrosArmGpuProcessPolicy::Eval
 #endif  // defined(__arm__) || defined(__aarch64__)
 
   switch (sysno) {
+#if defined(__aarch64__)
+    case __NR_mmap:
+#endif
 #if defined(__arm__) || defined(__aarch64__)
     // ARM GPU sandbox is started earlier so we need to allow networking
     // in the sandbox.
@@ -52,6 +55,14 @@ ResultExpr CrosArmGpuProcessPolicy::Eval
     case __NR_sched_setscheduler:
     case __NR_sysinfo:
     case __NR_uname:
+    case __NR_ioctl:
+    case __NR_madvise:
+    case __NR_futex:
+    case __NR_process_vm_readv:
+#if defined(__arm__)
+    // Only available on ARM 32bit devices
+    case __NR_mmap2:
+#endif
       return Allow();
     // Allow only AF_UNIX for |domain|.
     case __NR_socket:
Index: src/media/gpu/v4l2/v4l2_device.cc
===================================================================
--- src.orig/media/gpu/v4l2/v4l2_device.cc
+++ src/media/gpu/v4l2/v4l2_device.cc
@@ -34,6 +34,12 @@
 #include "media/gpu/v4l2/v4l2_queue.h"
 #include "media/gpu/v4l2/v4l2_utils.h"
 #include "ui/gl/egl_util.h"
+#include "media/gpu/v4l2/v4l2_stubs.h"
+#include "third_party/v4l-utils/lib/include/libv4l2.h"
+
+using media_gpu_v4l2::InitializeStubs;
+using media_gpu_v4l2::kModuleV4l2;
+using media_gpu_v4l2::StubPathMap;
 
 namespace media {
 
@@ -323,7 +329,7 @@ gfx::Size V4L2Device::AllocatedSizeFromV
 
 int V4L2Device::Ioctl(int request, void* arg) {
   DCHECK(device_fd_.is_valid());
-  return HANDLE_EINTR(ioctl(device_fd_.get(), request, arg));
+  return HANDLE_EINTR(v4l2_ioctl(device_fd_.get(), request, arg));
 }
 
 bool V4L2Device::Poll(bool poll_device, bool* event_pending) {
@@ -357,11 +363,11 @@ void* V4L2Device::Mmap(void* addr,
                        int flags,
                        unsigned int offset) {
   DCHECK(device_fd_.is_valid());
-  return mmap(addr, len, prot, flags, device_fd_.get(), offset);
+  return v4l2_mmap(addr, len, prot, flags, device_fd_.get(), offset);
 }
 
 void V4L2Device::Munmap(void* addr, unsigned int len) {
-  munmap(addr, len);
+  v4l2_munmap(addr, len);
 }
 
 bool V4L2Device::SetDevicePollInterrupt() {
@@ -840,11 +846,20 @@ bool V4L2Device::OpenDevicePath(const st
 
   device_fd_.reset(
       HANDLE_EINTR(open(path.c_str(), O_RDWR | O_NONBLOCK | O_CLOEXEC)));
+  if (!device_fd_.is_valid())
+    return false;
+
+  if (HANDLE_EINTR(v4l2_fd_open(device_fd_.get(), V4L2_DISABLE_CONVERSION)) !=
+          -1) {
+    DVLOGF(3) << "Using libv4l2 for " << path;
+  }
   return device_fd_.is_valid();
 }
 
 void V4L2Device::CloseDevice() {
   DVLOGF(3);
+  if (device_fd_.is_valid())
+    v4l2_close(device_fd_.release());
   device_fd_.reset();
 }
 
@@ -935,4 +950,14 @@ std::string V4L2Device::GetDevicePathFor
   return std::string();
 }
 
+scoped_refptr<V4L2Device> V4L2Device::Create() {
+  scoped_refptr<V4L2Device> device = new V4L2Device();
+  StubPathMap paths;
+  paths[kModuleV4l2].push_back(V4L2Device::kLibV4l2Path);
+  if (InitializeStubs(paths))
+    return device;
+  LOG(ERROR) << "failed to init v4l2 lib.";
+  return nullptr;
+}
+
 }  //  namespace media
Index: src/media/gpu/v4l2/BUILD.gn
===================================================================
--- src.orig/media/gpu/v4l2/BUILD.gn
+++ src/media/gpu/v4l2/BUILD.gn
@@ -8,10 +8,18 @@ import("//build/config/ui.gni")
 import("//media/gpu/args.gni")
 import("//media/media_options.gni")
 import("//testing/test.gni")
+import("//tools/generate_stubs/rules.gni")
 import("//ui/gl/features.gni")
 
 assert(use_v4l2_codec)
 
+generate_stubs("libv4l2_stubs") {
+  extra_header = "v4l2_stub_header.fragment"
+  sigs = [ "v4l2.sig" ]
+  output_name = "v4l2_stubs"
+  deps = [ "//base" ]
+}
+
 source_set("v4l2") {
   defines = [ "MEDIA_GPU_IMPLEMENTATION" ]
   sources = [
@@ -113,6 +121,7 @@ source_set("v4l2") {
   public_deps = [ "//ui/gl" ]
 
   deps = [
+    ":libv4l2_stubs",
     ":v4l2_status",
     "//base",
     "//build/config/linux/libdrm",
Index: src/media/gpu/v4l2/legacy/v4l2_video_decode_accelerator.cc
===================================================================
--- src.orig/media/gpu/v4l2/legacy/v4l2_video_decode_accelerator.cc
+++ src/media/gpu/v4l2/legacy/v4l2_video_decode_accelerator.cc
@@ -755,7 +755,9 @@ bool V4L2VideoDecodeAccelerator::TryToSe
 // static
 VideoDecodeAccelerator::SupportedProfiles
 V4L2VideoDecodeAccelerator::GetSupportedProfiles() {
-  auto device = base::MakeRefCounted<V4L2Device>();
+  auto device = V4L2Device::Create();
+  if (!device)
+    return std::vector<SupportedProfile>();
   return device->GetSupportedDecodeProfiles(kSupportedInputFourCCs);
 }
 
@@ -2220,7 +2222,9 @@ bool V4L2VideoDecodeAccelerator::SetupFo
         VLOGF(1) << "Can't find a usable output format from image processor";
         return false;
       }
-      image_processor_device_ = base::MakeRefCounted<V4L2Device>();
+      image_processor_device_ = V4L2Device::Create();
+      if (!image_processor_device_)
+        return false;
     }
   } else {
     egl_image_format_fourcc_ = output_format_fourcc_;
@@ -2263,7 +2267,9 @@ bool V4L2VideoDecodeAccelerator::CreateI
 
   // Start with a brand new image processor device, since the old one was
   // already opened and attempting to open it again is not supported.
-  image_processor_device_ = base::MakeRefCounted<V4L2Device>();
+  image_processor_device_ = V4L2Device::Create();
+  if (!image_processor_device_)
+    return false;
 
   image_processor_ = v4l2_vda_helpers::CreateImageProcessor(
       *output_format_fourcc_, *egl_image_format_fourcc_, coded_size_,
Index: src/media/gpu/v4l2/v4l2_device.h
===================================================================
--- src.orig/media/gpu/v4l2/v4l2_device.h
+++ src/media/gpu/v4l2/v4l2_device.h
@@ -96,6 +96,13 @@ class MEDIA_GPU_EXPORT V4L2Device
 
   V4L2Device();
 
+  inline static constexpr char kLibV4l2Path[] =
+#if defined(__aarch64__)
+      "/usr/lib64/libv4l2.so";
+#else
+      "/usr/lib/libv4l2.so";
+#endif
+  static scoped_refptr<V4L2Device> Create();
   // Open a V4L2 device of |type| for use with |v4l2_pixfmt|.
   // Return true on success.
   // The device will be closed in the destructor.
Index: src/media/gpu/v4l2/v4l2_jpeg_encode_accelerator.cc
===================================================================
--- src.orig/media/gpu/v4l2/v4l2_jpeg_encode_accelerator.cc
+++ src/media/gpu/v4l2/v4l2_jpeg_encode_accelerator.cc
@@ -116,7 +116,9 @@ void V4L2JpegEncodeAccelerator::EncodedI
 
 bool V4L2JpegEncodeAccelerator::EncodedInstanceDmaBuf::Initialize() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(parent_->encoder_sequence_);
-  device_ = base::MakeRefCounted<V4L2Device>();
+  device_ = V4L2Device::Create();
+  if (!device_)
+    return false;
   gpu_memory_buffer_support_ = std::make_unique<gpu::GpuMemoryBufferSupport>();
   output_buffer_pixelformat_ = V4L2_PIX_FMT_JPEG;
   if (!device_->Open(V4L2Device::Type::kJpegEncoder,
Index: src/media/gpu/v4l2/v4l2_video_decoder.cc
===================================================================
--- src.orig/media/gpu/v4l2/v4l2_video_decoder.cc
+++ src/media/gpu/v4l2/v4l2_video_decoder.cc
@@ -155,7 +155,9 @@ std::unique_ptr<VideoDecoderMixin> V4L2V
 // static
 std::optional<SupportedVideoDecoderConfigs>
 V4L2VideoDecoder::GetSupportedConfigs() {
-  auto device = base::MakeRefCounted<V4L2Device>();
+  auto device = V4L2Device::Create();
+  if (!device)
+    return absl::nullopt;
   auto configs = device->GetSupportedDecodeProfiles(kSupportedInputFourccs);
   if (configs.empty())
     return std::nullopt;
@@ -302,7 +304,9 @@ void V4L2VideoDecoder::Initialize(const
       can_use_decoder_ = false;
     }
 
-    device_ = base::MakeRefCounted<V4L2Device>();
+    device_ = V4L2Device::Create();
+    if (!device_)
+      return;
     continue_change_resolution_cb_.Reset();
     if (backend_)
       backend_ = nullptr;
Index: src/media/gpu/v4l2/v4l2_video_encode_accelerator.cc
===================================================================
--- src.orig/media/gpu/v4l2/v4l2_video_encode_accelerator.cc
+++ src/media/gpu/v4l2/v4l2_video_encode_accelerator.cc
@@ -647,7 +647,9 @@ bool V4L2VideoEncodeAccelerator::IsFlush
 
 VideoEncodeAccelerator::SupportedProfiles
 V4L2VideoEncodeAccelerator::GetSupportedProfiles() {
-  auto device = base::MakeRefCounted<V4L2Device>();
+  auto device = V4L2Device::Create();
+  if (!device)
+    return VideoEncodeAccelerator::SupportedProfiles();
   return device->GetSupportedEncodeProfiles();
 }
 
Index: src/media/gpu/v4l2/v4l2_image_processor_backend.cc
===================================================================
--- src.orig/media/gpu/v4l2/v4l2_image_processor_backend.cc
+++ src/media/gpu/v4l2/v4l2_image_processor_backend.cc
@@ -409,20 +409,26 @@ std::unique_ptr<ImageProcessorBackend> V
 
 // static
 bool V4L2ImageProcessorBackend::IsSupported() {
-  auto device = base::MakeRefCounted<V4L2Device>();
+  auto device = V4L2Device::Create();
+  if (!device)
+    return false;
   return device->IsImageProcessingSupported();
 }
 
 // static
 std::vector<uint32_t> V4L2ImageProcessorBackend::GetSupportedInputFormats() {
-  auto device = base::MakeRefCounted<V4L2Device>();
+  auto device = V4L2Device::Create();
+  if (!device)
+    return std::vector<uint32_t>();
   return device->GetSupportedImageProcessorPixelformats(
       V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
 }
 
 // static
 std::vector<uint32_t> V4L2ImageProcessorBackend::GetSupportedOutputFormats() {
-  auto device = base::MakeRefCounted<V4L2Device>();
+  auto device = V4L2Device::Create();
+  if (!device)
+    return std::vector<uint32_t>();
   return device->GetSupportedImageProcessorPixelformats(
       V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
 }
@@ -437,8 +443,8 @@ bool V4L2ImageProcessorBackend::TryOutpu
             << " input_size=" << input_size.ToString()
             << " output_format=" << FourccToString(output_pixelformat)
             << " output_size=" << output_size->ToString();
-  auto device = base::MakeRefCounted<V4L2Device>();
-  if (!device->Open(V4L2Device::Type::kImageProcessor, input_pixelformat)) {
+  auto device = V4L2Device::Create();
+  if (!device || !device->Open(V4L2Device::Type::kImageProcessor, input_pixelformat)) {
     return false;
   }
 
Index: src/media/gpu/v4l2/v4l2_mjpeg_decode_accelerator.cc
===================================================================
--- src.orig/media/gpu/v4l2/v4l2_mjpeg_decode_accelerator.cc
+++ src/media/gpu/v4l2/v4l2_mjpeg_decode_accelerator.cc
@@ -496,7 +496,9 @@ void V4L2MjpegDecodeAccelerator::Decode(
 
 // static
 bool V4L2MjpegDecodeAccelerator::IsSupported() {
-  auto device = base::MakeRefCounted<V4L2Device>();
+  auto device = V4L2Device::Create();
+  if (!device)
+    return false;
   return device->IsJpegDecodingSupported();
 }
 
Index: src/media/gpu/v4l2/v4l2_video_decoder_backend_stateful.cc
===================================================================
--- src.orig/media/gpu/v4l2/v4l2_video_decoder_backend_stateful.cc
+++ src/media/gpu/v4l2/v4l2_video_decoder_backend_stateful.cc
@@ -762,7 +762,9 @@ bool V4L2StatefulVideoDecoderBackend::Is
       V4L2_PIX_FMT_VP8,
       V4L2_PIX_FMT_VP9,
     };
-    auto device = base::MakeRefCounted<V4L2Device>();
+    auto device = V4L2Device::Create();
+    if (!device)
+      return false;
     VideoDecodeAccelerator::SupportedProfiles profiles =
         device->GetSupportedDecodeProfiles(kSupportedInputFourccs);
     for (const auto& entry : profiles)
Index: src/media/gpu/v4l2/v4l2_video_decoder_backend_stateless.cc
===================================================================
--- src.orig/media/gpu/v4l2/v4l2_video_decoder_backend_stateless.cc
+++ src/media/gpu/v4l2/v4l2_video_decoder_backend_stateless.cc
@@ -704,7 +704,9 @@ bool V4L2StatelessVideoDecoderBackend::I
       V4L2_PIX_FMT_VP9_FRAME,
       V4L2_PIX_FMT_AV1_FRAME,
     };
-    auto device = base::MakeRefCounted<V4L2Device>();
+    auto device = V4L2Device::Create();
+    if (!device)
+      return false;
     VideoDecodeAccelerator::SupportedProfiles profiles =
         device->GetSupportedDecodeProfiles(kSupportedInputFourccs);
     for (const auto& entry : profiles)
