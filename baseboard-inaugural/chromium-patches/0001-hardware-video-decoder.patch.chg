diff --git a/media/gpu/gpu_video_decode_accelerator_factory.cc b/media/gpu/gpu_video_decode_accelerator_factory.cc
index 0dc73a529bb3a..ab13e5819b845 100644
--- a/media/gpu/gpu_video_decode_accelerator_factory.cc
+++ b/media/gpu/gpu_video_decode_accelerator_factory.cc
@@ -33,8 +33,10 @@ namespace {
 gpu::VideoDecodeAcceleratorCapabilities GetDecoderCapabilitiesInternal(
     const gpu::GpuPreferences& gpu_preferences,
     const gpu::GpuDriverBugWorkarounds& workarounds) {
-  if (gpu_preferences.disable_accelerated_video_decode)
+  if (gpu_preferences.disable_accelerated_video_decode) {
+    VLOGF(1) << "gpu disable_accelerated_video_decode";
     return gpu::VideoDecodeAcceleratorCapabilities();
+  }

   // Query VDAs for their capabilities and construct a set of supported
   // profiles for current platform. This must be done in the same order as in
diff --git a/media/gpu/sandbox/hardware_video_decoding_sandbox_hook_linux.cc b/media/gpu/sandbox/hardware_video_decoding_sandbox_hook_linux.cc
index 038491c615f51..b440c2bf43362 100644
--- a/media/gpu/sandbox/hardware_video_decoding_sandbox_hook_linux.cc
+++ b/media/gpu/sandbox/hardware_video_decoding_sandbox_hook_linux.cc
@@ -134,11 +134,14 @@ bool HardwareVideoDecodingPreSandboxHookForV4L2(
     std::vector<BrokerFilePermission>& permissions) {
 #if BUILDFLAG(USE_V4L2_CODEC)
   command_set.set(sandbox::syscall_broker::COMMAND_OPEN);
+  command_set.set(sandbox::syscall_broker::COMMAND_STAT);
+  command_set.set(sandbox::syscall_broker::COMMAND_READLINK);
+  command_set.set(sandbox::syscall_broker::COMMAND_INOTIFY_ADD_WATCH);

   // TODO(b/210759684): we should open the render node for minigbm before
   // entering the sandbox so that we can remove this permission.
   AllowAccessToRenderNodes(permissions, /*include_sys_dev_char=*/false,
-                           /*read_write=*/false);
+                           /*read_write=*/true);

   // Device nodes for V4L2 video decode accelerator drivers.
   // We do not use a FileEnumerator because the device files may not exist yet
@@ -167,6 +170,28 @@ bool HardwareVideoDecodingPreSandboxHookForV4L2(
   // platforms that need it.
   static const char kDevImageProc0Path[] = "/dev/image-proc0";
   permissions.push_back(BrokerFilePermission::ReadWrite(kDevImageProc0Path));
+#if BUILDFLAG(USE_LIBV4L2)
+  permissions.push_back(BrokerFilePermission::ReadOnlyRecursive("/proc/device-tree"));
+  permissions.push_back(BrokerFilePermission::ReadWrite("/dev/mpp_service"));
+  permissions.push_back(BrokerFilePermission::ReadWrite("/dev/rga"));
+#if defined(__aarch64__)
+  dlopen("/usr/lib64/libv4l/plugins/libv4l-encplugin.so", RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE);
+  dlopen("/usr/lib64/librockchip_mpp.so", RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE);
+  dlopen("/usr/lib64/libv4l2.so", RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE);
+#if 0
+  permissions.push_back(BrokerFilePermission::ReadOnly("/usr/lib64/libv4l/plugins/libv4l-encplugin.so"));
+  permissions.push_back(BrokerFilePermission::ReadOnly("/usr/lib64/librockchip_mpp.so"));
+  constexpr unsigned int kFlags = RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE;
+  dlopen("/usr/lib64/libv4l2.so", kFlags );
+  dlopen("/usr/lib64/libv4l/plugins/libv4l-encplugin.so", kFlags);
+  dlopen("/usr/lib64/librockchip_mpp.so", kFlags);
+  dlopen("/usr/lib64/librockchip_vpu.so", kFlags);
+#endif
+#else
+  dlopen("/usr/lib/libv4l2.so", RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE);
+  dlopen("/usr/lib/libv42/plugins/libv4l-encplugin.so", RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE);
+#endif  // defined(__aarch64__)
+#endif  // BUILDFLAG(USE_LIBV4L2)
   return true;
 #else
   NOTREACHED_NORETURN();
diff --git a/media/gpu/sandbox/hardware_video_encoding_sandbox_hook_linux.cc b/media/gpu/sandbox/hardware_video_encoding_sandbox_hook_linux.cc
index e1dbbae4eeb40..b5a9a91988c11 100644
--- a/media/gpu/sandbox/hardware_video_encoding_sandbox_hook_linux.cc
+++ b/media/gpu/sandbox/hardware_video_encoding_sandbox_hook_linux.cc
@@ -29,6 +29,9 @@ bool HardwareVideoEncodingPreSandboxHook(

 #if BUILDFLAG(USE_V4L2_CODEC)
   command_set.set(sandbox::syscall_broker::COMMAND_OPEN);
+  command_set.set(sandbox::syscall_broker::COMMAND_STAT);
+  command_set.set(sandbox::syscall_broker::COMMAND_READLINK);
+  command_set.set(sandbox::syscall_broker::COMMAND_INOTIFY_ADD_WATCH);

   // Device nodes for V4L2 video encode accelerator drivers.
   // We do not use a FileEnumerator because the device files may not exist
@@ -50,6 +53,21 @@ bool HardwareVideoEncodingPreSandboxHook(
   // permission to only platforms that need it.
   static const char kDevImageProc0Path[] = "/dev/image-proc0";
   permissions.push_back(BrokerFilePermission::ReadWrite(kDevImageProc0Path));
+#if BUILDFLAG(USE_LIBV4L2)
+  permissions.push_back(BrokerFilePermission::ReadOnlyRecursive("/proc/device-tree"));
+  permissions.push_back(BrokerFilePermission::ReadWrite("/dev/mpp_service"));
+  permissions.push_back(BrokerFilePermission::ReadWrite("/dev/rga"));
+  permissions.push_back(BrokerFilePermission::ReadWrite("/dev/dri/renderD128"));
+#if defined(__aarch64__)
+  constexpr unsigned int kFlags = RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE;
+  dlopen("/usr/lib64/librockchip_mpp.so", kFlags);
+  dlopen("/usr/lib64/libv4l/plugins/libv4l-encplugin.so", kFlags);
+  dlopen("/usr/lib64/libv4l2.so", kFlags );
+#else
+  dlopen("/usr/lib/libv4l2.so", RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE);
+  dlopen("/usr/lib/libv4l/plugins/libv4l-encplugin.so", RTLD_NOW | RTLD_GLOBAL | RTLD_NODELETE);
+#endif  // defined(__aarch64__)
+#endif  // BUILDFLAG(USE_LIBV4L2)
 #elif BUILDFLAG(USE_VAAPI)
   command_set.set(sandbox::syscall_broker::COMMAND_OPEN);
   command_set.set(sandbox::syscall_broker::COMMAND_STAT);
diff --git a/media/gpu/v4l2/BUILD.gn b/media/gpu/v4l2/BUILD.gn
index cf469a68cd7ee..f66bddb15c733 100644
--- a/media/gpu/v4l2/BUILD.gn
+++ b/media/gpu/v4l2/BUILD.gn
@@ -8,10 +8,18 @@ import("//build/config/ui.gni")
 import("//media/gpu/args.gni")
 import("//media/media_options.gni")
 import("//testing/test.gni")
+import("//tools/generate_stubs/rules.gni")
 import("//ui/gl/features.gni")

 assert(use_v4l2_codec)

+generate_stubs("libv4l2_stubs") {
+  extra_header = "v4l2_stub_header.fragment"
+  sigs = [ "v4l2.sig" ]
+  output_name = "v4l2_stubs"
+  deps = [ "//base" ]
+}
+
 source_set("v4l2") {
   defines = [ "MEDIA_GPU_IMPLEMENTATION" ]
   sources = [
@@ -113,6 +121,7 @@ source_set("v4l2") {
   public_deps = [ "//ui/gl" ]

   deps = [
+    ":libv4l2_stubs",
     ":v4l2_status",
     "//base",
     "//build/config/linux/libdrm",
diff --git a/media/gpu/v4l2/legacy/v4l2_video_decode_accelerator.cc b/media/gpu/v4l2/legacy/v4l2_video_decode_accelerator.cc
index 0269d7ca7448d..93e3618a2b58f 100644
--- a/media/gpu/v4l2/legacy/v4l2_video_decode_accelerator.cc
+++ b/media/gpu/v4l2/legacy/v4l2_video_decode_accelerator.cc
@@ -755,7 +755,11 @@ bool V4L2VideoDecodeAccelerator::TryToSetupDecodeOnSeparateSequence(
 // static
 VideoDecodeAccelerator::SupportedProfiles
 V4L2VideoDecodeAccelerator::GetSupportedProfiles() {
-  auto device = base::MakeRefCounted<V4L2Device>();
+  auto device = V4L2Device::Create();
+  if (!device) {
+    VLOGF(2) << "no device found";
+    return std::vector<SupportedProfile>();
+  }
   return device->GetSupportedDecodeProfiles(kSupportedInputFourCCs);
 }

@@ -2220,7 +2224,9 @@ bool V4L2VideoDecodeAccelerator::SetupFormats() {
         VLOGF(1) << "Can't find a usable output format from image processor";
         return false;
       }
-      image_processor_device_ = base::MakeRefCounted<V4L2Device>();
+      image_processor_device_ = V4L2Device::Create();
+      if (!image_processor_device_)
+        return false;
     }
   } else {
     egl_image_format_fourcc_ = output_format_fourcc_;
@@ -2263,7 +2269,9 @@ bool V4L2VideoDecodeAccelerator::CreateImageProcessor() {

   // Start with a brand new image processor device, since the old one was
   // already opened and attempting to open it again is not supported.
-  image_processor_device_ = base::MakeRefCounted<V4L2Device>();
+  image_processor_device_ = V4L2Device::Create();
+  if (!image_processor_device_)
+    return false;

   image_processor_ = v4l2_vda_helpers::CreateImageProcessor(
       *output_format_fourcc_, *egl_image_format_fourcc_, coded_size_,
diff --git a/media/gpu/v4l2/v4l2.sig b/media/gpu/v4l2/v4l2.sig
index 32931df372017..8f1894536a7aa 100644
--- a/media/gpu/v4l2/v4l2.sig
+++ b/media/gpu/v4l2/v4l2.sig
@@ -8,3 +8,5 @@
 LIBV4L_PUBLIC int v4l2_close(int fd);
 LIBV4L_PUBLIC int v4l2_ioctl(int fd, unsigned long int request, ...);
 LIBV4L_PUBLIC int v4l2_fd_open(int fd, int v4l2_flags);
+LIBV4L_PUBLIC void *v4l2_mmap(void *start, size_t length, int prot, int flags, int fd, int64_t offset);
+LIBV4L_PUBLIC int v4l2_munmap(void *_start, size_t length);
diff --git a/media/gpu/v4l2/v4l2_device.cc b/media/gpu/v4l2/v4l2_device.cc
index e9fc02a472ca6..855cce7f57294 100644
--- a/media/gpu/v4l2/v4l2_device.cc
+++ b/media/gpu/v4l2/v4l2_device.cc
@@ -34,6 +34,12 @@
 #include "media/gpu/v4l2/v4l2_queue.h"
 #include "media/gpu/v4l2/v4l2_utils.h"
 #include "ui/gl/egl_util.h"
+#include "media/gpu/v4l2/v4l2_stubs.h"
+#include "third_party/v4l-utils/lib/include/libv4l2.h"
+
+using media_gpu_v4l2::InitializeStubs;
+using media_gpu_v4l2::kModuleV4l2;
+using media_gpu_v4l2::StubPathMap;

 namespace media {

@@ -323,7 +329,7 @@ gfx::Size V4L2Device::AllocatedSizeFromV4L2Format(

 int V4L2Device::Ioctl(int request, void* arg) {
   DCHECK(device_fd_.is_valid());
-  return HANDLE_EINTR(ioctl(device_fd_.get(), request, arg));
+  return HANDLE_EINTR(v4l2_ioctl(device_fd_.get(), request, arg));
 }

 bool V4L2Device::Poll(bool poll_device, bool* event_pending) {
@@ -357,11 +363,11 @@ void* V4L2Device::Mmap(void* addr,
                        int flags,
                        unsigned int offset) {
   DCHECK(device_fd_.is_valid());
-  return mmap(addr, len, prot, flags, device_fd_.get(), offset);
+  return v4l2_mmap(addr, len, prot, flags, device_fd_.get(), offset);
 }

 void V4L2Device::Munmap(void* addr, unsigned int len) {
-  munmap(addr, len);
+  v4l2_munmap(addr, len);
 }

 bool V4L2Device::SetDevicePollInterrupt() {
@@ -840,11 +846,20 @@ bool V4L2Device::OpenDevicePath(const std::string& path) {

   device_fd_.reset(
       HANDLE_EINTR(open(path.c_str(), O_RDWR | O_NONBLOCK | O_CLOEXEC)));
+  if (!device_fd_.is_valid())
+    return false;
+
+  if (HANDLE_EINTR(v4l2_fd_open(device_fd_.get(), V4L2_DISABLE_CONVERSION)) !=
+          -1) {
+    DVLOGF(3) << "Using libv4l2 for " << path;
+  }
   return device_fd_.is_valid();
 }

 void V4L2Device::CloseDevice() {
   DVLOGF(3);
+  if (device_fd_.is_valid())
+    v4l2_close(device_fd_.release());
   device_fd_.reset();
 }

@@ -935,4 +950,14 @@ std::string V4L2Device::GetDevicePathFor(Type type, uint32_t pixfmt) {
   return std::string();
 }

+scoped_refptr<V4L2Device> V4L2Device::Create() {
+  scoped_refptr<V4L2Device> device = new V4L2Device();
+  StubPathMap paths;
+  paths[kModuleV4l2].push_back(V4L2Device::kLibV4l2Path);
+  if (InitializeStubs(paths))
+    return device;
+  LOG(ERROR) << "failed to init v4l2 lib.";
+  return nullptr;
+}
+
 }  //  namespace media
diff --git a/media/gpu/v4l2/v4l2_device.h b/media/gpu/v4l2/v4l2_device.h
index 620dbd523723f..dfe9042975b3b 100644
--- a/media/gpu/v4l2/v4l2_device.h
+++ b/media/gpu/v4l2/v4l2_device.h
@@ -96,6 +96,13 @@ class MEDIA_GPU_EXPORT V4L2Device

   V4L2Device();

+  inline static constexpr char kLibV4l2Path[] =
+#if defined(__aarch64__)
+      "/usr/lib64/libv4l2.so";
+#else
+      "/usr/lib/libv4l2.so";
+#endif
+  static scoped_refptr<V4L2Device> Create();
   // Open a V4L2 device of |type| for use with |v4l2_pixfmt|.
   // Return true on success.
   // The device will be closed in the destructor.
diff --git a/media/gpu/v4l2/v4l2_image_processor_backend.cc b/media/gpu/v4l2/v4l2_image_processor_backend.cc
index 070f4db1fbf4f..4f4543f980b3e 100644
--- a/media/gpu/v4l2/v4l2_image_processor_backend.cc
+++ b/media/gpu/v4l2/v4l2_image_processor_backend.cc
@@ -409,20 +409,26 @@ std::unique_ptr<ImageProcessorBackend> V4L2ImageProcessorBackend::Create(

 // static
 bool V4L2ImageProcessorBackend::IsSupported() {
-  auto device = base::MakeRefCounted<V4L2Device>();
+  auto device = V4L2Device::Create();
+  if (!device)
+    return false;
   return device->IsImageProcessingSupported();
 }

 // static
 std::vector<uint32_t> V4L2ImageProcessorBackend::GetSupportedInputFormats() {
-  auto device = base::MakeRefCounted<V4L2Device>();
+  auto device = V4L2Device::Create();
+  if (!device)
+    return std::vector<uint32_t>();
   return device->GetSupportedImageProcessorPixelformats(
       V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);
 }

 // static
 std::vector<uint32_t> V4L2ImageProcessorBackend::GetSupportedOutputFormats() {
-  auto device = base::MakeRefCounted<V4L2Device>();
+  auto device = V4L2Device::Create();
+  if (!device)
+    return std::vector<uint32_t>();
   return device->GetSupportedImageProcessorPixelformats(
       V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);
 }
@@ -437,8 +443,8 @@ bool V4L2ImageProcessorBackend::TryOutputFormat(uint32_t input_pixelformat,
             << " input_size=" << input_size.ToString()
             << " output_format=" << FourccToString(output_pixelformat)
             << " output_size=" << output_size->ToString();
-  auto device = base::MakeRefCounted<V4L2Device>();
-  if (!device->Open(V4L2Device::Type::kImageProcessor, input_pixelformat)) {
+  auto device = V4L2Device::Create();
+  if (!device || !device->Open(V4L2Device::Type::kImageProcessor, input_pixelformat)) {
     return false;
   }

diff --git a/media/gpu/v4l2/v4l2_jpeg_encode_accelerator.cc b/media/gpu/v4l2/v4l2_jpeg_encode_accelerator.cc
index 8ade5ab42816f..94eee0cbb29c9 100644
--- a/media/gpu/v4l2/v4l2_jpeg_encode_accelerator.cc
+++ b/media/gpu/v4l2/v4l2_jpeg_encode_accelerator.cc
@@ -116,7 +116,9 @@ void V4L2JpegEncodeAccelerator::EncodedInstanceDmaBuf::DestroyTask() {

 bool V4L2JpegEncodeAccelerator::EncodedInstanceDmaBuf::Initialize() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(parent_->encoder_sequence_);
-  device_ = base::MakeRefCounted<V4L2Device>();
+  device_ = V4L2Device::Create();
+  if (!device_)
+    return false;
   gpu_memory_buffer_support_ = std::make_unique<gpu::GpuMemoryBufferSupport>();
   output_buffer_pixelformat_ = V4L2_PIX_FMT_JPEG;
   if (!device_->Open(V4L2Device::Type::kJpegEncoder,
diff --git a/media/gpu/v4l2/v4l2_mjpeg_decode_accelerator.cc b/media/gpu/v4l2/v4l2_mjpeg_decode_accelerator.cc
index e59dc80276268..4ca193d6e0124 100644
--- a/media/gpu/v4l2/v4l2_mjpeg_decode_accelerator.cc
+++ b/media/gpu/v4l2/v4l2_mjpeg_decode_accelerator.cc
@@ -496,7 +496,9 @@ void V4L2MjpegDecodeAccelerator::Decode(

 // static
 bool V4L2MjpegDecodeAccelerator::IsSupported() {
-  auto device = base::MakeRefCounted<V4L2Device>();
+  auto device = V4L2Device::Create();
+  if (!device)
+    return false;
   return device->IsJpegDecodingSupported();
 }

diff --git a/media/gpu/v4l2/v4l2_video_decoder.cc b/media/gpu/v4l2/v4l2_video_decoder.cc
index 1ba50a5aa643f..b0794dde09524 100644
--- a/media/gpu/v4l2/v4l2_video_decoder.cc
+++ b/media/gpu/v4l2/v4l2_video_decoder.cc
@@ -155,7 +155,9 @@ std::unique_ptr<VideoDecoderMixin> V4L2VideoDecoder::Create(
 // static
 std::optional<SupportedVideoDecoderConfigs>
 V4L2VideoDecoder::GetSupportedConfigs() {
-  auto device = base::MakeRefCounted<V4L2Device>();
+  auto device = V4L2Device::Create();
+  if (!device)
+    return std::nullopt;
   auto configs = device->GetSupportedDecodeProfiles(kSupportedInputFourccs);
   if (configs.empty())
     return std::nullopt;
@@ -302,7 +304,9 @@ void V4L2VideoDecoder::Initialize(const VideoDecoderConfig& config,
       can_use_decoder_ = false;
     }

-    device_ = base::MakeRefCounted<V4L2Device>();
+    device_ = V4L2Device::Create();
+    if (!device_)
+      return;
     continue_change_resolution_cb_.Reset();
     if (backend_)
       backend_ = nullptr;
diff --git a/media/gpu/v4l2/v4l2_video_decoder_backend_stateful.cc b/media/gpu/v4l2/v4l2_video_decoder_backend_stateful.cc
index efa47b903dc00..9638b69db91dc 100644
--- a/media/gpu/v4l2/v4l2_video_decoder_backend_stateful.cc
+++ b/media/gpu/v4l2/v4l2_video_decoder_backend_stateful.cc
@@ -762,7 +762,9 @@ bool V4L2StatefulVideoDecoderBackend::IsSupportedProfile(
       V4L2_PIX_FMT_VP8,
       V4L2_PIX_FMT_VP9,
     };
-    auto device = base::MakeRefCounted<V4L2Device>();
+    auto device = V4L2Device::Create();
+    if (!device)
+      return false;
     VideoDecodeAccelerator::SupportedProfiles profiles =
         device->GetSupportedDecodeProfiles(kSupportedInputFourccs);
     for (const auto& entry : profiles)
diff --git a/media/gpu/v4l2/v4l2_video_decoder_backend_stateless.cc b/media/gpu/v4l2/v4l2_video_decoder_backend_stateless.cc
index ee4d0a3c017a5..ab754f0dbdb4c 100644
--- a/media/gpu/v4l2/v4l2_video_decoder_backend_stateless.cc
+++ b/media/gpu/v4l2/v4l2_video_decoder_backend_stateless.cc
@@ -704,7 +704,9 @@ bool V4L2StatelessVideoDecoderBackend::IsSupportedProfile(
       V4L2_PIX_FMT_VP9_FRAME,
       V4L2_PIX_FMT_AV1_FRAME,
     };
-    auto device = base::MakeRefCounted<V4L2Device>();
+    auto device = V4L2Device::Create();
+    if (!device)
+      return false;
     VideoDecodeAccelerator::SupportedProfiles profiles =
         device->GetSupportedDecodeProfiles(kSupportedInputFourccs);
     for (const auto& entry : profiles)
diff --git a/media/gpu/v4l2/v4l2_video_encode_accelerator.cc b/media/gpu/v4l2/v4l2_video_encode_accelerator.cc
index d7a84c2d780d6..87b9a99374d39 100644
--- a/media/gpu/v4l2/v4l2_video_encode_accelerator.cc
+++ b/media/gpu/v4l2/v4l2_video_encode_accelerator.cc
@@ -647,7 +647,9 @@ bool V4L2VideoEncodeAccelerator::IsFlushSupported() {

 VideoEncodeAccelerator::SupportedProfiles
 V4L2VideoEncodeAccelerator::GetSupportedProfiles() {
-  auto device = base::MakeRefCounted<V4L2Device>();
+  auto device = V4L2Device::Create();
+  if (!device)
+    return VideoEncodeAccelerator::SupportedProfiles();
   return device->GetSupportedEncodeProfiles();
 }

diff --git a/sandbox/policy/linux/bpf_cros_arm_gpu_policy_linux.cc b/sandbox/policy/linux/bpf_cros_arm_gpu_policy_linux.cc
index 29798bc6200fa..ec2c65510624d 100644
--- a/sandbox/policy/linux/bpf_cros_arm_gpu_policy_linux.cc
+++ b/sandbox/policy/linux/bpf_cros_arm_gpu_policy_linux.cc
@@ -42,6 +42,9 @@ ResultExpr CrosArmGpuProcessPolicy::EvaluateSyscall(int sysno) const {
 #endif  // defined(__arm__) || defined(__aarch64__)

   switch (sysno) {
+#if defined(__aarch64__)
+    case __NR_mmap:
+#endif
 #if defined(__arm__) || defined(__aarch64__)
     // ARM GPU sandbox is started earlier so we need to allow networking
     // in the sandbox.
@@ -52,6 +55,14 @@ ResultExpr CrosArmGpuProcessPolicy::EvaluateSyscall(int sysno) const {
     case __NR_sched_setscheduler:
     case __NR_sysinfo:
     case __NR_uname:
+    case __NR_ioctl:
+    case __NR_madvise:
+    case __NR_futex:
+    case __NR_process_vm_readv:
+#if defined(__arm__)
+    // Only available on ARM 32bit devices
+    case __NR_mmap2:
+#endif
       return Allow();
     // Allow only AF_UNIX for |domain|.
     case __NR_socket:
diff --git a/sandbox/policy/linux/bpf_hardware_video_decoding_policy_linux.cc b/sandbox/policy/linux/bpf_hardware_video_decoding_policy_linux.cc
index b6b8550e50324..c6940d65c7324 100644
--- a/sandbox/policy/linux/bpf_hardware_video_decoding_policy_linux.cc
+++ b/sandbox/policy/linux/bpf_hardware_video_decoding_policy_linux.cc
@@ -132,8 +132,18 @@ ResultExpr HardwareVideoDecodingProcessPolicy::EvaluateSyscallForV4L2(
     return CrashSIGSYS();
   }

-  if (system_call_number == __NR_ioctl)
-    return Allow();
+  switch (system_call_number) {
+    case __NR_ioctl:
+    case __NR_madvise:
+    case __NR_futex:
+    case __NR_process_vm_readv:
+#if defined(__aarch64__)
+    case __NR_mmap:
+#elif defined(__arm__)
+    case __NR_mmap2:
+#endif
+      return Allow();
+  }

   if (system_call_number == __NR_sched_setaffinity) {
     return RestrictSchedTarget(GetPolicyPid(), system_call_number);
