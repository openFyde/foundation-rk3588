Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3568-hinlink-h66k.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3568-hinlink-h66k.dts
@@ -0,0 +1,23 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2020 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+/dts-v1/;
+
+#include "rk3568-hinlink-h6xk.dtsi"
+
+/ {
+	model = "HINLINK H66K";
+	compatible = "hinlink,h66k", "rockchip,rk3568";
+
+	aliases {
+		ethernet0 = &rtl8125_1;
+		ethernet1 = &rtl8125_2;
+	};
+};
+
+&vcc3v3_pcie {
+	gpio = <&gpio0 RK_PC4 GPIO_ACTIVE_HIGH>;
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3568-hinlink-h68k.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3568-hinlink-h68k.dts
@@ -0,0 +1,91 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2020 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+/dts-v1/;
+
+#include "rk3568-hinlink-h6xk.dtsi"
+
+/ {
+	model = "HINLINK H68K";
+	compatible = "hinlink,h68k", "rockchip,rk3568";
+
+	aliases {
+		ethernet0 = &gmac0;
+		ethernet1 = &gmac1;
+	};
+};
+
+&gmac0 {
+	phy-mode = "rgmii";
+	clock_in_out = "output";
+
+	snps,reset-gpio = <&gpio2 RK_PD3 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	/* Reset time is 20ms, 100ms for rtl8211f */
+	snps,reset-delays-us = <0 20000 100000>;
+
+	assigned-clocks = <&cru SCLK_GMAC0_RX_TX>, <&cru SCLK_GMAC0>;
+	assigned-clock-parents = <&cru SCLK_GMAC0_RGMII_SPEED>, <&cru CLK_MAC0_2TOP>;
+	assigned-clock-rates = <0>, <125000000>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac0_miim
+		     &gmac0_tx_bus2
+		     &gmac0_rx_bus2
+		     &gmac0_rgmii_clk
+		     &gmac0_rgmii_bus>;
+
+	tx_delay = <0x3c>;
+	rx_delay = <0x2f>;
+
+	phy-handle = <&rgmii_phy0>;
+	status = "okay";
+};
+
+&gmac1 {
+	phy-mode = "rgmii";
+	clock_in_out = "output";
+
+	snps,reset-gpio = <&gpio1 RK_PB0 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	/* Reset time is 20ms, 100ms for rtl8211f */
+	snps,reset-delays-us = <0 20000 100000>;
+
+	assigned-clocks = <&cru SCLK_GMAC1_RX_TX>, <&cru SCLK_GMAC1>;
+	assigned-clock-parents = <&cru SCLK_GMAC1_RGMII_SPEED>, <&cru CLK_MAC1_2TOP>;
+	assigned-clock-rates = <0>, <125000000>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac1m1_miim
+		     &gmac1m1_tx_bus2
+		     &gmac1m1_rx_bus2
+		     &gmac1m1_rgmii_clk
+		     &gmac1m1_rgmii_bus>;
+
+	tx_delay = <0x4f>;
+	rx_delay = <0x26>;
+
+	phy-handle = <&rgmii_phy1>;
+	status = "okay";
+};
+
+&mdio0 {
+	rgmii_phy0: phy@0 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x0>;
+	};
+};
+
+&mdio1 {
+	rgmii_phy1: phy@0 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x0>;
+	};
+};
+
+&vcc3v3_pcie {
+	gpio = <&gpio2 RK_PD2 GPIO_ACTIVE_HIGH>;
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3568-hinlink-h6xk.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3568-hinlink-h6xk.dtsi
@@ -0,0 +1,963 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2020 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/input/rk-input.h>
+#include <dt-bindings/display/drm_mipi_dsi.h>
+#include <dt-bindings/display/rockchip_vop.h>
+#include <dt-bindings/sensor-dev.h>
+#include "rk3568.dtsi"
+
+/ {
+	cspmu: cspmu@fd90c000 {
+		compatible = "rockchip,cspmu";
+		reg = <0x0 0xfd90c000 0x0 0x1000>,
+			<0x0 0xfd90d000 0x0 0x1000>,
+			<0x0 0xfd90e000 0x0 0x1000>,
+			<0x0 0xfd90f000 0x0 0x1000>;
+	};
+
+	dc_12v: dc-12v {
+		compatible = "regulator-fixed";
+		regulator-name = "dc_12v";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	debug: debug@fd904000 {
+		compatible = "rockchip,debug";
+		reg = <0x0 0xfd904000 0x0 0x1000>,
+			<0x0 0xfd905000 0x0 0x1000>,
+			<0x0 0xfd906000 0x0 0x1000>,
+			<0x0 0xfd907000 0x0 0x1000>;
+	};
+
+	fiq-debugger {
+		compatible = "rockchip,fiq-debugger";
+		rockchip,serial-id = <2>;
+		rockchip,wake-irq = <0>;
+		/* If enable uart uses irq instead of fiq */
+		rockchip,irq-mode-enable = <1>;
+		rockchip,baudrate = <1500000>;  /* Only 115200 and 1500000 */
+		interrupts = <GIC_SPI 252 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart2m0_xfer>;
+		status = "okay";
+	};
+
+	hdmi_sound: hdmi-sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <128>;
+		simple-audio-card,name = "rockchip,hdmi";
+		simple-audio-card,cpu {
+				sound-dai = <&i2s0_8ch>;
+		};
+		simple-audio-card,codec {
+				sound-dai = <&hdmi>;
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&led_work_en>;
+		led_work: work {
+			gpios = <&gpio3 RK_PB0 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	rk809_sound: rk809-sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,name = "rockchip,rk809-codec";
+		simple-audio-card,mclk-fs = <256>;
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s1_8ch>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&rk809_codec>;
+		};
+        };
+
+	rk_headset: rk-headset {
+		compatible = "rockchip_headset";
+		headset_gpio = <&gpio4 RK_PD2 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&hp_det>;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&dc_12v>;
+	};
+
+	vcc3v3_sys: vcc3v3-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		gpio = <&gpio0 RK_PB6 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc3v3_sys_en>;
+		vin-supply = <&vcc5v0_sys>;
+        };
+
+	vcc3v3_pcie: vcc3v3-pcie {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-name = "vcc3v3_pcie";
+		startup-delay-us = <5000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vcc5v0_otg: vcc5v0-otg-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_otg";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio0 RK_PA5 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_sys>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_otg_en>;
+	};
+};
+
+&bus_npu {
+	bus-supply = <&vdd_logic>;
+	pvtm-supply = <&vdd_cpu>;
+	status = "okay";
+};
+
+&combphy0_us {
+	status = "okay";
+};
+
+&combphy1_usq {
+	status = "okay";
+};
+
+&combphy2_psq {
+	status = "okay";
+};
+
+&cpu0 {
+	cpu-supply = <&vdd_cpu>;
+};
+
+&dfi {
+	status = "okay";
+};
+
+&dmc {
+	center-supply = <&vdd_logic>;
+	status = "okay";
+};
+
+&gpu {
+	clock-names = "gpu", "bus";
+	interrupt-names = "gpu", "mmu", "job";
+	mali-supply = <&vdd_gpu>;
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+	rockchip,phy-table =
+		<92812500  0x8009 0x0000 0x0270>,
+		<165000000 0x800b 0x0000 0x026d>,
+		<185625000 0x800b 0x0000 0x01ed>,
+		<297000000 0x800b 0x0000 0x01ad>,
+		<594000000 0x8029 0x0000 0x0088>,
+		<000000000 0x0000 0x0000 0x0000>;
+};
+
+&hdmi_in_vp0 {
+	status = "okay";
+};
+
+&hdmi_in_vp1 {
+	status = "disabled";
+};
+
+&i2c0 {
+	status = "okay";
+
+	vdd_cpu: tcs4525@1c {
+		compatible = "tcs,tcs452x";
+		reg = <0x1c>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "fan53555-reg";
+		regulator-name = "vdd_cpu";
+		regulator-min-microvolt = <712500>;
+		regulator-max-microvolt = <1390000>;
+		regulator-init-microvolt = <900000>;
+		regulator-initial-mode = <1>;
+		regulator-ramp-delay = <2300>;
+		fcs,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	rk809: pmic@20 {
+		compatible = "rockchip,rk809";
+		reg = <0x20>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <3 IRQ_TYPE_LEVEL_LOW>;
+
+		pinctrl-names = "default", "pmic-sleep",
+				"pmic-power-off", "pmic-reset";
+		pinctrl-0 = <&pmic_int>;
+		pinctrl-1 = <&soc_slppin_slp>, <&rk817_slppin_slp>;
+		pinctrl-2 = <&soc_slppin_gpio>, <&rk817_slppin_pwrdn>;
+		pinctrl-3 = <&soc_slppin_gpio>, <&rk817_slppin_rst>;
+
+		rockchip,system-power-controller;
+		wakeup-source;
+		#clock-cells = <1>;
+		clock-output-names = "rk808-clkout1", "rk808-clkout2";
+		//fb-inner-reg-idxs = <2>;
+		/* 1: rst regs (default in codes), 0: rst the pmic */
+		pmic-reset-func = <0>;
+		/* not save the PMIC_POWER_EN register in uboot */
+		not-save-power-en = <1>;
+
+		vcc1-supply = <&vcc3v3_sys>;
+		vcc2-supply = <&vcc3v3_sys>;
+		vcc3-supply = <&vcc3v3_sys>;
+		vcc4-supply = <&vcc3v3_sys>;
+		vcc5-supply = <&vcc3v3_sys>;
+		vcc6-supply = <&vcc3v3_sys>;
+		vcc7-supply = <&vcc3v3_sys>;
+		vcc8-supply = <&vcc3v3_sys>;
+		vcc9-supply = <&vcc3v3_sys>;
+
+		pwrkey {
+			status = "okay";
+		};
+
+		pinctrl_rk8xx: pinctrl_rk8xx {
+			gpio-controller;
+			#gpio-cells = <2>;
+
+			rk817_slppin_null: rk817_slppin_null {
+				pins = "gpio_slp";
+				function = "pin_fun0";
+			};
+
+			rk817_slppin_slp: rk817_slppin_slp {
+				pins = "gpio_slp";
+				function = "pin_fun1";
+			};
+
+			rk817_slppin_pwrdn: rk817_slppin_pwrdn {
+				pins = "gpio_slp";
+				function = "pin_fun2";
+			};
+
+			rk817_slppin_rst: rk817_slppin_rst {
+				pins = "gpio_slp";
+				function = "pin_fun3";
+			};
+		};
+
+		regulators {
+			vdd_logic: DCDC_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-init-microvolt = <900000>;
+				regulator-ramp-delay = <6001>;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vdd_logic";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdd_gpu: DCDC_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-init-microvolt = <900000>;
+				regulator-ramp-delay = <6001>;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vdd_gpu";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_ddr: DCDC_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vcc_ddr";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			vdd_npu: DCDC_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-init-microvolt = <900000>;
+				regulator-ramp-delay = <6001>;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vdd_npu";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdda0v9_image: LDO_REG1 {
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-name = "vdda0v9_image";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdda_0v9: LDO_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-name = "vdda_0v9";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdda0v9_pmu: LDO_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-name = "vdda0v9_pmu";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <900000>;
+				};
+			};
+
+			vccio_acodec: LDO_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-name = "vccio_acodec";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vccio_sd: LDO_REG5 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vccio_sd";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc3v3_pmu: LDO_REG6 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vcc3v3_pmu";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			vcca_1v8: LDO_REG7 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcca_1v8";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcca1v8_pmu: LDO_REG8 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcca1v8_pmu";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vcca1v8_image: LDO_REG9 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcca1v8_image";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_1v8: DCDC_REG5 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc_1v8";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_3v3: SWITCH_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-name = "vcc_3v3";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc3v3_sd: SWITCH_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-name = "vcc3v3_sd";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+		};
+
+		rk809_codec: codec {
+			#sound-dai-cells = <0>;
+			compatible = "rockchip,rk809-codec", "rockchip,rk817-codec";
+			clocks = <&cru I2S1_MCLKOUT>;
+			clock-names = "mclk";
+			assigned-clocks = <&cru I2S1_MCLKOUT>, <&cru I2S1_MCLK_TX_IOE>;
+			assigned-clock-rates = <12288000>;
+			assigned-clock-parents = <&cru I2S1_MCLKOUT_TX>, <&cru I2S1_MCLKOUT_TX>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2s1m0_mclk>;
+			hp-volume = <20>;
+			spk-volume = <3>;
+			mic-in-differential;
+			status = "okay";
+		};
+	};
+};
+
+&i2s0_8ch {
+	status = "okay";
+};
+
+&i2s1_8ch {
+	status = "okay";
+	rockchip,clk-trcm = <1>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2s1m0_sclktx
+		     &i2s1m0_lrcktx
+		     &i2s1m0_sdi0
+		     &i2s1m0_sdo0>;
+};
+
+&iep {
+	status = "okay";
+};
+
+&iep_mmu {
+	status = "okay";
+};
+
+&jpegd {
+	status = "okay";
+};
+
+&jpegd_mmu {
+	status = "okay";
+};
+
+&mpp_srv {
+	status = "okay";
+};
+
+&nandc0 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	status = "okay";
+
+	nand@0 {
+		reg = <0>;
+		nand-bus-width = <8>;
+		nand-ecc-mode = "hw";
+		nand-ecc-strength = <16>;
+		nand-ecc-step-size = <1024>;
+	};
+};
+
+&pcie2x1 {
+	reset-gpios = <&gpio2 RK_PD6 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_sys>;
+	status = "okay";
+};
+
+&pcie30phy {
+	status = "okay";
+};
+
+&pcie3x1 {
+	rockchip,bifurcation;
+	reset-gpios = <&gpio3 RK_PA4 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_pcie>;
+	status = "okay";
+
+	pcie@0,0 {
+		reg = <0x00100000 0 0 0 0>;
+		#address-cells = <3>;
+		#size-cells = <2>;
+
+		rtl8125_1: pcie@10,0 {
+			reg = <0x000000 0 0 0 0>;
+		};
+	};
+};
+
+&pcie3x2 {
+	rockchip,bifurcation;
+	rockchip,init-delay-ms = <100>;
+	reset-gpios = <&gpio2 RK_PD0 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_pcie>;
+	status = "okay";
+
+	pcie@0,0 {
+		reg = <0x00200000 0 0 0 0>;
+		#address-cells = <3>;
+		#size-cells = <2>;
+
+		rtl8125_2: pcie@20,0 {
+			reg = <0x000000 0 0 0 0>;
+		};
+	};
+};
+
+&pinctrl {
+	headphone {
+		hp_det: hp-det {
+			rockchip,pins = <4 RK_PD2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	leds {
+		led_work_en: led-work-en {
+			rockchip,pins =
+				<3 RK_PB0 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	pmic {
+		pmic_int: pmic_int {
+			rockchip,pins =
+				<0 RK_PA3 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		soc_slppin_gpio: soc_slppin_gpio {
+			rockchip,pins =
+				<0 RK_PA2 RK_FUNC_GPIO &pcfg_output_low>;
+		};
+
+		soc_slppin_slp: soc_slppin_slp {
+			rockchip,pins =
+				<0 RK_PA2 1 &pcfg_pull_none>;
+		};
+
+		soc_slppin_rst: soc_slppin_rst {
+			rockchip,pins =
+				<0 RK_PA2 2 &pcfg_pull_none>;
+		};
+	};
+
+	usb {
+		vcc5v0_otg_en: vcc5v0-otg-en {
+			rockchip,pins = <0 RK_PA5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	vcc {
+		vcc3v3_sys_en: vcc3v3-sys-en {
+			rockchip,pins = <0 RK_PB6 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+};
+
+&pmu_io_domains {
+	status = "okay";
+	pmuio1-supply = <&vcc3v3_pmu>;
+	pmuio2-supply = <&vcc3v3_pmu>;
+	vccio1-supply = <&vccio_acodec>;
+	vccio2-supply = <&vcc_1v8>;
+	vccio3-supply = <&vccio_sd>;
+	vccio4-supply = <&vcc_1v8>;
+	vccio5-supply = <&vcc_3v3>;
+	vccio6-supply = <&vcc_1v8>;
+	vccio7-supply = <&vcc_3v3>;
+};
+
+&pwm3 {
+	status = "okay";
+
+	compatible = "rockchip,remotectl-pwm";
+	remote_pwm_id = <3>;
+	handle_cpu_id = <1>;
+	remote_support_psci = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm3_pins>;
+
+	ir_key1 {
+		rockchip,usercode = <0x4040>;
+		rockchip,key_table =
+			<0xf2   KEY_REPLY>,
+			<0xba   KEY_BACK>,
+			<0xf4   KEY_UP>,
+			<0xf1   KEY_DOWN>,
+			<0xef   KEY_LEFT>,
+			<0xee   KEY_RIGHT>,
+			<0xbd   KEY_HOME>,
+			<0xea   KEY_VOLUMEUP>,
+			<0xe3   KEY_VOLUMEDOWN>,
+			<0xe2   KEY_SEARCH>,
+			<0xb2   KEY_POWER>,
+			<0xbc   KEY_MUTE>,
+			<0xec   KEY_MENU>,
+			<0xbf   0x190>,
+			<0xe0   0x191>,
+			<0xe1   0x192>,
+			<0xe9   183>,
+			<0xe6   248>,
+			<0xe8   185>,
+			<0xe7   186>,
+			<0xf0   388>,
+			<0xbe   0x175>;
+	};
+
+	ir_key2 {
+		rockchip,usercode = <0xff00>;
+		rockchip,key_table =
+			<0xf9   KEY_HOME>,
+			<0xbf   KEY_BACK>,
+			<0xfb   KEY_MENU>,
+			<0xaa   KEY_REPLY>,
+			<0xb9   KEY_UP>,
+			<0xe9   KEY_DOWN>,
+			<0xb8   KEY_LEFT>,
+			<0xea   KEY_RIGHT>,
+			<0xeb   KEY_VOLUMEDOWN>,
+			<0xef   KEY_VOLUMEUP>,
+			<0xf7   KEY_MUTE>,
+			<0xe7   KEY_POWER>,
+			<0xfc   KEY_POWER>,
+			<0xa9   KEY_VOLUMEDOWN>,
+			<0xa8   KEY_VOLUMEDOWN>,
+			<0xe0   KEY_VOLUMEDOWN>,
+			<0xa5   KEY_VOLUMEDOWN>,
+			<0xab   183>,
+			<0xb7   388>,
+			<0xe8   388>,
+			<0xf8   184>,
+			<0xaf   185>,
+			<0xed   KEY_VOLUMEDOWN>,
+			<0xee   186>,
+			<0xb3   KEY_VOLUMEDOWN>,
+			<0xf1   KEY_VOLUMEDOWN>,
+			<0xf2   KEY_VOLUMEDOWN>,
+			<0xf3   KEY_SEARCH>,
+			<0xb4   KEY_VOLUMEDOWN>,
+			<0xbe   KEY_SEARCH>;
+	};
+
+	ir_key3 {
+		rockchip,usercode = <0x1dcc>;
+		rockchip,key_table =
+			<0xee   KEY_REPLY>,
+			<0xf0   KEY_BACK>,
+			<0xf8   KEY_UP>,
+			<0xbb   KEY_DOWN>,
+			<0xef   KEY_LEFT>,
+			<0xed   KEY_RIGHT>,
+			<0xfc   KEY_HOME>,
+			<0xf1   KEY_VOLUMEUP>,
+			<0xfd   KEY_VOLUMEDOWN>,
+			<0xb7   KEY_SEARCH>,
+			<0xff   KEY_POWER>,
+			<0xf3   KEY_MUTE>,
+			<0xbf   KEY_MENU>,
+			<0xf9   0x191>,
+			<0xf5   0x192>,
+			<0xb3   388>,
+			<0xbe   KEY_1>,
+			<0xba   KEY_2>,
+			<0xb2   KEY_3>,
+			<0xbd   KEY_4>,
+			<0xf9   KEY_5>,
+			<0xb1   KEY_6>,
+			<0xfc   KEY_7>,
+			<0xf8   KEY_8>,
+			<0xb0   KEY_9>,
+			<0xb6   KEY_0>,
+			<0xb5   KEY_BACKSPACE>;
+	};
+
+	ir_key4 {
+		rockchip,usercode = <0xdd22>;
+		rockchip,key_table =
+			<0x23   KEY_POWER>,
+			<0x63   KEY_MUTE>,
+			<0x35   KEY_UP>,
+			<0x2d   KEY_DOWN>,
+			<0x66   KEY_LEFT>,
+			<0x3e   KEY_RIGHT>,
+			<0x31   KEY_ENTER>,
+			<0x6a   KEY_ESC>,
+			<0x7d   KEY_MENU>,
+			<0x7f   KEY_VOLUMEUP>,
+			<0x7e   KEY_VOLUMEDOWN>,
+			<0x77   KEY_HOME>;
+	};
+};
+
+&reserved_memory {
+	ramoops: ramoops@110000 {
+		compatible = "ramoops";
+		reg = <0x0 0x110000 0x0 0xf0000>;
+		record-size = <0x20000>;
+		console-size = <0x80000>;
+		ftrace-size = <0x00000>;
+		pmsg-size = <0x50000>;
+	};
+
+	rknpu_reserved: rknpu {
+		compatible = "shared-dma-pool";
+		inactive;
+		reusable;
+		size = <0x0 0x20000000>;
+		alignment = <0x0 0x1000>;
+	};
+};
+
+&rknpu {
+	memory-region = <&rknpu_reserved>;
+	rknpu-supply = <&vdd_npu>;
+	status = "okay";
+};
+
+&rknpu_mmu {
+	status = "okay";
+};
+
+&rk_rga {
+	status = "okay";
+};
+
+&rkvdec {
+	status = "okay";
+};
+
+&rkvdec_mmu {
+	status = "okay";
+};
+
+&rkvenc {
+	venc-supply = <&vdd_logic>;
+	status = "okay";
+};
+
+&rkvenc_mmu {
+	status = "okay";
+};
+
+&rng {
+	status = "okay";
+};
+
+&rockchip_suspend {
+	status = "okay";
+};
+
+&route_hdmi {
+	status = "okay";
+	connect = <&vp0_out_hdmi>;
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vcca_1v8>;
+};
+
+&sata0 {
+	status = "okay";
+};
+
+&sdhci {
+	bus-width = <8>;
+	non-removable;
+	max-frequency = <200000000>;
+	status = "okay";
+};
+
+&sdmmc0 {
+	max-frequency = <150000000>;
+	supports-sd;
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	sd-uhs-sdr104;
+	disable-wp;
+	vmmc-supply = <&vcc3v3_sd>;
+	vqmmc-supply = <&vccio_sd>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc0_bus4 &sdmmc0_clk &sdmmc0_cmd &sdmmc0_det>;
+	status = "okay";
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&u2phy0_host {
+	phy-supply = <&vcc5v0_otg>;
+	status = "okay";
+};
+
+&u2phy0_otg {
+	vbus-supply = <&vcc5v0_otg>;
+	status = "okay";
+};
+
+&u2phy1_host {
+	phy-supply = <&vcc5v0_otg>;
+	status = "okay";
+};
+
+&u2phy1_otg {
+	phy-supply = <&vcc5v0_otg>;
+	status = "okay";
+};
+
+&usb2phy0 {
+	status = "okay";
+};
+
+&usb2phy1 {
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&usbdrd_dwc3 {
+	dr_mode = "otg";
+	extcon = <&usb2phy0>;
+	phys = <&u2phy0_otg>;
+	status = "okay";
+};
+
+&usbdrd30 {
+	status = "okay";
+};
+
+&usbhost_dwc3 {
+	status = "okay";
+};
+
+&usbhost30 {
+	status = "okay";
+};
+
+&vdpu {
+	status = "okay";
+};
+
+&vdpu_mmu {
+	status = "okay";
+};
+
+&vepu {
+	status = "okay";
+};
+
+&vepu_mmu {
+	status = "okay";
+};
+
+&vop {
+	status = "okay";
+	assigned-clocks = <&cru DCLK_VOP0>, <&cru DCLK_VOP1>;
+	assigned-clock-parents = <&pmucru PLL_HPLL>, <&cru PLL_VPLL>;
+	support-multi-area;
+};
+
+&vop_mmu {
+	status = "okay";
+};
+
+&vp0 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART0>;
+};
+
+&vp1 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART1>;
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3568-radxa-e25.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3568-radxa-e25.dts
@@ -0,0 +1,325 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2020 Rockchip Electronics Co., Ltd.
+ * Copyright (c) 2021 Radxa Limited.
+ *
+ */
+
+/dts-v1/;
+
+#include "rk3568-radxa-rock-3-compute-module-plus.dtsi"
+
+/ {
+	model = "Radxa E25";
+	compatible = "radxa,e25", "rockchip,rk3568";
+
+	vcc5v0_otg: vcc5v0-otg-regulator {
+		compatible = "regulator-fixed";
+		regulator-always-on;
+		regulator-boot-on;
+		enable-active-high;
+		gpio = <&gpio0 RK_PB7 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_otg_en>;
+		regulator-name = "vcc5v0_otg";
+	};
+
+	pcie30_3v3: pcie30-3v3 {
+		compatible = "regulator-gpio";
+		regulator-name = "pcie30_3v3";
+		regulator-min-microvolt = <100000>;
+		regulator-max-microvolt = <3300000>;
+		gpios = <&gpio0 RK_PC7 GPIO_ACTIVE_HIGH>;
+		gpios-states = <0x1>;
+		states = <100000 0x0
+			  3300000 0x1>;
+	};
+
+	vcc3v3_minipcie: vcc3v3-minipcie {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio3 RK_PA7 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc3v3_minipcie_en>;
+		regulator-name = "vcc3v3_minipcie";
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	//low:wifi,high:5G
+	vcc3v3_minipcie_to_5g_or_wifi: vcc3v3-minipcie-to-5g-or-wifi {
+		compatible = "regulator-fixed";
+		enable-active-low;
+		gpio = <&gpio3 RK_PA0 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc3v3_minipcie_to_5g_or_wifi_en>;
+		regulator-name = "vcc3v3_minipcie_to_5g_or_wifi";
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	vcc3v3_pcie_30x1: vcc3v3-pci-30x1 {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio0 RK_PC5 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc3v3_pcie_30x1_en>;
+		regulator-name = "vcc3v3_pci_30x1";
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	em05_modem: em05-modem {
+		compatible = "lte-em05-modem-platdata";
+		pinctrl-names = "default";
+		pinctrl-0 = <&em05_power_en &em05_airplane_mode &em05_reset>;
+		em05,power-gpio = <&gpio0 RK_PD6 GPIO_ACTIVE_HIGH>;
+		em05,reset-gpio = <&gpio0 RK_PD5 GPIO_ACTIVE_HIGH>;
+		em05,airplane-gpio = <&gpio1 RK_PA4 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	rgb0: rgb0 {
+		compatible = "pwm-leds";
+		status = "okay";
+
+		rgb0-red {
+			pwms = <&pwm1 0 1000000 0>;
+			max-brightness = <255>;
+		};
+
+		rgb0-blue {
+			pwms = <&pwm12 0 1000000 0>;
+			max-brightness = <255>;
+		};
+
+		rgb0-green {
+			pwms = <&pwm2 0 1000000 0>;
+			max-brightness = <255>;
+		};
+	};
+};
+
+&fiq_debugger {
+	rockchip,baudrate = <115200>;
+};
+
+&sdio_pwrseq {
+	status = "disabled";
+};
+
+&wireless_wlan {
+	status = "disabled";
+};
+
+&wireless_bluetooth {
+	status = "disabled";
+};
+
+&sdmmc2 {
+	status = "disabled";
+};
+
+//sdcard
+&sdmmc0 {
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	sd-uhs-sdr50;
+	vmmc-supply = <&vcc3v3_sd>;
+	vqmmc-supply = <&vccio_sd>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc0_bus4 &sdmmc0_clk &sdmmc0_cmd>;
+	cd-gpios = <&gpio0 4 GPIO_ACTIVE_LOW>;
+	status = "okay";
+};
+
+&u2phy0_host {
+	phy-supply = <&vcc5v0_otg>;
+	status = "okay";
+};
+
+&u2phy0_otg {
+	vbus-supply = <&vcc5v0_otg>;
+	status = "okay";
+};
+
+&u2phy1_host {
+	phy-supply = <&vcc5v0_otg>;
+	status = "okay";
+};
+
+&u2phy1_otg {
+	phy-supply = <&vcc5v0_otg>;
+	status = "okay";
+};
+
+/* USB OTG/USB Host_1 USB 2.0 Comb PHY_0 */
+&usb2phy0 {
+	status = "okay";
+	u2phy0_host {
+        status = "okay";
+	};
+	u2phy0_otg {
+		 status = "okay";
+	};
+};
+
+/* USB Host_2/USB Host_3 USB 2.0 Comb PHY_1 */
+&usb2phy1 {
+	status = "okay";
+	u2phy1_host {
+        status = "okay";
+	};
+	u2phy1_otg {
+         status = "okay";
+	};
+};
+
+/* USB 2.0 Host_2 EHCI controller for high speed */
+&usb_host0_ehci {
+	status = "okay";
+};
+
+/* USB 2.0 Host_2 OHCI controller for full/low speed */
+&usb_host0_ohci {
+	status = "okay";
+};
+
+/* USB 2.0 Host_3 EHCI controller for high speed */
+&usb_host1_ehci {
+	status = "okay";
+};
+
+/* USB 2.0 Host_3 OHCI controller for full/low speed */
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&usbdrd_dwc3 {
+	extcon=<&usb2phy0>;
+	status="okay";
+};
+
+/* USB 3.0 OTG controller */
+&usbdrd30 {
+	status = "okay";
+};
+
+&usbhost_dwc3 {
+	phys = <&u2phy0_host>;
+	phy-names = "usb2-phy";
+	maximum-speed = "high-speed"; /* set dwc3 controller to high speed */
+	status = "okay";
+};
+
+/* USB 3.0 Host_1 controller */
+&usbhost30 {
+	status = "disabled";
+};
+
+/* USB 3.0 OTG/SATA Combo PHY_0 */
+&combphy0_us {
+	status = "okay";
+};
+
+/* USB 3.0 Host/SATA/QSGMII Combo PHY_1 */
+&combphy1_usq {
+	rockchip,dis-u3otg1-port; /* set dwc3 controller to high speed */
+	status = "okay";
+};
+
+&sata1 {
+	status = "okay";
+};
+
+&pcie30phy {
+	status = "okay";
+};
+
+&pcie3x1 {
+	rockchip,bifurcation;
+	reset-gpios = <&gpio0 RK_PC3 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&pcie30_3v3>;
+	pinctrl-0 = <&pcie30x1m0_pins>;
+	status = "okay";
+};
+
+&pcie3x2 {
+	rockchip,bifurcation;
+	reset-gpios = <&gpio2 RK_PD6 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&pcie30_3v3>;
+	pinctrl-0 = <&pcie30x2m1_pins>;
+	status = "okay";
+};
+
+&combphy2_psq {
+	status = "okay";
+};
+
+&pcie2x1 {
+	reset-gpios = <&gpio1 RK_PB2 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&pcie30_3v3>;
+	pinctrl-0 = <&pcie20m2_pins>;
+	status = "okay";
+};
+
+&pwm1 {
+	status = "okay";
+	pinctrl-names = "active";
+	pinctrl-0 = <&pwm1m0_pins>;
+};
+
+&pwm2 {
+	status = "okay";
+	pinctrl-names = "active";
+	pinctrl-0 = <&pwm2m0_pins>;
+};
+
+&pwm12 {
+	status = "okay";
+	pinctrl-names = "active";
+	pinctrl-0 = <&pwm12m1_pins>;
+};
+
+&user_leds {
+	linux,default-trigger = "none";
+	default-state = "off";
+};
+
+&pinctrl {
+	usb {
+		vcc5v0_otg_en: vcc5v0-otg-en {
+			rockchip,pins = <0 RK_PB7 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	pci-en {
+		vcc3v3_minipcie_en: vcc3v3-minipcie-en {
+			rockchip,pins = <3 RK_PA7 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		vcc3v3_pcie_30x1_en: vcc3v3-pcie-30x1-en {
+			rockchip,pins = <0 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		vcc3v3_minipcie_to_5g_or_wifi_en: vcc3v3-minipcie-to-5g-or-wifi-en {
+			rockchip,pins = <3 RK_PA0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	lte-em05-modem {
+		em05_airplane_mode: em05-airplane-mode {
+			rockchip,pins = <1 RK_PA4 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		em05_power_en: em05-power-en {
+			rockchip,pins = <0 RK_PD6 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		em05_reset: em05-reset {
+			rockchip,pins = <0 RK_PD5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3568-radxa-rock-3-compute-module-plus.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3568-radxa-rock-3-compute-module-plus.dtsi
@@ -0,0 +1,717 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2020 Rockchip Electronics Co., Ltd.
+ * Copyright (c) 2021 Radxa Limited.
+ *
+ */
+
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/input/rk-input.h>
+#include <dt-bindings/display/drm_mipi_dsi.h>
+#include <dt-bindings/sensor-dev.h>
+#include "rk3568.dtsi"
+
+/ {
+	compatible = "radxa,rock-3-compute-module-plus", "rockchip,rk3568";
+
+	fiq_debugger: fiq-debugger {
+		compatible = "rockchip,fiq-debugger";
+		rockchip,serial-id = <2>;
+		rockchip,wake-irq = <0>;
+		/* If enable uart uses irq instead of fiq */
+		rockchip,irq-mode-enable = <1>;
+		rockchip,baudrate = <1500000>;  /* Only 115200 and 1500000 */
+		interrupts = <GIC_SPI 252 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart2m0_xfer>;
+		status = "okay";
+	};
+
+	debug: debug@fd904000 {
+		compatible = "rockchip,debug";
+		reg = <0x0 0xfd904000 0x0 0x1000>,
+			<0x0 0xfd905000 0x0 0x1000>,
+			<0x0 0xfd906000 0x0 0x1000>,
+			<0x0 0xfd907000 0x0 0x1000>;
+	};
+
+	cspmu: cspmu@fd90c000 {
+		compatible = "rockchip,cspmu";
+		reg = <0x0 0xfd90c000 0x0 0x1000>,
+			<0x0 0xfd90d000 0x0 0x1000>,
+			<0x0 0xfd90e000 0x0 0x1000>,
+			<0x0 0xfd90f000 0x0 0x1000>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		rknpu_reserved: rknpu {
+			compatible = "shared-dma-pool";
+			inactive;
+			reusable;
+			size = <0x0 0x20000000>;
+			alignment = <0x0 0x1000>;
+		};
+	};
+
+	rk809_sound: rk809-sound {
+		status = "disabled";
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,name = "rockchip,rk809-codec";
+		simple-audio-card,mclk-fs = <256>;
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s1_8ch>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&rk809_codec>;
+		};
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+	};
+
+	vcc3v3_sys: vcc3v3-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		clocks = <&rk809 1>;
+		clock-names = "ext_clock";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_enable_h>;
+
+		/*
+		 * On the module itself this is one of these (depending
+		 * on the actual card populated):
+		 * - SDIO_RESET_L_WL_REG_ON
+		 * - PDN (power down when low)
+		 */
+		reset-gpios = <&gpio3 RK_PD4 GPIO_ACTIVE_LOW>;		//WIFI_REG_ON_H
+	};
+
+	wireless_wlan: wireless-wlan {
+		compatible = "wlan-platdata";
+		clocks = <&rk809 1>;
+		clock-names = "clk_wifi";
+		rockchip,grf = <&grf>;
+		wifi_chip_type = "ap6256";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_host_wake_irq>;
+		WIFI,host_wake_irq = <&gpio3 RK_PD5 GPIO_ACTIVE_HIGH>;		//WIFI_WAKE_HOST_H
+		status = "okay";
+	};
+
+	bt_uart8: wireless_bluetooth: wireless-bluetooth {
+		compatible = "bluetooth-platdata";
+		clocks = <&rk809 1>;
+		clock-names = "ext_clock";
+		//wifi-bt-power-toggle;
+		uart_rts_gpios = <&gpio2 RK_PB1 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default", "rts_gpio";
+		pinctrl-0 = <&uart8m0_rtsn>;
+		pinctrl-1 = <&uart8_gpios>;
+		BT,reset_gpio    = <&gpio4 RK_PB2 GPIO_ACTIVE_HIGH>;	//BT_REG_ON_H
+		BT,wake_gpio     = <&gpio4 RK_PB5 GPIO_ACTIVE_HIGH>;	//HOST_WAKE_BT_H
+		BT,wake_host_irq = <&gpio4 RK_PB4 GPIO_ACTIVE_HIGH>;	//BT_WAKE_HOST_H
+		status = "okay";
+	};
+
+	gpio_leds: gpio-leds {
+		compatible = "gpio-leds";
+		status = "okay";
+		user_leds: user-led {
+			gpios = <&gpio0 6 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "timer";
+			default-state = "on";
+			pinctrl-0 = <&user_led>;
+		};
+	};
+};
+
+&pmu_io_domains {
+	status = "okay";
+	pmuio2-supply = <&vcc_3v3>;
+	vccio1-supply = <&vccio_acodec>;
+	vccio3-supply = <&vccio_sd>;
+	vccio4-supply = <&vcc_1v8>;
+	vccio5-supply = <&vcc_3v3>;
+	vccio6-supply = <&vcc_1v8>;
+	vccio7-supply = <&vcc_3v3>;
+};
+
+&cpu0 {
+	cpu-supply = <&vdd_cpu>;
+};
+
+&dfi {
+	status = "okay";
+};
+
+&dmc {
+	center-supply = <&vdd_logic>;
+	status = "okay";
+};
+
+&gpu {
+	clock-names = "gpu", "bus";
+	interrupt-names = "gpu", "mmu", "job";
+	mali-supply = <&vdd_gpu>;
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+
+	vdd_cpu: tcs4525@1c {
+		compatible = "tcs,tcs452x";
+		reg = <0x1c>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "fan53555-reg";
+		regulator-name = "vdd_cpu";
+		regulator-min-microvolt = <712500>;
+		regulator-max-microvolt = <1390000>;
+		regulator-init-microvolt = <900000>;
+		regulator-ramp-delay = <2300>;
+		fcs,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	rk809: pmic@20 {
+		compatible = "rockchip,rk809";
+		reg = <0x20>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <3 IRQ_TYPE_LEVEL_LOW>;
+
+		pinctrl-names = "default", "pmic-sleep",
+				"pmic-power-off", "pmic-reset";
+		pinctrl-0 = <&pmic_int>;
+		pinctrl-1 = <&soc_slppin_slp>, <&rk817_slppin_slp>;
+		pinctrl-2 = <&soc_slppin_gpio>, <&rk817_slppin_pwrdn>;
+		pinctrl-3 = <&soc_slppin_gpio>, <&rk817_slppin_rst>;
+
+		rockchip,system-power-controller;
+		wakeup-source;
+		#clock-cells = <1>;
+		clock-output-names = "rk808-clkout1", "rk808-clkout2";
+		//fb-inner-reg-idxs = <2>;
+		/* 1: rst regs (default in codes), 0: rst the pmic */
+		pmic-reset-func = <0>;
+		/* not save the PMIC_POWER_EN register in uboot */
+		not-save-power-en = <1>;
+
+		vcc1-supply = <&vcc3v3_sys>;
+		vcc2-supply = <&vcc3v3_sys>;
+		vcc3-supply = <&vcc3v3_sys>;
+		vcc4-supply = <&vcc3v3_sys>;
+		vcc5-supply = <&vcc3v3_sys>;
+		vcc6-supply = <&vcc3v3_sys>;
+		vcc7-supply = <&vcc3v3_sys>;
+		vcc8-supply = <&vcc3v3_sys>;
+		vcc9-supply = <&vcc3v3_sys>;
+
+		pwrkey {
+			status = "okay";
+		};
+
+		pinctrl_rk8xx: pinctrl_rk8xx {
+			gpio-controller;
+			#gpio-cells = <2>;
+
+			rk817_slppin_null: rk817_slppin_null {
+				pins = "gpio_slp";
+				function = "pin_fun0";
+			};
+
+			rk817_slppin_slp: rk817_slppin_slp {
+				pins = "gpio_slp";
+				function = "pin_fun1";
+			};
+
+			rk817_slppin_pwrdn: rk817_slppin_pwrdn {
+				pins = "gpio_slp";
+				function = "pin_fun2";
+			};
+
+			rk817_slppin_rst: rk817_slppin_rst {
+				pins = "gpio_slp";
+				function = "pin_fun3";
+			};
+		};
+
+		regulators {
+			vdd_logic: DCDC_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-init-microvolt = <900000>;
+				regulator-ramp-delay = <6001>;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vdd_logic";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdd_gpu: DCDC_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-init-microvolt = <900000>;
+				regulator-ramp-delay = <6001>;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vdd_gpu";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_ddr: DCDC_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vcc_ddr";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			vdd_npu: DCDC_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-init-microvolt = <900000>;
+				regulator-ramp-delay = <6001>;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vdd_npu";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdda0v9_image: LDO_REG1 {
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-name = "vdda0v9_image";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdda_0v9: LDO_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-name = "vdda_0v9";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdda0v9_pmu: LDO_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-name = "vdda0v9_pmu";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <900000>;
+				};
+			};
+
+			vccio_acodec: LDO_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vccio_acodec";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vccio_sd: LDO_REG5 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vccio_sd";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc3v3_pmu: LDO_REG6 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vcc3v3_pmu";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			vcca_1v8: LDO_REG7 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcca_1v8";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcca1v8_pmu: LDO_REG8 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcca1v8_pmu";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vcca1v8_image: LDO_REG9 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcca1v8_image";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_1v8: DCDC_REG5 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc_1v8";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_3v3: SWITCH_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-name = "vcc_3v3";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc3v3_sd: SWITCH_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-name = "vcc3v3_sd";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+		};
+
+		rk809_codec: codec {
+			#sound-dai-cells = <0>;
+			compatible = "rockchip,rk809-codec", "rockchip,rk817-codec";
+			clocks = <&cru I2S1_MCLKOUT_TX>;
+			clock-names = "mclk";
+			assigned-clocks = <&cru I2S1_MCLKOUT_TX>;
+			assigned-clock-parents = <&cru CLK_I2S1_8CH_TX>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2s1m0_mclk>;
+			hp-volume = <20>;
+			spk-volume = <3>;
+			mic-in-differential;
+			status = "disabled";
+		};
+	};
+};
+
+&i2s1_8ch {
+	status = "disabled";
+	rockchip,clk-trcm = <1>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2s1m0_sclktx
+		     &i2s1m0_lrcktx
+		     &i2s1m0_sdi0
+		     &i2s1m0_sdo0>;
+};
+
+&gmac1 {
+	phy-mode = "rgmii";
+	clock_in_out = "output";
+
+	snps,reset-gpio = <&gpio4 RK_PC3 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	/* Reset time is 20ms, 100ms for rtl8211f */
+	snps,reset-delays-us = <0 20000 100000>;
+
+	assigned-clocks = <&cru SCLK_GMAC1_RX_TX>, <&cru SCLK_GMAC1>;
+	assigned-clock-parents = <&cru SCLK_GMAC1_RGMII_SPEED>;
+	assigned-clock-rates = <0>, <125000000>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac1m1_miim
+		     &gmac1m1_tx_bus2
+		     &gmac1m1_rx_bus2
+		     &gmac1m1_rgmii_clk
+		     &gmac1m1_rgmii_bus>;
+
+	tx_delay = <0x44>;
+	rx_delay = <0x26>;
+
+	phy-handle = <&rgmii_phy1>;
+	status = "disabled";
+};
+
+&mdio1 {
+	status = "disabled";
+
+	rgmii_phy1: phy@0 {
+		status = "disabled";
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x0>;
+	};
+};
+
+&iep {
+	status = "okay";
+};
+
+&iep_mmu {
+	status = "okay";
+};
+
+&jpegd {
+	status = "okay";
+};
+
+&jpegd_mmu {
+	status = "okay";
+};
+
+&mpp_srv {
+	status = "okay";
+};
+
+&rk_rga {
+	status = "okay";
+};
+
+&rkvdec {
+	status = "okay";
+};
+
+&rkvdec_mmu {
+	status = "okay";
+};
+
+&rkvenc {
+	venc-supply = <&vdd_logic>;
+	status = "okay";
+};
+
+&rkvenc_mmu {
+	status = "okay";
+};
+
+&bus_npu {
+	bus-supply = <&vdd_logic>;
+	pvtm-supply = <&vdd_cpu>;
+	status = "okay";
+};
+
+&rknpu {
+	memory-region = <&rknpu_reserved>;
+	rknpu-supply = <&vdd_npu>;
+	status = "okay";
+};
+
+&rknpu_mmu {
+	status = "okay";
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vcca_1v8>;
+};
+
+&sdhci {
+	bus-width = <8>;
+	supports-emmc;
+	non-removable;
+	max-frequency = <200000000>;
+	status = "okay";
+};
+
+//wifi
+&sdmmc2 {
+	max-frequency = <150000000>;
+	supports-sdio;
+	bus-width = <4>;
+	disable-wp;
+	cap-sd-highspeed;
+	cap-sdio-irq;
+	keep-power-in-suspend;
+	mmc-pwrseq = <&sdio_pwrseq>;
+	non-removable;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc2m0_bus4 &sdmmc2m0_cmd &sdmmc2m0_clk>;
+	sd-uhs-sdr104;
+	status = "okay";
+};
+
+&sfc {
+	status = "okay";
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&vdpu {
+	status = "okay";
+};
+
+&vdpu_mmu {
+	status = "okay";
+};
+
+&vepu {
+	status = "okay";
+};
+
+&vepu_mmu {
+	status = "okay";
+};
+
+&vop {
+	status = "okay";
+	assigned-clocks = <&cru DCLK_VOP0>, <&cru DCLK_VOP1>;
+	assigned-clock-parents = <&pmucru PLL_HPLL>, <&cru PLL_VPLL>;
+};
+
+&vop_mmu {
+	status = "okay";
+};
+
+&rkisp {
+	status = "okay";
+};
+
+&rkisp_mmu {
+	status = "okay";
+};
+
+//bt
+&uart8 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart8m0_xfer &uart8m0_ctsn>;
+};
+
+&reserved_memory {
+	ramoops: ramoops@110000 {
+		compatible = "ramoops";
+		reg = <0x0 0x110000 0x0 0xf0000>;
+		record-size = <0x20000>;
+		console-size = <0x80000>;
+		ftrace-size = <0x00000>;
+		pmsg-size = <0x50000>;
+	};
+};
+
+&rng {
+	status = "okay";
+};
+
+&rockchip_suspend {
+	status = "okay";
+};
+
+&pinctrl {
+	pmic {
+		pmic_int: pmic_int {
+			rockchip,pins =
+				<0 RK_PA3 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		soc_slppin_gpio: soc_slppin_gpio {
+			rockchip,pins =
+				<0 RK_PA2 RK_FUNC_GPIO &pcfg_output_low_pull_down>;
+		};
+
+		soc_slppin_slp: soc_slppin_slp {
+			rockchip,pins =
+				<0 RK_PA2 1 &pcfg_pull_up>;
+		};
+
+		soc_slppin_rst: soc_slppin_rst {
+			rockchip,pins =
+				<0 RK_PA2 2 &pcfg_pull_none>;
+		};
+	};
+
+	sdio-pwrseq {
+		wifi_enable_h: wifi-enable-h {
+			rockchip,pins = <3 RK_PD4 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	wireless-wlan {
+		wifi_host_wake_irq: wifi-host-wake-irq {
+			rockchip,pins = <3 RK_PD5 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	wireless-bluetooth {
+		uart8_gpios: uart8-gpios {
+			rockchip,pins = <2 RK_PB1 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	leds {
+		user_led: user-led {
+			rockchip,pins = <0 RK_PA6 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3568-rock-3a-display.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3568-rock-3a-display.dtsi
@@ -0,0 +1,100 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Radxa Limited.
+ *
+ */
+
+/ {
+	compatible = "radxa,rock-3a", "rockchip,rk3568";
+
+	vcc_mipi: vcc-mipi {
+		status = "disabled";
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_mipi";
+		regulator-boot-on;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		regulator-always-on;
+		gpio = <&gpio3 RK_PC0 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc3v3_sys>;
+
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&video_phy1 {
+    status = "disabled";
+};
+
+&dsi1 {
+	status = "disabled";
+	power-supply = <&vcc_mipi>;
+
+	dsi1_panel: dsi-panel@0 {
+		compatible = "rockpi,tc358762";
+		reg = <0x0>;
+		status = "disabled";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				panel_in_dsi1: endpoint {
+					remote-endpoint = <&dsi1_out_panel>;
+				};
+			};
+		};
+	};
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			dsi1_out_panel: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&panel_in_dsi1>;
+			};
+		};
+	};
+};
+
+&dsi1_in_vp0 {
+	status = "disabled";
+};
+
+&dsi1_in_vp1 {
+	status = "disabled";
+};
+
+&route_dsi1 {
+	status = "disabled";
+	connect = <&vp1_out_dsi1>;
+};
+
+&i2c3 {
+	status = "disabled";
+	pinctrl-0 = <&i2c3m1_xfer>;
+
+	rockpi_mcu: rockpi-mcu@45 {
+		compatible = "rockpi_mcu";
+		reg = <0x45>;
+		status = "disabled";
+	};
+
+	rockpi_ft5406: rockpi-ft5406@38 {
+		compatible = "rockpi_ft5406";
+		reg = <0x38>;
+		status = "disabled";
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3568-rock-3a.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3568-rock-3a.dts
@@ -0,0 +1,1061 @@
+/dts-v1/;
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/input/rk-input.h>
+#include <dt-bindings/display/drm_mipi_dsi.h>
+#include <dt-bindings/display/rockchip_vop.h>
+#include <dt-bindings/sensor-dev.h>
+#include "rk3568.dtsi"
+#include "rk3568-rock-3a-display.dtsi"
+#include "rk3568-rock-3ab-cameras.dtsi"
+
+/ {
+	model = "Radxa ROCK3 Model A";
+	compatible = "radxa,rock3a", "rockchip,rk3568";
+
+	fiq_debugger: fiq-debugger {
+		compatible = "rockchip,fiq-debugger";
+		rockchip,serial-id = <2>;
+		rockchip,wake-irq = <0>;
+		/* If enable uart uses irq instead of fiq */
+		rockchip,irq-mode-enable = <1>;
+		rockchip,baudrate = <1500000>;  /* Only 115200 and 1500000 */
+		interrupts = <GIC_SPI 252 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&uart2m0_xfer>;
+		status = "okay";
+	};
+
+	debug: debug@fd904000 {
+		compatible = "rockchip,debug";
+		reg = <0x0 0xfd904000 0x0 0x1000>,
+			<0x0 0xfd905000 0x0 0x1000>,
+			<0x0 0xfd906000 0x0 0x1000>,
+			<0x0 0xfd907000 0x0 0x1000>;
+	};
+
+	cspmu: cspmu@fd90c000 {
+		compatible = "rockchip,cspmu";
+		reg = <0x0 0xfd90c000 0x0 0x1000>,
+			<0x0 0xfd90d000 0x0 0x1000>,
+			<0x0 0xfd90e000 0x0 0x1000>,
+			<0x0 0xfd90f000 0x0 0x1000>;
+	};
+
+	adc_keys: adc-keys {
+		compatible = "adc-keys";
+		io-channels = <&saradc 0>;
+		io-channel-names = "buttons";
+		keyup-threshold-microvolt = <1800000>;
+		poll-interval = <100>;
+	};
+
+	audiopwmout_diff: audiopwmout-diff {
+		status = "disabled";
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,name = "rockchip,audiopwmout-diff";
+		simple-audio-card,mclk-fs = <256>;
+		simple-audio-card,bitclock-master = <&master>;
+		simple-audio-card,frame-master = <&master>;
+		simple-audio-card,cpu {
+			sound-dai = <&i2s3_2ch>;
+		};
+		master: simple-audio-card,codec {
+			sound-dai = <&dig_acodec>;
+		};
+	};
+
+	hdmi_sound: hdmi-sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <128>;
+		simple-audio-card,name = "rockchip,hdmi";
+		status = "okay";
+
+		simple-audio-card,cpu {
+				sound-dai = <&i2s0_8ch>;
+		};
+		simple-audio-card,codec {
+				sound-dai = <&hdmi>;
+		};
+	};
+
+	pdmics: dummy-codec {
+		status = "disabled";
+		compatible = "rockchip,dummy-codec";
+		#sound-dai-cells = <0>;
+	};
+
+	pdm_mic_array: pdm-mic-array {
+		status = "disabled";
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "rockchip,pdm-mic-array";
+		simple-audio-card,cpu {
+			sound-dai = <&pdm>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&pdmics>;
+		};
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		rknpu_reserved: rknpu {
+			compatible = "shared-dma-pool";
+			inactive;
+			reusable;
+			size = <0x0 0x20000000>;
+			alignment = <0x0 0x1000>;
+		};
+	};
+
+	rk809_sound: rk809-sound {
+		status = "okay";
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,name = "rockchip,rk809-codec";
+		simple-audio-card,mclk-fs = <256>;
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s1_8ch>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&rk809_codec>;
+		};
+	};
+
+	rk_headset: rk-headset {
+		compatible = "rockchip_headset";
+		headset_gpio = <&gpio2 RK_PD2 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&hp_det>;
+		io-channels = <&saradc 2>;    //HP_HOOK pin
+	};
+
+	dc_12v: dc-12v {
+		compatible = "regulator-fixed";
+		regulator-name = "dc_12v";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc3v3_sys: vcc3v3-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&dc_12v>;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&dc_12v>;
+	};
+
+	vcc5v0_host: vcc5v0-host-regulator {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio0 RK_PA6 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_host_en>;
+		regulator-name = "vcc5v0_host";
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	vcc5v0_otg: vcc5v0-otg-regulator {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio0 RK_PA5 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_otg_en>;
+		regulator-name = "vcc5v0_otg";
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	vcc5v0_usbhub: vcc5v0-usbhub-regulator {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio0 RK_PD5 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_hub_en>;
+		regulator-name = "vcc5v0_hub";
+		regulator-always-on;
+	};
+
+	pcie30_avdd0v9: pcie30-avdd0v9 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie30_avdd0v9";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <900000>;
+		regulator-max-microvolt = <900000>;
+		vin-supply = <&vcc3v3_sys>;
+	};
+
+	pcie30_avdd1v8: pcie30-avdd1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie30_avdd1v8";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&vcc3v3_sys>;
+	};
+
+	pcie30_3v3: gpio-regulator {
+		compatible = "regulator-gpio";
+		regulator-name = "pcie30_3v3";
+		regulator-min-microvolt = <100000>;
+		regulator-max-microvolt = <3300000>;
+		gpios = <&gpio0 RK_PD4 GPIO_ACTIVE_HIGH>;
+		gpios-states = <0x1>;
+		states = <100000 0x0
+			  3300000 0x1>;
+	};
+
+	vcc3v3_bu: vcc3v3-bu {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_bu";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		clocks = <&rk809 1>;
+		clock-names = "ext_clock";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_enable_h>;
+
+		/*
+		 * On the module itself this is one of these (depending
+		 * on the actual card populated):
+		 * - SDIO_RESET_L_WL_REG_ON
+		 * - PDN (power down when low)
+		 */
+		reset-gpios = <&gpio3 RK_PD4 GPIO_ACTIVE_LOW>;		//WIFI_REG_ON_H
+	};
+
+	wireless_wlan: wireless-wlan {
+		compatible = "wlan-platdata";
+		clocks = <&rk809 1>;
+		clock-names = "clk_wifi";
+		rockchip,grf = <&grf>;
+		wifi_chip_type = "ap6256";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_host_wake_irq>;
+		WIFI,host_wake_irq = <&gpio3 RK_PD5 GPIO_ACTIVE_HIGH>;		//WIFI_WAKE_HOST_H
+		status = "okay";
+	};
+
+	bt_uart1: wireless_bluetooth: wireless-bluetooth {
+		compatible = "bluetooth-platdata";
+		clocks = <&rk809 1>;
+		clock-names = "ext_clock";
+		//wifi-bt-power-toggle;
+		uart_rts_gpios = <&gpio2 RK_PB1 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default", "rts_gpio";
+		pinctrl-0 = <&uart1m0_rtsn>;
+		pinctrl-1 = <&uart1_gpios>;
+		BT,reset_gpio    = <&gpio4 RK_PB2 GPIO_ACTIVE_HIGH>;	//BT_REG_ON_H
+		BT,wake_gpio     = <&gpio4 RK_PB5 GPIO_ACTIVE_HIGH>;	//HOST_WAKE_BT_H
+		BT,wake_host_irq = <&gpio4 RK_PB4 GPIO_ACTIVE_HIGH>;	//BT_WAKE_HOST_H
+		status = "okay";
+	};
+
+	gpio_leds: gpio-leds {
+		compatible = "gpio-leds";
+		status = "okay";
+
+		user-led {
+			gpios = <&gpio0 RK_PB7 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "timer";
+			default-state = "on";
+			pinctrl-0 = <&user_led>;
+		};
+
+		wifi-led {
+			gpios = <&gpio2 RK_PB0 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "rfkill2";
+			default-state = "on";
+			pinctrl-0 = <&wifi_led>;
+		};
+	};
+};
+
+&cpu0 {
+	cpu-supply = <&vdd_cpu>;
+};
+
+&dfi {
+	status = "okay";
+};
+
+&dmc {
+	center-supply = <&vdd_logic>;
+	status = "okay";
+};
+
+&video_phy0 {
+	status = "okay";
+};
+
+&display_subsystem {
+    status = "okay";
+};
+
+&gpu {
+	clock-names = "gpu", "bus";
+	interrupt-names = "gpu", "mmu", "job";
+	mali-supply = <&vdd_gpu>;
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+	pinctrl-0 = <&hdmitx_scl &hdmitx_sda &hdmitxm1_cec>;
+};
+
+&hdmi_in_vp0 {
+	status = "okay";
+};
+
+&hdmi_in_vp1 {
+	status = "disabled";
+};
+
+&hdmi_sound {
+	status = "okay";
+};
+
+&route_hdmi {
+	status = "okay";
+	connect = <&vp0_out_hdmi>;
+};
+
+&i2c0 {
+	status = "okay";
+
+	vdd_cpu: tcs4525@1c {
+		compatible = "tcs,tcs452x";
+		reg = <0x1c>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "fan53555-reg";
+		regulator-name = "vdd_cpu";
+		regulator-min-microvolt = <712500>;
+		regulator-max-microvolt = <1390000>;
+		regulator-init-microvolt = <900000>;
+		regulator-ramp-delay = <2300>;
+		fcs,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	rk809: pmic@20 {
+		compatible = "rockchip,rk809";
+		reg = <0x20>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <3 IRQ_TYPE_LEVEL_LOW>;
+
+		pinctrl-names = "default", "pmic-sleep",
+				"pmic-power-off", "pmic-reset";
+		pinctrl-0 = <&pmic_int>;
+		pinctrl-1 = <&soc_slppin_slp>, <&rk817_slppin_slp>;
+		pinctrl-2 = <&soc_slppin_gpio>, <&rk817_slppin_pwrdn>;
+		pinctrl-3 = <&soc_slppin_gpio>, <&rk817_slppin_rst>;
+
+		rockchip,system-power-controller;
+		wakeup-source;
+		#clock-cells = <1>;
+		clock-output-names = "rk808-clkout1", "rk808-clkout2";
+		//fb-inner-reg-idxs = <2>;
+		/* 1: rst regs (default in codes), 0: rst the pmic */
+		pmic-reset-func = <0>;
+		/* not save the PMIC_POWER_EN register in uboot */
+		not-save-power-en = <1>;
+
+		vcc1-supply = <&vcc3v3_sys>;
+		vcc2-supply = <&vcc3v3_sys>;
+		vcc3-supply = <&vcc3v3_sys>;
+		vcc4-supply = <&vcc3v3_sys>;
+		vcc5-supply = <&vcc3v3_sys>;
+		vcc6-supply = <&vcc3v3_sys>;
+		vcc7-supply = <&vcc3v3_sys>;
+		vcc8-supply = <&vcc3v3_sys>;
+		vcc9-supply = <&vcc3v3_sys>;
+
+		pwrkey {
+			status = "okay";
+		};
+
+		pinctrl_rk8xx: pinctrl_rk8xx {
+			gpio-controller;
+			#gpio-cells = <2>;
+
+			rk817_slppin_null: rk817_slppin_null {
+				pins = "gpio_slp";
+				function = "pin_fun0";
+			};
+
+			rk817_slppin_slp: rk817_slppin_slp {
+				pins = "gpio_slp";
+				function = "pin_fun1";
+			};
+
+			rk817_slppin_pwrdn: rk817_slppin_pwrdn {
+				pins = "gpio_slp";
+				function = "pin_fun2";
+			};
+
+			rk817_slppin_rst: rk817_slppin_rst {
+				pins = "gpio_slp";
+				function = "pin_fun3";
+			};
+		};
+
+		regulators {
+			vdd_logic: DCDC_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-init-microvolt = <900000>;
+				regulator-ramp-delay = <6001>;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vdd_logic";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdd_gpu: DCDC_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-init-microvolt = <900000>;
+				regulator-ramp-delay = <6001>;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vdd_gpu";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_ddr: DCDC_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vcc_ddr";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			vdd_npu: DCDC_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-init-microvolt = <900000>;
+				regulator-ramp-delay = <6001>;
+				regulator-initial-mode = <0x2>;
+				regulator-name = "vdd_npu";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdda0v9_image: LDO_REG1 {
+				regulator-boot-on;
+				regulator-always-on;
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-name = "vdda0v9_image";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdda_0v9: LDO_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-name = "vdda_0v9";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdda0v9_pmu: LDO_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-name = "vdda0v9_pmu";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <900000>;
+				};
+			};
+
+			vccio_acodec: LDO_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-name = "vccio_acodec";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vccio_sd: LDO_REG5 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vccio_sd";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc3v3_pmu: LDO_REG6 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vcc3v3_pmu";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			vcca_1v8: LDO_REG7 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcca_1v8";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcca1v8_pmu: LDO_REG8 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcca1v8_pmu";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vcca1v8_image: LDO_REG9 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcca1v8_image";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_1v8: DCDC_REG5 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc_1v8";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_3v3: SWITCH_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-name = "vcc_3v3";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc3v3_sd: SWITCH_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-name = "vcc3v3_sd";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+		};
+
+		rk809_codec: codec {
+			#sound-dai-cells = <0>;
+			compatible = "rockchip,rk809-codec", "rockchip,rk817-codec";
+			clocks = <&cru I2S1_MCLKOUT>;
+			clock-names = "mclk";
+			assigned-clocks = <&cru I2S1_MCLKOUT>, <&cru I2S1_MCLK_TX_IOE>;
+			assigned-clock-rates = <12288000>;
+			assigned-clock-parents = <&cru I2S1_MCLKOUT_TX>, <&cru I2S1_MCLKOUT_TX>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2s1m0_mclk>;
+			hp-volume = <20>;
+			spk-volume = <3>;
+			mic-in-differential;
+			status = "okay";
+		};
+	};
+};
+
+&i2c5 {
+	status = "okay";
+	pinctrl-0 = <&i2c5m0_xfer>;
+
+	hym8563: hym8563@51 {
+		compatible = "haoyu,hym8563";
+		status = "okay";
+		reg = <0x51>;
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		clock-output-names = "hym8563";
+	};
+};
+
+&i2s0_8ch {
+	status = "okay";
+};
+
+&i2s1_8ch {
+	status = "okay";
+	rockchip,clk-trcm = <1>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2s1m0_sclktx
+		     &i2s1m0_lrcktx
+		     &i2s1m0_sdi0
+		     &i2s1m0_sdo0>;
+};
+
+&iep {
+	status = "okay";
+};
+
+&iep_mmu {
+	status = "okay";
+};
+
+&jpegd {
+	status = "okay";
+};
+
+&jpegd_mmu {
+	status = "okay";
+};
+
+&mpp_srv {
+	status = "okay";
+};
+
+&pmu_io_domains {
+	status = "okay";
+	pmuio2-supply = <&vcc3v3_pmu>;
+	vccio1-supply = <&vccio_acodec>;
+	vccio3-supply = <&vccio_sd>;
+	vccio4-supply = <&vcc_1v8>;
+	vccio5-supply = <&vcc_3v3>;
+	vccio6-supply = <&vcc_1v8>;
+	vccio7-supply = <&vcc_3v3>;
+};
+
+&rk_rga {
+	status = "okay";
+};
+
+&rkvdec {
+	status = "okay";
+};
+
+&rkvdec_mmu {
+	status = "okay";
+};
+
+&rkvenc {
+	venc-supply = <&vdd_logic>;
+	status = "okay";
+};
+
+&rkvenc_mmu {
+	status = "okay";
+};
+
+&bus_npu {
+	bus-supply = <&vdd_logic>;
+	pvtm-supply = <&vdd_cpu>;
+	status = "okay";
+};
+
+&rknpu {
+	memory-region = <&rknpu_reserved>;
+	rknpu-supply = <&vdd_npu>;
+	status = "okay";
+};
+
+&rknpu_mmu {
+	status = "okay";
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vcca_1v8>;
+};
+
+&sdhci {
+	bus-width = <8>;
+	supports-emmc;
+	non-removable;
+	max-frequency = <200000000>;
+	status = "okay";
+};
+
+&sdmmc0 {
+	max-frequency = <150000000>;
+	supports-sd;
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	sd-uhs-sdr104;
+	vmmc-supply = <&vcc3v3_sd>;
+	vqmmc-supply = <&vccio_sd>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc0_bus4 &sdmmc0_clk &sdmmc0_cmd &sdmmc0_det>;
+	status = "okay";
+};
+
+&sdmmc2 {
+	max-frequency = <150000000>;
+	supports-sdio;
+	bus-width = <4>;
+	disable-wp;
+	cap-sd-highspeed;
+	cap-sdio-irq;
+	keep-power-in-suspend;
+	mmc-pwrseq = <&sdio_pwrseq>;
+	non-removable;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc2m0_bus4 &sdmmc2m0_cmd &sdmmc2m0_clk>;
+	sd-uhs-sdr104;
+	status = "okay";
+};
+
+&sfc {
+	status = "okay";
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&u2phy0_host {
+	phy-supply = <&vcc5v0_host>;
+	status = "okay";
+};
+
+&u2phy0_otg {
+	vbus-supply = <&vcc5v0_otg>;
+	status = "okay";
+};
+
+&u2phy1_host {
+	phy-supply = <&vcc5v0_host>;
+	status = "okay";
+};
+
+&u2phy1_otg {
+	phy-supply = <&vcc5v0_host>;
+	status = "okay";
+};
+
+&usb2phy0 {
+	status = "okay";
+};
+
+&usb2phy1 {
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&usbdrd_dwc3 {
+	extcon=<&usb2phy0>;
+	status="okay";
+};
+
+&usbdrd30 {
+	status = "okay";
+};
+
+&usbhost_dwc3 {
+	status = "okay";
+};
+
+&usbhost30 {
+	status = "okay";
+};
+
+&combphy0_us {
+	status = "okay";
+};
+
+&combphy1_usq {
+	status = "okay";
+};
+
+&sata0 {
+	status = "disabled";
+};
+
+&sata1 {
+	status = "disabled";
+};
+
+&xpcs {
+	status="disabled";
+};
+
+&vdpu {
+	status = "okay";
+};
+
+&vdpu_mmu {
+	status = "okay";
+};
+
+&vepu {
+	status = "okay";
+};
+
+&vepu_mmu {
+	status = "okay";
+};
+
+&vop {
+	status = "okay";
+	assigned-clocks = <&cru DCLK_VOP0>, <&cru DCLK_VOP1>;
+	assigned-clock-parents = <&pmucru PLL_HPLL>, <&cru PLL_VPLL>;
+};
+
+&vop_mmu {
+	status = "okay";
+};
+
+&gmac1 {
+	phy-mode = "rgmii";
+	clock_in_out = "output";
+
+	snps,reset-gpio = <&gpio3 RK_PB0 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	/* Reset time is 20ms, 100ms for rtl8211f */
+	snps,reset-delays-us = <0 20000 100000>;
+
+	assigned-clocks = <&cru SCLK_GMAC1_RX_TX>, <&cru SCLK_GMAC1>;
+	assigned-clock-parents = <&cru SCLK_GMAC1_RGMII_SPEED>;
+	assigned-clock-rates = <0>, <125000000>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac1m1_miim
+		     &gmac1m1_tx_bus2
+		     &gmac1m1_rx_bus2
+		     &gmac1m1_rgmii_clk
+		     &gmac1m1_rgmii_bus>;
+
+	tx_delay = <0x42>;
+	rx_delay = <0x28>;
+
+	phy-handle = <&rgmii_phy1>;
+	status = "okay";
+};
+
+&mdio1 {
+	rgmii_phy1: phy@0 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x0>;
+	};
+};
+
+&pcie30phy {
+	status = "okay";
+};
+
+&pcie3x2 {
+	reset-gpios = <&gpio2 RK_PD6 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&pcie30_3v3>;
+	//num-lanes = <2>;
+	pinctrl-0 = <&pcie30x2m1_pins>;
+	status = "okay";
+};
+
+&combphy2_psq {
+	status = "okay";
+};
+
+&pcie2x1 {
+	reset-gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&pcie30_3v3>;
+	pinctrl-0 = <&pcie20m1_pins>;
+	status = "okay";
+};
+
+&rkisp {
+	status = "okay";
+};
+
+&rkisp_mmu {
+	status = "okay";
+};
+
+&uart1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1m0_xfer &uart1m0_ctsn>;
+};
+
+&reserved_memory {
+	ramoops: ramoops@110000 {
+		compatible = "ramoops";
+		reg = <0x0 0x110000 0x0 0xf0000>;
+		record-size = <0x20000>;
+		console-size = <0x80000>;
+		ftrace-size = <0x00000>;
+		pmsg-size = <0x50000>;
+	};
+};
+
+&rng {
+	status = "okay";
+};
+
+&rockchip_suspend {
+	status = "okay";
+};
+
+&pinctrl {
+	pmic {
+		pmic_int: pmic_int {
+			rockchip,pins =
+				<0 RK_PA3 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		soc_slppin_gpio: soc_slppin_gpio {
+			rockchip,pins =
+				<0 RK_PA2 RK_FUNC_GPIO &pcfg_output_low_pull_down>;
+		};
+
+		soc_slppin_slp: soc_slppin_slp {
+			rockchip,pins =
+				<0 RK_PA2 1 &pcfg_pull_up>;
+		};
+
+		soc_slppin_rst: soc_slppin_rst {
+			rockchip,pins =
+				<0 RK_PA2 2 &pcfg_pull_none>;
+		};
+	};
+
+	usb {
+		vcc5v0_host_en: vcc5v0-host-en {
+			rockchip,pins = <0 RK_PA6 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		vcc5v0_otg_en: vcc5v0-otg-en {
+			rockchip,pins = <0 RK_PA5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		vcc5v0_hub_en: vcc5v0-hub-en {
+			rockchip,pins = <0 RK_PD5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	sdio-pwrseq {
+		wifi_enable_h: wifi-enable-h {
+			rockchip,pins = <3 RK_PD4 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	wireless-wlan {
+		wifi_host_wake_irq: wifi-host-wake-irq {
+			rockchip,pins = <3 RK_PD5 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	wireless-bluetooth {
+		uart1_gpios: uart1-gpios {
+			rockchip,pins = <2 RK_PB5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	headphone {
+		hp_det: hp-det {
+			rockchip,pins = <2 RK_PD2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	leds {
+		user_led: user-led {
+			rockchip,pins = <0 RK_PB7 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		wifi_led: wifi-led {
+			rockchip,pins = <2 RK_PB0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+};
+
+&vp0 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART0>;
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3568-rock-3ab-cameras.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3568-rock-3ab-cameras.dtsi
@@ -0,0 +1,152 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Radxa Limited.
+ *
+ */
+
+/ {
+	ext_cam_clk: ext-cam-clk {
+		status = "disabled";
+		compatible = "fixed-clock";
+		clock-frequency = <25000000>;
+		clock-output-names = "ext_cam_clk";
+		#clock-cells = <0>;
+	};
+
+	ext_cam_clk_imx219: ext-cam-clk-imx219 {
+		status = "disabled";
+		compatible = "fixed-clock";
+		clock-frequency = <24000000>;
+		clock-output-names = "ext_cam_clk_imx219";
+		#clock-cells = <0>;
+	};
+
+	vcc_camera: vcc-camera {
+		status = "disabled";
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_camera";
+		gpio = <&gpio1 RK_PB1 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+		regulator-boot-on;
+	};
+};
+
+&i2c5 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c5m0_xfer>;
+
+	ov5647: ov5647@36 {
+		status = "disabled";
+		compatible = "ovti,ov5647";
+		reg = <0x36>;
+
+		clocks = <&ext_cam_clk>;
+		clock-names = "ext_cam_clk";
+		pwdn-gpios = <&gpio4 RK_PD2 GPIO_ACTIVE_LOW>;
+
+		port {
+			ov5647_out: endpoint {
+				remote-endpoint = <&mipi_in_ucam0>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+
+	imx219: imx219@10 {
+		status = "disabled";
+		compatible = "sony,imx219";
+		reg = <0x10>;
+
+		clocks = <&ext_cam_clk_imx219>;
+		clock-names = "ext_cam_clk_imx219";
+		pwdn-gpios = <&gpio4 RK_PD2 GPIO_ACTIVE_HIGH>;
+
+		rockchip,camera-module-index = <1>;
+		rockchip,camera-module-facing = "front";
+		rockchip,camera-module-name = "rpi-camera-v2";
+		rockchip,camera-module-lens-name = "default";
+
+		port {
+			imx219_out: endpoint {
+				remote-endpoint = <&mipi_in_ucam1>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+};
+
+&csi2_dphy_hw {
+	status = "disabled";
+};
+
+&csi2_dphy0 {
+	status = "disabled";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi_in_ucam0: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&ov5647_out>;
+				data-lanes = <1 2>;
+			};
+
+			mipi_in_ucam1: endpoint@2 {
+				reg = <2>;
+				remote-endpoint = <&imx219_out>;
+				data-lanes = <1 2>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			dphy0_out: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&isp0_in>;
+			};
+		};
+	};
+};
+
+&rkisp_vir0 {
+	status = "disabled";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		isp0_in: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&dphy0_out>;
+		};
+	};
+};
+
+&rkisp {
+	status = "disabled";
+};
+
+&rkisp_mmu {
+	status = "disabled";
+};
+
+&rkcif_mmu {
+	status = "disabled";
+};
+
+&rkcif {
+	status = "disabled";
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blade3-v101-linux.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blade3-v101-linux.dts
@@ -0,0 +1,1019 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Mixtile Limited
+ *
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/input/rk-input.h>
+#include <dt-bindings/display/drm_mipi_dsi.h>
+#include <dt-bindings/display/rockchip_vop.h>
+#include <dt-bindings/sensor-dev.h>
+
+#include "dt-bindings/usb/pd.h"
+#include "rk3588.dtsi"
+#include "rk3588-rk806-single.dtsi"
+#include "rk3588-linux.dtsi"
+
+/ {
+	model = "Mixtile Blade 3 v1.0.1";
+	compatible = "rockchip,rk3588-blade3-v101-linux", "rockchip,rk3588";
+	/delete-node/ chosen;
+
+	/* If hdmirx node is disabled, delete the reserved-memory node here. */
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* Reserve 256MB memory for hdmirx-controller@fdee0000 */
+		cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			reg = <0x0 (256 * 0x100000) 0x0 (256 * 0x100000)>;
+			linux,cma-default;
+		};
+	};
+
+	hdmiin-sound {
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,format = "i2s";
+		rockchip,bitclock-master = <&hdmirx_ctrler>;
+		rockchip,frame-master = <&hdmirx_ctrler>;
+		rockchip,card-name = "rockchip,hdmiin";
+		rockchip,cpu = <&i2s7_8ch>;
+		rockchip,codec = <&hdmirx_ctrler 0>;
+		rockchip,jack-det;
+	};
+
+	hdmi0_sound: hdmi0-sound {
+		status = "okay";
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,card-name = "rockchip-hdmi0";
+		rockchip,cpu = <&i2s5_8ch>;
+		rockchip,codec = <&hdmi0>;
+		rockchip,jack-det;
+	};
+
+	dp0_sound: dp0-sound {
+		status = "okay";
+		compatible = "rockchip,hdmi";
+		rockchip,card-name= "rockchip,dp0";
+		rockchip,mclk-fs = <512>;
+		rockchip,cpu = <&spdif_tx2>;
+		rockchip,codec = <&dp0 1>;
+		rockchip,jack-det;
+	};
+
+	dp1_sound: dp1-sound {
+		status = "okay";
+		compatible = "rockchip,hdmi";
+		rockchip,card-name= "rockchip,dp1";
+		rockchip,mclk-fs = <512>;
+		rockchip,cpu = <&spdif_tx5>;
+		rockchip,codec = <&dp1 1>;
+		rockchip,jack-det;
+	};
+
+	pcie20_avdd0v85: pcie20-avdd0v85 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie20_avdd0v85";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <850000>;
+		regulator-max-microvolt = <850000>;
+		vin-supply = <&vdd_0v85_s0>;
+	};
+
+	pcie20_avdd1v8: pcie20-avdd1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie20_avdd1v8";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&avcc_1v8_s0>;
+	};
+
+	pcie30_avdd0v75: pcie30-avdd0v75 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie30_avdd0v75";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <750000>;
+		regulator-max-microvolt = <750000>;
+		vin-supply = <&avdd_0v75_s0>;
+	};
+
+	pcie30_avdd1v8: pcie30-avdd1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie30_avdd1v8";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&avcc_1v8_s0>;
+	};
+
+	vcc3v3_pcie30: vcc3v3-pcie30 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_pcie30";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		gpios = <&gpio1 RK_PB2 GPIO_ACTIVE_HIGH>;
+		startup-delay-us = <5000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc_3v3_sd_s0: vcc-3v3-sd-s0-regulator {
+		compatible = "regulator-fixed";
+		gpio = <&gpio0 RK_PB7 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&sd_s0_pwr>;
+		regulator-name = "vcc_3v3_sd_s0";
+		enable-active-high;
+	};
+
+	vbus5v0_typec0: vbus5v0-typec0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vbus5v0_typec0";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio4 RK_PB0 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_usb>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&typec5v_pwren0>;
+	};
+
+	vbus5v0_typec1: vbus5v0-typec1 {
+		compatible = "regulator-fixed";
+		regulator-name = "vbus5v0_typec1";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio4 RK_PA3 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_usb>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&typec5v_pwren1>;
+	};
+
+	vcc12v_dcin: vcc12v-dcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc12v_dcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_usbdcin: vcc5v0-usbdcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_usbdcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_usb: vcc5v0-usb {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_usb";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc5v0_usbdcin>;
+	};
+
+	vcc_1v1_nldo_s3: vcc-1v1-nldo-s3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_1v1_nldo_s3";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1100000>;
+		regulator-max-microvolt = <1100000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	fan: pwm-fan {
+		compatible = "pwm-fan";
+
+		interrupt-parent = <&gpio3>;
+		interrupts = <RK_PB1 IRQ_TYPE_EDGE_FALLING>;
+		pulses-per-revolution = <2>;
+
+		#cooling-cells = <2>;
+		pwms = <&pwm8 0 50000 0>;
+    };
+};
+
+/*&pwrkey {
+	status = "disabled";
+};*/
+
+&av1d_mmu {
+	status = "okay";
+};
+
+&cpu_l0 {
+	cpu-supply = <&vdd_cpu_lit_s0>;
+	mem-supply = <&vdd_cpu_lit_mem_s0>;
+};
+
+&cpu_b0 {
+	cpu-supply = <&vdd_cpu_big0_s0>;
+	mem-supply = <&vdd_cpu_big0_mem_s0>;
+};
+
+&cpu_b2 {
+	cpu-supply = <&vdd_cpu_big1_s0>;
+	mem-supply = <&vdd_cpu_big1_mem_s0>;
+};
+
+&gpu {
+	mali-supply = <&vdd_gpu_s0>;
+	mem-supply = <&vdd_gpu_mem_s0>;
+	status = "okay";
+};
+
+&i2s0_8ch {
+	status = "okay";
+	pinctrl-0 = <&i2s0_lrck
+		     &i2s0_sclk
+		     &i2s0_sdi0
+		     &i2s0_sdo0>;
+};
+
+&i2s7_8ch {
+	status = "okay";
+};
+
+&i2s5_8ch {
+	status = "okay";
+};
+
+&iep {
+	status = "okay";
+};
+
+&iep_mmu {
+	status = "okay";
+};
+
+&jpegd {
+	status = "okay";
+};
+
+&jpegd_mmu {
+	status = "okay";
+};
+
+&jpege_ccu {
+	status = "okay";
+};
+
+&jpege0 {
+	status = "okay";
+};
+
+&jpege0_mmu {
+	status = "okay";
+};
+
+&jpege1 {
+	status = "okay";
+};
+
+&jpege1_mmu {
+	status = "okay";
+};
+
+&jpege2 {
+	status = "okay";
+};
+
+&jpege2_mmu {
+	status = "okay";
+};
+
+&jpege3 {
+	status = "okay";
+};
+
+&jpege3_mmu {
+	status = "okay";
+};
+
+&mpp_srv {
+	status = "okay";
+};
+
+&rga3_core0 {
+	status = "okay";
+};
+
+&rga3_0_mmu {
+	status = "okay";
+};
+
+&rga3_core1 {
+	status = "okay";
+};
+
+&rga3_1_mmu {
+	status = "okay";
+};
+
+&rga2 {
+	status = "okay";
+};
+
+&rknpu {
+	rknpu-supply = <&vdd_npu_s0>;
+	mem-supply = <&vdd_npu_mem_s0>;
+	status = "okay";
+};
+
+&rknpu_mmu {
+	status = "okay";
+};
+
+&rkvdec_ccu {
+	status = "okay";
+};
+
+&rkvdec0 {
+	status = "okay";
+};
+
+&rkvdec0_mmu {
+	status = "okay";
+};
+
+&rkvdec1 {
+	status = "okay";
+};
+
+&rkvdec1_mmu {
+	status = "okay";
+};
+
+&rkvenc_ccu {
+	status = "okay";
+};
+
+&rkvenc0 {
+	status = "okay";
+};
+
+&rkvenc0_mmu {
+	status = "okay";
+};
+
+&rkvenc1 {
+	status = "okay";
+};
+
+&rkvenc1_mmu {
+	status = "okay";
+};
+
+&rockchip_suspend {
+	status = "okay";
+	rockchip,sleep-debug-en = <1>;
+	rockchip,sleep-mode-config = <0x4000024>;
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vcc_1v8_s0>;
+};
+
+&sdhci {
+	bus-width = <8>;
+	no-sdio;
+	no-sd;
+	non-removable;
+	max-frequency = <200000000>;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	status = "okay";
+};
+
+&sdmmc {
+	max-frequency = <150000000>;
+	no-sdio;
+	no-mmc;
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	sd-uhs-sdr104;
+	vmmc-supply = <&vcc_3v3_sd_s0>;
+	vqmmc-supply = <&vccio_sd_s0>;
+	status = "okay";
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&u2phy0 {
+	status = "okay";
+};
+
+&u2phy1 {
+	status = "okay";
+};
+
+&u2phy2 {
+	status = "okay";
+};
+
+&u2phy3 {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	status = "okay";
+	rockchip,typec-vbus-det;
+};
+
+&u2phy1_otg {
+	status = "okay";
+	rockchip,typec-vbus-det;
+};
+
+&u2phy2_host { // 30PIN GPIO
+	status = "okay";
+};
+
+&u2phy3_host {
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&usbhost3_0 { // miniPCIe combo
+	status = "disable";
+};
+
+&usbhost_dwc3_0 { // miniPCIe combo
+	status = "disable";
+};
+
+&usbdp_phy0 {
+	status = "okay";
+
+	orientation-switch;
+	svid = <0xff01>;
+	sbu1-dc-gpios = <&gpio4 RK_PA6 GPIO_ACTIVE_HIGH>;
+	sbu2-dc-gpios = <&gpio4 RK_PA7 GPIO_ACTIVE_HIGH>;
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		usbdp_phy0_orientation_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_orien_sw>;
+		};
+
+		usbdp_phy0_dp_altmode_mux: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&dp0_altmode_mux>;
+		};
+	};
+};
+
+&usbdp_phy0_dp {
+	status = "okay";
+};
+
+&usbdp_phy0_u3 {
+	status = "okay";
+};
+
+&usbdp_phy1 {
+	status = "okay";
+
+	orientation-switch;
+	svid = <0xff01>;	// linux/usb/typec_dp.h:USB_TYPEC_DP_SID
+	sbu1-dc-gpios = <&gpio4 RK_PA4 GPIO_ACTIVE_HIGH>;
+	sbu2-dc-gpios = <&gpio4 RK_PA5 GPIO_ACTIVE_HIGH>;
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		usbdp_phy1_orientation_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc1_orien_sw>;
+		};
+
+		usbdp_phy1_dp_altmode_mux: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&dp1_altmode_mux>;
+		};
+	};
+};
+
+&usbdp_phy1_dp {
+	status = "okay";
+};
+
+&usbdp_phy1_u3 {
+	maximum-speed = "high-speed";
+	status = "okay";
+};
+
+&usbdrd3_0 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	dr_mode = "otg";
+	status = "okay";
+
+	usb-role-switch;
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		dwc3_0_role_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_role_sw>;
+		};
+	};
+};
+
+&usbdrd3_1 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_1 {
+	status = "okay";
+
+	dr_mode = "otg";
+	usb-role-switch;
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		dwc3_1_role_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc1_role_sw>;
+		};
+	};
+};
+
+&vdpu {
+	status = "okay";
+};
+
+&vdpu_mmu {
+	status = "okay";
+};
+
+&vop {
+	status = "okay";
+};
+
+&vop_mmu {
+	status = "okay";
+};
+
+/* vp0 & vp1 splice for 8K output */
+&vp0 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER0>;
+	cursor-win-id = <ROCKCHIP_VOP2_ESMART0>;
+};
+
+&vp1 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER1>;
+	cursor-win-id = <ROCKCHIP_VOP2_ESMART1>;
+};
+
+&vp2 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER2 | 1 << ROCKCHIP_VOP2_ESMART2)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER2>;
+	cursor-win-id = <ROCKCHIP_VOP2_ESMART2>;
+};
+
+&vp3 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER3>;
+	cursor-win-id = <ROCKCHIP_VOP2_ESMART3>;
+};
+
+&combphy0_ps {
+	status = "okay";
+};
+
+&combphy1_ps {
+	status = "okay";
+};
+
+&combphy2_psu {
+	status = "okay";
+};
+
+&dp0 {
+	status = "okay";
+};
+
+&dp0_in_vp1 {
+	status = "okay";
+};
+
+&spdif_tx2 {
+    status = "okay";
+};
+
+&dp1 {
+	status = "okay";
+};
+
+&dp1_in_vp2 {
+	status = "okay";
+};
+
+&spdif_tx5 {
+    status = "okay";
+};
+
+&hdmi0 {
+	enable-gpios = <&gpio4 RK_PB1 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
+
+&hdmi0_in_vp0 {
+	status = "okay";
+};
+
+/* Should work with at least 128MB cma reserved above. */
+&hdmirx_ctrler {
+	status = "okay";
+
+	#sound-dai-cells = <1>;
+	/* Effective level used to trigger HPD: 0-low, 1-high */
+	hpd-trigger-level = <1>;
+	hdmirx-det-gpios = <&gpio1 RK_PD5 GPIO_ACTIVE_LOW>;
+
+	pinctrl-0 = <&hdmim1_rx_cec &hdmim1_rx_hpdin &hdmim1_rx_scl &hdmim1_rx_sda &hdmirx_det>;
+	pinctrl-names = "default";
+};
+
+&hdptxphy_hdmi0 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0m2_xfer>;
+
+	vdd_cpu_big0_s0: vdd_cpu_big0_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big0_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vdd_cpu_big1_s0: vdd_cpu_big1_mem_s0: rk8603@43 {
+		compatible = "rockchip,rk8603";
+		reg = <0x43>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big1_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c1m2_xfer>;
+
+	vdd_npu_s0: vdd_npu_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_npu_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <950000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	usbc1: fusb302@22 {
+		compatible = "fcs,fusb302";
+		reg = <0x22>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PC6 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&usbc1_int>;
+		vbus-supply = <&vbus5v0_typec1>;
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				usbc1_role_sw: endpoint@0 {
+					remote-endpoint = <&dwc3_1_role_switch>;
+				};
+			};
+		};
+
+		usb_con1: connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+			data-role = "dual";
+			power-role = "dual";
+			try-power-role = "sink";
+			op-sink-microwatt = <15000000>;
+			sink-pdos =
+				// <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
+				<PDO_FIXED(5000, 1000, PDO_FIXED_USB_COMM)
+				PDO_VAR(5000, 20000, 1000)
+				PDO_PPS_APDO(5000, 20000, 1000)>;
+			source-pdos =
+				<PDO_FIXED(5000, 1000, PDO_FIXED_USB_COMM)>;
+
+			altmodes {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				altmode@0 {
+					reg = <0>;
+					svid = <0xff01>;
+					vdo = <0xffffffff>;
+				};
+			};
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					usbc1_orien_sw: endpoint {
+						remote-endpoint = <&usbdp_phy1_orientation_switch>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					dp1_altmode_mux: endpoint {
+						remote-endpoint = <&usbdp_phy1_dp_altmode_mux>;
+					};
+				};
+			};
+		};
+	};
+};
+
+&i2c4 { // U.2 port
+	status = "okay";
+	pinctrl-0 = <&i2c4m0_xfer>;
+};
+
+&i2c6 { // USB Type-C 0
+	status = "okay";
+	pinctrl-0 = <&i2c6m0_xfer>;
+
+	usbc0: fusb302@22 {
+		compatible = "fcs,fusb302";
+		reg = <0x22>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PC5 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&usbc0_int>;
+		vbus-supply = <&vbus5v0_typec0>;
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				usbc0_role_sw: endpoint@0 {
+					remote-endpoint = <&dwc3_0_role_switch>;
+				};
+			};
+		};
+
+		usb_con0: connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+			data-role = "dual";
+			power-role = "dual";
+			try-power-role = "sink";
+			op-sink-microwatt = <1000000>;
+			sink-pdos =
+				<PDO_FIXED(5000, 1000, PDO_FIXED_USB_COMM)>;
+			source-pdos =
+				<PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
+
+			altmodes {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				altmode@0 {
+					reg = <0>;
+					svid = <0xff01>;
+					vdo = <0xffffffff>;
+				};
+			};
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					usbc0_orien_sw: endpoint {
+						remote-endpoint = <&usbdp_phy0_orientation_switch>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					dp0_altmode_mux: endpoint {
+						remote-endpoint = <&usbdp_phy0_dp_altmode_mux>;
+					};
+				};
+			};
+		};
+	};
+};
+
+&i2c5 { // 30PIN GPIO
+	status = "okay";
+	pinctrl-0 = <&i2c5m3_xfer>;
+};
+
+&pwm8 { // 30PIN GPIO
+    pinctrl-names = "active";
+	status = "okay";
+	pinctrl-0 = <&pwm8m2_pins>;
+};
+
+&pwm14 { // 30PIN GPIO
+	status = "okay";
+	pinctrl-0 = <&pwm14m2_pins>;
+};
+
+&pwm15 { // 30PIN GPIO
+	status = "disabled";
+	pinctrl-0 = <&pwm15m3_pins>;
+};
+
+&spi4 { // 30PIN GPIO
+	status = "okay";
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi4m2_cs0 &spi4m2_pins>;
+	num-cs = <1>;
+};
+
+&i2s2_2ch { // 30PIN GPIO
+	status = "okay";
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2s2m1_mclk
+				 &i2s2m1_lrck
+			     &i2s2m1_sclk
+			     &i2s2m1_sdi
+			     &i2s2m1_sdo>;
+};
+
+&can2 { // 30PIN GPIO
+	status = "okay";
+};
+
+&pcie2x1l0 { // combphy1, to ASM1182e
+	reset-gpios = <&gpio1 RK_PB4 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
+
+&pcie2x1l1 { // combphy2, to miniPCIe socket
+	reset-gpios = <&gpio4 RK_PA2 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
+
+&pcie30phy {
+rockchip,pcie30-phymode = <PHY_MODE_PCIE_AGGREGATION>; /* P1:PCIe3x2  +  P0:PCIe3x2 */
+status = "okay";
+};
+
+&pcie3x4 {
+    reset-gpios = <&gpio4 RK_PB6 GPIO_ACTIVE_HIGH>;
+    vpcie3v3-supply = <&vcc3v3_pcie30>;
+    status = "okay";
+};
+
+&pinctrl {
+	sdmmc {
+		sd_s0_pwr: sd-s0-pwr {
+			rockchip,pins = <0 RK_PB7 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	usb {
+		vcc5v0_host_en: vcc5v0-host-en {
+			rockchip,pins = <4 RK_PB0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	hdmirx {
+		hdmirx_det: hdmirx-det {
+			rockchip,pins = <1 RK_PD5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	usb-typec {
+		usbc0_int: usbc0-int {
+			rockchip,pins = <0 RK_PC5 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		usbc1_int: usbc1-int {
+			rockchip,pins = <0 RK_PC6 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		typec5v_pwren0: typec5v-pwren0 {
+			rockchip,pins = <4 RK_PB0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		typec5v_pwren1: typec5v-pwren1 {
+			rockchip,pins = <4 RK_PA3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+};
+
+&route_hdmi0 {
+	status = "okay";
+};
+
+&sata0 {
+	status = "okay";
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry-edge-v10-linux.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry-edge-v10-linux.dts
@@ -0,0 +1,120 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+/dts-v1/;
+
+#include "rk3588-blueberry-edge-v10.dtsi"
+#include "rk3588-linux.dtsi"
+
+/ {
+	model = "Mekotronics R58X (RK3588 EDGE LP4x V1.0 BlueBerry Board)";
+	compatible = "rockchip,rk3588-blueberry-edge-v10-linux", "rockchip,rk3588";
+	/delete-node/ chosen;
+};
+
+&pwm3 {
+	compatible = "rockchip,remotectl-pwm";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm3m0_pins>;
+	remote_pwm_id = <3>;
+	handle_cpu_id = <1>;
+	remote_support_psci = <0>;
+	status = "okay";
+
+	ir_key1 {  //hugsun blue remote
+		rockchip,usercode = <0x7f80>;
+		rockchip,key_table =
+			<0xec	KEY_REPLY>,
+			<0xd8	KEY_BACK>,
+			<0xc7	KEY_UP>,
+			<0xbf	KEY_DOWN>,
+			<0xc8	KEY_LEFT>,
+			<0xc6	KEY_RIGHT>,
+			<0x8c	KEY_HOME>,
+			<0x78	KEY_VOLUMEUP>,
+			<0x76	KEY_VOLUMEDOWN>,
+			<0x7e	KEY_POWER>,
+			<0xed	KEY_POWER>,  //20171123
+			<0x7c	KEY_MENU>,
+			<0xb7	388>;
+	};
+
+	ir_key2 {   //hugsun
+		rockchip,usercode = <0xef10>;
+		rockchip,key_table =
+			<0xa2 KEY_POWER>,
+			<0xe8 KEY_VOLUMEUP>,
+			<0xec KEY_VOLUMEDOWN>,
+			<0xa6 141>,//KEY_SETUP>,
+			<0xa5 388>,
+			<0xff KEY_BACK>,
+			<0xba KEY_UP>,
+			<0xf8 KEY_LEFT>,
+			<0xbe KEY_REPLY>,
+			<0xfe KEY_RIGHT>,
+			<0xaa KEY_DOWN>,
+			<0xb9 KEY_HOME>,
+			<0xfa KEY_MENU>,
+			<0xe5 KEY_REWIND>,
+			<0xa7 KEY_PLAYPAUSE>,
+			<0xe2 KEY_FASTFORWARD>,
+			<0xa0 77>,  //@
+			<0xb0 KEY_0>,
+			<0xa1 14>,
+			<0xaf KEY_1>,
+			<0xad KEY_2>,
+			<0xef KEY_3>,
+			<0xb3 KEY_4>,
+			<0xb5 KEY_5>,
+			<0xee KEY_6>,
+			<0xf0 KEY_7>,
+			<0xb1 KEY_8>,
+			<0xf2	KEY_9>;
+	};
+
+	ir_key3 {
+		rockchip,usercode = <0xdf00>;
+		rockchip,key_table =
+			<0xe3 KEY_POWER>,
+			<0xb4 63>,	//youtube
+			<0xfe 67>,	//Media Center
+			<0xa2 KEY_VOLUMEUP>,
+			<0xb0 66>,	//Netflix
+			<0xa0 68>,	//SetupWizard
+			<0xa3 KEY_VOLUMEDOWN>,
+
+			<0xbd KEY_HOME>,
+			<0xf5 KEY_BACK>,
+
+			<0xe5 KEY_UP>,
+			<0xb8 KEY_LEFT>,
+			<0xf9 KEY_REPLY>,
+			<0xf8 KEY_RIGHT>,
+			<0xb7 KEY_DOWN>,
+			<0xfc 388>,
+			<0xe7 KEY_MENU>,
+
+			<0xab KEY_1>,
+			<0xe9 KEY_2>,
+			<0xea KEY_3>,
+			<0xaf KEY_4>,
+			<0xed KEY_5>,
+			<0xee KEY_6>,
+			<0xb3 KEY_7>,
+			<0xf1 KEY_8>,
+			<0xf2 KEY_9>,
+			<0xbe 227>,  //Fn
+			<0xf3 KEY_0>,
+			<0xef 14>;
+
+	};
+
+	ir_key4{
+		rockchip,usercode = <0x4040>;
+		rockchip,key_table =
+		<0x4d KEY_POWER>;     //power (for 2.4g)
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry-edge-v10.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry-edge-v10.dtsi
@@ -0,0 +1,854 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+#include "dt-bindings/usb/pd.h"
+#include "rk3588.dtsi"
+#include "rk3588-blueberry.dtsi"
+#include "rk3588-rk806-single.dtsi"
+
+/ {
+	/* If hdmirx node is disabled, delete the reserved-memory node here. */
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* Reserve 256MB memory for hdmirx-controller@fdee0000 */
+		cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			reg = <0x0 (256 * 0x100000) 0x0 (256 * 0x100000)>;
+			linux,cma-default;
+		};
+	};
+
+	i2s0_sound: i2s0-sound {
+		status = "okay";
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <256>;
+		simple-audio-card,name = "rockchip,es8311";
+		simple-audio-card,dai-link@0 {
+			format = "i2s";
+			cpu {
+				sound-dai = <&i2s0_8ch>;
+			};
+			codec {
+				sound-dai = <&es8311>;
+			};
+		};
+	};
+
+	hdmiin-sound {
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,format = "i2s";
+		rockchip,bitclock-master = <&hdmirx_ctrler>;
+		rockchip,frame-master = <&hdmirx_ctrler>;
+		rockchip,card-name = "rockchip,hdmiin";
+		rockchip,cpu = <&i2s7_8ch>;
+		rockchip,codec = <&hdmirx_ctrler 0>;
+		rockchip,jack-det;
+	};
+
+	leds: leds {
+		compatible = "gpio-leds";
+		wifi_led: wifi-led {
+			gpios = <&gpio3 RK_PC5 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+		hdd_led: hdd-led {
+			gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+		eth_led: eth-led {
+			gpios = <&gpio3 RK_PC0 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+		work_led: work-led {
+			gpios = <&gpio3 RK_PB7 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	gpio_keys: gpio-keys {
+		compatible = "gpio-keys";
+		autorepeat;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pwrbtn>;
+
+		power {
+			debounce-interval = <100>;
+			gpios = <&gpio1 RK_PD3 GPIO_ACTIVE_LOW>;
+			//gpios = <&gpio0 RK_PD5 GPIO_ACTIVE_LOW>;
+			label = "GPIO Key Power";
+			linux,code = <KEY_POWER>;
+			wakeup-source;
+		};
+	};
+
+	vk2c21_lcd {
+		compatible = "lcd_vk2c21";
+		i2c_scl = <&gpio0 RK_PC5 GPIO_ACTIVE_HIGH>;
+		i2c_sda = <&gpio0 RK_PC4 GPIO_ACTIVE_HIGH>;
+
+		status = "disabled";
+	};
+
+	pcie30_avdd0v75: pcie30-avdd0v75 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie30_avdd0v75";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <750000>;
+		regulator-max-microvolt = <750000>;
+		vin-supply = <&vdd_0v75_s0>;
+	};
+
+	pcie30_avdd1v8: pcie30-avdd1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie30_avdd1v8";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&avcc_1v8_s0>;
+	};
+
+	vcc12v_dcin: vcc12v-dcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc12v_dcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc3v3_pcie30: vcc3v3-pcie30 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_pcie30";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc3v3_pcie30_en>;
+		gpios = <&gpio1 RK_PC4 GPIO_ACTIVE_HIGH>;    //hugsun gpio1_c4
+		startup-delay-us = <10000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_host: vcc5v0-host-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_host";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio4 RK_PB0 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_sys>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_host_en>;
+	};
+
+	vcc5v0_otg: vcc5v0-otg-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_otg";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio4 RK_PA7 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_sys>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_otg_en>;
+	};
+
+	vcc_1v1_nldo_s3: vcc-1v1-nldo-s3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_1v1_nldo_s3";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1100000>;
+		regulator-max-microvolt = <1100000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	wireless_bluetooth: wireless-bluetooth {
+		compatible = "bluetooth-platdata";
+		clocks = <&hym8563>;
+		clock-names = "ext_clock";
+		uart_rts_gpios = <&gpio1 RK_PA2 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default", "rts_gpio";
+		pinctrl-0 = <&uart6m1_rtsn>, <&bt_gpio>;
+		pinctrl-1 = <&uart6_gpios>;
+		BT,reset_gpio    = <&gpio1 RK_PB2 GPIO_ACTIVE_HIGH>;
+		BT,wake_gpio     = <&gpio1 RK_PA4 GPIO_ACTIVE_HIGH>;
+		BT,wake_host_irq = <&gpio1 RK_PB0 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	wireless_wlan: wireless-wlan {
+		compatible = "wlan-platdata";
+		wifi_chip_type = "ap6275p";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_host_wake_irq>, <&wifi_poweren_gpio>;
+		WIFI,host_wake_irq = <&gpio1 RK_PA7 GPIO_ACTIVE_HIGH>;
+		WIFI,poweren_gpio = <&gpio1 RK_PB1 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+};
+
+&combphy0_ps {
+	status = "okay";
+};
+
+&combphy1_ps {
+	status = "okay";
+};
+
+&combphy2_psu {
+	status = "okay";
+};
+
+&dp0 {
+	status = "okay";
+};
+
+&dp0_in_vp1 {
+	status = "okay";
+};
+
+&dp0_sound{
+	status = "okay";
+};
+
+&dp1 {
+	pinctrl-0 = <&dp1m0_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&dp1_in_vp2 {
+	status = "okay";
+};
+
+&dp1_sound{
+	status = "okay";
+};
+
+&gmac0 {
+	/* Use rgmii-rxid mode to disable rx delay inside Soc */
+	phy-mode = "rgmii-rxid";
+	clock_in_out = "output";
+
+	snps,reset-gpio = <&gpio4 RK_PB3 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	/* Reset time is 20ms, 100ms for rtl8211f */
+	snps,reset-delays-us = <0 20000 100000>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac0_miim
+		     &gmac0_tx_bus2
+		     &gmac0_rx_bus2
+		     &gmac0_rgmii_clk
+		     &gmac0_rgmii_bus>;
+
+	tx_delay = <0x44>;
+	/* rx_delay = <0x4f>; */
+
+	phy-handle = <&rgmii_phy0>;
+	status = "okay";
+};
+
+&gmac1 {
+	/* Use rgmii-rxid mode to disable rx delay inside Soc */
+	phy-mode = "rgmii-rxid";
+	clock_in_out = "output";
+
+	snps,reset-gpio = <&gpio4 RK_PA2 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	/* Reset time is 20ms, 100ms for rtl8211f */
+	snps,reset-delays-us = <0 20000 100000>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac1_miim
+		     &gmac1_tx_bus2
+		     &gmac1_rx_bus2
+		     &gmac1_rgmii_clk
+		     &gmac1_rgmii_bus>;
+
+	tx_delay = <0x42>;
+	/* rx_delay = <0x4f>; */
+
+	phy-handle = <&rgmii_phy1>;
+	status = "okay";
+};
+
+&hdmi0 {
+	enable-gpios = <&gpio4 RK_PB1 GPIO_ACTIVE_HIGH>;
+	cec-enable = "true" ;
+	status = "okay";
+};
+
+&hdmi0_in_vp0 {
+	status = "okay";
+};
+
+&hdmi0_sound {
+	status = "okay";
+};
+
+&hdptxphy_hdmi0 {
+	status = "okay";
+};
+
+
+/* Should work with at least 128MB cma reserved above. */
+&hdmirx_ctrler {
+	status = "okay";
+
+	#sound-dai-cells = <1>;
+	/* Effective level used to trigger HPD: 0-low, 1-high */
+	hpd-trigger-level = <1>;
+	hdmirx-det-gpios = <&gpio1 29 GPIO_ACTIVE_LOW>;   //gpio1_d5
+};
+
+&i2c0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0m2_xfer>;
+
+	vdd_cpu_big0_s0: vdd_cpu_big0_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big0_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vdd_cpu_big1_s0: vdd_cpu_big1_mem_s0: rk8603@43 {
+		compatible = "rockchip,rk8603";
+		reg = <0x43>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big1_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c2 {
+	status = "okay";
+
+	vdd_npu_s0: vdd_npu_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_npu_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <950000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c3 {
+	status = "okay";
+	es8311: es8311@18 {
+		status = "okay";
+		compatible = "everest,es8311";
+		reg = <0x18>;
+		#sound-dai-cells = <0>;
+		adc-pga-gain = <6>;     /* 18dB */
+		adc-volume = <0xbf>;    /* 0dB */
+		dac-volume = <0xbf>;    /* 0dB */
+		aec-mode = "adc left, adc right";
+		clocks = <&mclkout_i2s0>;
+		clock-names = "mclk";
+		assigned-clocks = <&mclkout_i2s0>;
+		assigned-clock-rates = <12288000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s0_mclk>;
+	};
+};
+
+&i2c5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c5m3_xfer>;
+	status = "okay";
+};
+
+&i2c6 {
+	status = "okay";
+	usbc0: fusb302@22 {
+		compatible = "fcs,fusb302";
+		reg = <0x22>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <RK_PC7 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&usbc0_int>;
+		vbus-supply = <&vcc5v0_otg>;
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				usbc0_role_sw: endpoint@0 {
+					remote-endpoint = <&dwc3_0_role_switch>;
+				};
+			};
+		};
+
+		usb_con: connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+			data-role = "dual";
+			power-role = "dual";
+			try-power-role = "sink";
+			op-sink-microwatt = <1000000>;
+			sink-pdos =
+				<PDO_FIXED(5000, 1000, PDO_FIXED_USB_COMM)>;
+			source-pdos =
+				<PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
+
+			altmodes {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				altmode@0 {
+					reg = <0>;
+					svid = <0xff01>;
+					vdo = <0xffffffff>;
+				};
+			};
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					usbc0_orien_sw: endpoint {
+						remote-endpoint = <&usbdp_phy0_orientation_switch>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					dp_altmode_mux: endpoint {
+						remote-endpoint = <&usbdp_phy0_dp_altmode_mux>;
+					};
+				};
+			};
+		};
+	};
+
+	hym8563: hym8563@51 {
+		compatible = "haoyu,hym8563";
+		reg = <0x51>;
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		clock-output-names = "hym8563";
+		pinctrl-names = "default";
+		pinctrl-0 = <&hym8563_int>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PB2 IRQ_TYPE_LEVEL_LOW>;
+		wakeup-source;
+	};
+};
+
+&i2s0_8ch {
+	status = "okay";
+	pinctrl-0 = <&i2s0_lrck
+		     &i2s0_sclk
+		     &i2s0_sdi0
+		     &i2s0_sdo0>;
+};
+
+//hdmi01 sound
+&i2s5_8ch {
+	status = "okay";
+};
+
+//hdmi02 sound
+&i2s6_8ch {
+	status = "okay";
+};
+
+//hdmiin sound
+&i2s7_8ch {
+	status = "okay";
+};
+
+&spdif_tx2 {
+	status = "okay";
+};
+
+&spdif_tx5 {
+	status = "okay";
+};
+
+&mdio0 {
+	rgmii_phy0: phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x1>;
+	};
+};
+
+&mdio1 {
+	rgmii_phy1: phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x1>;
+	};
+};
+
+&pcie2x1l0 {
+	reset-gpios = <&gpio1 RK_PB4 GPIO_ACTIVE_HIGH>;
+	rockchip,skip-scan-in-resume;
+	status = "okay";
+};
+
+
+&pcie30phy {
+	rockchip,pcie30-phymode = <PHY_MODE_PCIE_AGGREGATION>;
+	status = "okay";
+};
+
+&pcie3x4 {
+	reset-gpios = <&gpio4 RK_PB6 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_pcie30>;
+	status = "okay";
+};
+
+&rk806single {
+	pinctrl-names = "default", "pmic-power-off";
+	pinctrl-0 = <&pmic_pins>, <&rk806_dvs1_null>, <&rk806_dvs2_null>, <&rk806_dvs3_null>;
+	pinctrl-1 = <&rk806_dvs1_slp>, <&rk806_dvs2_null>, <&rk806_dvs3_null>;
+
+	regulators {
+		avcc_1v8_s0: PLDO_REG1 {
+			regulator-always-on;
+			regulator-boot-on;
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-name = "avcc_1v8_s0";
+			regulator-state-mem {
+				regulator-on-in-suspend;
+				regulator-suspend-microvolt = <1800000>;
+			};
+		};
+	};
+};
+
+&vdd_log_s0 {  //fox.luo@2022.05.26 don't wake up
+        regulator-state-mem {
+        regulator-on-in-suspend;
+        regulator-suspend-microvolt = <750000>;
+        };
+};
+
+&rockchip_suspend {
+	status = "okay";
+	rockchip,sleep-debug-en = <1>;
+	rockchip,virtual-poweroff = <1>;
+	rockchip,sleep-mode-config = <
+		(0
+		| RKPM_SLP_ARMOFF_DDRPD
+		)
+	>;
+	rockchip,wakeup-config = <
+		(0
+		| RKPM_CPU0_WKUP_EN
+		| RKPM_GPIO_WKUP_EN
+		)
+	>;
+};
+
+&route_dp1 {
+	status = "okay";
+	connect = <&vp2_out_dp1>;
+};
+
+&route_hdmi0 {
+	status = "okay";
+	connect = <&vp0_out_hdmi0>;
+};
+
+&sata0 {
+	status = "okay";
+};
+
+//rs485
+&uart0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0m2_xfer>;
+};
+
+//rs232
+&uart3 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart3m2_xfer>;
+};
+
+&uart6 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart6m1_xfer &uart6m1_ctsn>;
+};
+
+&sdhci {
+	bus-width = <8>;
+	no-sdio;
+	no-sd;
+	non-removable;
+	max-frequency = <200000000>;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	status = "okay";
+};
+
+
+&pinctrl {
+
+
+	wireless-bluetooth {
+		uart6_gpios: uart6-gpios {
+			rockchip,pins = <1 RK_PA2 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		bt_gpio: bt-gpio {
+			rockchip,pins =
+				<1 RK_PB2 RK_FUNC_GPIO &pcfg_pull_none>,
+				<1 RK_PB0 RK_FUNC_GPIO &pcfg_pull_up>,
+				<1 RK_PA4 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	wireless-wlan {
+		wifi_host_wake_irq: wifi-host-wake-irq {
+			rockchip,pins = <1 RK_PA7 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+
+		wifi_poweren_gpio: wifi-poweren-gpio {
+			rockchip,pins = <1 RK_PB1 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	buttons {
+		pwrbtn: pwrbtn {
+			rockchip,pins = <1 RK_PD3 RK_FUNC_GPIO &pcfg_pull_up>;
+			//rockchip,pins = <0 RK_PD5 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	hym8563 {
+		hym8563_int: hym8563-int {
+			rockchip,pins = <0 RK_PB2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	usb {
+		vcc5v0_host_en: vcc5v0-host-en {
+			rockchip,pins = <4 RK_PB0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+	};
+
+	usb-typec {
+		usbc0_int: usbc0-int {
+			rockchip,pins = <3 RK_PC7 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		vcc5v0_otg_en: vcc5v0-otg-en {
+			rockchip,pins = <4 RK_PA7 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	pcie {
+		vcc3v3_pcie30_en: vcc3v3-pcie30-en {
+			rockchip,pins = <1 RK_PC4 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+	};
+};
+
+//type-c0
+&u2phy0 {
+	status = "okay";
+};
+
+&u2phy1 {
+	status = "okay";
+};
+
+//usb2.0 host0
+&u2phy2 {
+	status = "okay";
+};
+
+//usb2.0 host1
+&u2phy3 {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	rockchip,typec-vbus-det;
+	status = "okay";
+};
+
+&u2phy1_otg {
+	phy-supply = <&vcc5v0_host>;
+	status = "okay";
+};
+
+&u2phy2_host {
+	phy-supply = <&vcc5v0_host>;
+	status = "okay";
+};
+
+&u2phy3_host {
+	phy-supply = <&vcc5v0_host>;
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&usbdp_phy0 {
+	orientation-switch;
+	svid = <0xff01>;
+	sbu1-dc-gpios = <&gpio0 RK_PC6 GPIO_ACTIVE_HIGH>;
+	sbu2-dc-gpios = <&gpio0 RK_PD3 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		usbdp_phy0_orientation_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_orien_sw>;
+		};
+
+		usbdp_phy0_dp_altmode_mux: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&dp_altmode_mux>;
+		};
+	};
+};
+
+&usbdp_phy0_dp {
+	status = "okay";
+};
+
+&usbdp_phy0_u3 {
+	status = "okay";
+};
+
+&usbdp_phy1 {
+	rockchip,dp-lane-mux = < 0 1 2 3 >;
+	status = "okay";
+};
+
+&usbdp_phy1_dp {
+	status = "okay";
+};
+
+&usbdp_phy1_u3 {
+	maximum-speed = "high-speed";
+	status = "okay";
+};
+
+&usbdrd3_0 {
+	status = "okay";
+};
+
+&usbdrd3_1 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	dr_mode = "otg";
+	usb-role-switch;
+	status = "okay";
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		dwc3_0_role_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_role_sw>;
+		};
+	};
+};
+
+&usbdrd_dwc3_1 {
+	dr_mode = "host";
+	maximum-speed = "high-speed";
+	status = "okay";
+};
+
+&usbhost3_0 {
+	status = "okay";
+};
+
+&usbhost_dwc3_0 {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&vdd_vdenc_s0 {
+	regulator-init-microvolt = <750000>;
+};
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry-edge-v12-linux.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry-edge-v12-linux.dts
@@ -0,0 +1,120 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+/dts-v1/;
+
+#include "rk3588-blueberry-edge-v12.dtsi"
+#include "rk3588-linux.dtsi"
+
+/ {
+	model = "Mekotronics R58X-4G (RK3588 EDGE LP4x V1.2 BlueBerry Board)";
+	compatible = "rockchip,rk3588-blueberry-edge-v12-linux", "rockchip,rk3588";
+	/delete-node/ chosen;
+};
+
+&pwm3 {
+	compatible = "rockchip,remotectl-pwm";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm3m0_pins>;
+	remote_pwm_id = <3>;
+	handle_cpu_id = <1>;
+	remote_support_psci = <0>;
+	status = "okay";
+
+	ir_key1 {  //hugsun blue remote
+		rockchip,usercode = <0x7f80>;
+		rockchip,key_table =
+			<0xec	KEY_REPLY>,
+			<0xd8	KEY_BACK>,
+			<0xc7	KEY_UP>,
+			<0xbf	KEY_DOWN>,
+			<0xc8	KEY_LEFT>,
+			<0xc6	KEY_RIGHT>,
+			<0x8c	KEY_HOME>,
+			<0x78	KEY_VOLUMEUP>,
+			<0x76	KEY_VOLUMEDOWN>,
+			<0x7e	KEY_POWER>,
+			<0xed	KEY_POWER>,  //20171123
+			<0x7c	KEY_MENU>,
+			<0xb7	388>;
+	};
+
+	ir_key2 {   //hugsun
+		rockchip,usercode = <0xef10>;
+		rockchip,key_table =
+			<0xa2 KEY_POWER>,
+			<0xe8 KEY_VOLUMEUP>,
+			<0xec KEY_VOLUMEDOWN>,
+			<0xa6 141>,//KEY_SETUP>,
+			<0xa5 388>,
+			<0xff KEY_BACK>,
+			<0xba KEY_UP>,
+			<0xf8 KEY_LEFT>,
+			<0xbe KEY_REPLY>,
+			<0xfe KEY_RIGHT>,
+			<0xaa KEY_DOWN>,
+			<0xb9 KEY_HOME>,
+			<0xfa KEY_MENU>,
+			<0xe5 KEY_REWIND>,
+			<0xa7 KEY_PLAYPAUSE>,
+			<0xe2 KEY_FASTFORWARD>,
+			<0xa0 77>,  //@
+			<0xb0 KEY_0>,
+			<0xa1 14>,
+			<0xaf KEY_1>,
+			<0xad KEY_2>,
+			<0xef KEY_3>,
+			<0xb3 KEY_4>,
+			<0xb5 KEY_5>,
+			<0xee KEY_6>,
+			<0xf0 KEY_7>,
+			<0xb1 KEY_8>,
+			<0xf2	KEY_9>;
+	};
+
+	ir_key3 {
+		rockchip,usercode = <0xdf00>;
+		rockchip,key_table =
+			<0xe3 KEY_POWER>,
+			<0xb4 63>,	//youtube
+			<0xfe 67>,	//Media Center
+			<0xa2 KEY_VOLUMEUP>,
+			<0xb0 66>,	//Netflix
+			<0xa0 68>,	//SetupWizard
+			<0xa3 KEY_VOLUMEDOWN>,
+
+			<0xbd KEY_HOME>,
+			<0xf5 KEY_BACK>,
+
+			<0xe5 KEY_UP>,
+			<0xb8 KEY_LEFT>,
+			<0xf9 KEY_REPLY>,
+			<0xf8 KEY_RIGHT>,
+			<0xb7 KEY_DOWN>,
+			<0xfc 388>,
+			<0xe7 KEY_MENU>,
+
+			<0xab KEY_1>,
+			<0xe9 KEY_2>,
+			<0xea KEY_3>,
+			<0xaf KEY_4>,
+			<0xed KEY_5>,
+			<0xee KEY_6>,
+			<0xb3 KEY_7>,
+			<0xf1 KEY_8>,
+			<0xf2 KEY_9>,
+			<0xbe 227>,  //Fn
+			<0xf3 KEY_0>,
+			<0xef 14>;
+
+	};
+
+	ir_key4{
+		rockchip,usercode = <0x4040>;
+		rockchip,key_table =
+		<0x4d KEY_POWER>;     //power (for 2.4g)
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry-edge-v12-maizhuo-linux.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry-edge-v12-maizhuo-linux.dts
@@ -0,0 +1,44 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+/dts-v1/;
+
+#include "rk3588-blueberry-edge-v12.dtsi"
+#include "rk3588-linux.dtsi"
+
+/ {
+	model = "RK3588 EDGE LP4x V1.2 MeiZhuo BlueBerry Board";
+	compatible = "rockchip,rk3588-blueberry-edge-v12-linux", "rockchip,rk3588";
+	/delete-node/ chosen;
+
+	vk2c21_lcd {
+		compatible = "lcd_vk2c21";
+		i2c_scl = <&gpio0 RK_PC5 GPIO_ACTIVE_HIGH>;
+		i2c_sda = <&gpio0 RK_PC4 GPIO_ACTIVE_HIGH>;
+
+		status = "okay";//"okay";  //zxLog_2022.9.20 for maozhuo time-lcd show;
+	};
+};
+
+&gpio_keys{
+	vol_up {
+		debounce-interval = <0>;
+		autorepeat = <1>;
+		gpios = <&gpio3 RK_PD0 GPIO_ACTIVE_HIGH>;
+		label = "GPIO Key Vol+";
+		linux,code = <KEY_VOLUMEUP>;
+		wakeup-source;
+	};
+
+	vol_down {
+		debounce-interval = <0>;
+		autorepeat = <1>;
+		gpios = <&gpio3 RK_PC6 GPIO_ACTIVE_HIGH>;
+		label = "GPIO Key Vol-";
+		linux,code = <KEY_VOLUMEDOWN>;
+		wakeup-source;
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry-edge-v12.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry-edge-v12.dtsi
@@ -0,0 +1,899 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+#include "dt-bindings/usb/pd.h"
+#include "rk3588.dtsi"
+#include "rk3588-blueberry.dtsi"
+#include "rk3588-rk806-single.dtsi"
+
+/ {
+	/* If hdmirx node is disabled, delete the reserved-memory node here. */
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* Reserve 256MB memory for hdmirx-controller@fdee0000 */
+		cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			reg = <0x0 (256 * 0x100000) 0x0 (256 * 0x100000)>;
+			linux,cma-default;
+		};
+	};
+
+	es8388_sound: es8388-sound {
+		status = "okay";
+		compatible = "rockchip,multicodecs-card";
+		rockchip,card-name = "rockchip-es8388";
+		//hp-det-gpio = <&gpio3 RK_PB2 GPIO_ACTIVE_HIGH>;
+		rockchip,format = "i2s";
+		rockchip,mclk-fs = <256>;
+		rockchip,cpu = <&i2s0_8ch>;
+		rockchip,codec = <&es8388>;
+		rockchip,audio-routing =
+			"Headphone", "LOUT1",
+			"Headphone", "ROUT1",
+			"Speaker", "LOUT2",
+			"Speaker", "ROUT2",
+			"Headphone", "Headphone Power",
+			"Headphone", "Headphone Power",
+			"Speaker", "Speaker Power",
+			"Speaker", "Speaker Power",
+			"LINPUT1", "Main Mic",
+			"LINPUT2", "Main Mic",
+			"RINPUT1", "Headset Mic",
+			"RINPUT2", "Headset Mic";
+		pinctrl-names = "default";
+		pinctrl-0 = <&hp_det>;
+	};
+
+	rk_headset: rk-headset {
+		status = "disabled";
+		compatible = "rockchip_headset";
+		headset_gpio = <&gpio3 RK_PB2 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&hp_det>;
+		io-channels = <&saradc 3>;
+	};
+
+	hdmiin-sound {
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,format = "i2s";
+		rockchip,bitclock-master = <&hdmirx_ctrler>;
+		rockchip,frame-master = <&hdmirx_ctrler>;
+		rockchip,card-name = "rockchip,hdmiin";
+		rockchip,cpu = <&i2s7_8ch>;
+		rockchip,codec = <&hdmirx_ctrler 0>;
+		rockchip,jack-det;
+	};
+
+	leds: leds {
+		compatible = "gpio-leds";
+		wifi_led: wifi-led {
+			gpios = <&gpio3 RK_PC5 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+		hdd_led: hdd-led {
+			gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+		eth_led: eth-led {
+			gpios = <&gpio3 RK_PC0 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+		work_led: work-led {
+			gpios = <&gpio3 RK_PB7 GPIO_ACTIVE_HIGH>;
+			//linux,default-trigger = "heartbeat";
+			default-state = "on";
+		};
+	};
+
+	gpio_keys: gpio-keys {
+		compatible = "gpio-keys";
+		autorepeat;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pwrbtn>;
+
+		power {
+			debounce-interval = <100>;
+			gpios = <&gpio1 RK_PD3 GPIO_ACTIVE_LOW>;
+			//gpios = <&gpio0 RK_PD5 GPIO_ACTIVE_LOW>;
+			label = "GPIO Key Power";
+			linux,code = <KEY_POWER>;
+			wakeup-source;
+		};
+	};
+
+	vk2c21_lcd {
+		compatible = "lcd_vk2c21";
+		i2c_scl = <&gpio0 RK_PC5 GPIO_ACTIVE_HIGH>;
+		i2c_sda = <&gpio0 RK_PC4 GPIO_ACTIVE_HIGH>;
+
+		status = "disabled";//"okay";  //zxLog_2022.9.20 for maozhuo time-lcd show;
+	};
+
+	pcie30_avdd0v75: pcie30-avdd0v75 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie30_avdd0v75";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <750000>;
+		regulator-max-microvolt = <750000>;
+		vin-supply = <&vdd_0v75_s0>;
+	};
+
+	pcie30_avdd1v8: pcie30-avdd1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie30_avdd1v8";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&avcc_1v8_s0>;
+	};
+
+	vcc12v_dcin: vcc12v-dcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc12v_dcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc3v3_pcie30: vcc3v3-pcie30 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_pcie30";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc3v3_pcie30_en>;
+		gpios = <&gpio1 RK_PC4 GPIO_ACTIVE_HIGH>;    //hugsun gpio1_c4
+		startup-delay-us = <10000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_host: vcc5v0-host-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_host";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio4 RK_PB0 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_sys>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_host_en>;
+	};
+
+	vcc5v0_otg: vcc5v0-otg-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_otg";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio4 RK_PA7 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_sys>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_otg_en>;
+	};
+
+	vcc_1v1_nldo_s3: vcc-1v1-nldo-s3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_1v1_nldo_s3";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1100000>;
+		regulator-max-microvolt = <1100000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	modem {
+		compatible = "rockchip,modem";
+		status = "okay";
+		power-on_gpio = <&gpio0 RK_PD5 GPIO_ACTIVE_HIGH>;
+		reset_gpio = <&gpio0 RK_PA0 GPIO_ACTIVE_HIGH>; //GPIO_C4
+	};
+
+	wireless_bluetooth: wireless-bluetooth {
+		compatible = "bluetooth-platdata";
+		clocks = <&hym8563>;
+		clock-names = "ext_clock";
+		uart_rts_gpios = <&gpio1 RK_PA2 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default", "rts_gpio";
+		pinctrl-0 = <&uart6m1_rtsn>, <&bt_gpio>;
+		pinctrl-1 = <&uart6_gpios>;
+		BT,reset_gpio    = <&gpio1 RK_PB2 GPIO_ACTIVE_HIGH>;
+		BT,wake_gpio     = <&gpio1 RK_PA4 GPIO_ACTIVE_HIGH>;
+		BT,wake_host_irq = <&gpio1 RK_PB0 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	wireless_wlan: wireless-wlan {
+		compatible = "wlan-platdata";
+		wifi_chip_type = "ap6275p";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_host_wake_irq>, <&wifi_poweren_gpio>;
+		WIFI,host_wake_irq = <&gpio1 RK_PA7 GPIO_ACTIVE_HIGH>;
+		WIFI,poweren_gpio = <&gpio1 RK_PB1 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+};
+
+&combphy0_ps {
+	status = "okay";
+};
+
+&combphy1_ps {
+	status = "okay";
+};
+
+&combphy2_psu {
+	status = "okay";
+};
+
+&dp0 {
+	status = "disable";
+};
+
+//&dp0_in_vp2 {
+//	status = "okay";
+//};
+
+&dp1 {
+	pinctrl-0 = <&dp1m0_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&dp1_in_vp2 {
+	status = "okay";
+};
+
+&dp1_sound{
+	status = "okay";
+};
+
+&gmac0 {
+	/* Use rgmii-rxid mode to disable rx delay inside Soc */
+	phy-mode = "rgmii-rxid";
+	clock_in_out = "output";
+
+	snps,reset-gpio = <&gpio4 RK_PB3 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	/* Reset time is 20ms, 100ms for rtl8211f */
+	snps,reset-delays-us = <0 20000 100000>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac0_miim
+		     &gmac0_tx_bus2
+		     &gmac0_rx_bus2
+		     &gmac0_rgmii_clk
+		     &gmac0_rgmii_bus>;
+
+	tx_delay = <0x44>;
+	/* rx_delay = <0x4f>; */
+
+	phy-handle = <&rgmii_phy0>;
+	status = "okay";
+};
+
+&gmac1 {
+	/* Use rgmii-rxid mode to disable rx delay inside Soc */
+	phy-mode = "rgmii-rxid";
+	clock_in_out = "output";
+
+	snps,reset-gpio = <&gpio4 RK_PA2 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	/* Reset time is 20ms, 100ms for rtl8211f */
+	snps,reset-delays-us = <0 20000 100000>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac1_miim
+		     &gmac1_tx_bus2
+		     &gmac1_rx_bus2
+		     &gmac1_rgmii_clk
+		     &gmac1_rgmii_bus>;
+
+	tx_delay = <0x42>;
+	/* rx_delay = <0x4f>; */
+
+	phy-handle = <&rgmii_phy1>;
+	status = "okay";
+};
+
+&hdmi0 {
+	enable-gpios = <&gpio4 RK_PB1 GPIO_ACTIVE_HIGH>;
+	cec-enable = "true" ;
+	status = "okay";
+};
+
+&hdmi0_in_vp0 {
+	status = "okay";
+};
+
+&hdmi0_sound {
+	status = "okay";
+};
+
+&hdptxphy_hdmi0 {
+	status = "okay";
+};
+
+
+/* Should work with at least 128MB cma reserved above. */
+&hdmirx_ctrler {
+	status = "okay";
+
+	/* Effective level used to trigger HPD: 0-low, 1-high */
+	hpd-trigger-level = <1>;
+	hdmirx-det-gpios = <&gpio1 RK_PD5 GPIO_ACTIVE_LOW>;   //gpio1_d5
+	pinctrl-names = "default";
+	pinctrl-0 = <&hdmim1_rx &hdmirx_det>;
+};
+
+&i2c0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0m2_xfer>;
+
+	vdd_cpu_big0_s0: vdd_cpu_big0_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big0_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vdd_cpu_big1_s0: vdd_cpu_big1_mem_s0: rk8603@43 {
+		compatible = "rockchip,rk8603";
+		reg = <0x43>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big1_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c2 {
+	status = "okay";
+
+	vdd_npu_s0: vdd_npu_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_npu_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <950000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c3 {
+	status = "okay";
+	es8388: es8388@10 {
+		status = "okay";
+		#sound-dai-cells = <0>;
+		compatible = "everest,es8388", "everest,es8323";
+		reg = <0x10>;
+		clocks = <&mclkout_i2s0>;
+		clock-names = "mclk";
+		assigned-clocks = <&mclkout_i2s0>;
+		assigned-clock-rates = <12288000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s0_mclk>;
+	};
+};
+
+&i2c5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c5m3_xfer>;
+	status = "okay";
+};
+
+&i2c6 {
+	status = "okay";
+	usbc0: fusb302@22 {
+		compatible = "fcs,fusb302";
+		reg = <0x22>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <RK_PC7 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&usbc0_int>;
+		vbus-supply = <&vcc5v0_otg>;
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				usbc0_role_sw: endpoint@0 {
+					remote-endpoint = <&dwc3_0_role_switch>;
+				};
+			};
+		};
+
+		usb_con: connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+			data-role = "dual";
+			power-role = "dual";
+			try-power-role = "sink";
+			op-sink-microwatt = <1000000>;
+			sink-pdos =
+				<PDO_FIXED(5000, 1000, PDO_FIXED_USB_COMM)>;
+			source-pdos =
+				<PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
+
+			altmodes {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				altmode@0 {
+					reg = <0>;
+					svid = <0xff01>;
+					vdo = <0xffffffff>;
+				};
+			};
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					usbc0_orien_sw: endpoint {
+						remote-endpoint = <&usbdp_phy0_orientation_switch>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					dp_altmode_mux: endpoint {
+						remote-endpoint = <&usbdp_phy0_dp_altmode_mux>;
+					};
+				};
+			};
+		};
+	};
+
+	hym8563: hym8563@51 {
+		compatible = "haoyu,hym8563";
+		reg = <0x51>;
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		clock-output-names = "hym8563";
+		pinctrl-names = "default";
+		pinctrl-0 = <&hym8563_int>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PB2 IRQ_TYPE_LEVEL_LOW>;
+		wakeup-source;
+	};
+};
+
+&i2s0_8ch {
+	status = "okay";
+	pinctrl-0 = <&i2s0_lrck
+		     &i2s0_sclk
+		     &i2s0_sdi0
+		     &i2s0_sdo0>;
+};
+
+//hdmi01 sound
+&i2s5_8ch {
+	status = "okay";
+};
+
+//hdmi02 sound
+&i2s6_8ch {
+	status = "okay";
+};
+
+//hdmiin sound
+&i2s7_8ch {
+	status = "okay";
+};
+
+&spdif_tx2 {
+	status = "okay";
+};
+
+&spdif_tx5 {
+	status = "okay";
+};
+
+&mdio0 {
+	rgmii_phy0: phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x1>;
+	};
+};
+
+&mdio1 {
+	rgmii_phy1: phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x1>;
+	};
+};
+
+&pcie2x1l0 {
+	reset-gpios = <&gpio1 RK_PB4 GPIO_ACTIVE_HIGH>;
+	rockchip,skip-scan-in-resume;
+	status = "okay";
+};
+
+
+&pcie30phy {
+	rockchip,pcie30-phymode = <PHY_MODE_PCIE_AGGREGATION>;
+	status = "okay";
+};
+
+&pcie3x4 {
+	reset-gpios = <&gpio4 RK_PB6 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_pcie30>;
+	status = "okay";
+};
+
+&rk806single {
+	pinctrl-names = "default", "pmic-power-off";
+	pinctrl-0 = <&pmic_pins>, <&rk806_dvs1_null>, <&rk806_dvs2_null>, <&rk806_dvs3_null>;
+	pinctrl-1 = <&rk806_dvs1_slp>, <&rk806_dvs2_null>, <&rk806_dvs3_null>;
+
+	regulators {
+		avcc_1v8_s0: PLDO_REG1 {
+			regulator-always-on;
+			regulator-boot-on;
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-name = "avcc_1v8_s0";
+			regulator-state-mem {
+				regulator-on-in-suspend;
+				regulator-suspend-microvolt = <1800000>;
+			};
+		};
+	};
+};
+
+&vdd_log_s0 {  //fox.luo@2022.05.26 don't wake up
+        regulator-state-mem {
+        regulator-on-in-suspend;
+        regulator-suspend-microvolt = <750000>;
+        };
+};
+
+&rockchip_suspend {
+	status = "okay";
+	rockchip,sleep-debug-en = <1>;
+	rockchip,virtual-poweroff = <1>;
+	rockchip,sleep-mode-config = <
+		(0
+		| RKPM_SLP_ARMOFF_DDRPD
+		)
+	>;
+	rockchip,wakeup-config = <
+		(0
+		| RKPM_CPU0_WKUP_EN
+		| RKPM_GPIO_WKUP_EN
+		)
+	>;
+};
+
+&route_dp1 {
+	status = "okay";
+	connect = <&vp2_out_dp1>;
+};
+
+&route_hdmi0 {
+	status = "okay";
+	connect = <&vp0_out_hdmi0>;
+};
+
+&sata0 {
+	status = "okay";
+};
+
+//rs485
+&uart0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0m2_xfer>;
+};
+
+//rs232
+&uart3 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart3m2_xfer>;
+};
+
+&uart6 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart6m1_xfer &uart6m1_ctsn>;
+};
+
+&sdhci {
+	bus-width = <8>;
+	no-sdio;
+	no-sd;
+	non-removable;
+	max-frequency = <200000000>;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	full-pwr-cycle-in-suspend;
+	status = "okay";
+};
+
+&sdmmc {
+	max-frequency = <150000000>;
+	no-sdio;
+	no-mmc;
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	sd-uhs-sdr104;
+	vqmmc-supply = <&vccio_sd_s0>;
+	status = "okay";
+};
+
+
+&pinctrl {
+
+
+	wireless-bluetooth {
+		uart6_gpios: uart6-gpios {
+			rockchip,pins = <1 RK_PA2 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		bt_gpio: bt-gpio {
+			rockchip,pins =
+				<1 RK_PB2 RK_FUNC_GPIO &pcfg_pull_none>,
+				<1 RK_PB0 RK_FUNC_GPIO &pcfg_pull_up>,
+				<1 RK_PA4 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	wireless-wlan {
+		wifi_host_wake_irq: wifi-host-wake-irq {
+			rockchip,pins = <1 RK_PA7 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+
+		wifi_poweren_gpio: wifi-poweren-gpio {
+			rockchip,pins = <1 RK_PB1 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	buttons {
+		pwrbtn: pwrbtn {
+			rockchip,pins = <1 RK_PD3 RK_FUNC_GPIO &pcfg_pull_up>;
+			//rockchip,pins = <0 RK_PD5 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	hdmi {
+		hdmirx_det: hdmirx-det {
+			rockchip,pins = <1 RK_PD5 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	headphone {
+		hp_det: hp-det {
+			rockchip,pins = <3 RK_PB2 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	hym8563 {
+		hym8563_int: hym8563-int {
+			rockchip,pins = <0 RK_PB2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	usb {
+		vcc5v0_host_en: vcc5v0-host-en {
+			rockchip,pins = <4 RK_PB0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+	};
+
+	usb-typec {
+		usbc0_int: usbc0-int {
+			rockchip,pins = <3 RK_PC7 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		vcc5v0_otg_en: vcc5v0-otg-en {
+			rockchip,pins = <4 RK_PA7 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	pcie {
+		vcc3v3_pcie30_en: vcc3v3-pcie30-en {
+			rockchip,pins = <1 RK_PC4 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+	};
+};
+
+//type-c0
+&u2phy0 {
+	status = "okay";
+};
+
+&u2phy1 {
+	status = "okay";
+};
+
+//usb2.0 host0
+&u2phy2 {
+	status = "okay";
+};
+
+//usb2.0 host1
+&u2phy3 {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	rockchip,typec-vbus-det;
+	status = "okay";
+};
+
+&u2phy1_otg {
+	phy-supply = <&vcc5v0_host>;
+	status = "okay";
+};
+
+&u2phy2_host {
+	phy-supply = <&vcc5v0_host>;
+	status = "okay";
+};
+
+&u2phy3_host {
+	phy-supply = <&vcc5v0_host>;
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&usbdp_phy0 {
+	orientation-switch;
+	svid = <0xff01>;
+	sbu1-dc-gpios = <&gpio0 RK_PC6 GPIO_ACTIVE_HIGH>;
+	sbu2-dc-gpios = <&gpio0 RK_PD3 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		usbdp_phy0_orientation_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_orien_sw>;
+		};
+
+		usbdp_phy0_dp_altmode_mux: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&dp_altmode_mux>;
+		};
+	};
+};
+
+&usbdp_phy0_dp {
+	status = "okay";
+};
+
+&usbdp_phy0_u3 {
+	status = "okay";
+};
+
+&usbdp_phy1 {
+	rockchip,dp-lane-mux = < 0 1 2 3 >;
+	status = "okay";
+};
+
+&usbdp_phy1_dp {
+	status = "okay";
+};
+
+&usbdp_phy1_u3 {
+	maximum-speed = "high-speed";
+	status = "okay";
+};
+
+&usbdrd3_0 {
+	status = "okay";
+};
+
+&usbdrd3_1 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	dr_mode = "otg";
+	usb-role-switch;
+	status = "okay";
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		dwc3_0_role_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_role_sw>;
+		};
+	};
+};
+
+&usbdrd_dwc3_1 {
+	dr_mode = "host";
+	maximum-speed = "high-speed";
+	status = "okay";
+};
+
+&usbhost3_0 {
+	status = "okay";
+};
+
+&usbhost_dwc3_0 {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&vdd_vdenc_s0 {
+	regulator-init-microvolt = <750000>;
+};
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry-edge-v14-linux.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry-edge-v14-linux.dts
@@ -0,0 +1,120 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+/dts-v1/;
+
+#include "rk3588-blueberry-edge-v14.dtsi"
+#include "rk3588-linux.dtsi"
+
+/ {
+	model = "RK3588 EDGE LP4x V1.4 BlueBerry Board";
+	compatible = "rockchip,rk3588-blueberry-edge-v14-linux", "rockchip,rk3588";
+	/delete-node/ chosen;
+};
+
+&pwm3 {
+	compatible = "rockchip,remotectl-pwm";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm3m0_pins>;
+	remote_pwm_id = <3>;
+	handle_cpu_id = <1>;
+	remote_support_psci = <0>;
+	status = "okay";
+
+	ir_key1 {  //hugsun blue remote
+		rockchip,usercode = <0x7f80>;
+		rockchip,key_table =
+			<0xec	KEY_REPLY>,
+			<0xd8	KEY_BACK>,
+			<0xc7	KEY_UP>,
+			<0xbf	KEY_DOWN>,
+			<0xc8	KEY_LEFT>,
+			<0xc6	KEY_RIGHT>,
+			<0x8c	KEY_HOME>,
+			<0x78	KEY_VOLUMEUP>,
+			<0x76	KEY_VOLUMEDOWN>,
+			<0x7e	KEY_POWER>,
+			<0xed	KEY_POWER>,  //20171123
+			<0x7c	KEY_MENU>,
+			<0xb7	388>;
+	};
+
+	ir_key2 {   //hugsun
+		rockchip,usercode = <0xef10>;
+		rockchip,key_table =
+			<0xa2 KEY_POWER>,
+			<0xe8 KEY_VOLUMEUP>,
+			<0xec KEY_VOLUMEDOWN>,
+			<0xa6 141>,//KEY_SETUP>,
+			<0xa5 388>,
+			<0xff KEY_BACK>,
+			<0xba KEY_UP>,
+			<0xf8 KEY_LEFT>,
+			<0xbe KEY_REPLY>,
+			<0xfe KEY_RIGHT>,
+			<0xaa KEY_DOWN>,
+			<0xb9 KEY_HOME>,
+			<0xfa KEY_MENU>,
+			<0xe5 KEY_REWIND>,
+			<0xa7 KEY_PLAYPAUSE>,
+			<0xe2 KEY_FASTFORWARD>,
+			<0xa0 77>,  //@
+			<0xb0 KEY_0>,
+			<0xa1 14>,
+			<0xaf KEY_1>,
+			<0xad KEY_2>,
+			<0xef KEY_3>,
+			<0xb3 KEY_4>,
+			<0xb5 KEY_5>,
+			<0xee KEY_6>,
+			<0xf0 KEY_7>,
+			<0xb1 KEY_8>,
+			<0xf2	KEY_9>;
+	};
+
+	ir_key3 {
+		rockchip,usercode = <0xdf00>;
+		rockchip,key_table =
+			<0xe3 KEY_POWER>,
+			<0xb4 63>,	//youtube
+			<0xfe 67>,	//Media Center
+			<0xa2 KEY_VOLUMEUP>,
+			<0xb0 66>,	//Netflix
+			<0xa0 68>,	//SetupWizard
+			<0xa3 KEY_VOLUMEDOWN>,
+
+			<0xbd KEY_HOME>,
+			<0xf5 KEY_BACK>,
+
+			<0xe5 KEY_UP>,
+			<0xb8 KEY_LEFT>,
+			<0xf9 KEY_REPLY>,
+			<0xf8 KEY_RIGHT>,
+			<0xb7 KEY_DOWN>,
+			<0xfc 388>,
+			<0xe7 KEY_MENU>,
+
+			<0xab KEY_1>,
+			<0xe9 KEY_2>,
+			<0xea KEY_3>,
+			<0xaf KEY_4>,
+			<0xed KEY_5>,
+			<0xee KEY_6>,
+			<0xb3 KEY_7>,
+			<0xf1 KEY_8>,
+			<0xf2 KEY_9>,
+			<0xbe 227>,  //Fn
+			<0xf3 KEY_0>,
+			<0xef 14>;
+
+	};
+
+	ir_key4{
+		rockchip,usercode = <0x4040>;
+		rockchip,key_table =
+		<0x4d KEY_POWER>;     //power (for 2.4g)
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry-edge-v14.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry-edge-v14.dtsi
@@ -0,0 +1,1063 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+#include "dt-bindings/usb/pd.h"
+#include "rk3588.dtsi"
+#include "rk3588-blueberry.dtsi"
+#include "rk3588-rk806-single.dtsi"
+
+/ {
+	/* If hdmirx node is disabled, delete the reserved-memory node here. */
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* Reserve 256MB memory for hdmirx-controller@fdee0000 */
+		cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			reg = <0x0 (256 * 0x100000) 0x0 (256 * 0x100000)>;
+			linux,cma-default;
+		};
+	};
+
+	es8388_sound: es8388-sound {
+		status = "okay";
+		compatible = "rockchip,multicodecs-card";
+		rockchip,card-name = "rockchip-es8388";
+		//hp-det-gpio = <&gpio3 RK_PB2 GPIO_ACTIVE_HIGH>;
+		rockchip,format = "i2s";
+		rockchip,mclk-fs = <256>;
+		rockchip,cpu = <&i2s0_8ch>;
+		rockchip,codec = <&es8388>;
+		rockchip,audio-routing =
+			"Headphone", "LOUT1",
+			"Headphone", "ROUT1",
+			"Speaker", "LOUT2",
+			"Speaker", "ROUT2",
+			"Headphone", "Headphone Power",
+			"Headphone", "Headphone Power",
+			"Speaker", "Speaker Power",
+			"Speaker", "Speaker Power",
+			"LINPUT1", "Main Mic",
+			"LINPUT2", "Main Mic",
+			"RINPUT1", "Headset Mic",
+			"RINPUT2", "Headset Mic";
+		pinctrl-names = "default";
+		pinctrl-0 = <&hp_det>;
+	};
+
+	rk_headset: rk-headset {
+		status = "disabled";
+		compatible = "rockchip_headset";
+		headset_gpio = <&gpio3 RK_PB2 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&hp_det>;
+		io-channels = <&saradc 3>;
+	};
+
+	hdmiin-sound {
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,format = "i2s";
+		rockchip,bitclock-master = <&hdmirx_ctrler>;
+		rockchip,frame-master = <&hdmirx_ctrler>;
+		rockchip,card-name = "rockchip,hdmiin";
+		rockchip,cpu = <&i2s7_8ch>;
+		rockchip,codec = <&hdmirx_ctrler 0>;
+		rockchip,jack-det;
+	};
+
+
+	leds: leds {
+		compatible = "gpio-leds";
+		wifi_led: wifi-led {
+			gpios = <&gpio3 RK_PC5 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+		hdd_led: hdd-led {
+			gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+		eth_led: eth-led {
+			gpios = <&gpio3 RK_PC0 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+		work_led: work-led {
+			gpios = <&gpio3 RK_PB7 GPIO_ACTIVE_HIGH>;
+			//linux,default-trigger = "heartbeat";
+			default-state = "on";
+		};
+	};
+
+	gpio_keys: gpio-keys {
+		compatible = "gpio-keys";
+		autorepeat;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pwrbtn>;
+
+		power {
+			debounce-interval = <100>;
+			gpios = <&gpio1 RK_PD3 GPIO_ACTIVE_LOW>;
+			//gpios = <&gpio0 RK_PD5 GPIO_ACTIVE_LOW>;
+			label = "GPIO Key Power";
+			linux,code = <KEY_POWER>;
+			wakeup-source;
+		};
+	};
+
+	vk2c21_lcd {
+		compatible = "lcd_vk2c21";
+		i2c_scl = <&gpio0 RK_PC5 GPIO_ACTIVE_HIGH>;
+		i2c_sda = <&gpio0 RK_PC4 GPIO_ACTIVE_HIGH>;
+
+		status = "disabled";//"okay";  //zxLog_2022.9.20 for maozhuo time-lcd show;
+	};
+
+	pcie30_avdd0v75: pcie30-avdd0v75 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie30_avdd0v75";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <750000>;
+		regulator-max-microvolt = <750000>;
+		vin-supply = <&vdd_0v75_s0>;
+	};
+
+	pcie30_avdd1v8: pcie30-avdd1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie30_avdd1v8";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&avcc_1v8_s0>;
+	};
+
+	vcc12v_dcin: vcc12v-dcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc12v_dcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc3v3_pcie30: vcc3v3-pcie30 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_pcie30";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc3v3_pcie30_en>;
+		gpios = <&gpio1 RK_PC4 GPIO_ACTIVE_HIGH>;    //hugsun gpio1_c4
+		startup-delay-us = <10000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_host: vcc5v0-host-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_host";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio4 RK_PB0 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_sys>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_host_en>;
+	};
+
+	vcc5v0_otg: vcc5v0-otg-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_otg";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio4 RK_PA7 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_sys>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_otg_en>;
+	};
+
+	vcc_1v1_nldo_s3: vcc-1v1-nldo-s3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_1v1_nldo_s3";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1100000>;
+		regulator-max-microvolt = <1100000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	modem {
+		compatible = "rockchip,modem";
+		status = "okay";
+		power-on_gpio = <&gpio0 RK_PD5 GPIO_ACTIVE_HIGH>;
+		reset_gpio = <&gpio0 RK_PA0 GPIO_ACTIVE_HIGH>; //GPIO_C4
+	};
+
+	ext_cam_clk: external-camera-clock {
+		compatible = "fixed-clock";
+		clock-frequency = <24000000>;
+		clock-output-names = "CLK_CAMERA_24MHZ";
+		#clock-cells = <0>;
+	};
+
+	wireless_bluetooth: wireless-bluetooth {
+		compatible = "bluetooth-platdata";
+		clocks = <&hym8563>;
+		clock-names = "ext_clock";
+		uart_rts_gpios = <&gpio1 RK_PA2 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default", "rts_gpio";
+		pinctrl-0 = <&uart6m1_rtsn>, <&bt_gpio>;
+		pinctrl-1 = <&uart6_gpios>;
+		BT,reset_gpio    = <&gpio1 RK_PB2 GPIO_ACTIVE_HIGH>;
+		BT,wake_gpio     = <&gpio1 RK_PA4 GPIO_ACTIVE_HIGH>;
+		BT,wake_host_irq = <&gpio1 RK_PB0 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	wireless_wlan: wireless-wlan {
+		compatible = "wlan-platdata";
+		wifi_chip_type = "ap6275p";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_host_wake_irq>, <&wifi_poweren_gpio>;
+		WIFI,host_wake_irq = <&gpio1 RK_PA7 GPIO_ACTIVE_HIGH>;
+		WIFI,poweren_gpio = <&gpio1 RK_PB1 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+};
+
+&combphy0_ps {
+	status = "okay";
+};
+
+&combphy1_ps {
+	status = "okay";
+};
+
+&combphy2_psu {
+	status = "okay";
+};
+
+&dp0 {
+	status = "disable";
+};
+
+//&dp0_in_vp2 {
+//	status = "okay";
+//};
+
+&dp1 {
+	pinctrl-0 = <&dp1m0_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&dp1_in_vp2 {
+	status = "okay";
+};
+
+&dp1_sound{
+	status = "okay";
+};
+
+&gmac0 {
+	/* Use rgmii-rxid mode to disable rx delay inside Soc */
+	phy-mode = "rgmii-rxid";
+	clock_in_out = "output";
+
+	snps,reset-gpio = <&gpio4 RK_PB3 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	/* Reset time is 20ms, 100ms for rtl8211f */
+	snps,reset-delays-us = <0 20000 100000>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac0_miim
+		     &gmac0_tx_bus2
+		     &gmac0_rx_bus2
+		     &gmac0_rgmii_clk
+		     &gmac0_rgmii_bus>;
+
+	tx_delay = <0x44>;
+	/* rx_delay = <0x4f>; */
+
+	phy-handle = <&rgmii_phy0>;
+	status = "okay";
+};
+
+&gmac1 {
+	/* Use rgmii-rxid mode to disable rx delay inside Soc */
+	phy-mode = "rgmii-rxid";
+	clock_in_out = "output";
+
+	snps,reset-gpio = <&gpio4 RK_PA2 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	/* Reset time is 20ms, 100ms for rtl8211f */
+	snps,reset-delays-us = <0 20000 100000>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac1_miim
+		     &gmac1_tx_bus2
+		     &gmac1_rx_bus2
+		     &gmac1_rgmii_clk
+		     &gmac1_rgmii_bus>;
+
+	tx_delay = <0x42>;
+	/* rx_delay = <0x4f>; */
+
+	phy-handle = <&rgmii_phy1>;
+	status = "okay";
+};
+
+&hdmi0 {
+	enable-gpios = <&gpio4 RK_PB1 GPIO_ACTIVE_HIGH>;
+	cec-enable = "true" ;
+	status = "okay";
+};
+
+&hdmi0_in_vp0 {
+	status = "okay";
+};
+
+&hdmi0_sound {
+	status = "okay";
+};
+
+&hdptxphy_hdmi0 {
+	status = "okay";
+};
+
+/* lt6911 hdmi in */
+&mipi2_csi2 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi2_csi2_input: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&csidphy0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi2_csi2_output: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&cif_mipi2_in0>;
+			};
+		};
+	};
+};
+
+&csi2_dphy0 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi_in_lt6911: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&lt6911_out>;
+				data-lanes = <1 2 3 4>;
+			};
+		};
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			csidphy0_out: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&mipi2_csi2_input>;
+			};
+		};
+	};
+};
+
+&csi2_dphy0_hw {
+	status = "okay";
+};
+
+&i2c7 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c7m2_xfer>;
+	status = "okay";
+
+	lt6911:lt6911@2b {
+		compatible = "lontium,lt6911uxc";
+		status = "okay";
+		reg = <0x2b>;
+		clocks = <&ext_cam_clk>;
+		clock-names = "xvclk";
+		power-domains = <&power RK3588_PD_VI>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&lt6911uxc_pin>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <RK_PD1 IRQ_TYPE_LEVEL_LOW>;
+		reset-gpios = <&gpio4 RK_PA6 GPIO_ACTIVE_LOW>;
+		plugin-det-gpios = <&gpio1 RK_PD5 GPIO_ACTIVE_HIGH>;
+		rockchip,camera-module-index = <1>;
+		rockchip,camera-module-facing = "back";
+		rockchip,camera-module-name = "lt6911";
+		rockchip,camera-module-lens-name = "default";
+		port {
+			lt6911_out: endpoint {
+				remote-endpoint = <&mipi_in_lt6911>;
+				data-lanes = <1 2 3 4>;
+			};
+		};
+	};
+};
+
+&rkcif {
+	status = "okay";
+};
+
+&rkcif_mipi_lvds2 {
+	status = "okay";
+
+	port {
+		cif_mipi2_in0: endpoint {
+			remote-endpoint = <&mipi2_csi2_output>;
+		};
+	};
+};
+
+&rkcif_mipi_lvds2_sditf {
+	status = "okay";
+
+	port {
+		mipi_lvds2_sditf: endpoint {
+			remote-endpoint = <&isp0_vir0>;
+		};
+	};
+};
+
+&rkcif_mmu {
+	status = "okay";
+};
+
+&rkisp0 {
+	status = "okay";
+};
+
+&isp0_mmu {
+	status = "okay";
+};
+
+&rkisp0_vir0 {
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		isp0_vir0: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&mipi_lvds2_sditf>;
+		};
+	};
+};
+
+/* lt6911 hdmi in end */
+
+/* Should work with at least 128MB cma reserved above. */
+&hdmirx_ctrler {
+	status = "disabled";
+
+	/* Effective level used to trigger HPD: 0-low, 1-high */
+	hpd-trigger-level = <1>;
+	hdmirx-det-gpios = <&gpio1 RK_PD5 GPIO_ACTIVE_LOW>;   //gpio1_d5
+	pinctrl-names = "default";
+	pinctrl-0 = <&hdmim1_rx &hdmirx_det>;
+};
+
+&i2c0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0m2_xfer>;
+
+	vdd_cpu_big0_s0: vdd_cpu_big0_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big0_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vdd_cpu_big1_s0: vdd_cpu_big1_mem_s0: rk8603@43 {
+		compatible = "rockchip,rk8603";
+		reg = <0x43>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big1_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c2 {
+	status = "okay";
+
+	vdd_npu_s0: vdd_npu_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_npu_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <950000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c3 {
+	status = "okay";
+	es8388: es8388@10 {
+		status = "okay";
+		#sound-dai-cells = <0>;
+		compatible = "everest,es8388", "everest,es8323";
+		reg = <0x10>;
+		clocks = <&mclkout_i2s0>;
+		clock-names = "mclk";
+		assigned-clocks = <&mclkout_i2s0>;
+		assigned-clock-rates = <12288000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s0_mclk>;
+	};
+};
+
+&i2c5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c5m3_xfer>;
+	status = "okay";
+};
+
+&i2c6 {
+	status = "okay";
+	usbc0: fusb302@22 {
+		compatible = "fcs,fusb302";
+		reg = <0x22>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <RK_PC7 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&usbc0_int>;
+		vbus-supply = <&vcc5v0_otg>;
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				usbc0_role_sw: endpoint@0 {
+					remote-endpoint = <&dwc3_0_role_switch>;
+				};
+			};
+		};
+
+		usb_con: connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+			data-role = "dual";
+			power-role = "dual";
+			try-power-role = "sink";
+			op-sink-microwatt = <1000000>;
+			sink-pdos =
+				<PDO_FIXED(5000, 1000, PDO_FIXED_USB_COMM)>;
+			source-pdos =
+				<PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
+
+			altmodes {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				altmode@0 {
+					reg = <0>;
+					svid = <0xff01>;
+					vdo = <0xffffffff>;
+				};
+			};
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					usbc0_orien_sw: endpoint {
+						remote-endpoint = <&usbdp_phy0_orientation_switch>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					dp_altmode_mux: endpoint {
+						remote-endpoint = <&usbdp_phy0_dp_altmode_mux>;
+					};
+				};
+			};
+		};
+	};
+
+	hym8563: hym8563@51 {
+		compatible = "haoyu,hym8563";
+		reg = <0x51>;
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		clock-output-names = "hym8563";
+		pinctrl-names = "default";
+		pinctrl-0 = <&hym8563_int>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PB2 IRQ_TYPE_LEVEL_LOW>;
+		wakeup-source;
+	};
+};
+
+&i2s0_8ch {
+	status = "okay";
+	pinctrl-0 = <&i2s0_lrck
+		     &i2s0_sclk
+		     &i2s0_sdi0
+		     &i2s0_sdo0>;
+};
+
+//hdmi01 sound
+&i2s5_8ch {
+	status = "okay";
+};
+
+//hdmi02 sound
+&i2s6_8ch {
+	status = "okay";
+};
+
+//hdmiin sound
+&i2s7_8ch {
+	status = "okay";
+};
+
+&spdif_tx2 {
+	status = "okay";
+};
+
+&spdif_tx5 {
+	status = "okay";
+};
+
+&mdio0 {
+	rgmii_phy0: phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x1>;
+	};
+};
+
+&mdio1 {
+	rgmii_phy1: phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x1>;
+	};
+};
+
+&pcie2x1l0 {
+	reset-gpios = <&gpio1 RK_PB4 GPIO_ACTIVE_HIGH>;
+	rockchip,skip-scan-in-resume;
+	status = "okay";
+};
+
+
+&pcie30phy {
+	rockchip,pcie30-phymode = <PHY_MODE_PCIE_AGGREGATION>;
+	status = "okay";
+};
+
+&pcie3x4 {
+	reset-gpios = <&gpio4 RK_PB6 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_pcie30>;
+	status = "okay";
+};
+
+&rk806single {
+	pinctrl-names = "default", "pmic-power-off";
+	pinctrl-0 = <&pmic_pins>, <&rk806_dvs1_null>, <&rk806_dvs2_null>, <&rk806_dvs3_null>;
+	pinctrl-1 = <&rk806_dvs1_slp>, <&rk806_dvs2_null>, <&rk806_dvs3_null>;
+
+	regulators {
+		avcc_1v8_s0: PLDO_REG1 {
+			regulator-always-on;
+			regulator-boot-on;
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-name = "avcc_1v8_s0";
+			regulator-state-mem {
+				regulator-on-in-suspend;
+				regulator-suspend-microvolt = <1800000>;
+			};
+		};
+	};
+};
+
+&vdd_log_s0 {  //fox.luo@2022.05.26 don't wake up
+        regulator-state-mem {
+        regulator-on-in-suspend;
+        regulator-suspend-microvolt = <750000>;
+        };
+};
+
+&rockchip_suspend {
+	status = "okay";
+	rockchip,sleep-debug-en = <1>;
+	rockchip,virtual-poweroff = <1>;
+	rockchip,sleep-mode-config = <
+		(0
+		| RKPM_SLP_ARMOFF_DDRPD
+		)
+	>;
+	rockchip,wakeup-config = <
+		(0
+		| RKPM_CPU0_WKUP_EN
+		| RKPM_GPIO_WKUP_EN
+		)
+	>;
+};
+
+&route_dp1 {
+	status = "okay";
+	connect = <&vp2_out_dp1>;
+};
+
+&route_hdmi0 {
+	status = "okay";
+	connect = <&vp0_out_hdmi0>;
+};
+
+&sata0 {
+	status = "okay";
+};
+
+//rs485
+&uart0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0m2_xfer>;
+};
+
+//rs232
+&uart3 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart3m2_xfer>;
+};
+
+&uart6 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart6m1_xfer &uart6m1_ctsn>;
+};
+
+&sdhci {
+	bus-width = <8>;
+	no-sdio;
+	no-sd;
+	non-removable;
+	max-frequency = <200000000>;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	full-pwr-cycle-in-suspend;
+	status = "okay";
+};
+
+&sdmmc {
+	max-frequency = <150000000>;
+	no-sdio;
+	no-mmc;
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	sd-uhs-sdr104;
+	vqmmc-supply = <&vccio_sd_s0>;
+	status = "okay";
+};
+
+
+&pinctrl {
+
+
+	wireless-bluetooth {
+		uart6_gpios: uart6-gpios {
+			rockchip,pins = <1 RK_PA2 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		bt_gpio: bt-gpio {
+			rockchip,pins =
+				<1 RK_PB2 RK_FUNC_GPIO &pcfg_pull_none>,
+				<1 RK_PB0 RK_FUNC_GPIO &pcfg_pull_up>,
+				<1 RK_PA4 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	wireless-wlan {
+		wifi_host_wake_irq: wifi-host-wake-irq {
+			rockchip,pins = <1 RK_PA7 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+
+		wifi_poweren_gpio: wifi-poweren-gpio {
+			rockchip,pins = <1 RK_PB1 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	buttons {
+		pwrbtn: pwrbtn {
+			rockchip,pins = <1 RK_PD3 RK_FUNC_GPIO &pcfg_pull_up>;
+			//rockchip,pins = <0 RK_PD5 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	hdmi {
+		hdmirx_det: hdmirx-det {
+			rockchip,pins = <1 RK_PD5 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	headphone {
+		hp_det: hp-det {
+			rockchip,pins = <3 RK_PB2 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	hym8563 {
+		hym8563_int: hym8563-int {
+			rockchip,pins = <0 RK_PB2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	usb {
+		vcc5v0_host_en: vcc5v0-host-en {
+			rockchip,pins = <4 RK_PB0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+	};
+
+	usb-typec {
+		usbc0_int: usbc0-int {
+			rockchip,pins = <3 RK_PC7 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		vcc5v0_otg_en: vcc5v0-otg-en {
+			rockchip,pins = <4 RK_PA7 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	hdmiin {
+		lt6911uxc_pin: lt6911uxc-pin {
+			rockchip,pins = <3 RK_PD1 RK_FUNC_GPIO &pcfg_pull_none>,
+					<4 RK_PA6 RK_FUNC_GPIO &pcfg_pull_none>,
+					<1 RK_PD5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	pcie {
+		vcc3v3_pcie30_en: vcc3v3-pcie30-en {
+			rockchip,pins = <1 RK_PC4 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+	};
+};
+
+//type-c0
+&u2phy0 {
+	status = "okay";
+};
+
+&u2phy1 {
+	status = "okay";
+};
+
+//usb2.0 host0
+&u2phy2 {
+	status = "okay";
+};
+
+//usb2.0 host1
+&u2phy3 {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	rockchip,typec-vbus-det;
+	status = "okay";
+};
+
+&u2phy1_otg {
+	phy-supply = <&vcc5v0_host>;
+	status = "okay";
+};
+
+&u2phy2_host {
+	phy-supply = <&vcc5v0_host>;
+	status = "okay";
+};
+
+&u2phy3_host {
+	phy-supply = <&vcc5v0_host>;
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&usbdp_phy0 {
+	orientation-switch;
+	svid = <0xff01>;
+	sbu1-dc-gpios = <&gpio0 RK_PC6 GPIO_ACTIVE_HIGH>;
+	sbu2-dc-gpios = <&gpio0 RK_PD3 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		usbdp_phy0_orientation_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_orien_sw>;
+		};
+
+		usbdp_phy0_dp_altmode_mux: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&dp_altmode_mux>;
+		};
+	};
+};
+
+&usbdp_phy0_dp {
+	status = "okay";
+};
+
+&usbdp_phy0_u3 {
+	status = "okay";
+};
+
+&usbdp_phy1 {
+	rockchip,dp-lane-mux = < 0 1 2 3 >;
+	status = "okay";
+};
+
+&usbdp_phy1_dp {
+	status = "okay";
+};
+
+&usbdp_phy1_u3 {
+	maximum-speed = "high-speed";
+	status = "okay";
+};
+
+&usbdrd3_0 {
+	status = "okay";
+};
+
+&usbdrd3_1 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	dr_mode = "otg";
+	usb-role-switch;
+	status = "okay";
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		dwc3_0_role_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_role_sw>;
+		};
+	};
+};
+
+&usbdrd_dwc3_1 {
+	dr_mode = "host";
+	maximum-speed = "high-speed";
+	status = "okay";
+};
+
+&usbhost3_0 {
+	status = "okay";
+};
+
+&usbhost_dwc3_0 {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&vdd_vdenc_s0 {
+	regulator-init-microvolt = <750000>;
+};
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry-minipc-linux.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry-minipc-linux.dts
@@ -0,0 +1,120 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+/dts-v1/;
+
+#include "rk3588-blueberry-minipc.dtsi"
+#include "rk3588-linux.dtsi"
+
+/ {
+	model = "Mekotronics R58 MiniPC (RK3588 MINIPC LP4x V1.0 BlueBerry Board)";
+	compatible = "rockchip,rk3588-blueberry-minipc-linux", "rockchip,rk3588";
+	/delete-node/ chosen;
+};
+
+&pwm3 {
+	compatible = "rockchip,remotectl-pwm";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm3m0_pins>;
+	remote_pwm_id = <3>;
+	handle_cpu_id = <1>;
+	remote_support_psci = <0>;
+	status = "okay";
+
+	ir_key1 {  //hugsun blue remote
+		rockchip,usercode = <0x7f80>;
+		rockchip,key_table =
+			<0xec	KEY_REPLY>,
+			<0xd8	KEY_BACK>,
+			<0xc7	KEY_UP>,
+			<0xbf	KEY_DOWN>,
+			<0xc8	KEY_LEFT>,
+			<0xc6	KEY_RIGHT>,
+			<0x8c	KEY_HOME>,
+			<0x78	KEY_VOLUMEUP>,
+			<0x76	KEY_VOLUMEDOWN>,
+			<0x7e	KEY_POWER>,
+			<0xed	KEY_POWER>,  //20171123
+			<0x7c	KEY_MENU>,
+			<0xb7	388>;
+	};
+
+	ir_key2 {   //hugsun
+		rockchip,usercode = <0xef10>;
+		rockchip,key_table =
+			<0xa2 KEY_POWER>,
+			<0xe8 KEY_VOLUMEUP>,
+			<0xec KEY_VOLUMEDOWN>,
+			<0xa6 141>,//KEY_SETUP>,
+			<0xa5 388>,
+			<0xff KEY_BACK>,
+			<0xba KEY_UP>,
+			<0xf8 KEY_LEFT>,
+			<0xbe KEY_REPLY>,
+			<0xfe KEY_RIGHT>,
+			<0xaa KEY_DOWN>,
+			<0xb9 KEY_HOME>,
+			<0xfa KEY_MENU>,
+			<0xe5 KEY_REWIND>,
+			<0xa7 KEY_PLAYPAUSE>,
+			<0xe2 KEY_FASTFORWARD>,
+			<0xa0 77>,  //@
+			<0xb0 KEY_0>,
+			<0xa1 14>,
+			<0xaf KEY_1>,
+			<0xad KEY_2>,
+			<0xef KEY_3>,
+			<0xb3 KEY_4>,
+			<0xb5 KEY_5>,
+			<0xee KEY_6>,
+			<0xf0 KEY_7>,
+			<0xb1 KEY_8>,
+			<0xf2	KEY_9>;
+	};
+
+	ir_key3 {
+		rockchip,usercode = <0xdf00>;
+		rockchip,key_table =
+			<0xe3 KEY_POWER>,
+			<0xb4 63>,	//youtube
+			<0xfe 67>,	//Media Center
+			<0xa2 KEY_VOLUMEUP>,
+			<0xb0 66>,	//Netflix
+			<0xa0 68>,	//SetupWizard
+			<0xa3 KEY_VOLUMEDOWN>,
+
+			<0xbd KEY_HOME>,
+			<0xf5 KEY_BACK>,
+
+			<0xe5 KEY_UP>,
+			<0xb8 KEY_LEFT>,
+			<0xf9 KEY_REPLY>,
+			<0xf8 KEY_RIGHT>,
+			<0xb7 KEY_DOWN>,
+			<0xfc 388>,
+			<0xe7 KEY_MENU>,
+
+			<0xab KEY_1>,
+			<0xe9 KEY_2>,
+			<0xea KEY_3>,
+			<0xaf KEY_4>,
+			<0xed KEY_5>,
+			<0xee KEY_6>,
+			<0xb3 KEY_7>,
+			<0xf1 KEY_8>,
+			<0xf2 KEY_9>,
+			<0xbe 227>,  //Fn
+			<0xf3 KEY_0>,
+			<0xef 14>;
+
+	};
+
+	ir_key4{
+		rockchip,usercode = <0x4040>;
+		rockchip,key_table =
+		<0x4d KEY_POWER>;     //power (for 2.4g)
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry-minipc-mizhuo-linux.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry-minipc-mizhuo-linux.dts
@@ -0,0 +1,125 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+/dts-v1/;
+
+#include "rk3588-blueberry-minipc.dtsi"
+#include "rk3588-linux.dtsi"
+
+/ {
+	model = "RK3588 MINIPC-MIZHUO LP4x V1.0 BlueBerry Board";
+	compatible = "rockchip,rk3588-blueberry-minipc-linux", "rockchip,rk3588";
+	/delete-node/ chosen;
+};
+
+&work_led {
+	linux,default-trigger = "default-on";  //"timer";
+	default-state = "on";
+};
+
+&pwm3 {
+	compatible = "rockchip,remotectl-pwm";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm3m0_pins>;
+	remote_pwm_id = <3>;
+	handle_cpu_id = <1>;
+	remote_support_psci = <0>;
+	status = "okay";
+
+	ir_key1 {  //hugsun blue remote  mizhuo
+		rockchip,usercode = <0x7f80>;
+		rockchip,key_table =
+			<0xec	KEY_F11>,
+			<0xd8	KEY_F2>,
+			<0xc7	KEY_F7>,
+			<0xbf	KEY_F8>,
+			<0xc8	KEY_F9>,
+			<0xc6	KEY_F10>,
+			<0x8c	KEY_F1>,
+			<0x78	KEY_F6>,
+			<0x76	KEY_F4>,
+			<0x7e	KEY_F12>,
+			<0x7c	KEY_F3>,
+			<0xb7	KEY_F5>;
+	};
+
+	ir_key2 {   //hugsun
+		rockchip,usercode = <0xef10>;
+		rockchip,key_table =
+			<0xa2 KEY_POWER>,
+			<0xe8 KEY_VOLUMEUP>,
+			<0xec KEY_VOLUMEDOWN>,
+			<0xa6 141>,//KEY_SETUP>,
+			<0xa5 388>,
+			<0xff KEY_BACK>,
+			<0xba KEY_UP>,
+			<0xf8 KEY_LEFT>,
+			<0xbe KEY_REPLY>,
+			<0xfe KEY_RIGHT>,
+			<0xaa KEY_DOWN>,
+			<0xb9 KEY_HOME>,
+			<0xfa KEY_MENU>,
+			<0xe5 KEY_REWIND>,
+			<0xa7 KEY_PLAYPAUSE>,
+			<0xe2 KEY_FASTFORWARD>,
+			<0xa0 77>,  //@
+			<0xb0 KEY_0>,
+			<0xa1 14>,
+			<0xaf KEY_1>,
+			<0xad KEY_2>,
+			<0xef KEY_3>,
+			<0xb3 KEY_4>,
+			<0xb5 KEY_5>,
+			<0xee KEY_6>,
+			<0xf0 KEY_7>,
+			<0xb1 KEY_8>,
+			<0xf2	KEY_9>;
+	};
+
+	ir_key3 {
+		rockchip,usercode = <0xdf00>;
+		rockchip,key_table =
+			<0xe3 KEY_POWER>,
+			<0xb4 63>,	//youtube
+			<0xfe 67>,	//Media Center
+			<0xa2 KEY_VOLUMEUP>,
+			<0xb0 66>,	//Netflix
+			<0xa0 68>,	//SetupWizard
+			<0xa3 KEY_VOLUMEDOWN>,
+
+			<0xbd KEY_HOME>,
+			<0xf5 KEY_BACK>,
+
+			<0xe5 KEY_UP>,
+			<0xb8 KEY_LEFT>,
+			<0xf9 KEY_REPLY>,
+			<0xf8 KEY_RIGHT>,
+			<0xb7 KEY_DOWN>,
+			<0xfc 388>,
+			<0xe7 KEY_MENU>,
+
+			<0xab KEY_1>,
+			<0xe9 KEY_2>,
+			<0xea KEY_3>,
+			<0xaf KEY_4>,
+			<0xed KEY_5>,
+			<0xee KEY_6>,
+			<0xb3 KEY_7>,
+			<0xf1 KEY_8>,
+			<0xf2 KEY_9>,
+			<0xbe 227>,  //Fn
+			<0xf3 KEY_0>,
+			<0xef 14>;
+
+	};
+
+	ir_key4{
+		rockchip,usercode = <0x4040>;
+		rockchip,key_table =
+		<0x4d KEY_POWER>;     //power (for 2.4g)
+	};
+};
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry-minipc.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry-minipc.dtsi
@@ -0,0 +1,755 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+#include "dt-bindings/usb/pd.h"
+#include "rk3588.dtsi"
+#include "rk3588-blueberry.dtsi"
+#include "rk3588-rk806-single.dtsi"
+
+/ {
+	/* If hdmirx node is disabled, delete the reserved-memory node here. */
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* Reserve 256MB memory for hdmirx-controller@fdee0000 */
+		cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			reg = <0x0 (256 * 0x100000) 0x0 (256 * 0x100000)>;
+			linux,cma-default;
+		};
+	};
+
+	hdmiin-sound {
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,format = "i2s";
+		rockchip,bitclock-master = <&hdmirx_ctrler>;
+		rockchip,frame-master = <&hdmirx_ctrler>;
+		rockchip,card-name = "rockchip,hdmiin";
+		rockchip,cpu = <&i2s7_8ch>;
+		rockchip,codec = <&hdmirx_ctrler 0>;
+		rockchip,jack-det;
+	};
+
+	leds: leds {
+		compatible = "gpio-leds";
+		wifi_led: wifi-led {
+			gpios = <&gpio3 RK_PC5 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+		hdd_led: hdd-led {
+			gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+		eth_led: eth-led {
+			gpios = <&gpio3 RK_PC0 GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+		work_led: work-led {
+			gpios = <&gpio3 RK_PB7 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+		};
+	};
+
+	gpio_keys: gpio-keys {
+		compatible = "gpio-keys";
+		autorepeat;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pwrbtn>;
+
+		power {
+			debounce-interval = <100>;
+			gpios = <&gpio1 RK_PD3 GPIO_ACTIVE_LOW>;
+			label = "GPIO Key Power";
+			linux,code = <KEY_POWER>;
+			wakeup-source;
+		};
+	};
+
+	pcie30_avdd0v75: pcie30-avdd0v75 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie30_avdd0v75";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <750000>;
+		regulator-max-microvolt = <750000>;
+		vin-supply = <&vdd_0v75_s0>;
+	};
+
+	pcie30_avdd1v8: pcie30-avdd1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie30_avdd1v8";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&avcc_1v8_s0>;
+	};
+
+	vcc12v_dcin: vcc12v-dcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc12v_dcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_host: vcc5v0-host-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_host";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio4 RK_PB0 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_sys>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_host_en>;
+	};
+
+	vcc5v0_otg: vcc5v0-otg-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_otg";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio4 RK_PA7 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_sys>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_otg_en>;
+	};
+
+	vcc_1v1_nldo_s3: vcc-1v1-nldo-s3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_1v1_nldo_s3";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1100000>;
+		regulator-max-microvolt = <1100000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	wireless_bluetooth: wireless-bluetooth {
+		compatible = "bluetooth-platdata";
+		clocks = <&hym8563>;
+		clock-names = "ext_clock";
+		uart_rts_gpios = <&gpio1 RK_PA2 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default", "rts_gpio";
+		pinctrl-0 = <&uart6m1_rtsn>, <&bt_gpio>;
+		pinctrl-1 = <&uart6_gpios>;
+		BT,reset_gpio    = <&gpio1 RK_PB2 GPIO_ACTIVE_HIGH>;
+		BT,wake_gpio     = <&gpio1 RK_PA4 GPIO_ACTIVE_HIGH>;
+		BT,wake_host_irq = <&gpio1 RK_PB0 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	wireless_wlan: wireless-wlan {
+		compatible = "wlan-platdata";
+		wifi_chip_type = "ap6275p";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_host_wake_irq>, <&wifi_poweren_gpio>;
+		WIFI,host_wake_irq = <&gpio1 RK_PA7 GPIO_ACTIVE_HIGH>;
+		WIFI,poweren_gpio = <&gpio1 RK_PB1 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+};
+
+&combphy0_ps {
+	status = "okay";
+};
+
+&combphy1_ps {
+	status = "okay";
+};
+
+&combphy2_psu {
+	status = "okay";
+};
+
+&dp0 {
+	status = "disable";
+};
+
+//&dp0_in_vp1 {
+//	status = "okay";
+//};
+
+&dp1 {
+	pinctrl-0 = <&dp1m0_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&dp1_in_vp1 {
+	status = "okay";
+};
+
+&dp1_sound{
+	status = "okay";
+};
+
+&gmac0 {
+	/* Use rgmii-rxid mode to disable rx delay inside Soc */
+	phy-mode = "rgmii-rxid";
+	clock_in_out = "output";
+
+	snps,reset-gpio = <&gpio4 RK_PB3 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	/* Reset time is 20ms, 100ms for rtl8211f */
+	snps,reset-delays-us = <0 20000 100000>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac0_miim
+		     &gmac0_tx_bus2
+		     &gmac0_rx_bus2
+		     &gmac0_rgmii_clk
+		     &gmac0_rgmii_bus>;
+
+	tx_delay = <0x44>;
+	/* rx_delay = <0x4f>; */
+
+	phy-handle = <&rgmii_phy0>;
+	status = "okay";
+};
+
+&hdmi0 {
+	enable-gpios = <&gpio4 RK_PB1 GPIO_ACTIVE_HIGH>;
+	cec-enable = "true" ;
+	hdcp1x-enable;
+	status = "okay";
+};
+
+&hdmi0_in_vp0 {
+	status = "okay";
+};
+
+&hdmi0_sound {
+	status = "okay";
+};
+
+&hdptxphy_hdmi0 {
+	status = "okay";
+};
+
+&hdmi1 {
+	enable-gpios = <&gpio4 RK_PB2 GPIO_ACTIVE_HIGH>;
+	cec-enable = "true" ;
+	hdcp1x-enable;
+	status = "okay";
+};
+
+&hdmi1_in_vp2 {
+	status = "okay";
+};
+
+&hdmi1_sound {
+	status = "okay";
+};
+
+&hdptxphy_hdmi1 {
+	status = "okay";
+};
+
+/* Should work with at least 128MB cma reserved above. */
+&hdmirx_ctrler {
+	status = "okay";
+
+	#sound-dai-cells = <1>;
+	/* Effective level used to trigger HPD: 0-low, 1-high */
+	hpd-trigger-level = <1>;
+	hdmirx-det-gpios = <&gpio1 29 GPIO_ACTIVE_LOW>;   //gpio1_d5
+};
+
+&i2c0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0m2_xfer>;
+
+	vdd_cpu_big0_s0: vdd_cpu_big0_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big0_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vdd_cpu_big1_s0: vdd_cpu_big1_mem_s0: rk8603@43 {
+		compatible = "rockchip,rk8603";
+		reg = <0x43>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big1_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c2 {
+	status = "okay";
+
+	vdd_npu_s0: vdd_npu_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_npu_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <950000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c5m3_xfer>;
+	status = "okay";
+};
+
+&i2c6 {
+	status = "okay";
+	usbc0: fusb302@22 {
+		compatible = "fcs,fusb302";
+		reg = <0x22>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <RK_PC7 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&usbc0_int>;
+		vbus-supply = <&vcc5v0_otg>;
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				usbc0_role_sw: endpoint@0 {
+					remote-endpoint = <&dwc3_0_role_switch>;
+				};
+			};
+		};
+
+		usb_con: connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+			data-role = "dual";
+			power-role = "dual";
+			try-power-role = "sink";
+			op-sink-microwatt = <1000000>;
+			sink-pdos =
+				<PDO_FIXED(5000, 1000, PDO_FIXED_USB_COMM)>;
+			source-pdos =
+				<PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
+
+			altmodes {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				altmode@0 {
+					reg = <0>;
+					svid = <0xff01>;
+					vdo = <0xffffffff>;
+				};
+			};
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					usbc0_orien_sw: endpoint {
+						remote-endpoint = <&usbdp_phy0_orientation_switch>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					dp_altmode_mux: endpoint {
+						remote-endpoint = <&usbdp_phy0_dp_altmode_mux>;
+					};
+				};
+			};
+		};
+	};
+
+	hym8563: hym8563@51 {
+		compatible = "haoyu,hym8563";
+		reg = <0x51>;
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		clock-output-names = "hym8563";
+		pinctrl-names = "default";
+		pinctrl-0 = <&hym8563_int>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PB2 IRQ_TYPE_LEVEL_LOW>;
+		wakeup-source;
+	};
+};
+
+//hdmi01 sound
+&i2s5_8ch {
+	status = "okay";
+};
+
+//hdmi02 sound
+&i2s6_8ch {
+	status = "okay";
+};
+
+//hdmiin sound
+&i2s7_8ch {
+	status = "okay";
+};
+
+&mdio0 {
+	rgmii_phy0: phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x1>;
+	};
+};
+
+&mdio1 {
+	rgmii_phy1: phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x1>;
+	};
+};
+
+&pcie2x1l0 {
+	reset-gpios = <&gpio1 RK_PB4 GPIO_ACTIVE_HIGH>;
+	rockchip,skip-scan-in-resume;
+	status = "okay";
+};
+
+&rk806single {
+	pinctrl-names = "default", "pmic-power-off";
+	pinctrl-0 = <&pmic_pins>, <&rk806_dvs1_null>, <&rk806_dvs2_null>, <&rk806_dvs3_null>;
+	pinctrl-1 = <&rk806_dvs1_slp>, <&rk806_dvs2_null>, <&rk806_dvs3_null>;
+
+	regulators {
+		avcc_1v8_s0: PLDO_REG1 {
+			regulator-always-on;
+			regulator-boot-on;
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-name = "avcc_1v8_s0";
+			regulator-state-mem {
+				regulator-on-in-suspend;
+				regulator-suspend-microvolt = <1800000>;
+			};
+		};
+	};
+};
+
+&wdt {
+	status = "okay";
+};
+
+&vdd_log_s0 {  //fox.luo@2022.05.26 don't wake up
+        regulator-state-mem {
+        regulator-on-in-suspend;
+        regulator-suspend-microvolt = <750000>;
+        };
+};
+
+&rockchip_suspend {
+	status = "okay";
+	rockchip,sleep-debug-en = <1>;
+	rockchip,virtual-poweroff = <1>;
+	rockchip,sleep-mode-config = <
+		(0
+		| RKPM_SLP_ARMOFF_DDRPD
+		)
+	>;
+	rockchip,wakeup-config = <
+		(0
+		| RKPM_CPU0_WKUP_EN
+		| RKPM_GPIO_WKUP_EN
+		)
+	>;
+};
+
+&route_hdmi0 {
+	status = "okay";
+	connect = <&vp0_out_hdmi0>;
+};
+
+&route_hdmi1 {
+	status = "okay";
+	connect = <&vp2_out_hdmi1>;
+};
+
+&sata0 {
+	status = "okay";
+};
+
+//rs485
+&uart0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0m2_xfer>;
+};
+
+//rs232
+&uart3 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart3m2_xfer>;
+};
+
+&uart6 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart6m1_xfer &uart6m1_ctsn>;
+};
+
+&sdhci {
+	bus-width = <8>;
+	no-sdio;
+	no-sd;
+	non-removable;
+	max-frequency = <200000000>;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	status = "okay";
+};
+
+
+&pinctrl {
+
+
+	wireless-bluetooth {
+		uart6_gpios: uart6-gpios {
+			rockchip,pins = <1 RK_PA2 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		bt_gpio: bt-gpio {
+			rockchip,pins =
+				<1 RK_PB2 RK_FUNC_GPIO &pcfg_pull_none>,
+				<1 RK_PB0 RK_FUNC_GPIO &pcfg_pull_up>,
+				<1 RK_PA4 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	wireless-wlan {
+		wifi_host_wake_irq: wifi-host-wake-irq {
+			rockchip,pins = <1 RK_PA7 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+
+		wifi_poweren_gpio: wifi-poweren-gpio {
+			rockchip,pins = <1 RK_PB1 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	buttons {
+		pwrbtn: pwrbtn {
+			rockchip,pins = <1 RK_PD3 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	hym8563 {
+		hym8563_int: hym8563-int {
+			rockchip,pins = <0 RK_PB2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	usb {
+		vcc5v0_host_en: vcc5v0-host-en {
+			rockchip,pins = <4 RK_PB0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+	};
+
+	usb-typec {
+		usbc0_int: usbc0-int {
+			rockchip,pins = <3 RK_PC7 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		vcc5v0_otg_en: vcc5v0-otg-en {
+			rockchip,pins = <4 RK_PA7 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+};
+
+//type-c0
+&u2phy0 {
+	status = "okay";
+};
+
+&u2phy1 {
+	status = "okay";
+};
+
+//usb2.0 host0
+&u2phy2 {
+	status = "okay";
+};
+
+//usb2.0 host1
+&u2phy3 {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	rockchip,typec-vbus-det;
+	status = "okay";
+};
+
+&u2phy1_otg {
+	phy-supply = <&vcc5v0_host>;
+	status = "okay";
+};
+
+&u2phy2_host {
+	phy-supply = <&vcc5v0_host>;
+	status = "okay";
+};
+
+&u2phy3_host {
+	phy-supply = <&vcc5v0_host>;
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&usbdp_phy0 {
+	orientation-switch;
+	svid = <0xff01>;
+	sbu1-dc-gpios = <&gpio0 RK_PC6 GPIO_ACTIVE_HIGH>;
+	sbu2-dc-gpios = <&gpio0 RK_PD3 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		usbdp_phy0_orientation_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_orien_sw>;
+		};
+
+		usbdp_phy0_dp_altmode_mux: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&dp_altmode_mux>;
+		};
+	};
+};
+
+&usbdp_phy0_dp {
+	status = "okay";
+};
+
+&usbdp_phy0_u3 {
+	status = "okay";
+};
+
+&usbdp_phy1 {
+	rockchip,dp-lane-mux = < 0 1 2 3 >;
+	status = "okay";
+};
+
+&usbdp_phy1_dp {
+	status = "okay";
+};
+
+&usbdp_phy1_u3 {
+	maximum-speed = "high-speed";
+	status = "okay";
+};
+
+&usbdrd3_0 {
+	status = "okay";
+};
+
+&usbdrd3_1 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	dr_mode = "otg";
+	usb-role-switch;
+	status = "okay";
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		dwc3_0_role_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_role_sw>;
+		};
+	};
+};
+
+&usbdrd_dwc3_1 {
+	dr_mode = "host";
+	maximum-speed = "high-speed";
+	status = "okay";
+};
+
+&usbhost3_0 {
+	status = "okay";
+};
+
+&usbhost_dwc3_0 {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&vdd_vdenc_s0 {
+	regulator-init-microvolt = <750000>;
+};
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-blueberry.dtsi
@@ -0,0 +1,335 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/input/rk-input.h>
+#include <dt-bindings/display/drm_mipi_dsi.h>
+#include <dt-bindings/display/rockchip_vop.h>
+#include <dt-bindings/sensor-dev.h>
+#include "rk3588-cpu-swap.dtsi"
+
+/ {
+	adc_keys: adc-keys {
+		compatible = "adc-keys";
+		io-channels = <&saradc 1>;
+		io-channel-names = "buttons";
+		keyup-threshold-microvolt = <1800000>;
+		poll-interval = <100>;
+
+		vol-up-key {
+			label = "volume up";
+			linux,code = <KEY_VOLUMEUP>;
+			press-threshold-microvolt = <17000>;
+		};
+
+		vol-down-key {
+			label = "volume down";
+			linux,code = <KEY_VOLUMEDOWN>;
+			press-threshold-microvolt = <417000>;
+		};
+
+	};
+
+	dp0_sound: dp0-sound {
+		status = "disabled";
+		compatible = "rockchip,hdmi";
+		rockchip,card-name= "rockchip,dp0";
+		rockchip,mclk-fs = <512>;
+		rockchip,cpu = <&spdif_tx2>;
+		rockchip,codec = <&dp0 1>;
+		rockchip,jack-det;
+	};
+
+	dp1_sound: dp1-sound {
+		status = "disabled";
+		compatible = "rockchip,hdmi";
+		rockchip,card-name= "rockchip,dp1";
+		rockchip,mclk-fs = <512>;
+		rockchip,cpu = <&spdif_tx5>;
+		rockchip,codec = <&dp1 1>;
+		rockchip,jack-det;
+	};
+
+	hdmi0_sound: hdmi0-sound {
+		status = "disabled";
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,card-name = "rockchip-hdmi0";
+		rockchip,cpu = <&i2s5_8ch>;
+		rockchip,codec = <&hdmi0>;
+		rockchip,jack-det;
+	};
+
+	hdmi1_sound: hdmi1-sound {
+		status = "disabled";
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,card-name = "rockchip-hdmi1";
+		rockchip,cpu = <&i2s6_8ch>;
+		rockchip,codec = <&hdmi1>;
+		rockchip,jack-det;
+	};
+
+	test-power {
+		status = "okay";
+	};
+};
+
+&av1d_mmu {
+	status = "okay";
+};
+
+&CPU_SLEEP {
+	status = "disabled";
+};
+
+&cluster0_opp_table {
+	/delete-node/ opp-408000000;
+	/delete-node/ opp-600000000;
+	/delete-node/ opp-816000000;
+	/delete-node/ opp-1008000000;
+};
+
+&cluster1_opp_table {
+	/delete-node/ opp-408000000;
+	/delete-node/ opp-600000000;
+	/delete-node/ opp-816000000;
+	/delete-node/ opp-1008000000;
+};
+
+&cluster2_opp_table {
+	/delete-node/ opp-408000000;
+	/delete-node/ opp-600000000;
+	/delete-node/ opp-816000000;
+	/delete-node/ opp-1008000000;
+};
+
+&cpu_l0 {
+	cpu-supply = <&vdd_cpu_lit_s0>;
+	mem-supply = <&vdd_cpu_lit_mem_s0>;
+};
+
+&cpu_b0 {
+	cpu-supply = <&vdd_cpu_big0_s0>;
+	mem-supply = <&vdd_cpu_big0_mem_s0>;
+};
+
+&cpu_b2 {
+	cpu-supply = <&vdd_cpu_big1_s0>;
+	mem-supply = <&vdd_cpu_big1_mem_s0>;
+};
+
+&display_subsystem {
+	clocks = <&hdptxphy_hdmi_clk0>, <&hdptxphy_hdmi_clk1>;
+	clock-names = "hdmi0_phy_pll", "hdmi1_phy_pll";
+};
+
+&gpu_opp_table {
+	/delete-node/ opp-198000000;
+	/delete-node/ opp-297000000;
+	/delete-node/ opp-396000000;
+	/delete-node/ opp-500000000;
+	/delete-node/ opp-1000000000;
+
+};
+
+&gpu {
+	mali-supply = <&vdd_gpu_s0>;
+	mem-supply = <&vdd_gpu_mem_s0>;
+	status = "okay";
+};
+
+&hdptxphy_hdmi_clk0 {
+	status = "okay";
+};
+
+&hdptxphy_hdmi_clk1 {
+	status = "okay";
+};
+
+&iep {
+	status = "okay";
+};
+
+&iep_mmu {
+	status = "okay";
+};
+
+&jpegd {
+	status = "okay";
+};
+
+&jpegd_mmu {
+	status = "okay";
+};
+
+&jpege_ccu {
+	status = "okay";
+};
+
+&jpege0 {
+	status = "okay";
+};
+
+&jpege0_mmu {
+	status = "okay";
+};
+
+&jpege1 {
+	status = "okay";
+};
+
+&jpege1_mmu {
+	status = "okay";
+};
+
+&jpege2 {
+	status = "okay";
+};
+
+&jpege2_mmu {
+	status = "okay";
+};
+
+&jpege3 {
+	status = "okay";
+};
+
+&jpege3_mmu {
+	status = "okay";
+};
+
+&mpp_srv {
+	status = "okay";
+};
+
+&rga3_core0 {
+	status = "okay";
+};
+
+&rga3_0_mmu {
+	status = "okay";
+};
+
+&rga3_core1 {
+	status = "okay";
+};
+
+&rga3_1_mmu {
+	status = "okay";
+};
+
+&rga2 {
+	status = "okay";
+};
+
+&rknpu {
+	rknpu-supply = <&vdd_npu_s0>;
+	mem-supply = <&vdd_npu_mem_s0>;
+	status = "okay";
+};
+
+&rknpu_mmu {
+	status = "okay";
+};
+
+&rkvdec_ccu {
+	status = "okay";
+};
+
+&rkvdec0 {
+	status = "okay";
+};
+
+&rkvdec0_mmu {
+	status = "okay";
+};
+
+&rkvdec1 {
+	status = "okay";
+};
+
+&rkvdec1_mmu {
+	status = "okay";
+};
+
+&rkvenc_ccu {
+	status = "okay";
+};
+
+&rkvenc0 {
+	venc-supply = <&vdd_vdenc_s0>;
+	mem-supply = <&vdd_vdenc_mem_s0>;
+	status = "okay";
+};
+
+&rkvenc0_mmu {
+	status = "okay";
+};
+
+&rkvenc1 {
+	venc-supply = <&vdd_vdenc_s0>;
+	mem-supply = <&vdd_vdenc_mem_s0>;
+	status = "okay";
+};
+
+&rkvenc1_mmu {
+	status = "okay";
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&avcc_1v8_s0>;
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&vdpu {
+	status = "okay";
+};
+
+&vdpu_mmu {
+	status = "okay";
+};
+
+&vepu {
+	status = "okay";
+};
+
+&vop {
+	assigned-clocks = <&cru ACLK_VOP>;
+	assigned-clock-rates = <800000000>;
+	status = "okay";
+};
+
+&vop_mmu {
+	status = "okay";
+};
+
+/* vp0 & vp1 splice for 8K output */
+&vp0 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART0>;
+};
+
+&vp1 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART1>;
+};
+
+&vp2 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER2 | 1 << ROCKCHIP_VOP2_ESMART2)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART2>;
+};
+
+&vp3 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART3>;
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-hinlink-h88k.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-hinlink-h88k.dts
@@ -0,0 +1,1096 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/input/rk-input.h>
+#include <dt-bindings/display/drm_mipi_dsi.h>
+#include <dt-bindings/display/rockchip_vop.h>
+#include <dt-bindings/sensor-dev.h>
+#include "dt-bindings/usb/pd.h"
+#include "rk3588.dtsi"
+#include "rk3588-rk806-single.dtsi"
+
+/ {
+	model = "HINLINK H88K";
+	compatible = "hinlink,h88k", "rockchip,rk3588";
+
+	chosen {
+		stdout-path = "serial2:1500000n8";
+	};
+
+	dp0_sound: dp0-sound {
+		compatible = "rockchip,hdmi";
+		rockchip,card-name= "rockchip,dp0";
+		rockchip,mclk-fs = <512>;
+		rockchip,cpu = <&spdif_tx2>;
+		rockchip,codec = <&dp0 1>;
+		rockchip,jack-det;
+	};
+
+	es8388-sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <256>;
+		simple-audio-card,name = "rockchip-es8316";
+		simple-audio-card,dai-link@0 {
+			format = "i2s";
+			cpu {
+				sound-dai = <&i2s0_8ch>;
+			};
+			codec {
+				sound-dai = <&es8388>;
+			};
+		};
+	};
+
+	hdmi0-sound {
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,card-name = "rockchip-hdmi0";
+		rockchip,cpu = <&i2s5_8ch>;
+		rockchip,codec = <&hdmi0>;
+		rockchip,jack-det;
+	};
+
+	hdmi1-sound {
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,card-name = "rockchip-hdmi1";
+		rockchip,cpu = <&i2s6_8ch>;
+		rockchip,codec = <&hdmi1>;
+		rockchip,jack-det;
+	};
+
+	hdmiin-sound {
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,format = "i2s";
+		rockchip,bitclock-master = <&hdmirx_ctrler>;
+		rockchip,frame-master = <&hdmirx_ctrler>;
+		rockchip,card-name = "rockchip,hdmiin";
+		rockchip,cpu = <&i2s7_8ch>;
+		rockchip,codec = <&hdmirx_ctrler 0>;
+		rockchip,jack-det;
+	};
+
+	ir-receiver {
+		compatible = "gpio-ir-receiver";
+		gpios = <&gpio0 RK_PD4 GPIO_ACTIVE_LOW>;
+		pinctrl-0 = <&ir_int_pin>;
+		pinctrl-names = "default";
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&led_net_en>, <&led_sata_en>,
+			    <&led_user_en>, <&led_work_en>;
+
+		net {
+			label = "blue:net";
+			gpios = <&gpio2 RK_PC3 GPIO_ACTIVE_HIGH>;
+		};
+
+		sata {
+			label = "amber:sata";
+			gpios = <&gpio2 RK_PC5 GPIO_ACTIVE_HIGH>;
+		};
+
+		user {
+			label = "green:user";
+			gpios = <&gpio3 RK_PB7 GPIO_ACTIVE_HIGH>;
+		};
+
+		work {
+			label = "red:work";
+			gpios = <&gpio0 RK_PA0 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "default-on";
+		};
+	};
+
+	/* it's modem reset pin */
+	modem_enable: modem-enable {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		regulator-always-on;
+		regulator-boot-on;
+		gpios = <&gpio4 RK_PC6 GPIO_ACTIVE_HIGH>;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-name = "modem-enable";
+		vin-supply = <&vcc_3v3_s3>;
+		startup-delay-us = <500000>;
+		pinctrl-names = "default";
+		pintctrl-0 = <&modem_reset_en>;
+	};
+
+	pcie20_avdd0v85: pcie20-avdd0v85 {
+		compatible = "regulator-fixed";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <850000>;
+		regulator-max-microvolt = <850000>;
+		regulator-name = "pcie20_avdd0v85";
+		vin-supply = <&vdd_0v85_s0>;
+	};
+
+	pcie20_avdd1v8: pcie20-avdd1v8 {
+		compatible = "regulator-fixed";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-name = "pcie20_avdd1v8";
+		vin-supply = <&avcc_1v8_s0>;
+	};
+
+	pcie30_avdd0v75: pcie30-avdd0v75 {
+		compatible = "regulator-fixed";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <750000>;
+		regulator-max-microvolt = <750000>;
+		regulator-name = "pcie30_avdd0v75";
+		vin-supply = <&avdd_0v75_s0>;
+	};
+
+	pcie30_avdd1v8: pcie30-avdd1v8 {
+		compatible = "regulator-fixed";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-name = "pcie30_avdd1v8";
+		vin-supply = <&avcc_1v8_s0>;
+	};
+
+	pwm-fan {
+		compatible = "pwm-fan";
+		#cooling-cells = <2>;
+		pwms = <&pwm14 0 50000 0>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			reg = <0x0 (256 * 0x100000) 0x0 (256 * 0x100000)>;
+			linux,cma-default;
+		};
+	};
+
+	rk_headset: rk-headset {
+		compatible = "rockchip_headset";
+		headset_gpio = <&gpio1 RK_PD5 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&hp_det>;
+		io-channels = <&saradc 3>;
+	};
+
+	vcc12v_dcin: vcc12v-dcin {
+		compatible = "regulator-fixed";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+		regulator-name = "vcc12v_dcin";
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-name = "vcc5v0_sys";
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc_1v1_nldo_s3: vcc-1v1-nldo-s3 {
+		compatible = "regulator-fixed";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1100000>;
+		regulator-max-microvolt = <1100000>;
+		regulator-name = "vcc_1v1_nldo_s3";
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vcc3v3_pcie30: vcc3v3-pcie30 {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpios = <&gpio3 RK_PD5 GPIO_ACTIVE_HIGH>;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-name = "vcc3v3_pcie30";
+		startup-delay-us = <5000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc3v3_m2_sata: vcc3v3-m2-sata {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		regulator-always-on;
+		regulator-boot-on;
+		gpios = <&gpio4 RK_PA4 GPIO_ACTIVE_HIGH>;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-name = "vcc3v3_sata";
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc3v3_modem: vcc3v3-modem {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		regulator-always-on;
+		regulator-boot-on;
+		gpios = <&gpio4 RK_PA3 GPIO_ACTIVE_HIGH>;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-name = "vcc3v3_modem";
+		pinctrl-names = "default";
+		pintctrl-0 = <&modem_power_en>;
+		vin-supply = <&vcc_3v3_s3>;
+	};
+
+	vcc5v0_usb: vcc5v0-usb {
+		compatible = "regulator-fixed";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-name = "vcc5v0_usb";
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_usb_host: vcc5v0-usb-host {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio4 RK_PB0 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_usb_host_en>;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-name = "vcc5v0_usb_host";
+		vin-supply = <&vcc5v0_usb>;
+	};
+
+	vcc5v0_usb_hub: vcc5v0-usb-hub {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio4 RK_PA6 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_usb_hub_en>;
+		regulator-name = "vcc5v0_usb_hub";
+		regulator-always-on;
+		vin-supply = <&vcc5v0_usb>;
+	};
+
+	vcc5v0_usb_otg: vcc5v0-usb-otg {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio4 RK_PA7 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_usb_otg_en>;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-name = "vcc5v0_usb_otg";
+		vin-supply = <&vcc5v0_usb>;
+	};
+
+	wifi_regon: wifi-regon {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio3 RK_PB1 GPIO_ACTIVE_HIGH>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-name = "wifi_regon";
+		startup-delay-us = <5000>;
+	};
+};
+
+&av1d {
+	status = "okay";
+};
+
+&av1d_mmu {
+	status = "okay";
+};
+
+&combphy0_ps {
+	status = "okay";
+};
+
+&combphy1_ps {
+	status = "okay";
+};
+
+&combphy2_psu {
+	status = "okay";
+};
+
+&cpu_l0 {
+	cpu-supply = <&vdd_cpu_lit_s0>;
+	mem-supply = <&vdd_cpu_lit_s0>;
+};
+
+&cpu_b0 {
+	cpu-supply = <&vdd_cpu_big0_s0>;
+	mem-supply = <&vdd_cpu_big0_s0>;
+};
+
+&cpu_b2 {
+	cpu-supply = <&vdd_cpu_big1_s0>;
+	mem-supply = <&vdd_cpu_big1_s0>;
+};
+
+&crypto {
+	status = "okay";
+};
+
+&dfi {
+	status = "okay";
+};
+
+&dmc {
+	center-supply = <&vdd_ddr_s0>;
+	mem-supply = <&vdd_log_s0>;
+	status = "okay";
+};
+
+&dp0 {
+	status = "okay";
+};
+
+&dp0_in_vp2 {
+	status = "okay";
+};
+
+&dp1 {
+	status = "okay";
+};
+
+&dp1_in_vp2 {
+	status = "okay";
+};
+
+&gpu {
+	mali-supply = <&vdd_gpu_s0>;
+	mem-supply = <&vdd_gpu_mem_s0>;
+	status = "okay";
+};
+
+&gmac0 {
+	phy-mode = "rgmii-rxid";
+	clock_in_out = "output";
+
+	snps,reset-gpio = <&gpio4 RK_PB3 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	/* Reset time is 20ms, 100ms for rtl8211f */
+	snps,reset-delays-us = <0 20000 100000>;
+
+	phy-handle = <&rgmii_phy>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac0_miim
+		     &gmac0_tx_bus2
+		     &gmac0_rx_bus2
+		     &gmac0_rgmii_clk
+		     &gmac0_rgmii_bus>;
+
+	tx_delay = <0x44>;
+	status = "okay";
+};
+
+&hdmi0 {
+	enable-gpios = <&gpio4 RK_PB1 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
+
+&hdmi0_in_vp0 {
+	status = "okay";
+};
+
+&hdmi1 {
+	enable-gpios = <&gpio4 RK_PB2 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
+
+&hdmi1_in_vp1 {
+	status = "okay";
+};
+
+&hdmirx_ctrler {
+	status = "okay";
+
+	#sound-dai-cells = <1>;
+	/* Effective level used to trigger HPD: 0-low, 1-high */
+	hpd-trigger-level = <1>;
+	hdmirx-det-gpios = <&gpio2 RK_PB5 GPIO_ACTIVE_LOW>;
+
+	pinctrl-0 = <&hdmim1_rx_cec &hdmim1_rx_hpdin &hdmim1_rx_scl &hdmim1_rx_sda &hdmirx_det>;
+	pinctrl-names = "default";
+};
+
+&hdptxphy_hdmi0 {
+	status = "okay";
+};
+
+&hdptxphy_hdmi1 {
+	status = "okay";
+};
+
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0m2_xfer>;
+	status = "okay";
+
+	vdd_cpu_big0_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-compatible = "rk860x-reg";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-name = "vdd_cpu_big0_s0";
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		vin-supply = <&vcc5v0_sys>;
+
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vdd_cpu_big1_s0: rk8603@43 {
+		compatible = "rockchip,rk8603";
+		reg = <0x43>;
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-compatible = "rk860x-reg";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-name = "vdd_cpu_big1_s0";
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		vin-supply = <&vcc5v0_sys>;
+
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c2 {
+	status = "okay";
+
+	vdd_npu_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-compatible = "rk860x-reg";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <950000>;
+		regulator-name = "vdd_npu_s0";
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		vin-supply = <&vcc5v0_sys>;
+
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	hym8563: hym8563@51 {
+		compatible = "haoyu,hym8563";
+		reg = <0x51>;
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		clock-output-names = "hym8563";
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PB2 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&rtc_int>;
+		wakeup-source;
+	};
+};
+
+&i2c6 {
+	status = "okay";
+
+	husb311@4e {
+		compatible = "hynetek,husb311";
+		reg = <0x4e>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <RK_PA0 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&usbc0_int>;
+		vbus-supply = <&vcc5v0_usb_otg>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				usbc0_role_sw: endpoint@0 {
+					remote-endpoint = <&dwc3_0_role_switch>;
+				};
+			};
+		};
+
+		connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+			data-role = "dual";
+			power-role = "dual";
+			try-power-role = "sink";
+			op-sink-microwatt = <1000000>;
+			sink-pdos =
+				<PDO_FIXED(5000, 1000, PDO_FIXED_USB_COMM)>;
+			source-pdos =
+				<PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
+
+			altmodes {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				altmode@0 {
+					reg = <0>;
+					svid = <0xff01>;
+					vdo = <0xffffffff>;
+				};
+			};
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					usbc0_orien_sw: endpoint {
+						remote-endpoint = <&usbdp_phy0_orientation_switch>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					dp_altmode_mux: endpoint {
+						remote-endpoint = <&usbdp_phy0_dp_altmode_mux>;
+					};
+				};
+			};
+		};
+	};
+};
+
+&i2c7 {
+	status = "okay";
+
+	es8388: es8388@11 {
+		compatible = "everest,es8388", "everest,es8323";
+		reg = <0x11>;
+		assigned-clocks = <&mclkout_i2s0>;
+		assigned-clock-rates = <12288000>;
+		clocks = <&mclkout_i2s0>;
+		clock-names = "mclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s0_mclk>;
+		#sound-dai-cells = <0>;
+	};
+};
+
+&i2s0_8ch {
+	pinctrl-0 = <&i2s0_lrck
+		     &i2s0_sclk
+		     &i2s0_sdi0
+		     &i2s0_sdo0>;
+	status = "okay";
+};
+
+&i2s5_8ch {
+	status = "okay";
+};
+
+&i2s6_8ch {
+	status = "okay";
+};
+
+&i2s7_8ch {
+	status = "okay";
+};
+
+&iep {
+	status = "okay";
+};
+
+&iep_mmu {
+	status = "okay";
+};
+
+&jpegd {
+	status = "okay";
+};
+
+&jpegd_mmu {
+	status = "okay";
+};
+
+&jpege_ccu {
+	status = "okay";
+};
+
+&jpege0 {
+	status = "okay";
+};
+
+&jpege0_mmu {
+	status = "okay";
+};
+
+&jpege1 {
+	status = "okay";
+};
+
+&jpege1_mmu {
+	status = "okay";
+};
+
+&jpege2 {
+	status = "okay";
+};
+
+&jpege2_mmu {
+	status = "okay";
+};
+
+&jpege3 {
+	status = "okay";
+};
+
+&jpege3_mmu {
+	status = "okay";
+};
+
+&mdio0 {
+	rgmii_phy: phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x1>;
+	};
+};
+
+&mpp_srv {
+	status = "okay";
+};
+
+&pcie2x1l0 {
+	reset-gpios = <&gpio0 RK_PB0 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
+
+&pcie2x1l1 {
+	reset-gpios = <&gpio4 RK_PA2 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
+
+&pcie30phy {
+	rockchip,pcie30-phymode = <PHY_MODE_PCIE_AGGREGATION>;
+	status = "okay";
+};
+
+&pcie3x4 {
+	reset-gpios = <&gpio4 RK_PB6 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_pcie30>;
+	status = "okay";
+};
+
+&pinctrl {
+	hdmirx {
+		hdmirx_det: hdmirx-det {
+			rockchip,pins = <2 RK_PB5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	headphone {
+		hp_det: hp-det {
+			rockchip,pins = <1 RK_PD5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	ir {
+		ir_int_pin: ir-int-pin {
+			rockchip,pins = <0 RK_PD4 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	leds {
+		led_net_en: led_net_en {
+			rockchip,pins = <2 RK_PC3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		led_sata_en: led_sata_en {
+			rockchip,pins = <2 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		led_user_en: led_user_en {
+			rockchip,pins = <3 RK_PB7 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		led_work_en: led_work_en {
+			rockchip,pins = <0 RK_PA0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	modem {
+		modem_power_en: modem-power-en {
+			rockchip,pins = <4 RK_PA3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		modem_reset_en: modem-reset-en {
+			rockchip,pins = <4 RK_PC6 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	rtc {
+		rtc_int: rtc-int {
+			rockchip,pins = <0 RK_PB2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	usb {
+		vcc5v0_usb_host_en: vcc5v0_usb_host_en {
+			rockchip,pins = <4 RK_PB0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		vcc5v0_usb_hub_en: vcc5v0_usb_hub_en {
+			rockchip,pins = <4 RK_PA6 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		vcc5v0_usb_otg_en: vcc5v0_usb_otg_en {
+			rockchip,pins = <4 RK_PA7 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	usb-typec {
+		usbc0_int: usbc0-int {
+			rockchip,pins = <1 RK_PA0 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+};
+
+&pwm14 {
+	status = "okay";
+};
+
+&rga2 {
+	status = "okay";
+};
+
+&rga3_core0 {
+	status = "okay";
+};
+
+&rga3_0_mmu {
+	status = "okay";
+};
+
+&rga3_core1 {
+	status = "okay";
+};
+
+&rga3_1_mmu {
+	status = "okay";
+};
+
+&route_hdmi0 {
+	status = "okay";
+};
+
+&route_hdmi1 {
+	status = "okay";
+};
+
+&rknpu {
+	rknpu-supply = <&vdd_npu_s0>;
+	mem-supply = <&vdd_npu_s0>;
+	status = "okay";
+};
+
+&rknpu_mmu {
+	status = "okay";
+};
+
+&rkvdec_ccu {
+	status = "okay";
+};
+
+&rkvdec0 {
+	status = "okay";
+};
+
+&rkvdec0_mmu {
+	status = "okay";
+};
+
+&rkvdec1 {
+	status = "okay";
+};
+
+&rkvdec1_mmu {
+	status = "okay";
+};
+
+&rkvenc_ccu {
+	status = "okay";
+};
+
+&rkvenc0 {
+	status = "okay";
+};
+
+&rkvenc0_mmu {
+	status = "okay";
+};
+
+&rkvenc1 {
+	status = "okay";
+};
+
+&rkvenc1_mmu {
+	status = "okay";
+};
+
+&rng {
+	status = "okay";
+};
+
+&rockchip_suspend {
+	rockchip,sleep-debug-en = <1>;
+	rockchip,sleep-mode-config = <
+	       (0
+	       | RKPM_SLP_ARMOFF_DDRPD
+	       | RKPM_SLP_PMU_PMUALIVE_32K
+	       | RKPM_SLP_PMU_DIS_OSC
+	       | RKPM_SLP_32K_EXT
+	       | RKPM_SLP_PMU_DBG
+	       )
+	>;
+	status = "okay";
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&avcc_1v8_s0>;
+};
+
+&sata0 {
+	status = "okay";
+};
+
+&sdhci {
+	bus-width = <8>;
+	max-frequency = <200000000>;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	no-sd;
+	no-sdio;
+	non-removable;
+	status = "okay";
+};
+
+&sdmmc {
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	no-mmc;
+	no-sdio;
+	max-frequency = <50000000>;
+	vmmc-supply = <&vcc_3v3_s3>;
+	vqmmc-supply = <&vccio_sd_s0>;
+	status = "okay";
+};
+
+&spdif_tx2 {
+	status = "okay";
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&uart2 {
+	pinctrl-0 = <&uart2m0_xfer>;
+	status = "okay";
+};
+
+&u2phy0 {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	vbus-supply = <&vcc5v0_usb_otg>;
+	status = "okay";
+};
+
+&u2phy1 {
+	status = "okay";
+};
+
+&u2phy1_otg {
+	phy-supply = <&vcc5v0_usb_host>;
+	status = "okay";
+};
+
+&u2phy2 {
+	status = "okay";
+};
+
+&u2phy2_host {
+	status = "okay";
+};
+
+&u2phy3 {
+	status = "okay";
+};
+
+&u2phy3_host {
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&usbdp_phy0 {
+	orientation-switch;
+	rockchip,dp-lane-mux = < 0 1 2 3 >;
+	sbu1-dc-gpios = <&gpio0 RK_PC6 GPIO_ACTIVE_HIGH>;
+	sbu2-dc-gpios = <&gpio0 RK_PD3 GPIO_ACTIVE_HIGH>;
+	svid = <0xff01>;
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		usbdp_phy0_orientation_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_orien_sw>;
+		};
+
+		usbdp_phy0_dp_altmode_mux: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&dp_altmode_mux>;
+		};
+	};
+};
+
+&usbdp_phy0_dp {
+	status = "okay";
+};
+
+&usbdp_phy0_u3 {
+	status = "okay";
+};
+
+&usbdp_phy1 {
+	status = "okay";
+};
+
+&usbdp_phy1_dp {
+	status = "okay";
+};
+
+&usbdp_phy1_u3 {
+	status = "okay";
+};
+
+&usbdrd3_0 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	usb-role-switch;
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		dwc3_0_role_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_role_sw>;
+		};
+	};
+};
+
+&usbdrd3_1 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_1 {
+	status = "okay";
+};
+
+&vdpu {
+	status = "okay";
+};
+
+&vdpu_mmu {
+	status = "okay";
+};
+
+&vop {
+	status = "okay";
+};
+
+&vop_mmu {
+	status = "okay";
+};
+
+/* vp0 & vp1 splice for 8K output */
+&vp0 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART0>;
+};
+
+&vp1 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART1>;
+};
+
+&vp2 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER2 | 1 << ROCKCHIP_VOP2_ESMART2)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART2>;
+};
+
+&vp3 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART3>;
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-nanopc-t6.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-nanopc-t6.dts
@@ -0,0 +1,692 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 FriendlyElec Computer Tech. Co., Ltd.
+ * (http://www.friendlyelec.com)
+ */
+
+/dts-v1/;
+
+#include "rk3588.dtsi"
+#include "rk3588s-nanopi-r6-common.dtsi"
+
+/ {
+	model = "FriendlyElec NanoPC-T6";
+	compatible = "friendlyelec,nanopc-t6", "rockchip,rk3588";
+
+	aliases {
+		ethernet0 = &r8125_u10;
+		ethernet1 = &r8125_u12;
+	};
+
+	/* If hdmirx node is disabled, delete the reserved-memory node here. */
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* Reserve 256MB memory for hdmirx-controller@fdee0000 */
+		cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			reg = <0x0 (256 * 0x100000) 0x0 (256 * 0x100000)>;
+			linux,cma-default;
+		};
+	};
+
+	dp0_sound: dp0-sound {
+		status = "okay";
+		compatible = "rockchip,hdmi";
+		rockchip,card-name= "rockchip,dp0";
+		rockchip,mclk-fs = <512>;
+		rockchip,cpu = <&spdif_tx2>;
+		rockchip,codec = <&dp0 1>;
+		rockchip,jack-det;
+	};
+
+	rt5616_sound: rt5616-sound {
+		status = "okay";
+		compatible = "simple-audio-card";
+		pinctrl-names = "default";
+		pinctrl-0 = <&hp_det>;
+
+		simple-audio-card,name = "realtek,rt5616-codec";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <256>;
+
+		simple-audio-card,hp-det-gpio = <&gpio1 RK_PC4 GPIO_ACTIVE_LOW>;
+		simple-audio-card,hp-pin-name = "Headphone Jack";
+
+		simple-audio-card,widgets =
+			"Headphone", "Headphone Jack",
+			"Microphone", "Microphone Jack";
+		simple-audio-card,routing =
+			"Headphone Jack", "HPOL",
+			"Headphone Jack", "HPOR",
+			"MIC1", "Microphone Jack",
+			"Microphone Jack", "micbias1";
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s0_8ch>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&rt5616>;
+		};
+	};
+
+	fan: pwm-fan {
+		status = "okay";
+		compatible = "pwm-fan";
+		#cooling-cells = <2>;
+		pwms = <&pwm1 0 50000 0>;
+		cooling-levels = <0 50 100 150 200 255>;
+		rockchip,temp-trips = <
+			50000	1
+			55000	2
+			60000	3
+			65000	4
+			70000	5
+		>;
+	};
+
+	gpio_leds: gpio-leds {
+		compatible = "gpio-leds";
+
+		sys_led: led-0 {
+			gpios = <&gpio2 RK_PB7 GPIO_ACTIVE_HIGH>;
+			label = "sys_led";
+			linux,default-trigger = "heartbeat";
+			pinctrl-names = "default";
+			pinctrl-0 = <&sys_led_pin>;
+		};
+
+		usr_led: led-1 {
+			gpios = <&gpio2 RK_PC0 GPIO_ACTIVE_HIGH>;
+			label = "usr_led";
+			pinctrl-names = "default";
+			pinctrl-0 = <&usr_led_pin>;
+		};
+	};
+
+	hdmi1_sound: hdmi1-sound {
+		status = "disabled";
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <128>;
+		simple-audio-card,name = "rockchip,hdmi1";
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s6_8ch>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&hdmi1>;
+		};
+	};
+
+	hdmiin_sound: hdmiin-sound {
+		status = "disabled";
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,format = "i2s";
+		rockchip,bitclock-master = <&hdmirx_ctrler>;
+		rockchip,frame-master = <&hdmirx_ctrler>;
+		rockchip,card-name = "rockchip,hdmiin";
+		rockchip,cpu = <&i2s7_8ch>;
+		rockchip,codec = <&hdmirx_ctrler 0>;
+		rockchip,jack-det;
+	};
+
+	vcc5v0_host_30: vcc5v0-host-30 {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio4 RK_PB0 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_host30_en>;
+		regulator-name = "vcc5v0_host_30";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc5v0_usb>;
+	};
+
+	vcc3v3_pcie30: vcc3v3-pcie30 {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpios = <&gpio2 RK_PC5 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pcie_m2_0_pwren>;
+		regulator-name = "vcc3v3_pcie30";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vdd_mpcie_3v3: vdd-mpcie-3v3 {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio4 RK_PC2 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pcie_m2_1_pwren>;
+		regulator-name = "vdd_mpcie_3v3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vdd_4glte_3v3: vdd-4glte-3v3 {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio4 RK_PC6 GPIO_ACTIVE_HIGH>;
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-name = "vdd_4glte_3v3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		startup-delay-us = <10000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+};
+
+&combphy1_ps {
+	status = "okay";
+};
+
+&dp0 {
+	status = "okay";
+};
+
+&dp0_in_vp0 {
+	status = "disabled";
+};
+
+&dp0_in_vp1 {
+	status = "disabled";
+};
+
+&dp0_in_vp2 {
+	status = "okay";
+};
+
+&dp0_sound {
+	status = "okay";
+};
+
+&gmac1 {
+	status = "disabled";
+};
+
+&hdmi0 {
+	enable-gpios = <&gpio4 RK_PB1 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+	cec-enable = "true";
+};
+
+&hdmi0_in_vp0 {
+	status = "okay";
+};
+
+&hdmi0_in_vp1 {
+	status = "disabled";
+};
+
+&hdmi0_in_vp2 {
+	status = "disabled";
+};
+
+&hdmi0_sound {
+	status = "okay";
+};
+
+&hdmi1 {
+	enable-gpios = <&gpio4 RK_PB2 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+	cec-enable = "true";
+};
+
+&hdmi1_in_vp0 {
+	status = "disabled";
+};
+
+&hdmi1_in_vp1 {
+	status = "okay";
+};
+
+&hdmi1_in_vp2 {
+	status = "disabled";
+};
+
+&hdmi1_sound {
+	status = "okay";
+};
+
+&hdmiin_sound {
+	status = "okay";
+};
+
+/* Should work with at least 128MB cma reserved above. */
+&hdmirx_ctrler {
+	status = "okay";
+
+	#sound-dai-cells = <1>;
+	/* Effective level used to trigger HPD: 0-low, 1-high */
+	hpd-trigger-level = <1>;
+	hdmirx-det-gpios = <&gpio1 RK_PD5 GPIO_ACTIVE_LOW>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&hdmim1_rx &hdmirx_det>;
+};
+
+&hdptxphy_hdmi0 {
+	status = "okay";
+};
+
+&hdptxphy_hdmi1 {
+	status = "okay";
+};
+
+&i2c3 {
+	pinctrl-0 = <&i2c3m0_xfer>;
+	/* connected with MIPI-CSI0 */
+};
+
+&i2c4 {
+	pinctrl-0 = <&i2c4m3_xfer>;
+	/* connected with MIPI-DSI1 */
+};
+
+&i2c5 {
+	pinctrl-0 = <&i2c5m0_xfer>;
+	/* connected with MIPI-DSI0 */
+};
+
+&i2c6 {
+	clock-frequency = <200000>;
+	status = "okay";
+
+	eeprom@53 {
+		compatible = "microchip,24c02", "atmel,24c02";
+		reg = <0x53>;
+		#address-cells = <2>;
+		#size-cells = <0>;
+		pagesize = <16>;
+		size = <256>;
+
+		eui_48: eui-48@fa {
+			reg = <0xfa 0x06>;
+		};
+	};
+
+	usbc0: fusb302@22 {
+		compatible = "fcs,fusb302";
+		reg = <0x22>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PD3 IRQ_TYPE_LEVEL_LOW>;
+		int-n-gpios = <&gpio0 RK_PD3 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&usbc0_int>;
+		vbus-supply = <&vbus5v0_typec>;
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				usbc0_role_sw: endpoint@0 {
+					remote-endpoint = <&dwc3_0_role_switch>;
+				};
+			};
+		};
+
+		usb_con: connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+			data-role = "dual";
+			power-role = "dual";
+			try-power-role = "sink";
+			op-sink-microwatt = <1000000>;
+			sink-pdos =
+				<PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
+			source-pdos =
+				<PDO_FIXED(5000, 2000, PDO_FIXED_USB_COMM)>;
+
+			altmodes {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				altmode@0 {
+					reg = <0>;
+					svid = <0xff01>;
+					vdo = <0xffffffff>;
+				};
+			};
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					usbc0_orien_sw: endpoint {
+						remote-endpoint = <&usbdp_phy0_orientation_switch>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					dp_altmode_mux: endpoint {
+						remote-endpoint = <&usbdp_phy0_dp_altmode_mux>;
+					};
+				};
+			};
+		};
+	};
+};
+
+&i2c7 {
+	clock-frequency = <200000>;
+	status = "okay";
+
+	rt5616: rt5616@1b {
+		status = "okay";
+		#sound-dai-cells = <0>;
+		compatible = "rt5616";
+		reg = <0x1b>;
+		clocks = <&mclkout_i2s0>;
+		clock-names = "mclk";
+		assigned-clocks = <&mclkout_i2s0>;
+		assigned-clock-rates = <12288000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s0_mclk>;
+	};
+
+	/* connected with MIPI-CSI1 */
+};
+
+&i2c8 {
+	pinctrl-0 = <&i2c8m2_xfer>;
+	/* connected with Header_2.54MM */
+};
+
+&i2s0_8ch {
+	status = "okay";
+	pinctrl-0 = <&i2s0_lrck
+		     &i2s0_sclk
+		     &i2s0_sdi0
+		     &i2s0_sdo0>;
+};
+
+&i2s6_8ch {
+	status = "okay";
+};
+
+&i2s7_8ch {
+	status = "okay";
+};
+
+&mdio1 {
+	status = "disabled";
+};
+
+&pcie2x1l0 {
+	reset-gpios = <&gpio4 RK_PB3 GPIO_ACTIVE_HIGH>;
+	rockchip,init-delay-ms = <100>;
+	vpcie3v3-supply = <&vcc_3v3_pcie20>;
+	status = "okay";
+
+	pcie@20 {
+		reg = <0x00200000 0 0 0 0>;
+		#address-cells = <3>;
+		#size-cells = <2>;
+
+		r8125_u12: pcie@20,0 {
+			reg = <0x000000 0 0 0 0>;
+			local-mac-address = [ 00 00 00 00 00 00 ];
+		};
+	};
+};
+
+&pcie2x1l1 {
+	reset-gpios = <&gpio4 RK_PA2 GPIO_ACTIVE_HIGH>;
+	rockchip,init-delay-ms = <500>;
+	vpcie3v3-supply = <&vdd_mpcie_3v3>;
+	status = "okay";
+};
+
+&pcie2x1l2 {
+	reset-gpios = <&gpio4 RK_PA4 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc_3v3_pcie20>;
+	status = "okay";
+
+	pcie@40 {
+		reg = <0x00400000 0 0 0 0>;
+		#address-cells = <3>;
+		#size-cells = <2>;
+
+		r8125_u10: pcie@40,0 {
+			reg = <0x000000 0 0 0 0>;
+			local-mac-address = [ 00 00 00 00 00 00 ];
+		};
+	};
+};
+
+&pcie30phy {
+	status = "okay";
+};
+
+&pcie3x4 {
+	reset-gpios = <&gpio4 RK_PB6 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_pcie30>;
+	status = "okay";
+};
+
+&pinctrl {
+	gpio-leds {
+		sys_led_pin: sys-led-pin {
+			rockchip,pins = <2 RK_PB7 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		usr_led_pin: usr-led-pin {
+			rockchip,pins = <2 RK_PC0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	headphone {
+		hp_det: hp-det {
+			rockchip,pins = <1 RK_PC4 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	hdmi {
+		hdmirx_det: hdmirx-det {
+			rockchip,pins = <1 RK_PD5 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	lcd {
+		/omit-if-no-ref/
+		lcd_rst0_gpio: lcd-rst0-gpio {
+			rockchip,pins = <3 RK_PA6 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		lcd_rst1_gpio: lcd-rst1-gpio {
+			rockchip,pins = <4 RK_PA3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		touch_dsi0_gpio: touch-dsi0-gpio {
+			rockchip,pins =
+				<3 RK_PC0 RK_FUNC_GPIO &pcfg_pull_up>,
+				<3 RK_PC1 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		touch_dsi1_gpio: touch-dsi1-gpio {
+			rockchip,pins =
+				<4 RK_PA0 RK_FUNC_GPIO &pcfg_pull_up>,
+				<4 RK_PA1 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	pcie {
+		pcie_m2_0_pwren: pcie-m20-pwren {
+			rockchip,pins = <2 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		pcie_m2_1_pwren: pcie-m21-pwren {
+			rockchip,pins = <4 RK_PC2 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	sdmmc {
+		sd_s0_pwr: sd-s0-pwr {
+			rockchip,pins = <4 RK_PA5 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	usb {
+		vcc5v0_host30_en: vcc5v0-host30-en {
+			rockchip,pins = <4 RK_PB0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+};
+
+&pwm1 {
+	pinctrl-0 = <&pwm1m1_pins>;
+	status = "okay";
+};
+
+&pwm2 {
+	pinctrl-0 = <&pwm2m1_pins>;
+	/* connected with MIPI-DSI0 */
+};
+
+&pwm11 {
+	pinctrl-0 = <&pwm11m3_pins>;
+	/* connected with MIPI-DSI1 */
+};
+
+&spdif_tx2 {
+	status = "okay";
+};
+
+&u2phy0 {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	rockchip,typec-vbus-det;
+	status = "okay";
+};
+
+&u2phy1 {
+	status = "okay";
+};
+
+&u2phy1_otg {
+	phy-supply = <&vcc5v0_host_30>;
+	status = "okay";
+};
+
+&u2phy2 {
+	status = "okay";
+};
+
+&u2phy2_host {
+	status = "okay";
+};
+
+&u2phy3 {
+	status = "okay";
+};
+
+&u2phy3_host {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&usbdp_phy0 {
+	orientation-switch;
+	rockchip,dp-lane-mux = <0 1 2 3 >;
+	svid = <0xff01>;
+	sbu1-dc-gpios = <&gpio4 RK_PA6 GPIO_ACTIVE_HIGH>;
+	sbu2-dc-gpios = <&gpio4 RK_PA7 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		usbdp_phy0_orientation_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_orien_sw>;
+		};
+
+		usbdp_phy0_dp_altmode_mux: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&dp_altmode_mux>;
+		};
+	};
+};
+
+&usbdp_phy0_dp {
+	status = "okay";
+};
+
+&usbdp_phy0_u3 {
+	status = "okay";
+};
+
+&usbdrd3_0 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	dr_mode = "otg";
+	usb-role-switch;
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		dwc3_0_role_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_role_sw>;
+		};
+	};
+};
+
+&usbdp_phy1 {
+	status = "okay";
+};
+
+&usbdp_phy1_u3 {
+	status = "okay";
+};
+
+&usbdrd3_1 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_1 {
+	dr_mode = "host";
+	snps,xhci-trb-ent-quirk;
+	status = "okay";
+};
+
+&vcc_3v3_sd_s0 {
+	/delete-property/ enable-active-high;
+	gpio = <&gpio4 RK_PA5 GPIO_ACTIVE_LOW>;
+};
+
+
+&display_subsystem {
+	clocks = <&hdptxphy_hdmi_clk0>, <&hdptxphy_hdmi_clk1>;
+	clock-names = "hdmi0_phy_pll", "hdmi1_phy_pll";
+};
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-orangepi-5-plus-camera1.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-orangepi-5-plus-camera1.dtsi
@@ -0,0 +1,170 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+&csi2_dphy0_hw {
+	status = "disabled";
+};
+
+&csi2_dphy0 {
+	status = "disabled";
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi_in_ucam0: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&ov13850_out2>;
+				data-lanes = <1 2>;
+			};
+
+			mipi_in_ucam1: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&ov13855_out2>;
+				data-lanes = <1 2>;
+			};
+		};
+		port@1 {
+		        reg = <1>;
+		        #address-cells = <1>;
+		        #size-cells = <0>;
+		        csidphy0_out: endpoint@0 {
+		                reg = <0>;
+		                remote-endpoint = <&mipi2_csi2_input>;
+		        };
+		};
+	};
+};
+
+&i2c3 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c3m0_xfer>;
+
+	vm149c_p1: vm149c-p1@c {
+		compatible = "silicon touch,vm149c";
+		status = "disabled";
+		reg = <0x0c>;
+		rockchip,camera-module-index = <1>;
+		rockchip,camera-module-facing = "back";
+	};
+
+	ov13850_1: ov13850-1@10 {
+		compatible = "ovti,ov13850";
+		status = "disabled";
+		reg = <0x10>;
+		clocks = <&cru CLK_MIPI_CAMARAOUT_M3>;
+		clock-names = "xvclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&mipim1_camera3_clk>;
+		reset-gpios = <&gpio1 RK_PC4 GPIO_ACTIVE_HIGH>;
+		pwdn-gpios = <&gpio1 RK_PD5 GPIO_ACTIVE_HIGH>;
+		rockchip,camera-module-index = <0>;
+		rockchip,camera-module-facing = "back";
+		rockchip,camera-module-name = "CMK-CT0116";
+		rockchip,camera-module-lens-name = "default";
+		lens-focus = <&vm149c_p1>;
+		port {
+			ov13850_out2: endpoint {
+				remote-endpoint = <&mipi_in_ucam0>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+
+	dw9714_p1: dw9714-p1@c {
+		compatible = "dongwoon,dw9714";
+		status = "disabled";
+		reg = <0x0c>;
+		rockchip,camera-module-index = <0>;
+		rockchip,vcm-start-current = <10>;
+		rockchip,vcm-rated-current = <85>;
+		rockchip,vcm-step-mode = <5>;
+		rockchip,camera-module-facing = "back";
+	};
+
+	ov13855_1: ov13855-1@36 {
+		compatible = "ovti,ov13855";
+		status = "disabled";
+		reg = <0x36>;
+		clocks = <&cru CLK_MIPI_CAMARAOUT_M3>;
+		clock-names = "xvclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&mipim1_camera3_clk>;
+		reset-gpios = <&gpio1 RK_PC4 GPIO_ACTIVE_HIGH>;
+		pwdn-gpios = <&gpio1 RK_PD5 GPIO_ACTIVE_HIGH>;
+		rockchip,camera-module-index = <0>;
+		rockchip,camera-module-facing = "back";
+		rockchip,camera-module-name = "CMK-OT2016-FV1";
+		rockchip,camera-module-lens-name = "default";
+		lens-focus = <&dw9714_p1>;
+		port {
+			ov13855_out2: endpoint {
+				remote-endpoint = <&mipi_in_ucam1>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+};
+
+&mipi2_csi2 {
+	status = "disabled";
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			mipi2_csi2_input: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&csidphy0_out>;
+			};
+		};
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			mipi2_csi2_output: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&cif_mipi_in2>;
+			};
+		};
+	};
+};
+
+&rkcif_mipi_lvds2 {
+	status = "disabled";
+	port {
+		cif_mipi_in2: endpoint {
+			remote-endpoint = <&mipi2_csi2_output>;
+		};
+	};
+};
+
+&rkcif_mipi_lvds2_sditf {
+	status = "disabled";
+	port {
+		mipi2_lvds_sditf: endpoint {
+			remote-endpoint = <&isp0_vir1>;
+		};
+	};
+};
+
+&rkisp0_vir1 {
+	status = "disabled";
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		isp0_vir1: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&mipi2_lvds_sditf>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-orangepi-5-plus-lcd.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-orangepi-5-plus-lcd.dtsi
@@ -0,0 +1,45 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+
+&dsi1 {
+	status = "disabled";
+};
+
+&dsi1_panel {
+	status = "disabled";
+	reset-gpios = <&gpio2 RK_PC1 GPIO_ACTIVE_LOW>;
+	enable-gpios = <&gpio1 RK_PD2 GPIO_ACTIVE_HIGH>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&lcd_rst_gpio>;
+};
+
+&dsi1_in_vp2 {
+	status = "disabled";
+};
+
+&dsi1_in_vp3 {
+	status = "disabled";
+};
+
+&route_dsi1 {
+	status = "disabled";
+	connect = <&vp3_out_dsi1>;
+};
+
+&i2c7 {
+	status = "okay";
+
+	gt9xx_0: touchscreen@14 {
+		compatible = "goodix,gt9271";
+		reg = <0x14>;
+		interrupt-parent = <&gpio2>;
+		interrupts = <RK_PB2 IRQ_TYPE_LEVEL_LOW>;
+		irq-gpios = <&gpio2 RK_PB2 IRQ_TYPE_LEVEL_LOW>;
+		reset-gpios = <&gpio2 RK_PB5 GPIO_ACTIVE_HIGH>;
+		touchscreen-inverted-x;
+		//touchscreen-inverted-y;
+		touchscreen-swapped-x-y;
+		touchscreen-size-x = <1280>;
+		touchscreen-size-y = <800>;
+		status = "okay";
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-orangepi-5-plus.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-orangepi-5-plus.dts
@@ -0,0 +1,327 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+/dts-v1/;
+
+#include "rk3588-orangepi-5-plus.dtsi"
+#include "rk3588-linux.dtsi"
+#include "rk3588-orangepi-5-plus-lcd.dtsi"
+#include "rk3588-orangepi-5-plus-camera1.dtsi"
+
+/ {
+	model = "Orange Pi 5 Plus";
+	compatible = "rockchip,rk3588-orangepi-5-plus", "rockchip,rk3588";
+
+	/delete-node/ chosen;
+
+	leds: gpio-leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 =<&leds_rgb>;
+		status = "okay";
+
+		blue_led@1 {
+			gpios = <&gpio3 RK_PA6 GPIO_ACTIVE_HIGH>;
+			label = "blue_led";
+			linux,default-trigger = "heartbeat";
+			linux,default-trigger-delay-ms = <0>;
+		};
+
+		green_led@2 {
+			gpios = <&gpio3 RK_PB1 GPIO_ACTIVE_HIGH>;
+			label = "green_led";
+			linux,default-trigger = "heartbeat";
+			linux,default-trigger-delay-ms = <0>;
+		};
+	};
+
+	fan: pwm-fan {
+		compatible = "pwm-fan";
+		#cooling-cells = <2>;
+		pwms = <&pwm3 0 50000 0>;
+		cooling-levels = <0 50 100 150 200 255>;
+		rockchip,temp-trips = <
+			50000   1
+			55000   2
+			60000   3
+			65000   4
+			70000   5
+		>;
+
+		status = "okay";
+	};
+};
+
+&sdhci {
+	status = "okay";
+};
+
+&mipi_dcphy0 {
+	status = "okay";
+};
+
+&mipi_dcphy1 {
+	status = "okay";
+};
+
+&rkcif {
+        status = "okay";
+};
+
+&rkcif_mmu {
+        status = "okay";
+};
+
+&rkisp0 {
+        status = "okay";
+};
+
+&isp0_mmu {
+        status = "okay";
+};
+
+&usbdrd3_1 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_1 {
+	dr_mode = "host";
+	status = "okay";
+};
+
+/* Fan */
+&pwm3 {
+	status = "okay";
+	pinctrl-names = "active";
+	pinctrl-0 = <&pwm3m1_pins>;
+};
+
+/* watchdog */
+&wdt {
+	status = "okay";
+};
+
+&sfc {
+	status = "okay";
+	max-freq = <100000000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&fspim1_pins>;
+
+	spi_flash: spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "jedec,spi-nor";
+		reg = <0x0>;
+		spi-max-frequency = <100000000>;
+		spi-tx-bus-width = <1>;
+		spi-rx-bus-width = <4>;
+		status = "okay";
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			loader@0 {
+				label = "loader";
+				reg = <0x0 0x1000000>;
+			};
+		};
+	};
+};
+
+&pwm15 {
+	compatible = "rockchip,remotectl-pwm";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm15m1_pins>;
+	remote_pwm_id = <3>;
+	handle_cpu_id = <1>;
+	remote_support_psci = <0>;
+	status = "okay";
+
+	ir_key1 {
+		rockchip,usercode = <0xfb04>;
+		rockchip,key_table =
+			<0xa3   KEY_ENTER>,
+			<0xe4   388>,
+			<0xf5   KEY_BACK>,
+			<0xbb   KEY_UP>,
+			<0xe2   KEY_DOWN>,
+			<0xe3   KEY_LEFT>,
+			<0xb7   KEY_RIGHT>,
+			<0xe0   KEY_HOME>,
+			<0xba   KEY_VOLUMEUP>,
+			<0xda   KEY_VOLUMEUP>,
+			<0xe6   KEY_VOLUMEDOWN>,
+			<0xdb   KEY_VOLUMEDOWN>,
+			<0xbc   KEY_SEARCH>,
+			<0xb2   KEY_POWER>,
+			<0xe5   KEY_POWER>,
+			<0xde   KEY_POWER>,
+			<0xdc   KEY_MUTE>,
+			<0xa2   KEY_MENU>,
+			<0xec   KEY_1>,
+			<0xef   KEY_2>,
+			<0xee   KEY_3>,
+			<0xf0   KEY_4>,
+			<0xf3   KEY_5>,
+			<0xf2   KEY_6>,
+			<0xf4   KEY_7>,
+			<0xf7   KEY_8>,
+			<0xf6   KEY_9>,
+			<0xb8   KEY_0>;
+	};
+};
+
+&pinctrl {
+	leds_gpio {
+		leds_rgb: leds-rgb {
+		        rockchip,pins = <3 RK_PA6 RK_FUNC_GPIO &pcfg_pull_up>,
+					<3 RK_PB1 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+};
+
+/*** 40 pins ***/
+&i2c2 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c2m0_xfer>;
+};
+
+&can0 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&can0m0_pins>;
+	assigned-clocks = <&cru CLK_CAN0>;
+	assigned-clock-rates = <200000000>;
+};
+
+&can1 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&can1m0_pins>;
+	assigned-clocks = <&cru CLK_CAN1>;
+	assigned-clock-rates = <200000000>;
+};
+
+&pwm0 {
+	status = "disabled";
+};
+
+&pwm1 {
+	status = "disabled";
+};
+
+&pwm14 {
+	status = "disabled";
+};
+
+&spi0 {
+	status = "disabled";
+	assigned-clocks = <&cru CLK_SPI0>;
+	assigned-clock-rates = <200000000>;
+	num-cs = <2>;
+};
+
+&uart3 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart3m1_xfer>;
+};
+
+&uart4 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart4m2_xfer>;
+};
+
+&i2c2 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c2m4_xfer>;
+};
+
+&i2c4 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c4m3_xfer>;
+};
+
+&i2c5 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c5m3_xfer>;
+};
+
+&i2c8 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c8m2_xfer>;
+};
+
+&uart1 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1m1_xfer>;
+};
+
+&uart6 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart6m1_xfer>;
+};
+
+&uart7 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart7m2_xfer>;
+};
+
+&uart8 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart8m1_xfer>;
+};
+
+&pwm10 {
+	status = "disabled";
+	pinctrl-names = "active";
+	pinctrl-0 = <&pwm10m0_pins>;
+};
+
+&pwm11 {
+	status = "disabled";
+	pinctrl-names = "active";
+	pinctrl-0 = <&pwm11m0_pins>;
+};
+
+&pwm12 {
+	status = "disabled";
+	pinctrl-names = "active";
+	pinctrl-0 = <&pwm12m0_pins>;
+};
+
+&pwm13 {
+	status = "disabled";
+	pinctrl-names = "active";
+	pinctrl-0 = <&pwm13m2_pins>;
+	//pinctrl-0 = <&pwm13m0_pins>;
+};
+
+&spi4 {
+	status = "disabled";
+	assigned-clocks = <&cru CLK_SPI4>;
+	assigned-clock-rates = <200000000>;
+	num-cs = <2>;
+};
+/*** 40 pins ***/
+
+&hdmirx_ctrler {
+	status = "okay";
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-orangepi-5-plus.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-orangepi-5-plus.dtsi
@@ -0,0 +1,763 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+#include "dt-bindings/usb/pd.h"
+#include "rk3588.dtsi"
+#include "rk3588-orangepi.dtsi"
+#include "rk3588-rk806-single.dtsi"
+
+/ {
+	/* If hdmirx node is disabled, delete the reserved-memory node here. */
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* Reserve 256MB memory for hdmirx-controller@fdee0000 */
+		cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			reg = <0x0 (256 * 0x100000) 0x0 (256 * 0x100000)>;
+			linux,cma-default;
+		};
+	};
+
+	es8388_sound: es8388-sound {
+		status = "okay";
+		compatible = "rockchip,multicodecs-card";
+		rockchip,card-name = "rockchip,es8388";
+		hp-det-gpio = <&gpio1 RK_PD3 GPIO_ACTIVE_HIGH>;
+		io-channels = <&saradc 3>;
+		io-channel-names = "adc-detect";
+		keyup-threshold-microvolt = <1800000>;
+		poll-interval = <100>;
+		spk-con-gpio = <&gpio3 RK_PC0 GPIO_ACTIVE_HIGH>;
+		hp-con-gpio = <&gpio3 RK_PA7 GPIO_ACTIVE_HIGH>;
+		rockchip,format = "i2s";
+		rockchip,mclk-fs = <256>;
+		rockchip,cpu = <&i2s0_8ch>;
+		rockchip,codec = <&es8388>;
+		rockchip,audio-routing =
+			"Headphone", "LOUT1",
+			"Headphone", "ROUT1",
+			"Speaker", "LOUT2",
+			"Speaker", "ROUT2",
+			"Headphone", "Headphone Power",
+			"Headphone", "Headphone Power",
+			"Speaker", "Speaker Power",
+			"Speaker", "Speaker Power",
+			"LINPUT1", "Main Mic",
+			"LINPUT2", "Main Mic",
+			"RINPUT1", "Headset Mic",
+			"RINPUT2", "Headset Mic";
+		pinctrl-names = "default";
+		pinctrl-0 = <&hp_det>;
+		play-pause-key {
+			label = "playpause";
+			linux,code = <KEY_PLAYPAUSE>;
+			press-threshold-microvolt = <2000>;
+		};
+	};
+
+	hdmiin-sound {
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,format = "i2s";
+		rockchip,bitclock-master = <&hdmirx_ctrler>;
+		rockchip,frame-master = <&hdmirx_ctrler>;
+		rockchip,card-name = "rockchip,hdmiin";
+		rockchip,cpu = <&i2s7_8ch>;
+		rockchip,codec = <&hdmirx_ctrler 0>;
+		rockchip,jack-det;
+	};
+
+	pcie20_avdd0v85: pcie20-avdd0v85 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie20_avdd0v85";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <850000>;
+		regulator-max-microvolt = <850000>;
+		vin-supply = <&vdd_0v85_s0>;
+	};
+
+	pcie20_avdd1v8: pcie20-avdd1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie20_avdd1v8";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&avcc_1v8_s0>;
+	};
+
+	pcie30_avdd0v75: pcie30-avdd0v75 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie30_avdd0v75";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <750000>;
+		regulator-max-microvolt = <750000>;
+		vin-supply = <&avdd_0v75_s0>;
+	};
+
+	pcie30_avdd1v8: pcie30-avdd1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "pcie30_avdd1v8";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&avcc_1v8_s0>;
+	};
+
+	rk_headset: rk-headset {
+		status = "disabled";
+		compatible = "rockchip_headset";
+		headset_gpio = <&gpio1 RK_PD3 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&hp_det>;
+		io-channels = <&saradc 3>;
+	};
+
+	vbus5v0_typec: vbus5v0-typec {
+		compatible = "regulator-fixed";
+		regulator-name = "vbus5v0_typec";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio4 RK_PB0 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_usb>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&typec5v_pwren>;
+	};
+
+	vcc3v3_pcie30: vcc3v3-pcie30 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_pcie30";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		gpios = <&gpio2 RK_PB6 GPIO_ACTIVE_HIGH>;
+		startup-delay-us = <5000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vcc5v0_host: vcc5v0-host {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_host";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio3 RK_PB7 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_usb>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_host_en>;
+	};
+
+	vcc3v3_pcie2x1l0: vcc3v3-pcie2x1l0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_pcie2x1l0";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		gpios = <&gpio2 RK_PC5 GPIO_ACTIVE_HIGH>;
+		startup-delay-us = <50000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc3v3_pcie_eth: vcc3v3-pcie-eth {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_pcie_eth";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-boot-on;
+		regulator-always-on;
+		enable-active-low;
+		gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
+		startup-delay-us = <50000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc_mipicsi0: vcc-mipicsi0-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_mipicsi0";
+		enable-active-high;
+	};
+
+	vcc_mipicsi1: vcc-mipicsi1-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_mipicsi1";
+		enable-active-high;
+	};
+
+	vcc_mipidcphy0: vcc-mipidcphy0-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_mipicsi1";
+		enable-active-high;
+	};
+
+	wireless_bluetooth: wireless-bluetooth {
+		compatible = "bluetooth-platdata";
+		clocks = <&hym8563>;
+		clock-names = "ext_clock";
+		uart_rts_gpios = <&gpio4 RK_PC4 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default", "rts_gpio";
+		pinctrl-0 = <&uart9m0_rtsn>, <&bt_reset_gpio>, <&bt_wake_gpio>, <&bt_irq_gpio>;
+		pinctrl-1 = <&uart9_gpios>;
+		BT,reset_gpio    = <&gpio0 RK_PC5 GPIO_ACTIVE_HIGH>;
+		BT,wake_gpio     = <&gpio4 RK_PC6 GPIO_ACTIVE_HIGH>;
+		BT,wake_host_irq = <&gpio0 RK_PA0 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	wireless_wlan: wireless-wlan {
+		compatible = "wlan-platdata";
+		wifi_chip_type = "ap6275p";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_host_wake_irq>;
+		WIFI,host_wake_irq = <&gpio0 RK_PB0 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	wifi_disable: wifi-diable-gpio-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "wifi_disable";
+		enable-active-high;
+		gpio = <&gpio0 RK_PC4 GPIO_ACTIVE_HIGH>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+};
+
+&backlight {
+	pwms = <&pwm2 0 25000 0>;
+	status = "okay";
+};
+
+&can2 {
+	status = "disabled";
+};
+
+&combphy0_ps {
+	status = "okay";
+};
+
+&combphy1_ps {
+	status = "okay";
+};
+
+&combphy2_psu {
+	status = "okay";
+};
+
+&dp0 {
+	status = "okay";
+};
+
+&dp0_in_vp0 {
+	status = "disabled";
+};
+
+&dp0_in_vp1 {
+	status = "disabled";
+};
+
+&dp0_in_vp2 {
+	status = "okay";
+};
+
+&dp0_sound{
+        status = "okay";
+};
+
+&spdif_tx2{
+	status = "okay";
+};
+
+/*
+ * mipi_dcphy0 needs to be enabled
+ * when dsi0 is enabled
+ */
+&dsi0 {
+	status = "disabled";
+};
+
+&dsi0_in_vp2 {
+	status = "disabled";
+};
+
+&dsi0_in_vp3 {
+	status = "disabled";
+};
+
+&dsi0_panel {
+	status = "disabled";
+};
+
+/*
+ * mipi_dcphy1 needs to be enabled
+ * when dsi1 is enabled
+ */
+&dsi1 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&mipi_te1>;
+};
+
+&dsi1_in_vp2 {
+	status = "disabled";
+};
+
+&dsi1_in_vp3 {
+	status = "disabled";
+};
+
+&dsi1_panel {
+	status = "disabled";
+};
+
+&gmac0 {
+	status = "disabled";
+};
+
+&hdmi0 {
+	status = "okay";
+	enable-gpios = <&gpio4 RK_PB1 GPIO_ACTIVE_HIGH>;
+	cec-enable = "true";
+};
+
+&hdmi0_in_vp0 {
+	status = "okay";
+};
+
+&hdmi0_in_vp1 {
+	status = "disabled";
+};
+
+&hdmi0_in_vp2 {
+	status = "disabled";
+};
+
+&hdmi0_sound {
+	status = "okay";
+};
+
+&hdmi1 {
+	status = "okay";
+	enable-gpios = <&gpio4 RK_PB2 GPIO_ACTIVE_HIGH>;
+	cec-enable = "true";
+};
+
+&hdmi1_in_vp0 {
+	status = "disabled";
+};
+
+&hdmi1_in_vp1 {
+	status = "okay";
+};
+
+&hdmi1_in_vp2 {
+	status = "disabled";
+};
+
+&hdmi1_sound {
+	status = "okay";
+};
+
+/* Should work with at least 128MB cma reserved above. */
+&hdmirx_ctrler {
+	status = "disabled";
+
+	#sound-dai-cells = <1>;
+	/* Effective level used to trigger HPD: 0-low, 1-high */
+	hpd-trigger-level = <1>;
+	hdmirx-det-gpios = <&gpio1 RK_PC6 GPIO_ACTIVE_LOW>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&hdmim1_rx_cec &hdmim1_rx_hpdin &hdmim1_rx_scl &hdmim1_rx_sda &hdmirx_det>;
+};
+
+&hdptxphy_hdmi0 {
+	status = "okay";
+};
+
+&hdptxphy_hdmi1 {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0m2_xfer>;
+
+	vdd_cpu_big0_s0: vdd_cpu_big0_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big0_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vdd_cpu_big1_s0: vdd_cpu_big1_mem_s0: rk8603@43 {
+		compatible = "rockchip,rk8603";
+		reg = <0x43>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big1_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c6 {
+	status = "okay";
+	clock-frequency = <400000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c6m0_xfer>;
+
+	usbc0: fusb302@22 {
+		compatible = "fcs,fusb302";
+		reg = <0x22>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PD3 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&usbc0_int>;
+		vbus-supply = <&vbus5v0_typec>;
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				usbc0_role_sw: endpoint@0 {
+					remote-endpoint = <&dwc3_0_role_switch>;
+				};
+			};
+		};
+
+		usb_con: connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+			data-role = "dual";
+			power-role = "dual";
+			try-power-role = "sink";
+			op-sink-microwatt = <1000000>;
+			sink-pdos =
+				<PDO_FIXED(5000, 1000, PDO_FIXED_USB_COMM)>;
+			source-pdos =
+				<PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
+
+			altmodes {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				altmode@0 {
+					reg = <0>;
+					svid = <0xff01>;
+					vdo = <0xffffffff>;
+				};
+			};
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					usbc0_orien_sw: endpoint {
+						remote-endpoint = <&usbdp_phy0_orientation_switch>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					dp_altmode_mux: endpoint {
+						remote-endpoint = <&usbdp_phy0_dp_altmode_mux>;
+					};
+				};
+			};
+		};
+	};
+
+	hym8563: hym8563@51 {
+		compatible = "haoyu,hym8563";
+		reg = <0x51>;
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		clock-output-names = "hym8563";
+		pinctrl-names = "default";
+		pinctrl-0 = <&hym8563_int>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PC6 IRQ_TYPE_LEVEL_LOW>;
+		status = "okay";
+	};
+
+};
+
+&i2c1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c1m2_xfer>;
+
+	vdd_npu_s0: vdd_npu_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_npu_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <950000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c7 {
+	status = "okay";
+	es8388: es8388@11 {
+		status = "okay";
+		#sound-dai-cells = <0>;
+		compatible = "everest,es8388", "everest,es8323";
+		reg = <0x11>;
+		clocks = <&mclkout_i2s0>;
+		clock-names = "mclk";
+		assigned-clocks = <&mclkout_i2s0>;
+		assigned-clock-rates = <12288000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s0_mclk>;
+	};
+};
+
+&i2s5_8ch {
+	status = "okay";
+};
+
+&i2s6_8ch {
+	status = "okay";
+};
+
+&i2s7_8ch {
+	status = "okay";
+};
+
+&mdio0 {
+	rgmii_phy: phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x1>;
+	};
+};
+
+&mipi_dcphy0 {
+	status = "disabled";
+};
+
+&mipi_dcphy1 {
+	status = "disabled";
+};
+
+//phy1
+&pcie2x1l0 {
+	reset-gpios = <&gpio4 RK_PA5 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_pcie2x1l0>;
+	rockchip,skip-scan-in-resume;
+	status = "okay";
+};
+
+//phy2
+&pcie2x1l1 {
+	reset-gpios = <&gpio3 RK_PB3 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
+
+//phy0
+&pcie2x1l2 {
+	reset-gpios = <&gpio4 RK_PA2 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
+
+&pcie30phy {
+	rockchip,pcie30-phymode = <PHY_MODE_PCIE_AGGREGATION>;
+	status = "okay";
+};
+
+&pcie3x4 {
+	reset-gpios = <&gpio4 RK_PB6 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_pcie30>;
+	status = "okay";
+};
+
+&pinctrl {
+	hdmi {
+		hdmirx_det: hdmirx-det {
+			rockchip,pins = <1 RK_PC6 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	headphone {
+		hp_det: hp-det {
+			rockchip,pins = <1 RK_PD3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	hym8563 {
+		hym8563_int: hym8563-int {
+			rockchip,pins = <0 RK_PC6 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	lcd {
+		lcd_rst_gpio: lcd-rst-gpio {
+			rockchip,pins = <2 RK_PC1 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	usb {
+		vcc5v0_host_en: vcc5v0-host-en {
+			rockchip,pins = <3 RK_PB7 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	usb-typec {
+		usbc0_int: usbc0-int {
+			rockchip,pins = <0 RK_PD3 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		typec5v_pwren: typec5v-pwren {
+			rockchip,pins = <4 RK_PB0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	wireless-bluetooth {
+		uart9_gpios: uart9-gpios {
+			rockchip,pins = <4 RK_PC4 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		bt_reset_gpio: bt-reset-gpio {
+			rockchip,pins = <0 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		bt_wake_gpio: bt-wake-gpio {
+			rockchip,pins = <4 RK_PC6 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		bt_irq_gpio: bt-irq-gpio {
+			rockchip,pins = <0 RK_PA0 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	wireless-wlan {
+		wifi_host_wake_irq: wifi-host-wake-irq {
+			rockchip,pins = <0 RK_PB0 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	sdmmc {
+		sdmmc_pwr: sdmmc_pwr {
+			rockchip,pins = <3 RK_PD5 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+};
+
+&pwm2 {
+	pinctrl-names = "active";
+	pinctrl-0 = <&pwm2m2_pins>;
+	status = "okay";
+};
+
+&sata0 {
+	status = "disabled";
+};
+
+&u2phy1_otg {
+	phy-supply = <&vcc5v0_host>;
+};
+
+&u2phy2_host {
+	phy-supply = <&vcc5v0_host>;
+};
+
+&u2phy3_host {
+	phy-supply = <&vcc5v0_host>;
+};
+
+&uart9 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart9m0_xfer &uart9m0_ctsn>;
+};
+
+&usbdp_phy0 {
+	orientation-switch;
+	svid = <0xff01>;
+	sbu1-dc-gpios = <&gpio4 RK_PA6 GPIO_ACTIVE_HIGH>;
+	sbu2-dc-gpios = <&gpio4 RK_PA7 GPIO_ACTIVE_HIGH>;
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		usbdp_phy0_orientation_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_orien_sw>;
+		};
+
+		usbdp_phy0_dp_altmode_mux: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&dp_altmode_mux>;
+		};
+	};
+};
+
+&usbdp_phy1 {
+	rockchip,dp-lane-mux = <2 3>;
+};
+
+&usbdrd_dwc3_0 {
+	status = "okay";
+	dr_mode = "otg";
+	usb-role-switch;
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		dwc3_0_role_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_role_sw>;
+		};
+	};
+};
+
+&usbhost3_0 {
+	status = "disabled";
+};
+
+&usbhost_dwc3_0 {
+	status = "disabled";
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-orangepi.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-orangepi.dtsi
@@ -0,0 +1,647 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/input/rk-input.h>
+#include <dt-bindings/display/drm_mipi_dsi.h>
+#include <dt-bindings/display/rockchip_vop.h>
+#include <dt-bindings/sensor-dev.h>
+
+/ {
+	adc_keys: adc-keys {
+		compatible = "adc-keys";
+		io-channels = <&saradc 1>;
+		io-channel-names = "buttons";
+		keyup-threshold-microvolt = <1800000>;
+		poll-interval = <100>;
+
+		vol-up-key {
+			label = "volume up";
+			linux,code = <KEY_VOLUMEUP>;
+			press-threshold-microvolt = <17000>;
+		};
+
+		vol-down-key {
+			label = "volume down";
+			linux,code = <KEY_VOLUMEDOWN>;
+			press-threshold-microvolt = <417000>;
+		};
+
+		menu-key {
+			label = "menu";
+			linux,code = <KEY_MENU>;
+			press-threshold-microvolt = <890000>;
+		};
+
+		back-key {
+			label = "back";
+			linux,code = <KEY_BACK>;
+			press-threshold-microvolt = <1235000>;
+		};
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		brightness-levels = <
+			  0  20  20  21  21  22  22  23
+			 23  24  24  25  25  26  26  27
+			 27  28  28  29  29  30  30  31
+			 31  32  32  33  33  34  34  35
+			 35  36  36  37  37  38  38  39
+			 40  41  42  43  44  45  46  47
+			 48  49  50  51  52  53  54  55
+			 56  57  58  59  60  61  62  63
+			 64  65  66  67  68  69  70  71
+			 72  73  74  75  76  77  78  79
+			 80  81  82  83  84  85  86  87
+			 88  89  90  91  92  93  94  95
+			 96  97  98  99 100 101 102 103
+			104 105 106 107 108 109 110 111
+			112 113 114 115 116 117 118 119
+			120 121 122 123 124 125 126 127
+			128 129 130 131 132 133 134 135
+			136 137 138 139 140 141 142 143
+			144 145 146 147 148 149 150 151
+			152 153 154 155 156 157 158 159
+			160 161 162 163 164 165 166 167
+			168 169 170 171 172 173 174 175
+			176 177 178 179 180 181 182 183
+			184 185 186 187 188 189 190 191
+			192 193 194 195 196 197 198 199
+			200 201 202 203 204 205 206 207
+			208 209 210 211 212 213 214 215
+			216 217 218 219 220 221 222 223
+			224 225 226 227 228 229 230 231
+			232 233 234 235 236 237 238 239
+			240 241 242 243 244 245 246 247
+			248 249 250 251 252 253 254 255
+		>;
+		default-brightness-level = <200>;
+	};
+
+	dp0_sound: dp0-sound {
+		status = "disabled";
+		compatible = "rockchip,hdmi";
+		rockchip,card-name= "rockchip,dp0";
+		rockchip,mclk-fs = <512>;
+		rockchip,cpu = <&spdif_tx2>;
+		rockchip,codec = <&dp0 1>;
+		rockchip,jack-det;
+	};
+
+	dp1_sound: dp1-sound {
+		status = "disabled";
+		compatible = "rockchip,hdmi";
+		rockchip,card-name= "rockchip,dp1";
+		rockchip,mclk-fs = <512>;
+		rockchip,cpu = <&spdif_tx5>;
+		rockchip,codec = <&dp1 1>;
+		rockchip,jack-det;
+	};
+
+	hdmi0_sound: hdmi0-sound {
+		status = "disabled";
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,card-name = "rockchip-hdmi0";
+		rockchip,cpu = <&i2s5_8ch>;
+		rockchip,codec = <&hdmi0>;
+		rockchip,jack-det;
+	};
+
+	hdmi1_sound: hdmi1-sound {
+		status = "disabled";
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,card-name = "rockchip-hdmi1";
+		rockchip,cpu = <&i2s6_8ch>;
+		rockchip,codec = <&hdmi1>;
+		rockchip,jack-det;
+	};
+
+	spdif_tx1_dc: spdif-tx1-dc {
+		status = "disabled";
+		compatible = "linux,spdif-dit";
+		#sound-dai-cells = <0>;
+	};
+
+	spdif_tx1_sound: spdif-tx1-sound {
+		status = "disabled";
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "rockchip,spdif-tx1";
+		simple-audio-card,cpu {
+			sound-dai = <&spdif_tx1>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&spdif_tx1_dc>;
+		};
+	};
+
+	test-power {
+		status = "disabled";
+	};
+
+	vcc12v_dcin: vcc12v-dcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc12v_dcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_usbdcin: vcc5v0-usbdcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_usbdcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_usb: vcc5v0-usb {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_usb";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc5v0_usbdcin>;
+	};
+
+	spi2: spi@feb20000 {
+		compatible = "rockchip,rk3066-spi";
+		reg = <0x0 0xfeb20000 0x0 0x1000>;
+		interrupts = <GIC_SPI 328 IRQ_TYPE_LEVEL_HIGH>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		clocks = <&cru CLK_SPI2>, <&cru PCLK_SPI2>;
+		clock-names = "spiclk", "apb_pclk";
+		dmas = <&dmac1 15>, <&dmac1 16>;
+		dma-names = "tx", "rx";
+		pinctrl-names = "default";
+		pinctrl-0 = <&spi2m2_cs0 &spi2m2_pins>;
+		num-cs = <2>;
+		status = "okay";
+	};
+
+	vcc_1v1_nldo_s3: vcc-1v1-nldo-s3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_1v1_nldo_s3";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1100000>;
+		regulator-max-microvolt = <1100000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vcc_3v3_sd_s0: vcc-3v3-sd-s0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_3v3_sd_s0";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpios = <&gpio3 RK_PD5 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&sdmmc_pwr>;
+		enable-active-low;
+	};
+};
+
+&av1d_mmu {
+	status = "okay";
+};
+
+&dsi0 {
+	status = "disabled";
+	//rockchip,lane-rate = <1000>;
+	dsi0_panel: panel@0 {
+		status = "disabled";
+		compatible = "innolux,afj101-ba2131";
+		reg = <0>;
+		backlight = <&backlight>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				panel_in_dsi: endpoint {
+					remote-endpoint = <&dsi_out_panel>;
+				};
+			};
+		};
+	};
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@1 {
+			reg = <1>;
+			dsi_out_panel: endpoint {
+				remote-endpoint = <&panel_in_dsi>;
+			};
+		};
+	};
+};
+
+&dsi1 {
+	status = "disabled";
+	//rockchip,lane-rate = <1000>;
+	dsi1_panel: panel@0 {
+		status = "disabled";
+		compatible = "innolux,afj101-ba2131";
+		reg = <0>;
+		backlight = <&backlight>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				panel_in_dsi1: endpoint {
+					remote-endpoint = <&dsi1_out_panel>;
+				};
+			};
+		};
+	};
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@1 {
+			reg = <1>;
+			dsi1_out_panel: endpoint {
+				remote-endpoint = <&panel_in_dsi1>;
+			};
+		};
+	};
+};
+
+&gpu {
+	mali-supply = <&vdd_gpu_s0>;
+	mem-supply = <&vdd_gpu_mem_s0>;
+	status = "okay";
+};
+
+&i2s0_8ch {
+	status = "okay";
+	pinctrl-0 = <&i2s0_lrck
+		     &i2s0_sclk
+		     &i2s0_sdi0
+		     &i2s0_sdo0>;
+};
+
+&iep {
+	status = "okay";
+};
+
+&iep_mmu {
+	status = "okay";
+};
+
+&jpegd {
+	status = "okay";
+};
+
+&jpegd_mmu {
+	status = "okay";
+};
+
+&jpege_ccu {
+	status = "okay";
+};
+&jpege0 {
+	status = "okay";
+};
+
+&jpege0_mmu {
+	status = "okay";
+};
+
+&jpege1 {
+	status = "okay";
+};
+
+&jpege1_mmu {
+	status = "okay";
+};
+
+&jpege2 {
+	status = "okay";
+};
+
+&jpege2_mmu {
+	status = "okay";
+};
+
+&jpege3 {
+	status = "okay";
+};
+
+&jpege3_mmu {
+	status = "okay";
+};
+
+&mpp_srv {
+	status = "okay";
+};
+
+&rga3_core0 {
+	status = "okay";
+};
+
+&rga3_0_mmu {
+	status = "okay";
+};
+
+&rga3_core1 {
+	status = "okay";
+};
+
+&rga3_1_mmu {
+	status = "okay";
+};
+
+&rga2 {
+	status = "okay";
+};
+
+&rknpu {
+	rknpu-supply = <&vdd_npu_s0>;
+	mem-supply = <&vdd_npu_mem_s0>;
+	status = "okay";
+};
+
+&rknpu_mmu {
+	status = "okay";
+};
+
+&rkvdec_ccu {
+	status = "okay";
+};
+
+&rkvdec0 {
+	status = "okay";
+};
+
+&rkvdec0_mmu {
+	status = "okay";
+};
+
+&rkvdec1 {
+	status = "okay";
+};
+
+&rkvdec1_mmu {
+	status = "okay";
+};
+
+&rkvenc_ccu {
+	status = "okay";
+};
+
+&rkvenc0 {
+	status = "okay";
+};
+
+&rkvenc0_mmu {
+	status = "okay";
+};
+
+&rkvenc1 {
+	status = "okay";
+};
+
+&rkvenc1_mmu {
+	status = "okay";
+};
+
+&rockchip_suspend {
+	status = "okay";
+	rockchip,sleep-debug-en = <1>;
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vcc_1v8_s0>;
+};
+
+&sdhci {
+	bus-width = <8>;
+	no-sdio;
+	no-sd;
+	non-removable;
+	max-frequency = <200000000>;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	status = "disabled";
+};
+
+&sdmmc {
+	max-frequency = <150000000>;
+	no-sdio;
+	no-mmc;
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	sd-uhs-sdr104;
+	vmmc-supply = <&vcc_3v3_sd_s0>;
+	vqmmc-supply = <&vccio_sd_s0>;
+	status = "okay";
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&u2phy0 {
+	status = "okay";
+};
+
+&u2phy1 {
+	status = "okay";
+};
+
+&u2phy2 {
+	status = "okay";
+};
+
+&u2phy3 {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	rockchip,typec-vbus-det;
+	status = "okay";
+};
+
+&u2phy1_otg {
+	status = "okay";
+};
+
+&u2phy2_host {
+	status = "okay";
+};
+
+&u2phy3_host {
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&usbdp_phy0 {
+	status = "okay";
+};
+
+&usbdp_phy0_dp {
+	status = "okay";
+};
+
+&usbdp_phy0_u3 {
+	status = "okay";
+};
+
+&usbdp_phy1 {
+	status = "okay";
+};
+
+&usbdp_phy1_dp {
+	status = "okay";
+};
+
+&usbdp_phy1_u3 {
+	status = "okay";
+};
+
+&usbdrd3_0 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&usbhost3_0 {
+	status = "okay";
+};
+
+&usbhost_dwc3_0 {
+	status = "okay";
+};
+
+&usbdrd3_1 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_1 {
+	status = "okay";
+};
+
+&vdpu {
+	status = "okay";
+};
+
+&vdpu_mmu {
+	status = "okay";
+};
+
+&vepu {
+	status = "okay";
+};
+
+&vop {
+	status = "okay";
+	disable-win-move;
+	assigned-clocks = <&cru ACLK_VOP>;
+	assigned-clock-rates = <800000000>;
+};
+
+&vop_mmu {
+	status = "okay";
+};
+
+/* vp0 & vp1 splice for 8K output */
+&vp0 {
+	cursor-win-id=<ROCKCHIP_VOP2_ESMART0>;
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER0>;
+};
+
+&vp1 {
+	cursor-win-id=<ROCKCHIP_VOP2_ESMART1>;
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER1>;
+};
+
+&vp2 {
+	cursor-win-id=<ROCKCHIP_VOP2_ESMART2>;
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER2 | 1 << ROCKCHIP_VOP2_ESMART2)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER2>;
+};
+
+&vp3 {
+	cursor-win-id=<ROCKCHIP_VOP2_ESMART3>;
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER3>;
+};
+
+&display_subsystem {
+	clocks = <&hdptxphy_hdmi_clk0>, <&hdptxphy_hdmi_clk1>;
+	clock-names = "hdmi0_phy_pll", "hdmi1_phy_pll";
+};
+
+&i2c0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0m2_xfer>;
+};
+
+&cpu_l0 {
+	cpu-supply = <&vdd_cpu_lit_s0>;
+	mem-supply = <&vdd_cpu_lit_mem_s0>;
+};
+
+&cpu_b0 {
+	cpu-supply = <&vdd_cpu_big0_s0>;
+	mem-supply = <&vdd_cpu_big0_mem_s0>;
+};
+
+&cpu_b2 {
+	cpu-supply = <&vdd_cpu_big1_s0>;
+	mem-supply = <&vdd_cpu_big1_mem_s0>;
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-rk806-single-khadas.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-rk806-single-khadas.dtsi
@@ -0,0 +1,396 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2023 Wesion Technology Co., Ltd.
+ *
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+
+&spi2 {
+	status = "okay";
+	assigned-clocks = <&cru CLK_SPI2>;
+	assigned-clock-rates = <200000000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi2m2_cs0 &spi2m2_pins>;
+	num-cs = <1>;
+
+	rk806single: rk806single@0 {
+		compatible = "rockchip,rk806";
+		spi-max-frequency = <1000000>;
+		reg = <0x0>;
+
+		interrupt-parent = <&gpio0>;
+		interrupts = <7 IRQ_TYPE_LEVEL_LOW>;
+
+		pinctrl-names = "default", "pmic-power-off";
+		pinctrl-0 = <&pmic_pins>, <&rk806_dvs1_null>, <&rk806_dvs2_null>, <&rk806_dvs3_null>;
+		pinctrl-1 = <&rk806_dvs1_pwrdn>;
+
+		/* 2800mv-3500mv */
+		low_voltage_threshold = <3000>;
+		/* 2700mv-3400mv */
+		shutdown_voltage_threshold = <2700>;
+		/* 140 160 */
+		shutdown_temperture_threshold = <160>;
+		hotdie_temperture_threshold = <115>;
+
+		/* 0: restart PMU;
+		 * 1: reset all the power off reset registers,
+		 *    forcing the state to switch to ACTIVE mode;
+		 * 2: Reset all the power off reset registers,
+		 *    forcing the state to switch to ACTIVE mode,
+		 *    and simultaneously pull down the RESETB PIN for 5mS before releasing
+		 */
+		pmic-reset-func = <1>;
+
+		vcc1-supply = <&vcc5v0_sys>;
+		vcc2-supply = <&vcc5v0_sys>;
+		vcc3-supply = <&vcc5v0_sys>;
+		vcc4-supply = <&vcc5v0_sys>;
+		vcc5-supply = <&vcc5v0_sys>;
+		vcc6-supply = <&vcc5v0_sys>;
+		vcc7-supply = <&vcc5v0_sys>;
+		vcc8-supply = <&vcc5v0_sys>;
+		vcc9-supply = <&vcc5v0_sys>;
+		vcc10-supply = <&vcc5v0_sys>;
+		vcc11-supply = <&vcc_2v0_pldo_s3>;
+		vcc12-supply = <&vcc5v0_sys>;
+		vcc13-supply = <&vcc_1v1_nldo_s3>;
+		vcc14-supply = <&vcc_1v1_nldo_s3>;
+		vcca-supply = <&vcc5v0_sys>;
+
+		pwrkey {
+			status = "okay";
+		};
+
+		pinctrl_rk806: pinctrl_rk806 {
+			gpio-controller;
+			#gpio-cells = <2>;
+
+			rk806_dvs1_null: rk806_dvs1_null {
+				pins = "gpio_pwrctrl2";
+				function = "pin_fun0";
+			};
+
+			rk806_dvs1_slp: rk806_dvs1_slp {
+				pins = "gpio_pwrctrl1";
+				function = "pin_fun1";
+			};
+
+			rk806_dvs1_pwrdn: rk806_dvs1_pwrdn {
+				pins = "gpio_pwrctrl1";
+				function = "pin_fun2";
+			};
+
+			rk806_dvs1_rst: rk806_dvs1_rst {
+				pins = "gpio_pwrctrl1";
+				function = "pin_fun3";
+			};
+
+			rk806_dvs2_null: rk806_dvs2_null {
+				pins = "gpio_pwrctrl2";
+				function = "pin_fun0";
+			};
+
+			rk806_dvs2_slp: rk806_dvs2_slp {
+				pins = "gpio_pwrctrl2";
+				function = "pin_fun1";
+			};
+
+			rk806_dvs2_pwrdn: rk806_dvs2_pwrdn {
+				pins = "gpio_pwrctrl2";
+				function = "pin_fun2";
+			};
+
+			rk806_dvs2_rst: rk806_dvs2_rst {
+				pins = "gpio_pwrctrl2";
+				function = "pin_fun3";
+			};
+
+			rk806_dvs2_dvs: rk806_dvs2_dvs {
+				pins = "gpio_pwrctrl2";
+				function = "pin_fun4";
+			};
+
+			rk806_dvs2_gpio: rk806_dvs2_gpio {
+				pins = "gpio_pwrctrl2";
+				function = "pin_fun5";
+			};
+
+			rk806_dvs3_null: rk806_dvs3_null {
+				pins = "gpio_pwrctrl3";
+				function = "pin_fun0";
+			};
+
+			rk806_dvs3_slp: rk806_dvs3_slp {
+				pins = "gpio_pwrctrl3";
+				function = "pin_fun1";
+			};
+
+			rk806_dvs3_pwrdn: rk806_dvs3_pwrdn {
+				pins = "gpio_pwrctrl3";
+				function = "pin_fun2";
+			};
+
+			rk806_dvs3_rst: rk806_dvs3_rst {
+				pins = "gpio_pwrctrl3";
+				function = "pin_fun3";
+			};
+
+			rk806_dvs3_dvs: rk806_dvs3_dvs {
+				pins = "gpio_pwrctrl3";
+				function = "pin_fun4";
+			};
+
+			rk806_dvs3_gpio: rk806_dvs3_gpio {
+				pins = "gpio_pwrctrl3";
+				function = "pin_fun5";
+			};
+		};
+
+		regulators {
+			vdd_gpu_s0: vdd_gpu_mem_s0: DCDC_REG1 {
+				regulator-boot-on;
+				regulator-min-microvolt = <550000>;
+				regulator-max-microvolt = <950000>;
+				regulator-ramp-delay = <12500>;
+				regulator-name = "vdd_gpu_s0";
+				regulator-enable-ramp-delay = <400>;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdd_cpu_lit_s0: vdd_cpu_lit_mem_s0: DCDC_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <550000>;
+				regulator-max-microvolt = <950000>;
+				regulator-ramp-delay = <12500>;
+				regulator-name = "vdd_cpu_lit_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdd_log_s0: DCDC_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <675000>;
+				regulator-max-microvolt = <750000>;
+				regulator-ramp-delay = <12500>;
+				regulator-name = "vdd_log_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <750000>;
+				};
+			};
+
+			vdd_vdenc_s0: vdd_vdenc_mem_s0: DCDC_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <550000>;
+				regulator-max-microvolt = <950000>;
+				regulator-init-microvolt = <750000>;
+				regulator-ramp-delay = <12500>;
+				regulator-name = "vdd_vdenc_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdd_ddr_s0: DCDC_REG5 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <675000>;
+				regulator-max-microvolt = <900000>;
+				regulator-ramp-delay = <12500>;
+				regulator-name = "vdd_ddr_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <850000>;
+				};
+			};
+
+			vdd2_ddr_s3: DCDC_REG6 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-name = "vdd2_ddr_s3";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			vcc_2v0_pldo_s3: DCDC_REG7 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <2000000>;
+				regulator-max-microvolt = <2000000>;
+				regulator-name = "vdd_2v0_pldo_s3";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <2000000>;
+				};
+			};
+
+			vcc_3v3_s3: DCDC_REG8 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vcc_3v3_s3";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			vddq_ddr_s0: DCDC_REG9 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-name = "vddq_ddr_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_1v8_s3: DCDC_REG10 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc_1v8_s3";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			avcc_1v8_s0: PLDO_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "avcc_1v8_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_1v8_s0: PLDO_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc_1v8_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			avdd_1v2_s0: PLDO_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1200000>;
+				regulator-max-microvolt = <1200000>;
+				regulator-name = "avdd_1v2_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_3v3_s0: PLDO_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vcc_3v3_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vccio_sd_s0: PLDO_REG5 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vccio_sd_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			pldo6_s3: PLDO_REG6 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "pldo6_s3";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vdd_0v75_s3: NLDO_REG1 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <750000>;
+				regulator-max-microvolt = <750000>;
+				regulator-name = "vdd_0v75_s3";
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <750000>;
+				};
+			};
+
+			vdd_ddr_pll_s0: NLDO_REG2 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <850000>;
+				regulator-max-microvolt = <850000>;
+				regulator-name = "vdd_ddr_pll_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+					regulator-suspend-microvolt = <850000>;
+				};
+			};
+
+			avdd_0v75_s0: NLDO_REG3 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <837500>;
+				regulator-max-microvolt = <837500>;
+				regulator-name = "avdd_0v75_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdd_0v85_s0: NLDO_REG4 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <850000>;
+				regulator-max-microvolt = <850000>;
+				regulator-name = "vdd_0v85_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdd_0v75_s0: NLDO_REG5 {
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-min-microvolt = <750000>;
+				regulator-max-microvolt = <750000>;
+				regulator-name = "vdd_0v75_s0";
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-rock-5b-camera.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-rock-5b-camera.dtsi
@@ -0,0 +1,208 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+/ {
+	compatible = "radxa,rock-5b", "rockchip,rk3588";
+
+	camera_pwdn_gpio: camera-pwdn-gpio {
+		status = "disabled";
+		compatible = "regulator-fixed";
+		regulator-name = "camera_pwdn_gpio";
+		regulator-always-on;
+		regulator-boot-on;
+		enable-active-high;
+		gpio = <&gpio1 RK_PB0 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&cam_pwdn_gpio>;
+	};
+
+	clk_cam_24m: external-camera-clock-24m {
+		status = "disabled";
+		compatible = "fixed-clock";
+		clock-frequency = <24000000>;
+		clock-output-names = "clk_cam_24m";
+		#clock-cells = <0>;
+	};
+};
+
+&i2c3 {
+	status = "disabled";
+
+	imx415: imx415@1a {
+		status = "disabled";
+		compatible = "sony,imx415";
+		reg = <0x1a>;
+		clocks = <&cru CLK_MIPI_CAMARAOUT_M3>;
+		clock-names = "xvclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&mipim0_camera3_clk>;
+		power-domains = <&power RK3588_PD_VI>;
+		pwdn-gpios = <&gpio1 RK_PB0 GPIO_ACTIVE_HIGH>;
+		reset-gpios = <&gpio4 RK_PA0 GPIO_ACTIVE_LOW>;
+		rockchip,camera-module-index = <0>;
+		rockchip,camera-module-facing = "back";
+		rockchip,camera-module-name = "RADXA-CAMERA-4K";
+		rockchip,camera-module-lens-name = "DEFAULT";
+		port {
+			imx415_out0: endpoint {
+				remote-endpoint = <&mipidphy0_in_ucam0>;
+				data-lanes = <1 2 3 4>;
+			};
+		};
+	};
+
+	camera_imx219: camera-imx219@10 {
+		status = "disabled";
+		compatible = "sony,imx219";
+		reg = <0x10>;
+
+		clocks = <&clk_cam_24m>;
+		clock-names = "xvclk";
+
+		rockchip,camera-module-index = <0>;
+		rockchip,camera-module-facing = "back";
+		rockchip,camera-module-name = "rpi-camera-v2";
+		rockchip,camera-module-lens-name = "default";
+
+		port {
+			imx219_out0: endpoint {
+				remote-endpoint = <&mipidphy0_in_ucam1>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+};
+
+&csi2_dphy0_hw {
+	status = "disabled";
+};
+
+&csi2_dphy0 {
+	status = "disabled";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipidphy0_in_ucam0: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&imx415_out0>;
+				data-lanes = <1 2 3 4>;
+			};
+
+			mipidphy0_in_ucam1: endpoint@2 {
+				reg = <2>;
+				remote-endpoint = <&imx219_out0>;
+				data-lanes = <1 2>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			csidphy0_out: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&mipi2_csi2_input>;
+			};
+		};
+	};
+};
+
+&mipi2_csi2 {
+	status = "disabled";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi2_csi2_input: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&csidphy0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi2_csi2_output: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&cif_mipi2_in0>;
+			};
+		};
+	};
+};
+
+&rkcif {
+	status = "disabled";
+};
+
+&rkcif_mipi_lvds2 {
+	status = "disabled";
+
+	port {
+		cif_mipi2_in0: endpoint {
+			remote-endpoint = <&mipi2_csi2_output>;
+		};
+	};
+};
+
+&rkcif_mipi_lvds2_sditf {
+	status = "disabled";
+
+	port {
+		mipi_lvds2_sditf: endpoint {
+			remote-endpoint = <&isp0_vir0>;
+		};
+	};
+};
+
+&rkcif_mmu {
+	status = "disabled";
+};
+
+&rkisp0 {
+	status = "disabled";
+};
+
+&isp0_mmu {
+	status = "disabled";
+};
+
+&rkisp0_vir0 {
+	status = "disabled";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		isp0_vir0: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&mipi_lvds2_sditf>;
+		};
+	};
+};
+
+&pinctrl {
+	camera {
+		cam_pwdn_gpio: cam-pwdn-gpio {
+			rockchip,pins = <1 RK_PB0 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+};
\ No newline at end of file
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-rock-5b-display.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-rock-5b-display.dtsi
@@ -0,0 +1,193 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Radxa Limited.
+ *
+ */
+
+/ {
+	compatible = "radxa,rock-5b", "rockchip,rk3588";
+
+	vcc_lcd_mipi1: vcc-lcd-mipi1 {
+		status = "disabled";
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_lcd_mipi1";
+		gpio = <&gpio1 RK_PC4 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-boot-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	dsi1_backlight: dsi1-backlight {
+		status = "disabled";
+		compatible = "pwm-backlight";
+		pwms = <&pwm2 0 25000 0>;
+		brightness-levels = <
+			  0  20  20  21  21  22  22  23
+			 23  24  24  25  25  26  26  27
+			 27  28  28  29  29  30  30  31
+			 31  32  32  33  33  34  34  35
+			 35  36  36  37  37  38  38  39
+			 40  41  42  43  44  45  46  47
+			 48  49  50  51  52  53  54  55
+			 56  57  58  59  60  61  62  63
+			 64  65  66  67  68  69  70  71
+			 72  73  74  75  76  77  78  79
+			 80  81  82  83  84  85  86  87
+			 88  89  90  91  92  93  94  95
+			 96  97  98  99 100 101 102 103
+			104 105 106 107 108 109 110 111
+			112 113 114 115 116 117 118 119
+			120 121 122 123 124 125 126 127
+			128 129 130 131 132 133 134 135
+			136 137 138 139 140 141 142 143
+			144 145 146 147 148 149 150 151
+			152 153 154 155 156 157 158 159
+			160 161 162 163 164 165 166 167
+			168 169 170 171 172 173 174 175
+			176 177 178 179 180 181 182 183
+			184 185 186 187 188 189 190 191
+			192 193 194 195 196 197 198 199
+			200 201 202 203 204 205 206 207
+			208 209 210 211 212 213 214 215
+			216 217 218 219 220 221 222 223
+			224 225 226 227 228 229 230 231
+			232 233 234 235 236 237 238 239
+			240 241 242 243 244 245 246 247
+			248 249 250 251 252 253 254 255
+		>;
+		default-brightness-level = <200>;
+		enable-gpios = <&gpio2 RK_PC2 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&dsi1_backlight_en>;
+	};
+};
+
+&pwm2 {
+	status = "disabled";
+	pinctrl-names = "active";
+	pinctrl-0 = <&pwm2m2_pins>;
+};
+
+&dsi1 {
+	status = "disabled";
+	rockchip,lane-rate = <480>;
+
+	dsi1_panel: panel@0 {
+		status = "disabled";
+		compatible ="chongzhou,cz101b4001";
+		reg = <0>;
+		backlight = <&dsi1_backlight>;
+
+		vdd-supply = <&vcc_lcd_mipi1>;
+		vccio-supply = <&vcc_1v8_s0>;
+		reset-gpios = <&gpio2 RK_PC1 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&dsi1_lcd_rst_gpio>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				panel_in_dsi1: endpoint {
+					remote-endpoint = <&dsi1_out_panel>;
+				};
+			};
+		};
+	};
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@1 {
+			reg = <1>;
+			dsi1_out_panel: endpoint {
+				remote-endpoint = <&panel_in_dsi1>;
+			};
+		};
+	};
+};
+
+&mipi_dcphy1 {
+	status = "disabled";
+};
+
+&route_dsi1 {
+	status = "disabled";
+	connect = <&vp3_out_dsi1>;
+};
+
+&dsi1_in_vp2 {
+	status = "disabled";
+};
+
+&dsi1_in_vp3 {
+	status = "disabled";
+};
+
+&i2c6 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c6m0_xfer>;
+	clock-frequency = <400000>;
+
+	gt9xx: gt9xx@14 {
+		status = "disabled";
+		compatible = "goodix,gt9xx";
+		reg = <0x14>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&gt9xx_gpio>;
+		touch-gpio = <&gpio0 RK_PD3 IRQ_TYPE_LEVEL_HIGH>;
+		reset-gpio = <&gpio0 RK_PC6 GPIO_ACTIVE_HIGH>;
+		max-x = <800>;
+		max-y = <1280>;
+		tp-size = <9112>;
+		tp-supply = <&vcc_lcd_mipi1>;
+	};
+
+	focaltech: focaltech@38 {
+		status = "disabled";
+		compatible = "focaltech,fts";
+		reg = <0x38>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&focaltech_gpio>;
+		focaltech,irq-gpio = <&gpio0 RK_PD3 IRQ_TYPE_LEVEL_LOW>;
+		focaltech,reset-gpio = <&gpio0 RK_PC6 GPIO_ACTIVE_HIGH>;
+		focaltech,display-coords = <0 0 799 1279>;
+	};
+};
+
+&pinctrl {
+
+	dsi1-lcd {
+		dsi1_lcd_rst_gpio: dsi1-lcd-rst-gpio {
+			rockchip,pins =
+				<2 RK_PC1 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		dsi1_backlight_en: dsi1-backlight-en {
+			rockchip,pins =
+				<2 RK_PC2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	gt9xx {
+		gt9xx_gpio: gt9xx-gpio {
+			rockchip,pins =
+				<0 RK_PC6 RK_FUNC_GPIO &pcfg_pull_none>,
+				<0 RK_PD3 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	focaltech {
+		focaltech_gpio: focaltech-gpio {
+		    rockchip,pins =
+				<0 RK_PC6 RK_FUNC_GPIO &pcfg_pull_none>,
+				<0 RK_PD3 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-rock-5b.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588-rock-5b.dts
@@ -0,0 +1,1340 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co., Ltd.
+ * Copyright (c) 2022 Radxa Limited
+ *
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/input/rk-input.h>
+#include <dt-bindings/display/drm_mipi_dsi.h>
+#include <dt-bindings/display/rockchip_vop.h>
+#include <dt-bindings/sensor-dev.h>
+#include "dt-bindings/usb/pd.h"
+#include "rk3588.dtsi"
+#include "rk3588-rk806-single.dtsi"
+#include "rk3588-linux.dtsi"
+
+/ {
+	model = "Radxa ROCK 5B";
+	compatible = "radxa,rock-5b", "rockchip,rk3588";
+
+	/delete-node/ chosen;
+
+	vcc12v_dcin: vcc12v-dcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc12v_dcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	wifi_disable: wifi-diable-gpio-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "wifi_disable";
+		enable-active-high;
+		gpio = <&gpio4 RK_PA2 GPIO_ACTIVE_HIGH>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	bt_wake: bt-wake-gpio-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "bt_wake";
+		enable-active-high;
+		gpio = <&gpio3 RK_PD5 GPIO_ACTIVE_HIGH>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		clocks = <&hym8563>;
+		clock-names = "ext_clock";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_enable_h>;
+		reset-gpios = <&gpio0 RK_PC4 GPIO_ACTIVE_LOW>;
+	};
+
+	wireless_wlan: wireless-wlan {
+		compatible = "wlan-platdata";
+		wifi_chip_type = "ap6256";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_host_wake_irq>;
+		WIFI,host_wake_irq = <&gpio0 RK_PB2 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	vcc_1v1_nldo_s3: vcc-1v1-nldo-s3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_1v1_nldo_s3";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1100000>;
+		regulator-max-microvolt = <1100000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	hdmi0_sound: hdmi0-sound {
+		status = "okay";
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,card-name = "rockchip-hdmi0";
+		rockchip,cpu = <&i2s5_8ch>;
+		rockchip,codec = <&hdmi0>;
+		rockchip,jack-det;
+	};
+
+	hdmi1_sound: hdmi1-sound {
+		status = "okay";
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,card-name = "rockchip-hdmi1";
+		rockchip,cpu = <&i2s6_8ch>;
+		rockchip,codec = <&hdmi1>;
+		rockchip,jack-det;
+	};
+
+	dp0_sound: dp0-sound {
+		status = "okay";
+		compatible = "rockchip,hdmi";
+		rockchip,card-name= "rockchip,dp0";
+		rockchip,mclk-fs = <512>;
+		rockchip,cpu = <&spdif_tx2>;
+		rockchip,codec = <&dp0 1>;
+		rockchip,jack-det;
+	};
+
+	es8316_sound: es8316-sound {
+		status = "okay";
+		compatible = "rockchip,multicodecs-card";
+		rockchip,card-name = "rockchip-es8316";
+		rockchip,format = "i2s";
+		rockchip,mclk-fs = <256>;
+		rockchip,cpu = <&i2s0_8ch >;
+		rockchip,codec = <&es8316>;
+		poll-interval = <100>;
+		io-channels = <&saradc 3>;
+		io-channel-names = "adc-detect";
+		keyup-threshold-microvolt = <1800000>;
+		pinctrl-0 = <&hp_det>;
+		pinctrl-names = "default";
+		hp-det-gpio = <&gpio1 RK_PD5 GPIO_ACTIVE_HIGH>;
+		play-pause-key {
+			label = "playpause";
+			linux,code = <164>;
+			press-threshold-microvolt = <2000>;
+		};
+	};
+
+	vcc5v0_host: vcc5v0-host-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_host";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio4 RK_PB0 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_host_en>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vcc3v3_pcie2x1l2: vcc3v3-pcie2x1l2 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_pcie2x1l2";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		startup-delay-us = <5000>;
+		vin-supply = <&vcc_3v3_s3>;
+	};
+
+	vcc3v3_pcie2x1l0: vcc3v3-pcie2x1l0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_pcie2x1l0";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		regulator-boot-on;
+		regulator-always-on;
+		gpios = <&gpio1 RK_PD2 GPIO_ACTIVE_HIGH>;
+		startup-delay-us = <50000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vcc3v3_pcie30: vcc3v3-pcie30 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_pcie30";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		gpios = <&gpio1 RK_PA4 GPIO_ACTIVE_HIGH>;
+		startup-delay-us = <5000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+
+		user-led2 {
+			gpios = <&gpio0 RK_PB7 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "on";
+		};
+	};
+
+	/* If hdmirx node is disabled, delete the reserved-memory node here. */
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* Reserve 256MB memory for hdmirx-controller@fdee0000 */
+		cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			reg = <0x0 (256 * 0x100000) 0x0 (256 * 0x100000)>;
+			linux,cma-default;
+		};
+	};
+
+	hdmiin-sound {
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,format = "i2s";
+		rockchip,bitclock-master = <&hdmirx_ctrler>;
+		rockchip,frame-master = <&hdmirx_ctrler>;
+		rockchip,card-name = "rockchip,hdmiin";
+		rockchip,cpu = <&i2s7_8ch>;
+		rockchip,codec = <&hdmirx_ctrler 0>;
+		rockchip,jack-det;
+	};
+
+	fan0: pwm-fan {
+		compatible = "pwm-fan";
+		#cooling-cells = <2>;
+		cooling-levels = <72 94 117 139 162 184 207 229 255>;
+		pwms = <&pwm1 0 10000 0>;
+	};
+};
+
+&av1d {
+	status = "okay";
+};
+
+&av1d_mmu {
+	status = "okay";
+};
+
+&cpu_l0 {
+	cpu-supply = <&vdd_cpu_lit_s0>;
+	mem-supply = <&vdd_cpu_lit_mem_s0>;
+};
+
+&cpu_b0 {
+	cpu-supply = <&vdd_cpu_big0_s0>;
+	mem-supply = <&vdd_cpu_big0_mem_s0>;
+};
+
+&cpu_b2 {
+	cpu-supply = <&vdd_cpu_big1_s0>;
+	mem-supply = <&vdd_cpu_big1_mem_s0>;
+};
+
+&gpu {
+	mali-supply = <&vdd_gpu_s0>;
+	mem-supply = <&vdd_gpu_mem_s0>;
+	status = "okay";
+};
+
+&rknpu {
+	rknpu-supply = <&vdd_npu_s0>;
+	mem-supply = <&vdd_npu_mem_s0>;
+	status = "okay";
+};
+
+&rknpu_mmu {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0m2_xfer>;
+
+	vdd_cpu_big0_s0: vdd_cpu_big0_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big0_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vdd_cpu_big1_s0: vdd_cpu_big1_mem_s0: rk8603@43 {
+		compatible = "rockchip,rk8603";
+		reg = <0x43>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big1_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&dmc {
+	center-supply = <&vdd_ddr_s0>;
+	mem-supply = <&vdd_log_s0>;
+	status = "okay";
+};
+
+&dfi {
+	status = "okay";
+};
+
+&i2c1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c1m2_xfer>;
+
+	vdd_npu_s0: vdd_npu_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_npu_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <950000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&iep {
+	status = "okay";
+};
+
+&iep_mmu {
+	status = "okay";
+};
+
+&jpegd {
+	status = "okay";
+};
+
+&jpegd_mmu {
+	status = "okay";
+};
+
+&jpege_ccu {
+	status = "okay";
+};
+
+&jpege0 {
+	status = "okay";
+};
+
+&jpege0_mmu {
+	status = "okay";
+};
+
+&jpege1 {
+	status = "okay";
+};
+
+&jpege1_mmu {
+	status = "okay";
+};
+
+&jpege2 {
+	status = "okay";
+};
+
+&jpege2_mmu {
+	status = "okay";
+};
+
+&jpege3 {
+	status = "okay";
+};
+
+&jpege3_mmu {
+	status = "okay";
+};
+
+&vdpu {
+	status = "okay";
+};
+
+&vdpu_mmu {
+	status = "okay";
+};
+
+&mpp_srv {
+	status = "okay";
+};
+
+&rga3_core0 {
+	status = "okay";
+};
+
+&rga3_0_mmu {
+	status = "okay";
+};
+
+&rga3_core1 {
+	status = "okay";
+};
+
+&rga3_1_mmu {
+	status = "okay";
+};
+
+&rga2 {
+	status = "okay";
+};
+
+&rkvdec_ccu {
+	status = "okay";
+};
+
+&rkvdec0 {
+	status = "okay";
+};
+
+&rkvdec0_mmu {
+	status = "okay";
+};
+
+&rkvdec1 {
+	status = "okay";
+};
+
+&rkvdec1_mmu {
+	status = "okay";
+};
+
+&rkvenc_ccu {
+	status = "okay";
+};
+
+&rkvenc0 {
+	status = "okay";
+};
+
+&rkvenc0_mmu {
+	status = "okay";
+};
+
+&rkvenc1 {
+	status = "okay";
+};
+
+&rkvenc1_mmu {
+	status = "okay";
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&avcc_1v8_s0>;
+};
+
+&sdhci {
+	bus-width = <8>;
+	no-sdio;
+	no-sd;
+	non-removable;
+	max-frequency = <200000000>;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	status = "okay";
+};
+
+&sdmmc {
+	max-frequency = <200000000>;
+	no-sdio;
+	no-mmc;
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	sd-uhs-sdr104;
+	vmmc-supply = <&vcc_3v3_s3>;
+	vqmmc-supply = <&vccio_sd_s0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc_bus4 &sdmmc_clk &sdmmc_cmd &sdmmc_det>;
+	status = "okay";
+};
+
+&sdio {
+	max-frequency = <150000000>;
+	supports-sdio;
+	bus-width = <4>;
+	disable-wp;
+	cap-sd-highspeed;
+	cap-sdio-irq;
+	keep-power-in-suspend;
+	mmc-pwrseq = <&sdio_pwrseq>;
+	non-removable;
+	num-slots = <1>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdiom0_pins>;
+	sd-uhs-sdr104;
+	status = "okay";
+};
+
+&soc_thermal {
+	polling-delay = <1000>;
+	polling-delay-passive = <2000>;
+	trips {
+		trip0: trip-point@0 {
+			temperature = <45000>;
+			hysteresis = <5000>;
+			type = "active";
+		};
+		trip1: trip-point@1 {
+			temperature = <50000>;
+			hysteresis = <5000>;
+			type = "active";
+		};
+		trip2: trip-point@2 {
+			temperature = <55000>;
+			hysteresis = <5000>;
+			type = "active";
+		};
+		trip3: trip-point@3 {
+			temperature = <60000>;
+			hysteresis = <5000>;
+			type = "active";
+		};
+		trip4: trip-point@4 {
+			temperature = <65000>;
+			hysteresis = <5000>;
+			type = "active";
+		};
+		trip5: trip-point@5 {
+			temperature = <70000>;
+			hysteresis = <5000>;
+			type = "active";
+		};
+		trip6: trip-point@6 {
+			temperature = <75000>;
+			hysteresis = <5000>;
+			type = "active";
+		};
+		pcritical: trip-point@7 {
+			temperature = <80000>;
+			hysteresis = <1000>;
+			type = "active";
+		};
+	};
+	cooling-maps {
+		map0 {
+			trip = <&trip0>;
+			cooling-device = <&fan0 0 1>;
+			contribution = <1024>;
+		};
+		map1 {
+			trip = <&trip1>;
+			cooling-device = <&fan0 1 2>;
+			contribution = <1024>;
+		};
+		map2 {
+			trip = <&trip2>;
+			cooling-device = <&fan0 2 3>;
+			contribution = <1024>;
+		};
+		map3 {
+			trip = <&trip3>;
+			cooling-device = <&fan0 3 4>;
+			contribution = <1024>;
+		};
+		map4 {
+			trip = <&trip4>;
+			cooling-device = <&fan0 4 5>;
+			contribution = <1024>;
+		};
+		map5 {
+			trip = <&trip5>;
+			cooling-device = <&fan0 5 6>;
+			contribution = <1024>;
+		};
+		map6 {
+			trip = <&trip6>;
+			cooling-device = <&fan0 6 7>;
+			contribution = <1024>;
+		};
+		map7 {
+			trip = <&pcritical>;
+			cooling-device = <&fan0 7 8>;
+			contribution = <1024>;
+		};
+	};
+};
+
+&uart6 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart6m1_xfer &uart6m1_ctsn &uart6m1_rtsn>;
+	status = "okay";
+
+	bluetooth {
+		compatible = "brcm,bcm4345c5";
+		clocks = <&hym8563>;
+		clock-names = "ext_clock";
+		host-wakeup-gpios = <&gpio0 RK_PC5 GPIO_ACTIVE_HIGH>;
+		shutdown-gpios = <&gpio3 RK_PA6 GPIO_ACTIVE_HIGH>;
+		max-speed = <1500000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&bt_host_wake_l &bt_wake_l &bt_enable_h>;
+		vbat-supply = <&vcc3v3_pcie2x1l0>;
+	};
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&display_subsystem {
+	clocks = <&hdptxphy_hdmi_clk0>, <&hdptxphy_hdmi_clk1>;
+	clock-names = "hdmi0_phy_pll", "hdmi1_phy_pll";
+
+	route {
+		route_hdmi0: route-hdmi0 {
+			status = "okay";
+			logo,uboot = "logo.bmp";
+			logo,kernel = "logo_kernel.bmp";
+			logo,mode = "center";
+			charge_logo,mode = "center";
+			connect = <&vp0_out_hdmi0>;
+		};
+
+		route_hdmi1: route-hdmi1 {
+			status = "okay";
+			logo,uboot = "logo.bmp";
+			logo,kernel = "logo_kernel.bmp";
+			logo,mode = "center";
+			charge_logo,mode = "center";
+			connect = <&vp1_out_hdmi1>;
+		};
+	};
+};
+
+&hdptxphy_hdmi_clk0 {
+	status = "okay";
+};
+
+&hdptxphy_hdmi_clk1 {
+	status = "okay";
+};
+
+&hdmi0 {
+	status = "okay";
+        cec-enable = "true";
+};
+
+&hdmi0_in_vp0 {
+	status = "okay";
+};
+
+&hdmi0_in_vp1 {
+	status = "disabled";
+};
+
+&hdmi0_in_vp2 {
+	status = "disabled";
+};
+
+&hdmi0_sound {
+	status = "okay";
+};
+
+&hdmi1 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&hdmim0_tx1_cec &hdmim0_tx1_hpd &hdmim1_tx1_scl &hdmim1_tx1_sda>;
+        cec-enable = "true";
+};
+
+&hdmi1_in_vp0 {
+	status = "disabled";
+};
+
+&hdmi1_in_vp1 {
+	status = "okay";
+};
+
+&hdmi1_in_vp2 {
+	status = "disabled";
+};
+
+&hdmi1_sound {
+	status = "okay";
+};
+
+/* Should work with at least 128MB cma reserved above. */
+&hdmirx_ctrler {
+	status = "okay";
+
+	#sound-dai-cells = <1>;
+	/* Effective level used to trigger HPD: 0-low, 1-high */
+	hpd-trigger-level = <1>;
+	hdmirx-det-gpios = <&gpio1 RK_PC6 GPIO_ACTIVE_LOW>;
+
+	pinctrl-0 = <&hdmim1_rx_cec &hdmim1_rx_hpdin &hdmim1_rx_scl &hdmim1_rx_sda &hdmirx_det>;
+	pinctrl-names = "default";
+};
+
+&hdptxphy_hdmi0 {
+	status = "okay";
+};
+
+&hdptxphy_hdmi1 {
+	status = "okay";
+};
+
+&i2s5_8ch {
+	status = "okay";
+};
+
+&i2s6_8ch {
+	status = "okay";
+};
+
+&i2s7_8ch {
+	status = "okay";
+};
+
+&vop {
+	status = "okay";
+};
+
+&vop_mmu {
+	status = "okay";
+};
+
+&vepu {
+	status = "okay";
+};
+
+/* vp0 & vp1 splice for 8K output */
+&vp0 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER0>;
+	cursor-win-id = <ROCKCHIP_VOP2_ESMART0>;
+};
+
+&vp1 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER1>;
+	cursor-win-id = <ROCKCHIP_VOP2_ESMART1>;
+};
+
+&vp2 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER2 | 1 << ROCKCHIP_VOP2_ESMART2)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER2>;
+	cursor-win-id = <ROCKCHIP_VOP2_ESMART2>;
+};
+
+&vp3 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER3>;
+	cursor-win-id = <ROCKCHIP_VOP2_ESMART3>;
+};
+
+&u2phy2 {
+	status = "okay";
+};
+
+&u2phy2_host {
+	status = "okay";
+};
+
+&u2phy3 {
+	status = "okay";
+};
+
+&u2phy3_host {
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&usbhost3_0 {
+	status = "okay";
+};
+
+&usbhost_dwc3_0 {
+	status = "okay";
+};
+
+&combphy2_psu {
+	status = "okay";
+};
+
+&u2phy1 {
+	status = "okay";
+};
+
+&u2phy1_otg {
+	status = "okay";
+};
+
+&usbdrd3_1{
+	status = "okay";
+};
+
+&usbdrd_dwc3_1{
+	status = "okay";
+};
+
+&usbdp_phy1 {
+	status = "okay";
+};
+
+&usbdp_phy1_u3 {
+	status = "okay";
+};
+
+&i2c4 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c4m1_xfer>;
+
+	usbc0: fusb302@22 {
+		compatible = "fcs,fusb302";
+		reg = <0x22>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <RK_PB4 IRQ_TYPE_LEVEL_LOW>;
+		int-n-gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&usbc0_int>;
+		vbus-supply = <&vcc12v_dcin>;
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				usbc0_role_sw: endpoint@0 {
+					remote-endpoint = <&dwc3_0_role_switch>;
+				};
+			};
+		};
+
+		usb_con: connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+			data-role = "dual";
+			faster-pd-negotiation;
+			power-role = "sink";
+			try-power-role = "sink";
+			op-sink-microwatt = <1000000>;
+			sink-pdos =
+				<PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)
+				 PDO_VAR(5000, 20000, 5000)>;
+
+			altmodes {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				altmode@0 {
+					reg = <0>;
+					svid = <0xff01>;
+					vdo = <0xffffffff>;
+				};
+			};
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					usbc0_orien_sw: endpoint {
+						remote-endpoint = <&usbdp_phy0_orientation_switch>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					dp_altmode_mux: endpoint {
+						remote-endpoint = <&usbdp_phy0_dp_altmode_mux>;
+					};
+				};
+			};
+		};
+	};
+};
+
+&u2phy0 {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	rockchip,typec-vbus-det;
+	status = "okay";
+};
+
+&usbdrd3_0 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	status = "okay";
+	dr_mode = "otg";
+	usb-role-switch;
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		dwc3_0_role_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_role_sw>;
+		};
+	};
+};
+
+&usbdp_phy0 {
+	status = "okay";
+	orientation-switch;
+	svid = <0xff01>;
+	sbu1-dc-gpios = <&gpio4 RK_PA6 GPIO_ACTIVE_HIGH>;
+	sbu2-dc-gpios = <&gpio4 RK_PA7 GPIO_ACTIVE_HIGH>;
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		usbdp_phy0_orientation_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_orien_sw>;
+		};
+
+		usbdp_phy0_dp_altmode_mux: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&dp_altmode_mux>;
+		};
+	};
+};
+
+&usbdp_phy0_u3 {
+	status = "okay";
+};
+
+&usbdp_phy0_dp {
+	status = "okay";
+};
+
+&dp0 {
+	status = "okay";
+};
+
+&dp0_in_vp2 {
+	status = "okay";
+};
+
+&route_dp0 {
+	status = "okay";
+	connect = <&vp2_out_dp0>;
+};
+
+&spdif_tx2 {
+	status = "okay";
+};
+
+&combphy0_ps {
+	status = "okay";
+};
+
+&pcie2x1l2 {
+	reset-gpios = <&gpio3 RK_PB0 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_pcie2x1l2>;
+	status = "okay";
+};
+
+&pcie2x1l0 {
+	reset-gpios = <&gpio4 RK_PA5 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_pcie2x1l0>;
+	status = "okay";
+};
+
+&combphy1_ps {
+	status = "okay";
+};
+
+&pcie30phy {
+	status = "okay";
+};
+
+&pcie3x4 {
+	reset-gpios = <&gpio4 RK_PB6 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_pcie30>;
+	status = "okay";
+};
+
+&pwm1 {
+	pinctrl-names = "active";
+	pinctrl-0 = <&pwm1m0_pins>;
+	status = "okay";
+};
+
+&i2c6 {
+	status = "okay";
+
+	hym8563: hym8563@51 {
+		compatible = "haoyu,hym8563";
+		reg = <0x51>;
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		clock-output-names = "hym8563";
+		pinctrl-names = "default";
+		pinctrl-0 = <&rtc_int>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PB0 IRQ_TYPE_LEVEL_LOW>;
+	};
+};
+
+&i2c7 {
+	status = "okay";
+
+	es8316: es8316@11 {
+		compatible = "everest,es8316";
+		reg = <0x11>;
+		clocks = <&mclkout_i2s0>;
+		clock-names = "mclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s0_mclk>;
+		#sound-dai-cells = <0>;
+	};
+};
+
+&i2s0_8ch {
+	status = "okay";
+	rockchip,playback-channels = <2>;
+	rockchip,capture-channels = <2>;
+	#sound-dai-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2s0_lrck
+			 &i2s0_sclk
+			 &i2s0_sdi0
+			 &i2s0_sdo0>;
+};
+
+&sfc {
+	status = "okay";
+	max-freq = <50000000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&fspim2_pins>;
+
+	spi_flash: spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "jedec,spi-nor";
+		reg = <0x0>;
+		spi-max-frequency = <50000000>;
+		spi-tx-bus-width = <1>;
+		spi-rx-bus-width = <4>;
+		status = "okay";
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			loader@0 {
+				label = "loader";
+				reg = <0x0 0x1000000>;
+			};
+		};
+	};
+};
+
+&rockchip_suspend {
+	compatible = "rockchip,pm-rk3588";
+	status = "okay";
+	rockchip,sleep-debug-en = <1>;
+	rockchip,sleep-mode-config = <
+		(0
+		| RKPM_SLP_ARMOFF_DDRPD
+		)
+	>;
+	rockchip,wakeup-config = <
+		(0
+		| RKPM_GPIO_WKUP_EN
+		| RKPM_USB_WKUP_EN
+		)
+	>;
+};
+
+&avdd_0v75_s0 {
+	regulator-state-mem {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <837500>;
+	};
+};
+
+&avcc_1v8_s0 {
+	regulator-state-mem {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <1800000>;
+	};
+};
+
+&vcc_1v8_s0 {
+	regulator-state-mem {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <1800000>;
+	};
+};
+
+&vcc_3v3_s0 {
+	regulator-state-mem {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <3300000>;
+	};
+};
+
+&vdd_log_s0 {
+	regulator-state-mem {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <750000>;
+	};
+};
+
+&vdd_ddr_pll_s0 {
+	regulator-state-mem {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <850000>;
+	};
+};
+
+&pinctrl {
+	usb {
+		vcc5v0_host_en: vcc5v0-host-en {
+			rockchip,pins = <4 RK_PB0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		vcc5v0_otg_en: vcc5v0-otg-en {
+			rockchip,pins = <2 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	usb-typec {
+		usbc0_int: usbc0-int {
+			rockchip,pins = <3 RK_PB4 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	hym8563 {
+		rtc_int: rtc-int {
+			rockchip,pins = <0 RK_PB0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	headphone {
+		hp_det: hp-det {
+			rockchip,pins = <1 RK_PD5 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	hdmirx {
+		hdmirx_det: hdmirx-det {
+			rockchip,pins = <1 RK_PC6 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	sdio-pwrseq {
+		wifi_enable_h: wifi-enable-h {
+			rockchip,pins = <0 RK_PC4 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	wireless-wlan {
+		wifi_host_wake_irq: wifi-host-wake-irq {
+			rockchip,pins = <0 RK_PB2 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	bt {
+		bt_enable_h: bt-enable-h {
+			rockchip,pins = <3 RK_PA6 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		bt_host_wake_l: bt-host-wake-l {
+			rockchip,pins = <0 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		bt_wake_l: bt-wake-l {
+			rockchip,pins = <3 RK_PD5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+};
+
+&gpio0 {
+	gpio-line-names =
+		/* GPIO0_A0-A3 */
+		"", "", "", "",
+		/* GPIO0_A4-A7 */
+		"", "", "", "",
+
+		/* GPIO0_B0-B3 */
+		"", "", "", "",
+		/* GPIO0_B4-B7 */
+		"", "PIN_8", "PIN_10", "",
+
+		/* GPIO0_C0-C3 */
+		"", "", "", "",
+		/* GPIO0_C4-C7 */
+		"", "", "", "",
+
+		/* GPIO0_D0-D3 */
+		"", "", "", "",
+		/* GPIO0_D4-D7 */
+		"", "", "", "";
+};
+
+&gpio1 {
+	gpio-line-names =
+		/* GPIO1_A0-A3 */
+		"", "", "", "",
+		/* GPIO1_A4-A7 */
+		"", "", "", "",
+
+		/* GPIO1_B0-B3 */
+		"", "PIN_21", "PIN_19", "PIN_23",
+		/* GPIO1_B4-B7 */
+		"PIN_24", "PIN_26", "", "PIN_31",
+
+		/* GPIO1_C0-C3 */
+		"", "", "", "",
+		/* GPIO1_C4-C7 */
+		"", "", "", "",
+
+		/* GPIO1_D0-D3 */
+		"", "", "", "",
+		/* GPIO1_D4-D7 */
+		"", "", "", "PIN_29";
+};
+
+&gpio2 {
+	gpio-line-names =
+		/* GPIO2_A0-A3 */
+		"", "", "", "",
+		/* GPIO2_A4-A7 */
+		"", "", "", "",
+
+		/* GPIO2_B0-B3 */
+		"", "", "", "",
+		/* GPIO2_B4-B7 */
+		"", "", "", "",
+
+		/* GPIO2_C0-C3 */
+		"", "", "", "",
+		/* GPIO2_C4-C7 */
+		"", "", "", "",
+
+		/* GPIO2_D0-D3 */
+		"", "", "", "",
+		/* GPIO2_D4-D7 */
+		"", "", "", "";
+};
+
+&gpio3 {
+	gpio-line-names =
+		/* GPIO3_A0-A3 */
+		"", "", "", "",
+		/* GPIO3_A4-A7 */
+		"PIN_16", "", "", "PIN_33",
+
+		/* GPIO3_B0-B3 */
+		"", "PIN_36", "PIN_38", "PIN_40",
+		/* GPIO3_B4-B7 */
+		"", "PIN_12", "PIN_35", "PIN_13",
+
+		/* GPIO3_C0-C3 */
+		"PIN_15", "PIN_11", "PIN_32", "PIN_7",
+		/* GPIO3_C4-C7 */
+		"", "", "", "",
+
+		/* GPIO3_D0-D3 */
+		"", "", "", "",
+		/* GPIO3_D4-D7 */
+		"", "", "", "";
+};
+
+&gpio4 {
+	gpio-line-names =
+		/* GPIO4_A0-A3 */
+		"", "", "", "",
+		/* GPIO4_A4-A7 */
+		"", "", "", "",
+
+		/* GPIO4_B0-B3 */
+		"", "", "PIN_5", "PIN_3",
+		/* GPIO4_B4-B7 */
+		"", "", "", "",
+
+		/* GPIO4_C0-C3 */
+		"", "", "", "",
+		/* GPIO4_C4-C7 */
+		"PIN_18", "PIN_28", "PIN_27", "",
+
+		/* GPIO4_D0-D3 */
+		"", "", "", "",
+		/* GPIO4_D4-D7 */
+		"", "", "", "";
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-9tripod-linux.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-9tripod-linux.dts
@@ -0,0 +1,1214 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/input/rk-input.h>
+#include <dt-bindings/display/drm_mipi_dsi.h>
+#include <dt-bindings/display/rockchip_vop.h>
+#include <dt-bindings/sensor-dev.h>
+#include "dt-bindings/usb/pd.h"
+#include "rk3588s.dtsi"
+#include "rk3588-rk806-single.dtsi"
+#include "rk3588-linux.dtsi"
+
+/ {
+	model = "Indiedroid Nova";
+	compatible = "9tripod,rk3588s", "rockchip,rk3588";
+
+	/delete-node/ chosen;
+
+	adc_keys: adc-keys {
+		compatible = "adc-keys";
+		io-channels = <&saradc 1>;
+		io-channel-names = "buttons";
+		keyup-threshold-microvolt = <1800000>;
+		poll-interval = <100>;
+
+		vol-up-key {
+			label = "volume up";
+			linux,code = <KEY_VOLUMEUP>;
+			press-threshold-microvolt = <17000>;
+		};
+
+		vol-down-key {
+			label = "volume down";
+			linux,code = <KEY_VOLUMEDOWN>;
+			press-threshold-microvolt = <890000>;
+		};
+
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		brightness-levels = <
+			  0  20  20  21  21  22  22  23
+			 23  24  24  25  25  26  26  27
+			 27  28  28  29  29  30  30  31
+			 31  32  32  33  33  34  34  35
+			 35  36  36  37  37  38  38  39
+			 40  41  42  43  44  45  46  47
+			 48  49  50  51  52  53  54  55
+			 56  57  58  59  60  61  62  63
+			 64  65  66  67  68  69  70  71
+			 72  73  74  75  76  77  78  79
+			 80  81  82  83  84  85  86  87
+			 88  89  90  91  92  93  94  95
+			 96  97  98  99 100 101 102 103
+			104 105 106 107 108 109 110 111
+			112 113 114 115 116 117 118 119
+			120 121 122 123 124 125 126 127
+			128 129 130 131 132 133 134 135
+			136 137 138 139 140 141 142 143
+			144 145 146 147 148 149 150 151
+			152 153 154 155 156 157 158 159
+			160 161 162 163 164 165 166 167
+			168 169 170 171 172 173 174 175
+			176 177 178 179 180 181 182 183
+			184 185 186 187 188 189 190 191
+			192 193 194 195 196 197 198 199
+			200 201 202 203 204 205 206 207
+			208 209 210 211 212 213 214 215
+			216 217 218 219 220 221 222 223
+			224 225 226 227 228 229 230 231
+			232 233 234 235 236 237 238 239
+			240 241 242 243 244 245 246 247
+			248 249 250 251 252 253 254 255
+		>;
+		default-brightness-level = <200>;
+	};
+
+	es8388_sound: es8388-sound {
+		status = "okay";
+		compatible = "rockchip,multicodecs-card";
+		rockchip,card-name = "rockchip-es8388";
+		hp-det-gpio = <&gpio4 RK_PA7 GPIO_ACTIVE_LOW>;
+		io-channels = <&saradc 3>;
+		io-channel-names = "adc-detect";
+		keyup-threshold-microvolt = <1800000>;
+		poll-interval = <100>;
+		//spk-con-gpio = <&gpio4 RK_PA5 GPIO_ACTIVE_HIGH>;
+		//hp-con-gpio = <&gpio4 RK_PA4 GPIO_ACTIVE_HIGH>;
+		rockchip,format = "i2s";
+		rockchip,mclk-fs = <256>;
+		rockchip,cpu = <&i2s0_8ch>;
+		rockchip,codec = <&es8388>;
+		rockchip,audio-routing =
+			"Headphone", "LOUT2",
+			"Headphone", "ROUT2",
+			"Speaker", "LOUT1",
+			"Speaker", "ROUT1",
+			"Headphone", "Headphone Power",
+			"Headphone", "Headphone Power",
+			"Speaker", "Speaker Power",
+			"Speaker", "Speaker Power",
+			"LINPUT1", "Main Mic",
+			"LINPUT2", "Main Mic",
+			"RINPUT1", "Headset Mic",
+			"RINPUT2", "Headset Mic";
+		pinctrl-names = "default";
+		pinctrl-0 = <&hp_det>;
+		play-pause-key {
+			label = "playpause";
+			linux,code = <KEY_PLAYPAUSE>;
+			press-threshold-microvolt = <2000>;
+		};
+	};
+
+	hdmi0_sound: hdmi0-sound {
+		status = "okay";
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <128>;
+		simple-audio-card,name = "rockchip,hdmi0";
+		rockchip,jack-det;
+		simple-audio-card,cpu {
+			sound-dai = <&i2s5_8ch>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&hdmi0>;
+		};
+	};
+
+	minipcie_power: minipcie-power {
+		compatible = "regulator-fixed";
+		regulator-name = "minipcie_power";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		regulator-boot-on;
+		regulator-always-on;
+		gpios = <&gpio3 RK_PC3 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	test-power {
+		status = "okay";
+	};
+
+	vcc12v_dcin: vcc12v-dcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc12v_dcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc5v0_host: vcc5v0-host {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_host";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		//gpio = <&gpio1 RK_PB1 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_usb>;
+		//pinctrl-names = "default";
+		//pinctrl-0 = <&vcc5v0_host_en>;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vbus5v0_typec: vbus5v0-typec {
+		compatible = "regulator-fixed";
+		regulator-name = "vbus5v0_typec";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		//gpio = <&gpio1 RK_PA1 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_usb>;
+		//pinctrl-names = "default";
+		//pinctrl-0 = <&typec5v_pwren>;
+	};
+
+	vcc5v0_usbdcin: vcc5v0-usbdcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_usbdcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_usb: vcc5v0-usb {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_usb";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc5v0_usbdcin>;
+	};
+
+	vcc3v3_pcie20: vcc3v3-pcie20 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_pcie20";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		//gpios = <&gpio4 RK_PB1 GPIO_ACTIVE_HIGH>;
+		startup-delay-us = <5000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc_2v8_cam_s0: vcc-2v8-cam-s0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_2v8_cam_s0";
+		regulator-min-microvolt = <2800000>;
+		regulator-max-microvolt = <2800000>;
+		vin-supply = <&vcc_3v3_s3>;
+	};
+
+	vcc_1v1_nldo_s3: vcc-1v1-nldo-s3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_1v1_nldo_s3";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1100000>;
+		regulator-max-microvolt = <1100000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vcc_1v2_cam_s0: vcc-1v2-cam-s0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_1v2_cam_s0";
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+		gpios = <&gpio1 RK_PA6 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		vin-supply = <&vcc_3v3_s3>;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vcc_1v8_cam_s0: vcc-1v8-cam-s0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_1v8_cam_s0";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&vcc_3v3_s3>;
+	};
+
+// ANDROID
+//	sdio_pwrseq: sdio-pwrseq {
+//		compatible = "mmc-pwrseq-simple";
+//		clocks = <&hym8563>;
+//		clock-names = "ext_clock";
+//		pinctrl-names = "default";
+//		pinctrl-0 = <&wifi_enable_h>;
+//		/*
+//		 * On the module itself this is one of these (depending
+//		 * on the actual card populated):
+//		 * - SDIO_RESET_L_WL_REG_ON
+//		 * - PDN (power down when low)
+//		 */
+//		post-power-on-delay-ms = <200>;
+//		reset-gpios = <&gpio0 RK_PC7 GPIO_ACTIVE_LOW>;
+//	};
+
+	wireless_bluetooth: wireless-bluetooth {
+		compatible = "bluetooth-platdata";
+		clocks = <&hym8563>;
+		clock-names = "ext_clock";
+		uart_rts_gpios = <&gpio3 RK_PD2 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default", "rts_gpio";
+		pinctrl-0 = <&uart9m2_rtsn>, <&bt_reset_gpio>, <&bt_wake_gpio>, <&bt_wake_host_irq>;
+		pinctrl-1 = <&uart9_gpios>;
+		BT,reset_gpio    = <&gpio0 RK_PD4 GPIO_ACTIVE_HIGH>;
+		BT,wake_gpio     = <&gpio0 RK_PC6 GPIO_ACTIVE_HIGH>;
+		BT,wake_host_irq = <&gpio0 RK_PC5 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	wireless_wlan: wireless-wlan {
+		compatible = "wlan-platdata";
+		wifi_chip_type = "rtl8821cs";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_host_wake_irq>, <&wifi_poweren_gpio>;
+		WIFI,host_wake_irq = <&gpio0 RK_PA0 GPIO_ACTIVE_HIGH>;
+		rockchip,grf = <&sys_grf>;
+		status = "okay";
+	};
+};
+
+&av1d {
+	status = "okay";
+};
+
+&av1d_mmu {
+	status = "okay";
+};
+
+&avsd {
+	status = "okay";
+};
+
+&backlight {
+	pwms = <&pwm14 0 25000 0>;
+	enable-gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_HIGH>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&bl_en>;
+	status = "disabled";
+};
+
+&combphy0_ps {
+	status = "okay";
+};
+
+&combphy2_psu {
+	status = "okay";
+};
+
+&cpu_l0 {
+	cpu-supply = <&vdd_cpu_lit_s0>;
+	mem-supply = <&vdd_cpu_lit_mem_s0>;
+};
+
+&cpu_b0 {
+	cpu-supply = <&vdd_cpu_big0_s0>;
+	mem-supply = <&vdd_cpu_big0_mem_s0>;
+};
+
+&cpu_b2 {
+	cpu-supply = <&vdd_cpu_big1_s0>;
+	mem-supply = <&vdd_cpu_big1_mem_s0>;
+};
+
+&dfi {
+	status = "okay";
+};
+
+&display_subsystem {
+    clocks = <&hdptxphy_hdmi_clk0>;
+    clock-names = "hdmi0_phy_pll";
+};
+
+&dmc {
+	center-supply = <&vdd_ddr_s0>;
+	mem-supply = <&vdd_log_s0>;
+	status = "okay";
+};
+
+&dp0 {
+	//pinctrl-names = "default";
+	//pinctrl-0 = <&dp0_hpd>;
+	//hpd-gpios = <&gpio1 RK_PD5 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
+
+&dp0_in_vp2 {
+	status = "okay";
+};
+
+/*
+ * mipi_dcphy0 needs to be enabled
+ * when dsi0 is enabled
+ */
+
+&dsi0 {
+	status = "disabled";
+	//rockchip,lane-rate = <600>;
+	dsi0_panel: panel@0 {
+		status = "okay";
+		compatible = "simple-panel-dsi";
+		reg = <0>;
+		backlight = <&backlight>;
+		//power-supply = <&vcc3v3_lcd_n>;
+		//reset-gpios = <&gpio1 RK_PB0 GPIO_ACTIVE_LOW>;
+		//pinctrl-names = "default";
+		//pinctrl-0 = <&lcd_rst_gpio>;
+		reset-delay-ms = <120>;
+		enable-delay-ms = <120>;
+		prepare-delay-ms = <120>;
+		unprepare-delay-ms = <120>;
+		disable-delay-ms = <120>;
+		dsi,flags = <(MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			MIPI_DSI_MODE_LPM | MIPI_DSI_MODE_EOT_PACKET)>;
+		dsi,format = <MIPI_DSI_FMT_RGB888>;
+		dsi,lanes  = <4>;
+
+		disp_timings0: display-timings {
+			native-mode = <&dsi0_timing0>;
+			dsi0_timing0: timing0 {
+				clock-frequency = <50000000>;
+				hactive = <1024>;
+				vactive = <600>;
+				hfront-porch = <150>;
+				hsync-len = <20>;
+				hback-porch = <150>;
+				vfront-porch = <8>;
+				vsync-len = <3>;
+				vback-porch = <24>;
+				hsync-active = <1>;
+				vsync-active = <1>;
+				de-active = <0>;
+				pixelclk-active = <1>;
+			};
+		};
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				panel_in_dsi: endpoint {
+					remote-endpoint = <&dsi_out_panel>;
+				};
+			};
+		};
+	};
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@1 {
+			reg = <1>;
+			dsi_out_panel: endpoint {
+				remote-endpoint = <&panel_in_dsi>;
+			};
+		};
+	};
+};
+
+&dsi0_in_vp2 {
+	status = "disabled";
+};
+
+&dsi0_in_vp3 {
+	status = "disabled";
+};
+
+&dsi0_panel {
+	status = "disabled";
+	reset-gpios = <&gpio1 RK_PB0 GPIO_ACTIVE_LOW>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&lcd_rst_gpio>;
+};
+
+&gpu {
+	mali-supply = <&vdd_gpu_s0>;
+	mem-supply = <&vdd_gpu_mem_s0>;
+	status = "okay";
+};
+
+&hdmi0 {
+        enable-gpios = <&gpio4 RK_PB6 GPIO_ACTIVE_HIGH>;
+        status = "okay";
+        cec-enable = "true";
+};
+
+&hdmi0_in_vp0 {
+	status = "okay";
+};
+
+&hdptxphy_hdmi0 {
+        status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0m2_xfer>;
+
+	vdd_cpu_big0_s0: vdd_cpu_big0_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big0_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vdd_cpu_big1_s0: vdd_cpu_big1_mem_s0: rk8603@43 {
+		compatible = "rockchip,rk8603";
+		reg = <0x43>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big1_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c2 {
+	status = "okay";
+
+	vdd_npu_s0: vdd_npu_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_npu_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <950000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c4 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c4m3_xfer>;
+
+	gslx680@40 {
+		compatible = "9tripod,gslx680";
+		reg = <0x40>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&tp_irq_gpio &tp_rst_gpio>;
+		touch-gpio = <&gpio0 RK_PD5 IRQ_TYPE_EDGE_RISING>;
+		reset-gpio = <&gpio3 RK_PC2 GPIO_ACTIVE_LOW>;
+		max-x = <1024>;
+		max-y = <600>;
+		status = "okay";
+	};
+};
+
+&i2c6 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c6m3_xfer>;
+
+	usbc0: fusb302@22 {
+		compatible = "fcs,fusb302";
+		reg = <0x22>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PC4 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&usbc0_int>;
+		vbus-supply = <&vbus5v0_typec>;
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				usbc0_role_sw: endpoint@0 {
+					remote-endpoint = <&dwc3_0_role_switch>;
+				};
+			};
+		};
+
+		usb_con: connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+			data-role = "dual";
+			power-role = "dual";
+			try-power-role = "sink";
+			op-sink-microwatt = <1000000>;
+			sink-pdos =
+				<PDO_FIXED(5000, 1000, PDO_FIXED_USB_COMM)>;
+			source-pdos =
+				<PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
+
+			altmodes {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				altmode@0 {
+					reg = <0>;
+					svid = <0xff01>;
+					vdo = <0xffffffff>;
+				};
+			};
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					usbc0_orien_sw: endpoint {
+						remote-endpoint = <&usbdp_phy0_orientation_switch>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					dp_altmode_mux: endpoint {
+						remote-endpoint = <&usbdp_phy0_dp_altmode_mux>;
+					};
+				};
+			};
+		};
+	};
+
+	hym8563: hym8563@51 {
+		compatible = "haoyu,hym8563";
+		reg = <0x51>;
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		clock-output-names = "hym8563";
+		//pinctrl-names = "default";
+		//pinctrl-0 = <&hym8563_int>;
+		//interrupt-parent = <&gpio0>;
+		//interrupts = <RK_PB0 IRQ_TYPE_LEVEL_LOW>;
+		//wakeup-source;
+		status = "okay";
+	};
+};
+
+&i2c7 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c7m0_xfer>;
+
+	es8388: es8388@11 {
+		status = "okay";
+		#sound-dai-cells = <0>;
+		compatible = "everest,es8388", "everest,es8323";
+		reg = <0x11>;
+		clocks = <&mclkout_i2s0>;
+		clock-names = "mclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s0_mclk>;
+	};
+};
+
+// ES8388 Sound
+&i2s0_8ch {
+	status = "okay";
+	pinctrl-0 = <&i2s0_lrck
+		     &i2s0_sclk
+		     &i2s0_sdi0
+		     &i2s0_sdo0>;
+};
+
+&i2s1_8ch {
+	status = "okay";
+	rockchip,i2s-tx-route = <3 2 1 0>;
+	rockchip,i2s-rx-route = <1 3 2 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2s1m0_sclk
+	             &i2s1m0_lrck
+	             &i2s1m0_sdi1
+	             &i2s1m0_sdo3>;
+};
+
+&i2s5_8ch {
+	status = "okay";
+};
+
+&iep {
+	status = "okay";
+};
+
+&iep_mmu {
+	status = "okay";
+};
+
+&jpegd {
+	status = "okay";
+};
+
+&jpegd_mmu {
+	status = "okay";
+};
+
+&jpege_ccu {
+	status = "okay";
+};
+
+&jpege0 {
+	status = "okay";
+};
+
+&jpege0_mmu {
+	status = "okay";
+};
+
+&jpege1 {
+	status = "okay";
+};
+
+&jpege1_mmu {
+	status = "okay";
+};
+
+&jpege2 {
+	status = "okay";
+};
+
+&jpege2_mmu {
+	status = "okay";
+};
+
+&jpege3 {
+	status = "okay";
+};
+
+&jpege3_mmu {
+	status = "okay";
+};
+
+/*
+ * mipi_dcphy0 needs to be enabled
+ * when dsi0 is enabled
+ */
+
+&mipi_dcphy0 {
+	status = "disabled";
+};
+
+&mpp_srv {
+	status = "okay";
+};
+
+// PCIE
+&pcie2x1l2 {
+	reset-gpios = <&gpio3 RK_PD1 GPIO_ACTIVE_HIGH>;
+	rockchip,skip-scan-in-resume;
+	pinctrl-names = "default";
+	pinctrl-0 = <&rtl8111_isolate>;
+	status = "okay";
+};
+
+&pinctrl {
+	backlight {
+		bl_en: bl-en {
+			rockchip,pins = <3 RK_PC1 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	dp {
+		dp0_hpd: dp0-hpd {
+			rockchip,pins = <1 RK_PD5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	headphone {
+		hp_det: hp-det {
+			rockchip,pins = <4 RK_PA7 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	hym8563 {
+		hym8563_int: hym8563-int {
+			rockchip,pins = <0 RK_PB0 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	lcd {
+		lcd_rst_gpio: lcd-rst-gpio {
+			rockchip,pins = <1 RK_PB0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	rtl8111 {
+		rtl8111_isolate: rtl8111-isolate {
+			rockchip,pins = <3 RK_PD1 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+// ANDROID
+//	sdio-pwrseq {
+//		wifi_enable_h: wifi-enable-h {
+//			rockchip,pins = <0 RK_PC7 RK_FUNC_GPIO &pcfg_pull_up>;
+//		};
+//	};
+
+	tp_irq {
+		tp_irq_gpio: tp-irq-gpio {
+			rockchip,pins = <0 RK_PD5 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+		tp_rst_gpio: tp-rst-gpio {
+			rockchip,pins = <3 RK_PC2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	usb {
+		//vcc5v0_host_en: vcc5v0-host-en {
+		//	rockchip,pins = <1 RK_PB1 RK_FUNC_GPIO &pcfg_pull_none>;
+		//};
+	};
+
+	usb-typec {
+		usbc0_int: usbc0-int {
+			rockchip,pins = <0 RK_PC4 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		// CAN I ENABLE THIS?
+		//typec5v_pwren: typec5v-pwren {
+		//	rockchip,pins = <1 RK_PA1 RK_FUNC_GPIO &pcfg_pull_none>;
+		//};
+	};
+
+	wireless-bluetooth {
+		bt_reset_gpio: bt-reset-gpio {
+			rockchip,pins = <0 RK_PD4 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		bt_wake_gpio: bt-wake-gpio {
+			rockchip,pins = <0 RK_PC6 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		bt_wake_host_irq: bt-wake-host-irq {
+			rockchip,pins = <0 RK_PC5 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+
+		uart9_gpios: uart9-gpios {
+			rockchip,pins = <3 RK_PD2 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	wireless-wlan {
+		wifi_host_wake_irq: wifi-host-wake-irq {
+			rockchip,pins = <0 RK_PA0 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+
+		wifi_poweren_gpio: wifi-poweren-gpio {
+			rockchip,pins = <0 RK_PC7 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+};
+
+&pwm14 {
+	status = "okay";
+	pinctrl-names = "active";
+	pinctrl-0 = <&pwm14m1_pins>;
+};
+
+&rga2 {
+	status = "okay";
+};
+
+&rga3_core0 {
+	status = "okay";
+};
+
+&rga3_0_mmu {
+	status = "okay";
+};
+
+&rga3_core1 {
+	status = "okay";
+};
+
+&rga3_1_mmu {
+	status = "okay";
+};
+
+&rknpu {
+	rknpu-supply = <&vdd_npu_s0>;
+	mem-supply = <&vdd_npu_mem_s0>;
+	status = "okay";
+};
+
+&rknpu_mmu {
+	status = "okay";
+};
+
+&rkvdec_ccu {
+	status = "okay";
+};
+
+&rkvdec0 {
+	status = "okay";
+};
+
+&rkvdec0_mmu {
+	status = "okay";
+};
+
+&rkvdec1 {
+	status = "okay";
+};
+
+&rkvdec1_mmu {
+	status = "okay";
+};
+
+&rkvenc_ccu {
+	status = "okay";
+};
+
+&rkvenc0 {
+	status = "okay";
+};
+
+&rkvenc0_mmu {
+	status = "okay";
+};
+
+&rkvenc1 {
+	status = "okay";
+};
+
+&rkvenc1_mmu {
+	status = "okay";
+};
+
+&rockchip_suspend {
+	status = "okay";
+	rockchip,sleep-debug-en = <1>;
+};
+
+&route_dp0 {
+	status = "okay";
+	connect = <&vp2_out_dp0>;
+};
+
+&route_dsi0 {
+	status = "disabled";
+	connect = <&vp3_out_dsi0>;
+};
+
+&route_hdmi0{
+        status = "okay";
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vcc_1v8_s0>;
+};
+
+// EMMC
+&sdhci {
+	bus-width = <8>;
+	no-sdio;
+	no-sd;
+	non-removable;
+	max-frequency = <200000000>;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	status = "okay";
+};
+
+// WLAN
+&sdio {
+	max-frequency = <100000000>;
+	no-sd;
+	no-mmc;
+	bus-width = <4>;
+	disable-wp;
+	cap-sd-highspeed;
+	cap-sdio-irq;
+	keep-power-in-suspend;
+	// mmc-pwrseq = <&sdio_pwrseq>; //ANDROID
+	non-removable;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdiom1_pins>;
+	// sd-uhs-sdr104; // commented out for sd card stability
+	status = "okay";
+};
+
+// SD
+&sdmmc {
+	max-frequency = <150000000>;
+	no-sdio;
+	no-mmc;
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	sd-uhs-sdr104;
+	//vmmc-supply = <&vcc_3v3_sd_s0>;
+	vqmmc-supply = <&vccio_sd_s0>;
+	status = "okay";
+};
+
+&spi2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi2m2_cs0 &spi2m2_pins>;
+	num-cs = <1>;
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&uart0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0m2_xfer>;
+};
+
+&uart3 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart3m0_xfer>;
+};
+
+&uart4 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart4m0_xfer>;
+};
+
+&uart5 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart5m1_xfer>;
+};
+
+&uart6 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart6m1_xfer>;
+};
+
+&uart7 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart7m2_xfer>;
+};
+
+// BT UART
+&uart9 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart9m2_xfer &uart9m2_ctsn>;
+};
+
+&u2phy0 {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	rockchip,typec-vbus-det;
+};
+
+&u2phy2 {
+	status = "okay";
+	rockchip,typec-vbus-det;
+};
+
+&u2phy2_host {
+	status = "okay";
+};
+
+&u2phy3 {
+	status = "okay";
+};
+
+&u2phy3_host {
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+// #USB3.1/DP PHY0
+&usbdp_phy0 {
+    status = "okay";
+	orientation-switch;
+	svid = <0xff01>;
+	sbu1-dc-gpios = <&gpio4 RK_PA0 GPIO_ACTIVE_HIGH>;
+	sbu2-dc-gpios = <&gpio4 RK_PA1 GPIO_ACTIVE_HIGH>;
+	rockchip,dp-lane-mux = <2 3>;
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		usbdp_phy0_orientation_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_orien_sw>;
+		};
+
+		usbdp_phy0_dp_altmode_mux: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&dp_altmode_mux>;
+		};
+	};
+};
+
+&usbdp_phy0_dp {
+	status = "okay";
+};
+
+&usbdp_phy0_u3 {
+	status = "okay";
+};
+
+&usbdrd3_0 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	dr_mode = "otg";
+    status = "okay";
+	usb-role-switch;
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		dwc3_0_role_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_role_sw>;
+		};
+	};
+};
+
+&usbhost3_0 {
+	status = "okay";
+};
+
+&usbhost_dwc3_0 {
+	status = "okay";
+};
+
+&vdpu {
+	status = "okay";
+};
+
+&vdpu_mmu {
+	status = "okay";
+};
+
+&vepu {
+	status = "okay";
+};
+
+&vop {
+	status = "okay";
+	disable-win-move;
+};
+
+&vop_mmu {
+	status = "okay";
+};
+
+/* vp0 & vp1 splice for 8K output */
+&vp0 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER0>;
+	cursor-win-id = <ROCKCHIP_VOP2_ESMART0>;
+};
+
+&vp1 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER1>;
+	cursor-win-id = <ROCKCHIP_VOP2_ESMART1>;
+};
+
+&vp2 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER2 | 1 << ROCKCHIP_VOP2_ESMART2)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER2>;
+	cursor-win-id = <ROCKCHIP_VOP2_ESMART2>;
+};
+
+&vp3 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER2>;
+	cursor-win-id = <ROCKCHIP_VOP2_ESMART2>;
+};
+
+/* pin 40 pwm fan control */
+&pwm15 {
+        pinctrl-0 = <&pwm15m1_pins>;
+        status = "okay";
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-khadas-edge2-camera.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-khadas-edge2-camera.dtsi
@@ -0,0 +1,492 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2023 Wesion Technology Co., Ltd.
+ *
+ */
+
+&csi2_dcphy0 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi_in_dcphy0: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&imx415b_out0>;
+				data-lanes = <1 2 3 4>;
+			};
+		};
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			csidcphy0_out: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&mipi0_csi2_input>;
+			};
+		};
+	};
+};
+
+&mipi_dcphy0 {
+	status = "okay";
+};
+
+&csi2_dcphy1 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi_in_dcphy1: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&imx415f_out1>;
+				data-lanes = <1 2 3 4>;
+			};
+		};
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			csidcphy1_out: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&mipi1_csi2_input>;
+			};
+		};
+	};
+};
+
+&mipi_dcphy1 {
+	status = "okay";
+};
+
+&csi2_dphy0 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipidphy0_in_ucam0: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&imx415c_out0>;
+				data-lanes = <1 2 3 4>;
+			};
+		};
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			csidphy0_out: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&mipi2_csi2_input>;
+			};
+		};
+	};
+};
+
+&csi2_dphy0_hw {
+	status = "okay";
+};
+
+&i2c4 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c4m3_xfer>;
+
+	dw9714b: dw9714b@c {
+		compatible = "dongwoon,dw9714";
+		status = "okay";
+		reg = <0x0c>;
+		pinctrl-names = "focusb_gpios";
+		pinctrl-0 = <&focusb_gpio>;
+		focus-gpios = <&gpio1 RK_PA0 GPIO_ACTIVE_HIGH>;
+		rockchip,vcm-start-current = <20>;
+		rockchip,vcm-rated-current = <76>;
+		rockchip,vcm-step-mode = <0>;
+		rockchip,camera-module-index = <0>;
+		rockchip,camera-module-facing = "back";
+	};
+
+	imx415b: imx415b@1a {
+		compatible = "sony,imx415";
+		status = "okay";
+		reg = <0x1a>;
+		clocks = <&cru CLK_MIPI_CAMARAOUT_M1>;
+		clock-names = "xvclk";
+		power-domains = <&power RK3588_PD_VI>;
+		pinctrl-names = "default", "camb_gpios";
+		pinctrl-0 = <&mipim1_camera1_clk>, <&camb_gpio>;
+		rockchip,grf = <&sys_grf>;
+		reset-gpios = <&gpio1 RK_PB2 GPIO_ACTIVE_LOW>;
+		pwdn-gpios = <&gpio1 RK_PB3 GPIO_ACTIVE_HIGH>;
+		rockchip,camera-module-index = <0>;
+		rockchip,camera-module-facing = "back";
+		rockchip,camera-module-name = "CMK-OT2022-PX1";
+		rockchip,camera-module-lens-name = "IR0147-50IRC-8M-F20";
+		lens-focus = <&dw9714b>;
+		port {
+			imx415b_out0: endpoint {
+				remote-endpoint = <&mipi_in_dcphy0>;
+				data-lanes = <1 2 3 4>;
+			};
+		};
+	};
+};
+
+&i2c3 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c3m0_xfer>;
+
+	dw9714f: dw9714f@c {
+		compatible = "dongwoon,dw9714";
+		status = "okay";
+		reg = <0x0c>;
+		pinctrl-names = "focusf_gpios";
+		pinctrl-0 = <&focusf_gpio>;
+		focus-gpios = <&gpio1 RK_PA1 GPIO_ACTIVE_HIGH>;
+		rockchip,vcm-start-current = <20>;
+		rockchip,vcm-rated-current = <76>;
+		rockchip,vcm-step-mode = <0>;
+		rockchip,camera-module-index = <1>;
+		rockchip,camera-module-facing = "front";
+	};
+
+	imx415f: imx415f@1a {
+		compatible = "sony,imx415";
+		status = "okay";
+		reg = <0x1a>;
+		clocks = <&cru CLK_MIPI_CAMARAOUT_M2>;
+		clock-names = "xvclk";
+		power-domains = <&power RK3588_PD_VI>;
+		pinctrl-names = "default", "camf_gpios";
+		pinctrl-0 = <&mipim1_camera2_clk>, <&camf_gpio>;
+		rockchip,grf = <&sys_grf>;
+		reset-gpios = <&gpio3 RK_PC6 GPIO_ACTIVE_LOW>;
+		pwdn-gpios = <&gpio3 RK_PC5 GPIO_ACTIVE_HIGH>;
+		rockchip,camera-module-index = <1>;
+		rockchip,camera-module-facing = "front";
+		rockchip,camera-module-name = "CMK-OT2022-PX1";
+		rockchip,camera-module-lens-name = "IR0147-50IRC-8M-F20";
+		lens-focus = <&dw9714f>;
+		port {
+			imx415f_out1: endpoint {
+				remote-endpoint = <&mipi_in_dcphy1>;
+				data-lanes = <1 2 3 4>;
+			};
+		};
+	};
+};
+
+&i2c8 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c8m2_xfer>;
+
+	dw9714c: dw9714c@c {
+		compatible = "dongwoon,dw9714";
+		status = "okay";
+		reg = <0x0c>;
+		pinctrl-names = "focusc_gpios";
+		pinctrl-0 = <&focusc_gpio>;
+		focus-gpios = <&gpio1 RK_PA6 GPIO_ACTIVE_HIGH>;
+		rockchip,vcm-start-current = <20>;
+		rockchip,vcm-rated-current = <76>;
+		rockchip,vcm-step-mode = <0>;
+		rockchip,camera-module-index = <0>;
+		rockchip,camera-module-facing = "back";
+	};
+
+	imx415: imx415@1a {
+		compatible = "sony,imx415";
+		reg = <0x1a>;
+		clocks = <&cru CLK_MIPI_CAMARAOUT_M3>;
+		clock-names = "xvclk";
+		pinctrl-names = "default", "camc_gpios";
+		pinctrl-0 = <&mipim1_camera3_clk>, <&camc_gpio>;
+		power-domains = <&power RK3588_PD_VI>;
+		reset-gpios = <&gpio3 RK_PB4 GPIO_ACTIVE_LOW>;
+		pwdn-gpios = <&gpio1 RK_PA4 GPIO_ACTIVE_HIGH>;
+		rockchip,camera-module-index = <0>;
+		rockchip,camera-module-facing = "back";
+		rockchip,camera-module-name = "CMK-OT2022-PX1";
+		rockchip,camera-module-lens-name = "IR0147-50IRC-8M-F20";
+		lens-focus = <&dw9714c>;
+		port {
+			imx415c_out0: endpoint {
+				remote-endpoint = <&mipidphy0_in_ucam0>;
+				data-lanes = <1 2 3 4>;
+			};
+		};
+	};
+};
+
+&pinctrl {
+	cam {
+		camf_gpio: camf-gpio {
+			rockchip,pins =
+				<3 RK_PC6 RK_FUNC_GPIO &pcfg_pull_none>,
+				<3 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		camb_gpio: camb-gpio {
+			rockchip,pins =
+				<1 RK_PB2 RK_FUNC_GPIO &pcfg_pull_none>,
+				<1 RK_PB3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		camc_gpio: camc-gpio {
+			rockchip,pins =
+				<3 RK_PB4 RK_FUNC_GPIO &pcfg_pull_none>,
+				<1 RK_PA4 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		focusb_gpio: focusb-gpio {
+			rockchip,pins =
+				<1 RK_PA0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		focusf_gpio: focusf-gpio {
+			rockchip,pins =
+				<1 RK_PA1 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		focusc_gpio: focusc-gpio {
+			rockchip,pins =
+				<1 RK_PA6 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+};
+
+&mipi0_csi2 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi0_csi2_input: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&csidcphy0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi0_csi2_output: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&cif_mipi_in0>;
+			};
+		};
+	};
+};
+
+&mipi1_csi2 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi1_csi2_input: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&csidcphy1_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi1_csi2_output: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&cif_mipi_in1>;
+			};
+		};
+	};
+};
+
+&mipi2_csi2 {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi2_csi2_input: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&csidphy0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi2_csi2_output: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&cif_mipi2_in0>;
+			};
+		};
+	};
+};
+
+&rkcif {
+	status = "okay";
+};
+
+&rkcif_mipi_lvds {
+	status = "okay";
+
+	port {
+		cif_mipi_in0: endpoint {
+			remote-endpoint = <&mipi0_csi2_output>;
+		};
+	};
+};
+
+&rkcif_mipi_lvds_sditf {
+	status = "okay";
+
+	port {
+		mipi_lvds_sditf: endpoint {
+			remote-endpoint = <&isp0_vir0>;
+		};
+	};
+};
+
+&rkcif_mipi_lvds1 {
+	status = "okay";
+
+	port {
+		cif_mipi_in1: endpoint {
+			remote-endpoint = <&mipi1_csi2_output>;
+		};
+	};
+};
+
+&rkcif_mipi_lvds1_sditf {
+	status = "okay";
+
+	port {
+		mipi1_lvds_sditf: endpoint {
+			remote-endpoint = <&isp0_vir1>;
+		};
+	};
+};
+
+&rkcif_mipi_lvds2 {
+	status = "okay";
+
+	port {
+		cif_mipi2_in0: endpoint {
+			remote-endpoint = <&mipi2_csi2_output>;
+		};
+	};
+};
+
+&rkcif_mipi_lvds2_sditf {
+	status = "okay";
+
+	port {
+		mipi_lvds2_sditf: endpoint {
+			remote-endpoint = <&isp1_vir0>;
+		};
+	};
+};
+
+&rkcif_mmu {
+	status = "okay";
+};
+
+&rkisp0 {
+	status = "okay";
+
+};
+
+&isp0_mmu {
+	status = "okay";
+};
+
+&rkisp0_vir0 {
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		isp0_vir0: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&mipi_lvds_sditf>;
+		};
+	};
+};
+
+&rkisp0_vir1 {
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		isp0_vir1: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&mipi1_lvds_sditf>;
+		};
+	};
+};
+
+&rkisp1 {
+	status = "okay";
+};
+
+&isp1_mmu {
+	status = "okay";
+};
+
+&rkisp1_vir0 {
+	status = "okay";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		isp1_vir0: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&mipi_lvds2_sditf>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-khadas-edge2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-khadas-edge2.dts
@@ -0,0 +1,943 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2023 Wesion Technology Co., Ltd.
+ *
+ */
+
+/dts-v1/;
+
+#include "dt-bindings/usb/pd.h"
+#include "rk3588s.dtsi"
+#include "rk3588s-khadas-edge2.dtsi"
+#include "rk3588-rk806-single-khadas.dtsi"
+#include "rk3588-linux.dtsi"
+#include "rk3588s-khadas-edge2-camera.dtsi"
+
+/ {
+	model = "Khadas Edge2";
+	compatible = "khadas,edge2", "rockchip,rk3588";
+	/delete-node/ chosen;
+
+	combophy_avdd0v85: combophy-avdd0v85 {
+		compatible = "regulator-fixed";
+		regulator-name = "combophy_avdd0v85";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <850000>;
+		regulator-max-microvolt = <850000>;
+		vin-supply = <&vdd_0v85_s0>;
+	};
+
+	combophy_avdd1v8: combophy-avdd1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "combophy_avdd1v8";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&avcc_1v8_s0>;
+	};
+
+	sound_micarray: sound-micarray {
+		status = "okay";
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,name = "rockchip,sound-micarray";
+		simple-audio-card,mclk-fs = <256>;
+		simple-audio-card,dai-link@0 {
+			format = "pdm";
+			cpu {
+				sound-dai = <&pdm0>;
+			};
+			codec {
+				sound-dai = <&dummy_codec>;
+			};
+		};
+	};
+
+	dummy_codec: dummy-codec {
+		compatible = "rockchip,dummy-codec";
+		#sound-dai-cells = <0>;
+		status = "okay";
+	};
+
+	es8316_sound: es8316-sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <256>;
+		simple-audio-card,name = "rockchip,es8316-codec";
+		simple-audio-card,dai-link@0 {
+			format = "i2s";
+			cpu {
+				sound-dai = <&i2s0_8ch>;
+			};
+			codec {
+				sound-dai = <&es8316>;
+			};
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 = <&red_led_gpio &green_led_gpio &blue_led_gpio>;
+
+		red_led {
+			gpios = <&gpio4 RK_PB4 GPIO_ACTIVE_HIGH>;
+			label = "red_led";
+			linux,default-trigger = "none";
+			default-state = "off";
+		};
+
+		green_led {
+			gpios = <&gpio4 RK_PB2 GPIO_ACTIVE_HIGH>;
+			label = "green_led";
+			linux,default-trigger = "default-on";
+			default-state = "on";
+		};
+
+		blue_led {
+			gpios = <&gpio4 RK_PB3 GPIO_ACTIVE_HIGH>;
+			label = "blue_led";
+			linux,default-trigger = "none";
+			default-state = "off";
+		};
+	};
+
+	khadas_wdt {
+		compatible = "linux,wdt-khadas";
+		status = "okay";
+		hw_margin_ms = <500>;
+		hw-gpios = <&gpio0 RK_PB0 GPIO_ACTIVE_HIGH>;
+	};
+
+	vbus5v0_typec: vbus5v0-typec {
+		compatible = "regulator-fixed";
+		regulator-name = "vbus5v0_typec";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio3 RK_PA4 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_usb>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&typec5v_pwren>;
+	};
+
+	vcc3v3_pcie20: vcc3v3-pcie20 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_pcie20";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		gpios = <&gpio0 RK_PC4 GPIO_ACTIVE_HIGH>;
+		startup-delay-us = <5000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_host: vcc5v0-host {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_host";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio1 RK_PB1 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_usb>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_host_en>;
+	};
+
+	vcc_sd: vcc-sd {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_sd";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		gpio = <&gpio1 RK_PB6 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc_3v3_s3>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc_sd_en>;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	wireless_bluetooth: wireless-bluetooth {
+		compatible = "bluetooth-platdata";
+		clocks = <&pt7c4363>;
+		clock-names = "ext_clock";
+		uart_rts_gpios = <&gpio3 RK_PD2 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default", "rts_gpio";
+		pinctrl-0 = <&uart9m2_rtsn>, <&bt_gpio>;
+		pinctrl-1 = <&uart9_gpios>;
+		BT,reset_gpio    = <&gpio0 RK_PD4 GPIO_ACTIVE_HIGH>;
+		BT,wake_gpio     = <&gpio0 RK_PD3 GPIO_ACTIVE_HIGH>;
+		BT,wake_host_irq = <&gpio0 RK_PD5 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	bt-sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "dsp_a";
+		simple-audio-card,bitclock-inversion = <1>;
+		simple-audio-card,mclk-fs = <256>;
+		simple-audio-card,name = "rockchip,bt";
+		simple-audio-card,cpu {
+			sound-dai = <&i2s2_2ch>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&bt_sco>;
+		};
+	};
+
+	bt_sco: bt-sco {
+		compatible = "delta,dfbmcs320";
+		#sound-dai-cells = <0>;
+		status = "okay";
+	};
+
+	wireless_wlan: wireless-wlan {
+		compatible = "wlan-platdata";
+		wifi_chip_type = "ap6275p";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_host_wake_irq>;
+		WIFI,host_wake_irq = <&gpio0 RK_PA0 GPIO_ACTIVE_HIGH>;
+	//	WIFI,poweren_gpio = <&gpio0 RK_PC7 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	vcc3v3_lcd1_en: vcc3v3-lcd1-en {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_lcd1_en";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio4 RK_PA4 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-boot-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+
+	};
+
+	vcc3v3_lcd2_en: vcc3v3-lcd2-en {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_lcd2_en";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpio = <&gpio4 RK_PB0 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-boot-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+
+	};
+
+};
+
+&backlight_mipi0 {
+	pwms = <&pwm12 0 25000 0>;
+	power-supply = <&vcc3v3_lcd1_en>;
+	status = "okay";
+};
+
+&backlight_mipi1 {
+	pwms = <&pwm13 0 25000 0>;
+	power-supply = <&vcc3v3_lcd2_en>;
+	status = "disabled";
+};
+
+
+&combphy0_ps {
+	status = "okay";
+};
+
+&dp0 {
+	status = "okay";
+};
+
+&dp0_in_vp2 {
+	status = "okay";
+};
+
+&dp0_sound{
+	status = "okay";
+};
+
+&dsi0 {
+	status = "disabled";
+	reset-delay-ms = <20>;
+	reset-gpios = <&gpio4 RK_PA3 GPIO_ACTIVE_HIGH>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&lcd1_rst_gpio>;
+
+};
+
+&dsi0_panel {
+	status = "okay";
+	power-supply = <&vcc3v3_lcd1_en>;
+};
+
+&dsi0_in_vp2 {
+	status = "disabled";
+};
+
+&dsi0_in_vp3 {
+	status = "okay";
+};
+
+&hdmi0_sound {
+	status = "okay";
+};
+
+&route_dsi0 {
+	status = "okay";
+	connect = <&vp3_out_dsi0>;
+};
+
+&mipi_dcphy0 {
+	status = "okay";
+};
+
+&dsi1 {
+	reset-delay-ms = <20>;
+	reset-gpios = <&gpio4 RK_PA7 GPIO_ACTIVE_HIGH>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&lcd2_rst_gpio1>;
+	status = "disabled";
+};
+
+&dsi1_panel {
+	status = "disabled";
+	power-supply = <&vcc3v3_lcd2_en>;
+};
+
+&mipi_dcphy1 {
+	status = "okay";
+};
+
+&dsi1_in_vp2 {
+	status = "disabled";
+};
+
+&dsi1_in_vp3 {
+	status = "disabled";
+};
+
+&route_dsi1 {
+	status = "disabled";
+	connect = <&vp3_out_dsi1>;
+};
+
+//&hdptxphy0 {
+	/* Single Vdiff Training Table for power reduction (optional) */
+//	training-table = /bits/ 8 <
+		/* voltage swing 0, pre-emphasis 0->3 */
+//		0x0d 0x00 0x00 0x00 0x00 0x00
+//		0x0d 0x00 0x00 0x00 0x00 0x00
+//		0x0d 0x00 0x00 0x00 0x00 0x00
+//		0x0d 0x00 0x00 0x00 0x00 0x00
+		/* voltage swing 1, pre-emphasis 0->2 */
+//		0x0d 0x00 0x00 0x00 0x00 0x00
+//		0x0d 0x00 0x00 0x00 0x00 0x00
+//		0x0d 0x00 0x00 0x00 0x00 0x00
+		/* voltage swing 2, pre-emphasis 0->1 */
+//		0x0d 0x00 0x00 0x00 0x00 0x00
+//		0x0d 0x00 0x00 0x00 0x00 0x00
+		/* voltage swing 3, pre-emphasis 0 */
+//		0x0d 0x00 0x00 0x00 0x00 0x00
+//	>;
+//	status = "okay";
+//};
+
+&hdmi0 {
+	enable-gpios = <&gpio4 RK_PB1 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+};
+
+&hdmi0_in_vp0 {
+	status = "okay";
+ };
+
+&hdptxphy_hdmi0 {
+	status = "okay";
+ };
+
+&i2s2_2ch {
+	status = "okay";
+};
+
+&i2c0 {
+    status = "okay";
+    pinctrl-names = "default";
+    pinctrl-0 = <&i2c0m2_xfer>;
+
+    vdd_cpu_big0_s0: vdd_cpu_big0_mem_s0: rk8602@42 {
+        compatible = "rockchip,rk8602";
+        reg = <0x42>;
+        vin-supply = <&vcc5v0_sys>;
+        regulator-compatible = "rk860x-reg";
+        regulator-name = "vdd_cpu_big0_s0";
+        regulator-min-microvolt = <550000>;
+        regulator-max-microvolt = <1050000>;
+        regulator-ramp-delay = <12500>;
+        rockchip,suspend-voltage-selector = <1>;
+        regulator-boot-on;
+        regulator-always-on;
+        regulator-state-mem {
+            regulator-off-in-suspend;
+        };
+    };
+
+    vdd_cpu_big1_s0: vdd_cpu_big1_mem_s0: rk8603@43 {
+        compatible = "rockchip,rk8603";
+        reg = <0x43>;
+        vin-supply = <&vcc5v0_sys>;
+        regulator-compatible = "rk860x-reg";
+        regulator-name = "vdd_cpu_big1_s0";
+        regulator-min-microvolt = <550000>;
+        regulator-max-microvolt = <1050000>;
+        regulator-ramp-delay = <12500>;
+        rockchip,suspend-voltage-selector = <1>;
+        regulator-boot-on;
+        regulator-always-on;
+        regulator-state-mem {
+            regulator-off-in-suspend;
+        };
+    };
+};
+
+&i2s5_8ch {
+	status = "okay";
+};
+
+&i2c2 {
+
+    status = "okay";
+
+    vdd_npu_s0: vdd_npu_mem_s0: rk8602@42 {
+        compatible = "rockchip,rk8602";
+        reg = <0x42>;
+        vin-supply = <&vcc5v0_sys>;
+        regulator-compatible = "rk860x-reg";
+        regulator-name = "vdd_npu_s0";
+        regulator-min-microvolt = <550000>;
+        regulator-max-microvolt = <950000>;
+        regulator-ramp-delay = <12500>;
+        rockchip,suspend-voltage-selector = <1>;
+        regulator-boot-on;
+        regulator-always-on;
+        regulator-state-mem {
+            regulator-off-in-suspend;
+        };
+    };
+
+    usbc0: fusb302@22 {
+        compatible = "fcs,fusb302";
+        reg = <0x22>;
+        interrupt-parent = <&gpio1>;
+        interrupts = <RK_PB5 IRQ_TYPE_LEVEL_LOW>;
+        int-n-gpios = <&gpio1 RK_PB5 GPIO_ACTIVE_LOW>;
+        pinctrl-names = "default";
+        pinctrl-0 = <&usbc0_int>;
+        vbus-supply = <&vbus5v0_typec>;
+        status = "okay";
+
+        ports {
+            #address-cells = <1>;
+            #size-cells = <0>;
+
+            port@0 {
+                reg = <0>;
+                usbc0_role_sw: endpoint@0 {
+                    remote-endpoint = <&dwc3_0_role_switch>;
+                };
+            };
+        };
+
+        usb_con: connector {
+            compatible = "usb-c-connector";
+            label = "USB-C";
+            data-role = "dual";
+            power-role = "dual";
+            try-power-role = "sink";
+            op-sink-microwatt = <1000000>;
+            sink-pdos =
+                <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)
+                 PDO_FIXED(9000, 3000, PDO_FIXED_USB_COMM)
+                 PDO_FIXED(12000, 3000, PDO_FIXED_USB_COMM)>;
+            source-pdos =
+                <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
+
+            altmodes {
+                #address-cells = <1>;
+                #size-cells = <0>;
+
+                altmode@0 {
+                    reg = <0>;
+                    svid = <0xff01>;
+                    vdo = <0xffffffff>;
+                };
+            };
+
+             ports {
+                #address-cells = <1>;
+                #size-cells = <0>;
+
+                port@0 {
+                    reg = <0>;
+                    usbc0_orien_sw: endpoint {
+                        remote-endpoint = <&usbdp_phy0_orientation_switch>;
+                    };
+                };
+
+                port@1 {
+                    reg = <1>;
+                    dp_altmode_mux: endpoint {
+                        remote-endpoint = <&usbdp_phy0_dp_altmode_mux>;
+                    };
+                };
+            };
+        };
+    };
+
+    pt7c4363: pt7c4363@51 {
+        compatible = "haoyu,hym8563";
+        reg = <0x51>;
+        #clock-cells = <0>;
+        clock-frequency = <32768>;
+        clock-output-names = "pt7c4363";
+        wakeup-source;
+    };
+
+    mcu: khadas-mcu@18 {
+        compatible = "khadas-mcu";
+        status = "okay";
+        reg = <0x18>;
+        fan,trig_temp_level0 = <50>;
+        fan,trig_temp_level1 = <60>;
+        fan,trig_temp_level2 = <70>;
+        fan,trig_temp_level3 = <80>;
+        hwver = "EDGE2.V11";
+
+    };
+};
+
+&reboot_mode {
+	mode-reboot_test = <BOOT_QUIESCENT>;
+};
+
+&i2c3 {
+	status = "okay";
+
+	gs_kxtj3: gs_kxtj3@e {
+		compatible = "gs_kxtj3";
+		reg = <0x0e>;
+		irq-gpio = <&gpio1 RK_PB0 IRQ_TYPE_EDGE_RISING>;
+		irq_enable = <0>;
+		poll_delay_ms = <30>;
+		type = <SENSOR_TYPE_ACCEL>;
+		layout = <0>;
+		status = "okay";
+	};
+
+	es8316: es8316@10 {
+		status = "okay";
+		#sound-dai-cells = <0>;
+		compatible = "everest,es8316";
+		reg = <0x10>;
+		clocks = <&mclkout_i2s0>;
+		clock-names = "mclk";
+		assigned-clocks = <&mclkout_i2s0>;
+		assigned-clock-rates = <12288000>;
+		pinctrl-names = "default","hp_det","spk_con";
+		pinctrl-0 = <&i2s0_mclk>,<&hp_det>,<&spk_con>;
+		spk-con-gpio = <&gpio1 RK_PD0 GPIO_ACTIVE_HIGH>;
+		hp-det-gpio = <&gpio1 RK_PD3 GPIO_ACTIVE_LOW>;
+	};
+
+};
+
+&i2c4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c4m3_xfer>;
+	status = "okay";
+};
+
+&i2c5 {
+	status = "disabled";
+
+	ls_stk3332: light@47 {
+		compatible = "ls_stk3332";
+		status = "disabled";
+		reg = <0x47>;
+		type = <SENSOR_TYPE_LIGHT>;
+		irq_enable = <0>;
+		als_threshold_high = <100>;
+		als_threshold_low = <10>;
+		als_ctrl_gain = <2>; /* 0:x1 1:x4 2:x16 3:x64 */
+		poll_delay_ms = <100>;
+	};
+
+	ps_stk3332: proximity@47 {
+		compatible = "ps_stk3332";
+		status = "disabled";
+		reg = <0x47>;
+		type = <SENSOR_TYPE_PROXIMITY>;
+		//pinctrl-names = "default";
+		//pinctrl-0 = <&gpio3_c6>;
+		//irq-gpio = <&gpio3 RK_PC6 IRQ_TYPE_LEVEL_LOW>;
+		//irq_enable = <1>;
+		ps_threshold_high = <0x200>;
+		ps_threshold_low = <0x100>;
+		ps_ctrl_gain = <3>; /* 0:x1 1:x2 2:x5 3:x8 */
+		ps_led_current = <4>; /* 0:3.125mA 1:6.25mA 2:12.5mA 3:25mA 4:50mA 5:100mA*/
+		poll_delay_ms = <100>;
+	};
+
+	mpu6500_acc: mpu_acc@68 {
+		compatible = "mpu6500_acc";
+		reg = <0x68>;
+		irq-gpio = <&gpio3 RK_PB4 IRQ_TYPE_EDGE_RISING>;
+		irq_enable = <0>;
+		poll_delay_ms = <30>;
+		type = <SENSOR_TYPE_ACCEL>;
+		layout = <5>;
+	};
+
+	mpu6500_gyro: mpu_gyro@68 {
+		compatible = "mpu6500_gyro";
+		reg = <0x68>;
+		poll_delay_ms = <30>;
+		type = <SENSOR_TYPE_GYROSCOPE>;
+		layout = <5>;
+	};
+};
+
+&i2c6 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c6m0_xfer>;
+
+	ft5336@38 {
+		compatible = "edt,edt-ft5336", "ft5x06";
+		reg = <0x38>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PC6 IRQ_TYPE_EDGE_FALLING>;
+		reset-gpio = <&gpio0 RK_PC5 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&tp_rst_gpio>;
+		status = "okay";
+	};
+
+	gt9xx: gt9xx@14 {
+			   compatible = "goodix,gt9xx";
+			   reg = <0x14>;
+			   touch-gpio = <&gpio0 RK_PC6 IRQ_TYPE_LEVEL_LOW>;
+			   reset-gpio = <&gpio0 RK_PC5 GPIO_ACTIVE_HIGH>;
+			   max-x = <1920>;
+			   max-y = <1200>;
+			   tp-size = <89>;
+	};
+
+};
+
+&pcie2x1l1 {
+//	reset-gpios = <&gpio4 RK_PA2 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_pcie20>;
+	status = "disabled";
+};
+
+&pcie2x1l2 {
+//	reset-gpios = <&gpio4 RK_PC1 GPIO_ACTIVE_HIGH>;
+	reset-gpios = <&gpio3 RK_PD1 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_pcie20>;
+	rockchip,skip-scan-in-resume;
+	status = "okay";
+};
+
+&pdm0 {
+	pinctrl-names = "default";
+    pinctrl-0 = <&pdm0m0_clk
+    &pdm0m0_clk1
+    &pdm0m0_sdi0
+    &pdm0m0_sdi1
+    &pdm0m0_sdi2>;
+    rockchip,path-map = <0 1 2 3>;
+    status = "okay";
+};
+
+&pinctrl {
+	audio {
+		hp_det: hp-det {
+			rockchip,pins = <1 RK_PD3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		spk_con: spk-con {
+			rockchip,pins = <1 RK_PD0 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	lcd {
+		lcd1_rst_gpio: lcd1-rst-gpio {
+			rockchip,pins = <4 RK_PA3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+		lcd2_rst_gpio1: lcd2-rst-gpio1 {
+			rockchip,pins = <4 RK_PA7 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	leds {
+		red_led_gpio: red-led-gpio {
+			rockchip,pins = <4 RK_PB4 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		green_led_gpio: green-led-gpio {
+			rockchip,pins = <4 RK_PB2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		blue_led_gpio: blue-led-gpio {
+			rockchip,pins = <4 RK_PB3 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	usb {
+		vcc5v0_host_en: vcc5v0-host-en {
+			rockchip,pins = <1 RK_PB1 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	vcc_sd {
+		vcc_sd_en: vcc-sd-en {
+			rockchip,pins = <1 RK_PB6 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	usb-typec {
+		usbc0_int: usbc0-int {
+			rockchip,pins = <1 RK_PB5 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		typec5v_pwren: typec5v-pwren {
+			rockchip,pins = <3 RK_PA4 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	ft5336 {
+		tp_rst_gpio: tp-rst-gpio {
+			rockchip,pins = <0 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>;
+       };
+   };
+
+	wireless-bluetooth {
+		uart9_gpios: uart9-gpios {
+			rockchip,pins = <3 RK_PD2 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		bt_gpio: bt-gpio {
+			rockchip,pins =
+				<0 RK_PD4 RK_FUNC_GPIO &pcfg_pull_none>,
+				<0 RK_PD3 RK_FUNC_GPIO &pcfg_pull_up>,
+				<0 RK_PD5 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	wireless-wlan {
+		wifi_host_wake_irq: wifi-host-wake-irq {
+			rockchip,pins = <0 RK_PA0 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+
+	//	wifi_poweren_gpio: wifi-poweren-gpio {
+	//		rockchip,pins = <0 RK_PC7 RK_FUNC_GPIO &pcfg_pull_up>;
+	//	};
+	};
+};
+
+&pwm3 {
+	compatible = "rockchip,remotectl-pwm";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm3m3_pins>;
+	remote_pwm_id = <3>;
+	handle_cpu_id = <1>;
+	remote_support_psci = <0>;
+	status = "okay";
+
+	ir_key1 {
+		rockchip,usercode = <0xff00>;
+		rockchip,key_table =
+			<0xeb KEY_POWER>,
+			<0xec KEY_MENU>,
+			<0xfc KEY_UP>,
+			<0xfd KEY_DOWN>,
+			<0xf1 KEY_LEFT>,
+			<0xe5 KEY_RIGHT>,
+			<0xf8 KEY_ENTER>,
+			<0xa7 KEY_VOLUMEDOWN>,
+			<0xa3 388>,
+			<0xa4 388>,
+			<0xf4 KEY_VOLUMEUP>,
+			<0xfe KEY_BACK>,
+			<0xb7 KEY_HOMEPAGE>;
+	};
+};
+
+&pwm7 {
+	pinctrl-0 = <&pwm7m0_pins>;
+	status = "disabled";
+};
+
+&pwm12 {
+	pinctrl-0 = <&pwm12m1_pins>;
+	status = "okay";
+};
+
+&pwm13 {
+	pinctrl-0 = <&pwm13m1_pins>;
+	status = "okay";
+};
+
+
+&rockchip_suspend {
+
+    rockchip,sleep-mode-config = <
+		(0
+		| RKPM_SLP_ARMOFF_DDRPD
+		| RKPM_SLP_PMU_PMUALIVE_32K
+		| RKPM_SLP_PMU_DIS_OSC
+		| RKPM_SLP_32K_EXT
+		| RKPM_SLP_PMU_DBG
+		)
+	>;
+};
+
+&route_hdmi0 {
+    status = "okay";
+    connect = <&vp0_out_hdmi0>;
+    /delete-property/ force-output;
+    /delete-node/ force_timing;
+};
+
+&sdmmc {
+	status = "okay";
+	card-detect-delay = <1200>;
+};
+
+&sfc {
+	pinctrl-names = "default";
+	pinctrl-0 = <&fspim2_pins>;
+	status = "okay";
+};
+
+&spdif_tx1 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spdif1m1_tx>;
+};
+
+&spdif_tx1_dc {
+	status = "disabled";
+};
+
+&spdif_tx1_sound {
+	status = "disabled";
+};
+
+&spdif_tx2 {
+	status = "okay";
+};
+
+&spi1 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi1m1_cs0 &spi1m1_pins>;
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	rockchip,typec-vbus-det;
+};
+
+&u2phy2_host {
+	phy-supply = <&vcc5v0_host>;
+};
+
+&u2phy3_host {
+	phy-supply = <&vcc5v0_host>;
+};
+
+&uart9 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart9m2_xfer &uart9m2_ctsn>;
+};
+
+&usbdp_phy0 {
+	orientation-switch;
+	svid = <0xff01>;
+	sbu1-dc-gpios = <&gpio4 RK_PA0 GPIO_ACTIVE_HIGH>;
+	sbu2-dc-gpios = <&gpio4 RK_PA1 GPIO_ACTIVE_HIGH>;
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		usbdp_phy0_orientation_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_orien_sw>;
+		};
+
+		usbdp_phy0_dp_altmode_mux: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&dp_altmode_mux>;
+		};
+	};
+};
+
+&usbdrd_dwc3_0 {
+	usb-role-switch;
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		dwc3_0_role_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_role_sw>;
+		};
+	};
+};
+
+&usbhost3_0 {
+	status = "okay";
+};
+
+&usbhost_dwc3_0 {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&vdd_log_s0 {
+	regulator-state-mem {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <750000>;
+	};
+};
+
+&vcc_1v8_s0 {
+	/delete-property/ regulator-state-mem;
+	regulator-state-mem {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <1800000>;
+	};
+};
+
+&vcc_3v3_s0 {
+	/delete-property/ regulator-state-mem;
+	regulator-state-mem {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <3300000>;
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-khadas-edge2.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-khadas-edge2.dtsi
@@ -0,0 +1,1780 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2023 Wesion Technology Co., Ltd.
+ *
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/input/rk-input.h>
+#include <dt-bindings/display/drm_mipi_dsi.h>
+#include <dt-bindings/display/rockchip_vop.h>
+#include <dt-bindings/sensor-dev.h>
+
+/ {
+	adc_keys: adc-keys {
+		compatible = "adc-keys";
+		io-channels = <&saradc 1>;
+		io-channel-names = "buttons";
+		keyup-threshold-microvolt = <1800000>;
+		poll-interval = <100>;
+
+		home-key {
+			label = "home";
+			linux,code = <KEY_HOMEPAGE>;
+			press-threshold-microvolt = <17000>;
+		};
+	};
+
+	backlight_mipi0: backlight-mipi0 {
+		compatible = "pwm-backlight";
+		brightness-levels = <
+			  0  20  20  21  21  22  22  23
+			 23  24  24  25  25  26  26  27
+			 27  28  28  29  29  30  30  31
+			 31  32  32  33  33  34  34  35
+			 35  36  36  37  37  38  38  39
+			 40  41  42  43  44  45  46  47
+			 48  49  50  51  52  53  54  55
+			 56  57  58  59  60  61  62  63
+			 64  65  66  67  68  69  70  71
+			 72  73  74  75  76  77  78  79
+			 80  81  82  83  84  85  86  87
+			 88  89  90  91  92  93  94  95
+			 96  97  98  99 100 101 102 103
+			104 105 106 107 108 109 110 111
+			112 113 114 115 116 117 118 119
+			120 121 122 123 124 125 126 127
+			128 129 130 131 132 133 134 135
+			136 137 138 139 140 141 142 143
+			144 145 146 147 148 149 150 151
+			152 153 154 155 156 157 158 159
+			160 161 162 163 164 165 166 167
+			168 169 170 171 172 173 174 175
+			176 177 178 179 180 181 182 183
+			184 185 186 187 188 189 190 191
+			192 193 194 195 196 197 198 199
+			200 201 202 203 204 205 206 207
+			208 209 210 211 212 213 214 215
+			216 217 218 219 220 221 222 223
+			224 225 226 227 228 229 230 231
+			232 233 234 235 236 237 238 239
+			240 241 242 243 244 245 246 247
+			248 249 250 251 252 253 254 255
+		>;
+		default-brightness-level = <200>;
+	};
+
+	dp0_sound: dp0-sound {
+		status = "disabled";
+		compatible = "rockchip,hdmi";
+		rockchip,card-name= "rockchip,dp0";
+		rockchip,mclk-fs = <512>;
+		rockchip,cpu = <&spdif_tx2>;
+		rockchip,codec = <&dp0 1>;
+		rockchip,jack-det;
+	};
+
+	backlight_mipi1: backlight-mipi1 {
+        compatible = "pwm-backlight";
+        brightness-levels = <
+              0  20  20  21  21  22  22  23
+             23  24  24  25  25  26  26  27
+             27  28  28  29  29  30  30  31
+             31  32  32  33  33  34  34  35
+             35  36  36  37  37  38  38  39
+             40  41  42  43  44  45  46  47
+             48  49  50  51  52  53  54  55
+             56  57  58  59  60  61  62  63
+             64  65  66  67  68  69  70  71
+             72  73  74  75  76  77  78  79
+             80  81  82  83  84  85  86  87
+             88  89  90  91  92  93  94  95
+             96  97  98  99 100 101 102 103
+            104 105 106 107 108 109 110 111
+            112 113 114 115 116 117 118 119
+            120 121 122 123 124 125 126 127
+            128 129 130 131 132 133 134 135
+            136 137 138 139 140 141 142 143
+            144 145 146 147 148 149 150 151
+            152 153 154 155 156 157 158 159
+            160 161 162 163 164 165 166 167
+            168 169 170 171 172 173 174 175
+            176 177 178 179 180 181 182 183
+            184 185 186 187 188 189 190 191
+            192 193 194 195 196 197 198 199
+            200 201 202 203 204 205 206 207
+            208 209 210 211 212 213 214 215
+            216 217 218 219 220 221 222 223
+            224 225 226 227 228 229 230 231
+            232 233 234 235 236 237 238 239
+            240 241 242 243 244 245 246 247
+            248 249 250 251 252 253 254 255
+        >;
+        default-brightness-level = <200>;
+    };
+
+
+
+	hdmi0_sound: hdmi0-sound {
+		status = "disabled";
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <128>;
+		simple-audio-card,name = "rockchip,hdmi0";
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s5_8ch>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&hdmi0>;
+		};
+	};
+
+	spdif_tx1_dc: spdif-tx1-dc {
+		status = "disabled";
+		compatible = "linux,spdif-dit";
+		#sound-dai-cells = <0>;
+	};
+
+	spdif_tx1_sound: spdif-tx1-sound {
+		status = "disabled";
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "rockchip,spdif-tx1";
+		simple-audio-card,cpu {
+			sound-dai = <&spdif_tx1>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&spdif_tx1_dc>;
+		};
+	};
+
+	test-power {
+		status = "okay";
+	};
+
+	vcc12v_dcin: vcc12v-dcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc12v_dcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc_1v1_nldo_s3: vcc-1v1-nldo-s3 {
+        compatible = "regulator-fixed";
+        regulator-name = "vcc_1v1_nldo_s3";
+        regulator-always-on;
+        regulator-boot-on;
+        regulator-min-microvolt = <1100000>;
+        regulator-max-microvolt = <1100000>;
+        vin-supply = <&vcc5v0_sys>;
+    };
+
+	vcc5v0_usbdcin: vcc5v0-usbdcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_usbdcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_usb: vcc5v0-usb {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_usb";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc5v0_usbdcin>;
+	};
+};
+
+&av1d_mmu {
+	status = "okay";
+};
+
+&combphy0_ps {
+	status = "okay";
+};
+
+&combphy2_psu {
+	status = "okay";
+};
+
+&cpu_l0 {
+	cpu-supply = <&vdd_cpu_lit_s0>;
+	mem-supply = <&vdd_cpu_lit_mem_s0>;
+};
+
+&cpu_b0 {
+	cpu-supply = <&vdd_cpu_big0_s0>;
+	mem-supply = <&vdd_cpu_big0_mem_s0>;
+};
+
+&cpu_b2 {
+	cpu-supply = <&vdd_cpu_big1_s0>;
+	mem-supply = <&vdd_cpu_big1_mem_s0>;
+};
+
+&dsi0 {
+	status = "disabled";
+	//rockchip,lane-rate = <1000>;
+	dsi0_panel: panel@0 {
+		status = "okay";
+		compatible = "simple-panel-dsi";
+		reg = <0>;
+		backlight = <&backlight_mipi0>;
+	//	reset-delay-ms = <60>;
+		enable-delay-ms = <60>;
+		prepare-delay-ms = <60>;
+		unprepare-delay-ms = <60>;
+		disable-delay-ms = <60>;
+		dsi,flags = <(MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			MIPI_DSI_MODE_LPM | MIPI_DSI_MODE_EOT_PACKET)>;
+		dsi,format = <MIPI_DSI_FMT_RGB888>;
+		dsi,lanes  = <4>;
+		panel-init-sequence = [
+			15 00 02 FF 05
+			15 00 02 FB 01
+			15 64 02 C5 01
+			15 00 02 FF EE
+			15 00 02 FB 01
+			15 00 02 1F 45
+			15 00 02 24 4F
+			15 00 02 38 C8
+			15 00 02 39 27
+			15 00 02 1E 77
+			15 00 02 1D 0F
+			15 00 02 7E 71
+			15 00 02 7C 03
+			15 00 02 FF 00
+			15 00 02 FB 01
+			15 00 02 35 01
+			15 00 02 FF 01
+			15 00 02 FB 01
+			15 00 02 00 01
+			15 00 02 01 55
+			15 00 02 02 40
+			15 00 02 05 40
+			15 00 02 06 4A
+			15 00 02 07 24
+			15 00 02 08 0C
+			15 00 02 0B 7D
+			15 00 02 0C 7D
+			15 00 02 0E B0
+			15 00 02 0F AE
+			15 00 02 11 10
+			15 00 02 12 10
+			15 00 02 13 03
+			15 00 02 14 4A
+			15 00 02 15 12
+			15 00 02 16 12
+			15 00 02 18 00
+			15 00 02 19 77
+			15 00 02 1A 55
+			15 00 02 1B 13
+			15 00 02 1C 00
+			15 00 02 1D 00
+			15 00 02 1E 13
+			15 00 02 1F 00
+			15 00 02 23 00
+			15 00 02 24 00
+			15 00 02 25 00
+			15 00 02 26 00
+			15 00 02 27 00
+			15 00 02 28 00
+			15 00 02 35 00
+			15 00 02 66 00
+			15 00 02 58 82
+			15 00 02 59 02
+			15 00 02 5A 02
+			15 00 02 5B 02
+			15 00 02 5C 82
+			15 00 02 5D 82
+			15 00 02 5E 02
+			15 00 02 5F 02
+			15 00 02 72 31
+			15 00 02 FF 05
+			15 00 02 FB 01
+			15 00 02 00 01
+			15 00 02 01 0B
+			15 00 02 02 0C
+			15 00 02 03 09
+			15 00 02 04 0A
+			15 00 02 05 00
+			15 00 02 06 0F
+			15 00 02 07 10
+			15 00 02 08 00
+			15 00 02 09 00
+			15 00 02 0A 00
+			15 00 02 0B 00
+			15 00 02 0C 00
+			15 00 02 0D 13
+			15 00 02 0E 15
+			15 00 02 0F 17
+			15 00 02 10 01
+			15 00 02 11 0B
+			15 00 02 12 0C
+			15 00 02 13 09
+			15 00 02 14 0A
+			15 00 02 15 00
+			15 00 02 16 0F
+			15 00 02 17 10
+			15 00 02 18 00
+			15 00 02 19 00
+			15 00 02 1A 00
+			15 00 02 1B 00
+			15 00 02 1C 00
+			15 00 02 1D 13
+			15 00 02 1E 15
+			15 00 02 1F 17
+			15 00 02 20 00
+			15 00 02 21 03
+			15 00 02 22 01
+			15 00 02 23 40
+			15 00 02 24 40
+			15 00 02 25 ED
+			15 00 02 29 58
+			15 00 02 2A 12
+			15 00 02 2B 01
+			15 00 02 4B 06
+			15 00 02 4C 11
+			15 00 02 4D 20
+			15 00 02 4E 02
+			15 00 02 4F 02
+			15 00 02 50 20
+			15 00 02 51 61
+			15 00 02 52 01
+			15 00 02 53 63
+			15 00 02 54 77
+			15 00 02 55 ED
+			15 00 02 5B 00
+			15 00 02 5C 00
+			15 00 02 5D 00
+			15 00 02 5E 00
+			15 00 02 5F 15
+			15 00 02 60 75
+			15 00 02 61 00
+			15 00 02 62 00
+			15 00 02 63 00
+			15 00 02 64 00
+			15 00 02 65 00
+			15 00 02 66 00
+			15 00 02 67 00
+			15 00 02 68 04
+			15 00 02 69 00
+			15 00 02 6A 00
+			15 00 02 6C 40
+			15 00 02 75 01
+			15 00 02 76 01
+			15 00 02 7A 80
+			15 00 02 7B A3
+			15 00 02 7C D8
+			15 00 02 7D 60
+			15 00 02 7F 15
+			15 00 02 80 81
+			15 00 02 83 05
+			15 00 02 93 08
+			15 00 02 94 10
+			15 00 02 8A 00
+			15 00 02 9B 0F
+			15 00 02 EA FF
+			15 00 02 EC 00
+			15 00 02 FF 01
+			15 00 02 FB 01
+			15 00 02 75 00
+			15 00 02 76 DF
+			15 00 02 77 00
+			15 00 02 78 E4
+			15 00 02 79 00
+			15 00 02 7A ED
+			15 00 02 7B 00
+			15 00 02 7C F6
+			15 00 02 7D 00
+			15 00 02 7E FF
+			15 00 02 7F 01
+			15 00 02 80 07
+			15 00 02 81 01
+			15 00 02 82 10
+			15 00 02 83 01
+			15 00 02 84 18
+			15 00 02 85 01
+			15 00 02 86 20
+			15 00 02 87 01
+			15 00 02 88 3D
+			15 00 02 89 01
+			15 00 02 8A 56
+			15 00 02 8B 01
+			15 00 02 8C 84
+			15 00 02 8D 01
+			15 00 02 8E AB
+			15 00 02 8F 01
+			15 00 02 90 EC
+			15 00 02 91 02
+			15 00 02 92 22
+			15 00 02 93 02
+			15 00 02 94 23
+			15 00 02 95 02
+			15 00 02 96 55
+			15 00 02 97 02
+			15 00 02 98 8B
+			15 00 02 99 02
+			15 00 02 9A AF
+			15 00 02 9B 02
+			15 00 02 9C DF
+			15 00 02 9D 03
+			15 00 02 9E 01
+			15 00 02 9F 03
+			15 00 02 A0 2C
+			15 00 02 A2 03
+			15 00 02 A3 39
+			15 00 02 A4 03
+			15 00 02 A5 47
+			15 00 02 A6 03
+			15 00 02 A7 56
+			15 00 02 A9 03
+			15 00 02 AA 66
+			15 00 02 AB 03
+			15 00 02 AC 76
+			15 00 02 AD 03
+			15 00 02 AE 85
+			15 00 02 AF 03
+			15 00 02 B0 90
+			15 00 02 B1 03
+			15 00 02 B2 CB
+			15 00 02 B3 00
+			15 00 02 B4 DF
+			15 00 02 B5 00
+			15 00 02 B6 E4
+			15 00 02 B7 00
+			15 00 02 B8 ED
+			15 00 02 B9 00
+			15 00 02 BA F6
+			15 00 02 BB 00
+			15 00 02 BC FF
+			15 00 02 BD 01
+			15 00 02 BE 07
+			15 00 02 BF 01
+			15 00 02 C0 10
+			15 00 02 C1 01
+			15 00 02 C2 18
+			15 00 02 C3 01
+			15 00 02 C4 20
+			15 00 02 C5 01
+			15 00 02 C6 3D
+			15 00 02 C7 01
+			15 00 02 C8 56
+			15 00 02 C9 01
+			15 00 02 CA 84
+			15 00 02 CB 01
+			15 00 02 CC AB
+			15 00 02 CD 01
+			15 00 02 CE EC
+			15 00 02 CF 02
+			15 00 02 D0 22
+			15 00 02 D1 02
+			15 00 02 D2 23
+			15 00 02 D3 02
+			15 00 02 D4 55
+			15 00 02 D5 02
+			15 00 02 D6 8B
+			15 00 02 D7 02
+			15 00 02 D8 AF
+			15 00 02 D9 02
+			15 00 02 DA DF
+			15 00 02 DB 03
+			15 00 02 DC 01
+			15 00 02 DD 03
+			15 00 02 DE 2C
+			15 00 02 DF 03
+			15 00 02 E0 39
+			15 00 02 E1 03
+			15 00 02 E2 47
+			15 00 02 E3 03
+			15 00 02 E4 56
+			15 00 02 E5 03
+			15 00 02 E6 66
+			15 00 02 E7 03
+			15 00 02 E8 76
+			15 00 02 E9 03
+			15 00 02 EA 85
+			15 00 02 EB 03
+			15 00 02 EC 90
+			15 00 02 ED 03
+			15 00 02 EE CB
+			15 00 02 EF 00
+			15 00 02 F0 BB
+			15 00 02 F1 00
+			15 00 02 F2 C0
+			15 00 02 F3 00
+			15 00 02 F4 CC
+			15 00 02 F5 00
+			15 00 02 F6 D6
+			15 00 02 F7 00
+			15 00 02 F8 E1
+			15 00 02 F9 00
+			15 00 02 FA EA
+			15 00 02 FF 02
+			15 00 02 FB 01
+			15 00 02 00 00
+			15 00 02 01 F4
+			15 00 02 02 00
+			15 00 02 03 EF
+			15 00 02 04 01
+			15 00 02 05 07
+			15 00 02 06 01
+			15 00 02 07 28
+			15 00 02 08 01
+			15 00 02 09 44
+			15 00 02 0A 01
+			15 00 02 0B 76
+			15 00 02 0C 01
+			15 00 02 0D A0
+			15 00 02 0E 01
+			15 00 02 0F E7
+			15 00 02 10 02
+			15 00 02 11 1F
+			15 00 02 12 02
+			15 00 02 13 22
+			15 00 02 14 02
+			15 00 02 15 54
+			15 00 02 16 02
+			15 00 02 17 8B
+			15 00 02 18 02
+			15 00 02 19 AF
+			15 00 02 1A 02
+			15 00 02 1B E0
+			15 00 02 1C 03
+			15 00 02 1D 01
+			15 00 02 1E 03
+			15 00 02 1F 2D
+			15 00 02 20 03
+			15 00 02 21 39
+			15 00 02 22 03
+			15 00 02 23 47
+			15 00 02 24 03
+			15 00 02 25 57
+			15 00 02 26 03
+			15 00 02 27 65
+			15 00 02 28 03
+			15 00 02 29 77
+			15 00 02 2A 03
+			15 00 02 2B 85
+			15 00 02 2D 03
+			15 00 02 2F 8F
+			15 00 02 30 03
+			15 00 02 31 CB
+			15 00 02 32 00
+			15 00 02 33 BB
+			15 00 02 34 00
+			15 00 02 35 C0
+			15 00 02 36 00
+			15 00 02 37 CC
+			15 00 02 38 00
+			15 00 02 39 D6
+			15 00 02 3A 00
+			15 00 02 3B E1
+			15 00 02 3D 00
+			15 00 02 3F EA
+			15 00 02 40 00
+			15 00 02 41 F4
+			15 00 02 42 00
+			15 00 02 43 FE
+			15 00 02 44 01
+			15 00 02 45 07
+			15 00 02 46 01
+			15 00 02 47 28
+			15 00 02 48 01
+			15 00 02 49 44
+			15 00 02 4A 01
+			15 00 02 4B 76
+			15 00 02 4C 01
+			15 00 02 4D A0
+			15 00 02 4E 01
+			15 00 02 4F E7
+			15 00 02 50 02
+			15 00 02 51 1F
+			15 00 02 52 02
+			15 00 02 53 22
+			15 00 02 54 02
+			15 00 02 55 54
+			15 00 02 56 02
+			15 00 02 58 8B
+			15 00 02 59 02
+			15 00 02 5A AF
+			15 00 02 5B 02
+			15 00 02 5C E0
+			15 00 02 5D 03
+			15 00 02 5E 01
+			15 00 02 5F 03
+			15 00 02 60 2D
+			15 00 02 61 03
+			15 00 02 62 39
+			15 00 02 63 03
+			15 00 02 64 47
+			15 00 02 65 03
+			15 00 02 66 57
+			15 00 02 67 03
+			15 00 02 68 65
+			15 00 02 69 03
+			15 00 02 6A 77
+			15 00 02 6B 03
+			15 00 02 6C 85
+			15 00 02 6D 03
+			15 00 02 6E 8F
+			15 00 02 6F 03
+			15 00 02 70 CB
+			15 00 02 71 00
+			15 00 02 72 00
+			15 00 02 73 00
+			15 00 02 74 21
+			15 00 02 75 00
+			15 00 02 76 4C
+			15 00 02 77 00
+			15 00 02 78 6B
+			15 00 02 79 00
+			15 00 02 7A 85
+			15 00 02 7B 00
+			15 00 02 7C 9A
+			15 00 02 7D 00
+			15 00 02 7E AD
+			15 00 02 7F 00
+			15 00 02 80 BE
+			15 00 02 81 00
+			15 00 02 82 CD
+			15 00 02 83 01
+			15 00 02 84 01
+			15 00 02 85 01
+			15 00 02 86 29
+			15 00 02 87 01
+			15 00 02 88 68
+			15 00 02 89 01
+			15 00 02 8A 98
+			15 00 02 8B 01
+			15 00 02 8C E5
+			15 00 02 8D 02
+			15 00 02 8E 1E
+			15 00 02 8F 02
+			15 00 02 90 30
+			15 00 02 91 02
+			15 00 02 92 52
+			15 00 02 93 02
+			15 00 02 94 88
+			15 00 02 95 02
+			15 00 02 96 AA
+			15 00 02 97 02
+			15 00 02 98 D7
+			15 00 02 99 02
+			15 00 02 9A F7
+			15 00 02 9B 03
+			15 00 02 9C 21
+			15 00 02 9D 03
+			15 00 02 9E 2E
+			15 00 02 9F 03
+			15 00 02 A0 3D
+			15 00 02 A2 03
+			15 00 02 A3 4C
+			15 00 02 A4 03
+			15 00 02 A5 5E
+			15 00 02 A6 03
+			15 00 02 A7 71
+			15 00 02 A9 03
+			15 00 02 AA 86
+			15 00 02 AB 03
+			15 00 02 AC 94
+			15 00 02 AD 03
+			15 00 02 AE FA
+			15 00 02 AF 00
+			15 00 02 B0 00
+			15 00 02 B1 00
+			15 00 02 B2 21
+			15 00 02 B3 00
+			15 00 02 B4 4C
+			15 00 02 B5 00
+			15 00 02 B6 6B
+			15 00 02 B7 00
+			15 00 02 B8 85
+			15 00 02 B9 00
+			15 00 02 BA 9A
+			15 00 02 BB 00
+			15 00 02 BC AD
+			15 00 02 BD 00
+			15 00 02 BE BE
+			15 00 02 BF 00
+			15 00 02 C0 CD
+			15 00 02 C1 01
+			15 00 02 C2 01
+			15 00 02 C3 01
+			15 00 02 C4 29
+			15 00 02 C5 01
+			15 00 02 C6 68
+			15 00 02 C7 01
+			15 00 02 C8 98
+			15 00 02 C9 01
+			15 00 02 CA E5
+			15 00 02 CB 02
+			15 00 02 CC 1E
+			15 00 02 CD 02
+			15 00 02 CE 20
+			15 00 02 CF 02
+			15 00 02 D0 52
+			15 00 02 D1 02
+			15 00 02 D2 88
+			15 00 02 D3 02
+			15 00 02 D4 AA
+			15 00 02 D5 02
+			15 00 02 D6 D7
+			15 00 02 D7 02
+			15 00 02 D8 F7
+			15 00 02 D9 03
+			15 00 02 DA 21
+			15 00 02 DB 03
+			15 00 02 DC 2E
+			15 00 02 DD 03
+			15 00 02 DE 3D
+			15 00 02 DF 03
+			15 00 02 E0 4C
+			15 00 02 E1 03
+			15 00 02 E2 5E
+			15 00 02 E3 03
+			15 00 02 E4 71
+			15 00 02 E5 03
+			15 00 02 E6 86
+			15 00 02 E7 03
+			15 00 02 E8 94
+			15 00 02 E9 03
+			15 00 02 EA FA
+			15 00 02 FF 01
+			15 00 02 FB 01
+			15 00 02 FF 02
+			15 00 02 FB 01
+			15 00 02 FF 04
+			15 00 02 FB 01
+			15 00 02 FF 00
+			15 00 02 D3 05
+			15 00 02 D4 04
+			05 78 01 11
+			15 00 02 FF 00
+			15 00 02 35 00
+			05 0A 01 29
+		];
+
+		panel-init-sequence2 = [
+			39 00 04 B9 FF 83 99
+			39 00 05 BA 63 23 68 CF
+			15 00 02 D2 55
+			39 00 10 B1 02 04 70 90 01 32 33 11 11 4D 57 56 73 02 02
+			39 00 0c B2 00 80 80 AE 0A 0E 75 11 00 00 00
+			39 00 2f B4 00 FF 04 A4 02 A0 00 00 10 00 00 02 00 24 02 04 0A 21 03 00 00 08 A6 88 04 A4 02 A0 00 00 10 00 00 02 00 24 02 04 0A 00 00 08 A6 00 08 11
+			39 00 22 D3 00 00 00 00 00 00 18 18 32 10 09 00 09 32 10 00 00 00 00 00 00 00 00 11 00 02 02 03 00 00 00 0A 40
+			39 00 21 D5 18 18 18 18 21 20 18 18 19 19 19 19 18 18 18 18 03 02 01 00 2F 2F 30 30 31 31 18 18 18 18 18 18
+			39 00 21 D6 18 18 18 18 20 21 19 19 18 18 19 19 18 18 18 18 00 01 02 03 2F 2F 30 30 31 31 18 18 18 18 18 18
+			39 00 09 D8 0A BE FA A0 0A BE FA A0
+			15 00 02 BD 01
+			39 00 09 D8 0F FF FF E0 0F FF FF E0
+			15 00 02 BD 02
+			39 00 09 D8 0F FF FF E0 0F FF FF E0
+			15 00 02 BD 00
+			39 00 37 E0 01 35 41 3B 79 81 8C 85 8E 95 9B A0 A4 AB B1 B3 B7 C5 BD C5 B6 C2 C2 62 5D 66 73 01 35 41 3B 79 81 8C 85 8E 95 9B A0 A4 AB B1 B3 B7 B5 BD C5 B6 C2 C2 62 5D 66 73
+			39 00 03 B6 97 97
+			15 00 02 CC C8
+			39 00 05 BF 40 41 50 19
+			39 00 03 C6 FF F9
+			39 00 03 C0 25 5A
+			05 78 01 11
+			05 14 01 29
+		];
+
+		panel-exit-sequence = [
+			05 05 01 28
+			05 78 01 10
+		];
+
+		disp_timings0: display-timings {
+			native-mode = <&dsi0_timing0>;
+			dsi0_timing0: timing0 {
+				clock-frequency = <152200000>;
+				hactive = <1080>;
+				vactive = <1920>;
+				hfront-porch = <104>;
+				hsync-len = <4>;
+				hback-porch = <127>;
+				vfront-porch = <4>;
+				vsync-len = <2>;
+				vback-porch = <3>;
+				hsync-active = <0>;
+				vsync-active = <0>;
+				de-active = <0>;
+				pixelclk-active = <0>;
+			};
+		};
+
+		disp_timings01: display-timings1 {
+			native-mode = <&dsi0_timing01>;
+			dsi0_timing01: timing01 {
+				clock-frequency = <152350000>;
+				hactive = <1920>;
+				vactive = <1200>;
+				hfront-porch = <110>;
+				hsync-len = <4>;
+				hback-porch = <32>;
+				vfront-porch = <11>;
+				vsync-len = <4>;
+				vback-porch = <14>;
+				hsync-active = <0>;
+				vsync-active = <0>;
+				de-active = <0>;
+				pixelclk-active = <0>;
+			};
+		};
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				panel_in_dsi: endpoint {
+					remote-endpoint = <&dsi_out_panel>;
+				};
+			};
+		};
+	};
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@1 {
+			reg = <1>;
+			dsi_out_panel: endpoint {
+				remote-endpoint = <&panel_in_dsi>;
+			};
+		};
+	};
+
+};
+
+&dsi1 {
+	status = "disabled";
+	//rockchip,lane-rate = <1000>;
+	dsi1_panel: panel@0 {
+		status = "disabled";
+		compatible = "simple-panel-dsi";
+		reg = <0>;
+		backlight = <&backlight_mipi1>;
+//		reset-delay-ms = <60>;
+		enable-delay-ms = <60>;
+		prepare-delay-ms = <60>;
+		unprepare-delay-ms = <60>;
+		disable-delay-ms = <60>;
+		dsi,flags = <(MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			MIPI_DSI_MODE_LPM | MIPI_DSI_MODE_EOT_PACKET)>;
+		dsi,format = <MIPI_DSI_FMT_RGB888>;
+		dsi,lanes  = <4>;
+		panel-init-sequence = [
+			15 00 02 FF 05
+			15 00 02 FB 01
+			15 64 02 C5 01
+			15 00 02 FF EE
+			15 00 02 FB 01
+			15 00 02 1F 45
+			15 00 02 24 4F
+			15 00 02 38 C8
+			15 00 02 39 27
+			15 00 02 1E 77
+			15 00 02 1D 0F
+			15 00 02 7E 71
+			15 00 02 7C 03
+			15 00 02 FF 00
+			15 00 02 FB 01
+			15 00 02 35 01
+			15 00 02 FF 01
+			15 00 02 FB 01
+			15 00 02 00 01
+			15 00 02 01 55
+			15 00 02 02 40
+			15 00 02 05 40
+			15 00 02 06 4A
+			15 00 02 07 24
+			15 00 02 08 0C
+			15 00 02 0B 7D
+			15 00 02 0C 7D
+			15 00 02 0E B0
+			15 00 02 0F AE
+			15 00 02 11 10
+			15 00 02 12 10
+			15 00 02 13 03
+			15 00 02 14 4A
+			15 00 02 15 12
+			15 00 02 16 12
+			15 00 02 18 00
+			15 00 02 19 77
+			15 00 02 1A 55
+			15 00 02 1B 13
+			15 00 02 1C 00
+			15 00 02 1D 00
+			15 00 02 1E 13
+			15 00 02 1F 00
+			15 00 02 23 00
+			15 00 02 24 00
+			15 00 02 25 00
+			15 00 02 26 00
+			15 00 02 27 00
+			15 00 02 28 00
+			15 00 02 35 00
+			15 00 02 66 00
+			15 00 02 58 82
+			15 00 02 59 02
+			15 00 02 5A 02
+			15 00 02 5B 02
+			15 00 02 5C 82
+			15 00 02 5D 82
+			15 00 02 5E 02
+			15 00 02 5F 02
+			15 00 02 72 31
+			15 00 02 FF 05
+			15 00 02 FB 01
+			15 00 02 00 01
+			15 00 02 01 0B
+			15 00 02 02 0C
+			15 00 02 03 09
+			15 00 02 04 0A
+			15 00 02 05 00
+			15 00 02 06 0F
+			15 00 02 07 10
+			15 00 02 08 00
+			15 00 02 09 00
+			15 00 02 0A 00
+			15 00 02 0B 00
+			15 00 02 0C 00
+			15 00 02 0D 13
+			15 00 02 0E 15
+			15 00 02 0F 17
+			15 00 02 10 01
+			15 00 02 11 0B
+			15 00 02 12 0C
+			15 00 02 13 09
+			15 00 02 14 0A
+			15 00 02 15 00
+			15 00 02 16 0F
+			15 00 02 17 10
+			15 00 02 18 00
+			15 00 02 19 00
+			15 00 02 1A 00
+			15 00 02 1B 00
+			15 00 02 1C 00
+			15 00 02 1D 13
+			15 00 02 1E 15
+			15 00 02 1F 17
+			15 00 02 20 00
+			15 00 02 21 03
+			15 00 02 22 01
+			15 00 02 23 40
+			15 00 02 24 40
+			15 00 02 25 ED
+			15 00 02 29 58
+			15 00 02 2A 12
+			15 00 02 2B 01
+			15 00 02 4B 06
+			15 00 02 4C 11
+			15 00 02 4D 20
+			15 00 02 4E 02
+			15 00 02 4F 02
+			15 00 02 50 20
+			15 00 02 51 61
+			15 00 02 52 01
+			15 00 02 53 63
+			15 00 02 54 77
+			15 00 02 55 ED
+			15 00 02 5B 00
+			15 00 02 5C 00
+			15 00 02 5D 00
+			15 00 02 5E 00
+			15 00 02 5F 15
+			15 00 02 60 75
+			15 00 02 61 00
+			15 00 02 62 00
+			15 00 02 63 00
+			15 00 02 64 00
+			15 00 02 65 00
+			15 00 02 66 00
+			15 00 02 67 00
+			15 00 02 68 04
+			15 00 02 69 00
+			15 00 02 6A 00
+			15 00 02 6C 40
+			15 00 02 75 01
+			15 00 02 76 01
+			15 00 02 7A 80
+			15 00 02 7B A3
+			15 00 02 7C D8
+			15 00 02 7D 60
+			15 00 02 7F 15
+			15 00 02 80 81
+			15 00 02 83 05
+			15 00 02 93 08
+			15 00 02 94 10
+			15 00 02 8A 00
+			15 00 02 9B 0F
+			15 00 02 EA FF
+			15 00 02 EC 00
+			15 00 02 FF 01
+			15 00 02 FB 01
+			15 00 02 75 00
+			15 00 02 76 DF
+			15 00 02 77 00
+			15 00 02 78 E4
+			15 00 02 79 00
+			15 00 02 7A ED
+			15 00 02 7B 00
+			15 00 02 7C F6
+			15 00 02 7D 00
+			15 00 02 7E FF
+			15 00 02 7F 01
+			15 00 02 80 07
+			15 00 02 81 01
+			15 00 02 82 10
+			15 00 02 83 01
+			15 00 02 84 18
+			15 00 02 85 01
+			15 00 02 86 20
+			15 00 02 87 01
+			15 00 02 88 3D
+			15 00 02 89 01
+			15 00 02 8A 56
+			15 00 02 8B 01
+			15 00 02 8C 84
+			15 00 02 8D 01
+			15 00 02 8E AB
+			15 00 02 8F 01
+			15 00 02 90 EC
+			15 00 02 91 02
+			15 00 02 92 22
+			15 00 02 93 02
+			15 00 02 94 23
+			15 00 02 95 02
+			15 00 02 96 55
+			15 00 02 97 02
+			15 00 02 98 8B
+			15 00 02 99 02
+			15 00 02 9A AF
+			15 00 02 9B 02
+			15 00 02 9C DF
+			15 00 02 9D 03
+			15 00 02 9E 01
+			15 00 02 9F 03
+			15 00 02 A0 2C
+			15 00 02 A2 03
+			15 00 02 A3 39
+			15 00 02 A4 03
+			15 00 02 A5 47
+			15 00 02 A6 03
+			15 00 02 A7 56
+			15 00 02 A9 03
+			15 00 02 AA 66
+			15 00 02 AB 03
+			15 00 02 AC 76
+			15 00 02 AD 03
+			15 00 02 AE 85
+			15 00 02 AF 03
+			15 00 02 B0 90
+			15 00 02 B1 03
+			15 00 02 B2 CB
+			15 00 02 B3 00
+			15 00 02 B4 DF
+			15 00 02 B5 00
+			15 00 02 B6 E4
+			15 00 02 B7 00
+			15 00 02 B8 ED
+			15 00 02 B9 00
+			15 00 02 BA F6
+			15 00 02 BB 00
+			15 00 02 BC FF
+			15 00 02 BD 01
+			15 00 02 BE 07
+			15 00 02 BF 01
+			15 00 02 C0 10
+			15 00 02 C1 01
+			15 00 02 C2 18
+			15 00 02 C3 01
+			15 00 02 C4 20
+			15 00 02 C5 01
+			15 00 02 C6 3D
+			15 00 02 C7 01
+			15 00 02 C8 56
+			15 00 02 C9 01
+			15 00 02 CA 84
+			15 00 02 CB 01
+			15 00 02 CC AB
+			15 00 02 CD 01
+			15 00 02 CE EC
+			15 00 02 CF 02
+			15 00 02 D0 22
+			15 00 02 D1 02
+			15 00 02 D2 23
+			15 00 02 D3 02
+			15 00 02 D4 55
+			15 00 02 D5 02
+			15 00 02 D6 8B
+			15 00 02 D7 02
+			15 00 02 D8 AF
+			15 00 02 D9 02
+			15 00 02 DA DF
+			15 00 02 DB 03
+			15 00 02 DC 01
+			15 00 02 DD 03
+			15 00 02 DE 2C
+			15 00 02 DF 03
+			15 00 02 E0 39
+			15 00 02 E1 03
+			15 00 02 E2 47
+			15 00 02 E3 03
+			15 00 02 E4 56
+			15 00 02 E5 03
+			15 00 02 E6 66
+			15 00 02 E7 03
+			15 00 02 E8 76
+			15 00 02 E9 03
+			15 00 02 EA 85
+			15 00 02 EB 03
+			15 00 02 EC 90
+			15 00 02 ED 03
+			15 00 02 EE CB
+			15 00 02 EF 00
+			15 00 02 F0 BB
+			15 00 02 F1 00
+			15 00 02 F2 C0
+			15 00 02 F3 00
+			15 00 02 F4 CC
+			15 00 02 F5 00
+			15 00 02 F6 D6
+			15 00 02 F7 00
+			15 00 02 F8 E1
+			15 00 02 F9 00
+			15 00 02 FA EA
+			15 00 02 FF 02
+			15 00 02 FB 01
+			15 00 02 00 00
+			15 00 02 01 F4
+			15 00 02 02 00
+			15 00 02 03 EF
+			15 00 02 04 01
+			15 00 02 05 07
+			15 00 02 06 01
+			15 00 02 07 28
+			15 00 02 08 01
+			15 00 02 09 44
+			15 00 02 0A 01
+			15 00 02 0B 76
+			15 00 02 0C 01
+			15 00 02 0D A0
+			15 00 02 0E 01
+			15 00 02 0F E7
+			15 00 02 10 02
+			15 00 02 11 1F
+			15 00 02 12 02
+			15 00 02 13 22
+			15 00 02 14 02
+			15 00 02 15 54
+			15 00 02 16 02
+			15 00 02 17 8B
+			15 00 02 18 02
+			15 00 02 19 AF
+			15 00 02 1A 02
+			15 00 02 1B E0
+			15 00 02 1C 03
+			15 00 02 1D 01
+			15 00 02 1E 03
+			15 00 02 1F 2D
+			15 00 02 20 03
+			15 00 02 21 39
+			15 00 02 22 03
+			15 00 02 23 47
+			15 00 02 24 03
+			15 00 02 25 57
+			15 00 02 26 03
+			15 00 02 27 65
+			15 00 02 28 03
+			15 00 02 29 77
+			15 00 02 2A 03
+			15 00 02 2B 85
+			15 00 02 2D 03
+			15 00 02 2F 8F
+			15 00 02 30 03
+			15 00 02 31 CB
+			15 00 02 32 00
+			15 00 02 33 BB
+			15 00 02 34 00
+			15 00 02 35 C0
+			15 00 02 36 00
+			15 00 02 37 CC
+			15 00 02 38 00
+			15 00 02 39 D6
+			15 00 02 3A 00
+			15 00 02 3B E1
+			15 00 02 3D 00
+			15 00 02 3F EA
+			15 00 02 40 00
+			15 00 02 41 F4
+			15 00 02 42 00
+			15 00 02 43 FE
+			15 00 02 44 01
+			15 00 02 45 07
+			15 00 02 46 01
+			15 00 02 47 28
+			15 00 02 48 01
+			15 00 02 49 44
+			15 00 02 4A 01
+			15 00 02 4B 76
+			15 00 02 4C 01
+			15 00 02 4D A0
+			15 00 02 4E 01
+			15 00 02 4F E7
+			15 00 02 50 02
+			15 00 02 51 1F
+			15 00 02 52 02
+			15 00 02 53 22
+			15 00 02 54 02
+			15 00 02 55 54
+			15 00 02 56 02
+			15 00 02 58 8B
+			15 00 02 59 02
+			15 00 02 5A AF
+			15 00 02 5B 02
+			15 00 02 5C E0
+			15 00 02 5D 03
+			15 00 02 5E 01
+			15 00 02 5F 03
+			15 00 02 60 2D
+			15 00 02 61 03
+			15 00 02 62 39
+			15 00 02 63 03
+			15 00 02 64 47
+			15 00 02 65 03
+			15 00 02 66 57
+			15 00 02 67 03
+			15 00 02 68 65
+			15 00 02 69 03
+			15 00 02 6A 77
+			15 00 02 6B 03
+			15 00 02 6C 85
+			15 00 02 6D 03
+			15 00 02 6E 8F
+			15 00 02 6F 03
+			15 00 02 70 CB
+			15 00 02 71 00
+			15 00 02 72 00
+			15 00 02 73 00
+			15 00 02 74 21
+			15 00 02 75 00
+			15 00 02 76 4C
+			15 00 02 77 00
+			15 00 02 78 6B
+			15 00 02 79 00
+			15 00 02 7A 85
+			15 00 02 7B 00
+			15 00 02 7C 9A
+			15 00 02 7D 00
+			15 00 02 7E AD
+			15 00 02 7F 00
+			15 00 02 80 BE
+			15 00 02 81 00
+			15 00 02 82 CD
+			15 00 02 83 01
+			15 00 02 84 01
+			15 00 02 85 01
+			15 00 02 86 29
+			15 00 02 87 01
+			15 00 02 88 68
+			15 00 02 89 01
+			15 00 02 8A 98
+			15 00 02 8B 01
+			15 00 02 8C E5
+			15 00 02 8D 02
+			15 00 02 8E 1E
+			15 00 02 8F 02
+			15 00 02 90 30
+			15 00 02 91 02
+			15 00 02 92 52
+			15 00 02 93 02
+			15 00 02 94 88
+			15 00 02 95 02
+			15 00 02 96 AA
+			15 00 02 97 02
+			15 00 02 98 D7
+			15 00 02 99 02
+			15 00 02 9A F7
+			15 00 02 9B 03
+			15 00 02 9C 21
+			15 00 02 9D 03
+			15 00 02 9E 2E
+			15 00 02 9F 03
+			15 00 02 A0 3D
+			15 00 02 A2 03
+			15 00 02 A3 4C
+			15 00 02 A4 03
+			15 00 02 A5 5E
+			15 00 02 A6 03
+			15 00 02 A7 71
+			15 00 02 A9 03
+			15 00 02 AA 86
+			15 00 02 AB 03
+			15 00 02 AC 94
+			15 00 02 AD 03
+			15 00 02 AE FA
+			15 00 02 AF 00
+			15 00 02 B0 00
+			15 00 02 B1 00
+			15 00 02 B2 21
+			15 00 02 B3 00
+			15 00 02 B4 4C
+			15 00 02 B5 00
+			15 00 02 B6 6B
+			15 00 02 B7 00
+			15 00 02 B8 85
+			15 00 02 B9 00
+			15 00 02 BA 9A
+			15 00 02 BB 00
+			15 00 02 BC AD
+			15 00 02 BD 00
+			15 00 02 BE BE
+			15 00 02 BF 00
+			15 00 02 C0 CD
+			15 00 02 C1 01
+			15 00 02 C2 01
+			15 00 02 C3 01
+			15 00 02 C4 29
+			15 00 02 C5 01
+			15 00 02 C6 68
+			15 00 02 C7 01
+			15 00 02 C8 98
+			15 00 02 C9 01
+			15 00 02 CA E5
+			15 00 02 CB 02
+			15 00 02 CC 1E
+			15 00 02 CD 02
+			15 00 02 CE 20
+			15 00 02 CF 02
+			15 00 02 D0 52
+			15 00 02 D1 02
+			15 00 02 D2 88
+			15 00 02 D3 02
+			15 00 02 D4 AA
+			15 00 02 D5 02
+			15 00 02 D6 D7
+			15 00 02 D7 02
+			15 00 02 D8 F7
+			15 00 02 D9 03
+			15 00 02 DA 21
+			15 00 02 DB 03
+			15 00 02 DC 2E
+			15 00 02 DD 03
+			15 00 02 DE 3D
+			15 00 02 DF 03
+			15 00 02 E0 4C
+			15 00 02 E1 03
+			15 00 02 E2 5E
+			15 00 02 E3 03
+			15 00 02 E4 71
+			15 00 02 E5 03
+			15 00 02 E6 86
+			15 00 02 E7 03
+			15 00 02 E8 94
+			15 00 02 E9 03
+			15 00 02 EA FA
+			15 00 02 FF 01
+			15 00 02 FB 01
+			15 00 02 FF 02
+			15 00 02 FB 01
+			15 00 02 FF 04
+			15 00 02 FB 01
+			15 00 02 FF 00
+			15 00 02 D3 05
+			15 00 02 D4 04
+			05 78 01 11
+			15 00 02 FF 00
+			15 00 02 35 00
+			05 0A 01 29
+		];
+
+		panel-init-sequence2 = [
+			39 00 04 B9 FF 83 99
+			39 00 05 BA 63 23 68 CF
+			15 00 02 D2 55
+			39 00 10 B1 02 04 70 90 01 32 33 11 11 4D 57 56 73 02 02
+			39 00 0c B2 00 80 80 AE 0A 0E 75 11 00 00 00
+			39 00 2f B4 00 FF 04 A4 02 A0 00 00 10 00 00 02 00 24 02 04 0A 21 03 00 00 08 A6 88 04 A4 02 A0 00 00 10 00 00 02 00 24 02 04 0A 00 00 08 A6 00 08 11
+			39 00 22 D3 00 00 00 00 00 00 18 18 32 10 09 00 09 32 10 00 00 00 00 00 00 00 00 11 00 02 02 03 00 00 00 0A 40
+			39 00 21 D5 18 18 18 18 21 20 18 18 19 19 19 19 18 18 18 18 03 02 01 00 2F 2F 30 30 31 31 18 18 18 18 18 18
+			39 00 21 D6 18 18 18 18 20 21 19 19 18 18 19 19 18 18 18 18 00 01 02 03 2F 2F 30 30 31 31 18 18 18 18 18 18
+			39 00 09 D8 0A BE FA A0 0A BE FA A0
+			15 00 02 BD 01
+			39 00 09 D8 0F FF FF E0 0F FF FF E0
+			15 00 02 BD 02
+			39 00 09 D8 0F FF FF E0 0F FF FF E0
+			15 00 02 BD 00
+			39 00 37 E0 01 35 41 3B 79 81 8C 85 8E 95 9B A0 A4 AB B1 B3 B7 C5 BD C5 B6 C2 C2 62 5D 66 73 01 35 41 3B 79 81 8C 85 8E 95 9B A0 A4 AB B1 B3 B7 B5 BD C5 B6 C2 C2 62 5D 66 73
+			39 00 03 B6 97 97
+			15 00 02 CC C8
+			39 00 05 BF 40 41 50 19
+			39 00 03 C6 FF F9
+			39 00 03 C0 25 5A
+			05 78 01 11
+			05 14 01 29
+		];
+
+		panel-exit-sequence = [
+			05 05 01 28
+			05 78 01 10
+		];
+
+		disp_timings1: display-timings {
+			native-mode = <&dsi1_timing0>;
+			dsi1_timing0: timing0 {
+				clock-frequency = <152198100>;
+				hactive = <1080>;
+				vactive = <1920>;
+				hfront-porch = <104>;
+				hsync-len = <4>;
+				hback-porch = <127>;
+				vfront-porch = <4>;
+				vsync-len = <2>;
+				vback-porch = <3>;
+				hsync-active = <0>;
+				vsync-active = <0>;
+				de-active = <0>;
+				pixelclk-active = <0>;
+			};
+		};
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				panel_in_dsi1: endpoint {
+					remote-endpoint = <&dsi1_out_panel>;
+				};
+			};
+		};
+	};
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@1 {
+			reg = <1>;
+			dsi1_out_panel: endpoint {
+				remote-endpoint = <&panel_in_dsi1>;
+			};
+		};
+	};
+
+};
+
+&gpu {
+	mali-supply = <&vdd_gpu_s0>;
+	mem-supply = <&vdd_gpu_mem_s0>;
+	status = "okay";
+};
+
+&i2s0_8ch {
+	status = "okay";
+	pinctrl-0 = <&i2s0_lrck
+		     &i2s0_sclk
+		     &i2s0_sdi0
+		     &i2s0_sdo0>;
+};
+
+&iep {
+	status = "okay";
+};
+
+&iep_mmu {
+	status = "okay";
+};
+
+&jpegd {
+	status = "okay";
+};
+
+&jpegd_mmu {
+	status = "okay";
+};
+
+&jpege_ccu {
+	status = "okay";
+};
+
+&jpege0 {
+	status = "okay";
+};
+
+&jpege0_mmu {
+	status = "okay";
+};
+
+&jpege1 {
+	status = "okay";
+};
+
+&jpege1_mmu {
+	status = "okay";
+};
+
+&jpege2 {
+	status = "okay";
+};
+
+&jpege2_mmu {
+	status = "okay";
+};
+
+&jpege3 {
+	status = "okay";
+};
+
+&jpege3_mmu {
+	status = "okay";
+};
+
+&mpp_srv {
+	status = "okay";
+};
+
+&rga3_core0 {
+	status = "okay";
+};
+
+&rga3_0_mmu {
+	status = "okay";
+};
+
+&rga3_core1 {
+	status = "okay";
+};
+
+&rga3_1_mmu {
+	status = "okay";
+};
+
+&rga2 {
+	status = "okay";
+};
+
+&rknpu {
+	rknpu-supply = <&vdd_npu_s0>;
+	mem-supply = <&vdd_npu_mem_s0>;
+	status = "okay";
+};
+
+&rknpu_mmu {
+	status = "okay";
+};
+
+&rkvdec_ccu {
+	status = "okay";
+};
+
+&rkvdec0 {
+	status = "okay";
+};
+
+&rkvdec0_mmu {
+	status = "okay";
+};
+
+&rkvdec1 {
+	status = "okay";
+};
+
+&rkvdec1_mmu {
+	status = "okay";
+};
+
+&rkvenc_ccu {
+	status = "okay";
+};
+
+&rkvenc0 {
+	status = "okay";
+};
+
+&rkvenc0_mmu {
+	status = "okay";
+};
+
+&rkvenc1 {
+	status = "okay";
+};
+
+&rkvenc1_mmu {
+	status = "okay";
+};
+
+&rockchip_suspend {
+	status = "okay";
+	rockchip,sleep-debug-en = <1>;
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vcc_1v8_s0>;
+};
+
+&sdhci {
+	bus-width = <8>;
+	no-sdio;
+	no-sd;
+	non-removable;
+	max-frequency = <200000000>;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	status = "okay";
+};
+
+&sdmmc {
+	max-frequency = <150000000>;
+	no-sdio;
+	no-mmc;
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	sd-uhs-sdr104;
+	vmmc-supply = <&vcc_sd>;
+	vqmmc-supply = <&vccio_sd_s0>;
+	status = "disabled";
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&u2phy0 {
+	status = "okay";
+};
+
+&u2phy2 {
+	status = "okay";
+};
+
+&u2phy3 {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	status = "okay";
+};
+
+&u2phy2_host {
+	status = "okay";
+};
+
+&u2phy3_host {
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&usbdp_phy0 {
+	status = "okay";
+};
+
+&usbdp_phy0_dp {
+	status = "okay";
+};
+
+&usbdp_phy0_u3 {
+	status = "okay";
+};
+
+&usbdrd3_0 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&usbhost3_0 {
+	status = "okay";
+};
+
+&usbhost_dwc3_0 {
+	status = "okay";
+};
+
+&vdpu {
+	status = "okay";
+};
+
+&vdpu_mmu {
+	status = "okay";
+};
+
+&vepu {
+	status = "okay";
+};
+
+&vop {
+	status = "okay";
+};
+
+&vop_mmu {
+	status = "okay";
+};
+
+/* vp0 & vp1 splice for 8K output */
+&vp0 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART0>;
+};
+
+&vp1 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART1>;
+};
+
+&vp2 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER2 | 1 << ROCKCHIP_VOP2_ESMART2)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART2>;
+};
+
+&vp3 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_ESMART3>;
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-nanopi-r6-common.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-nanopi-r6-common.dtsi
@@ -0,0 +1,699 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 FriendlyElec Computer Tech. Co., Ltd.
+ * (http://www.friendlyelec.com)
+ *
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/input/rk-input.h>
+#include <dt-bindings/display/drm_mipi_dsi.h>
+#include <dt-bindings/display/rockchip_vop.h>
+#include <dt-bindings/sensor-dev.h>
+#include <dt-bindings/usb/pd.h>
+#include "rk3588s.dtsi"
+#include "rk3588-rk806-single.dtsi"
+#include "rk3588-linux.dtsi"
+
+/ {
+	aliases {
+		mmc0 = &sdhci;
+		mmc1 = &sdmmc;
+		mmc2 = &sdio;
+	};
+
+	chosen: chosen {
+		bootargs = "earlycon=uart8250,mmio32,0xfeb50000 console=ttyFIQ0 coherent_pool=1m irqchip.gicv3_pseudo_nmi=0";
+	};
+
+	hdmi0_sound: hdmi0-sound {
+		status = "disabled";
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <128>;
+		simple-audio-card,name = "rockchip,hdmi0";
+
+		simple-audio-card,cpu {
+			sound-dai = <&i2s5_8ch>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&hdmi0>;
+		};
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+	};
+
+	vcc5v0_usb: vcc5v0-usb {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_usb";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vcc_1v1_nldo_s3: vcc-1v1-nldo-s3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_1v1_nldo_s3";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1100000>;
+		regulator-max-microvolt = <1100000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vcc_3v3_sd_s0: vcc-3v3-sd-s0-regulator {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio4 RK_PB4 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&sd_s0_pwr>;
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-max-microvolt = <3000000>;
+		regulator-min-microvolt = <3000000>;
+		regulator-name = "vcc_3v3_sd_s0";
+		vin-supply = <&vcc_3v3_s3>;
+	};
+
+	vcc_3v3_pcie20: vcc3v3-pcie20 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_3v3_pcie20";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&vcc_3v3_s3>;
+	};
+
+	vbus5v0_typec: vbus5v0-typec {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio1 RK_PD2 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&typec5v_pwren>;
+		regulator-name = "vbus5v0_typec";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc5v0_usb>;
+	};
+
+	test-power {
+		status = "okay";
+	};
+};
+
+&av1d {
+	status = "okay";
+};
+
+&av1d_mmu {
+	status = "okay";
+};
+
+&combphy0_ps {
+	status = "okay";
+};
+
+&combphy2_psu {
+	status = "okay";
+};
+
+&cpu_l0 {
+	cpu-supply = <&vdd_cpu_lit_s0>;
+	mem-supply = <&vdd_cpu_lit_mem_s0>;
+};
+
+&cpu_b0 {
+	cpu-supply = <&vdd_cpu_big0_s0>;
+	mem-supply = <&vdd_cpu_big0_mem_s0>;
+};
+
+&cpu_b2 {
+	cpu-supply = <&vdd_cpu_big1_s0>;
+	mem-supply = <&vdd_cpu_big1_mem_s0>;
+};
+
+&gpu {
+	mali-supply = <&vdd_gpu_s0>;
+	mem-supply = <&vdd_gpu_mem_s0>;
+	upthreshold = <60>;
+	downdifferential = <30>;
+	status = "okay";
+};
+
+&gmac1 {
+	/* Use rgmii-rxid mode to disable rx delay inside Soc */
+	phy-mode = "rgmii-rxid";
+	clock_in_out = "output";
+
+	snps,no-vlhash;
+	snps,reset-gpio = <&gpio3 RK_PB7 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	/* Reset time is 20ms, 100ms for rtl8211f */
+	snps,reset-delays-us = <0 20000 100000>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac1_miim
+		     &gmac1_tx_bus2
+		     &gmac1_rx_bus2
+		     &gmac1_rgmii_clk
+		     &gmac1_rgmii_bus>;
+
+	tx_delay = <0x42>;
+	/* rx_delay = <0x4f>; */
+
+	phy-handle = <&rgmii_phy1>;
+	status = "okay";
+};
+
+&mdio1 {
+	rgmii_phy1: phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x1>;
+	};
+};
+
+&i2s5_8ch {
+	status = "okay";
+};
+
+&hdmi0 {
+	enable-gpios = <&gpio4 RK_PB6 GPIO_ACTIVE_HIGH>;
+	status = "okay";
+	cec-enable = "true";
+};
+
+&hdmi0_in_vp0 {
+	status = "okay";
+};
+
+&hdmi0_sound {
+	status = "okay";
+};
+
+&hdptxphy_hdmi0 {
+	status = "okay";
+};
+
+&hdptxphy0 {
+	/* Single Vdiff Training Table for power reduction (optional) */
+	training-table = /bits/ 8 <
+		/* voltage swing 0, pre-emphasis 0->3 */
+		0x0d 0x00 0x00 0x00 0x00 0x00
+		0x0d 0x00 0x00 0x00 0x00 0x00
+		0x0d 0x00 0x00 0x00 0x00 0x00
+		0x0d 0x00 0x00 0x00 0x00 0x00
+		/* voltage swing 1, pre-emphasis 0->2 */
+		0x0d 0x00 0x00 0x00 0x00 0x00
+		0x0d 0x00 0x00 0x00 0x00 0x00
+		0x0d 0x00 0x00 0x00 0x00 0x00
+		/* voltage swing 2, pre-emphasis 0->1 */
+		0x0d 0x00 0x00 0x00 0x00 0x00
+		0x0d 0x00 0x00 0x00 0x00 0x00
+		/* voltage swing 3, pre-emphasis 0 */
+		0x0d 0x00 0x00 0x00 0x00 0x00
+	>;
+	status = "disabled";
+};
+
+&i2c0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0m2_xfer>;
+
+	vdd_cpu_big0_s0: vdd_cpu_big0_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big0_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vdd_cpu_big1_s0: vdd_cpu_big1_mem_s0: rk8603@43 {
+		compatible = "rockchip,rk8603";
+		reg = <0x43>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big1_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c2 {
+	status = "okay";
+
+	vdd_npu_s0: vdd_npu_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_npu_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <950000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c3 {
+	status = "disabled";
+};
+
+&i2c4 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c4m3_xfer>;
+};
+
+&i2c5 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c5m3_xfer>;
+};
+
+&i2c6 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c6m0_xfer>;
+
+	hym8563: hym8563@51 {
+		compatible = "haoyu,hym8563";
+		reg = <0x51>;
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		clock-output-names = "hym8563";
+		pinctrl-names = "default";
+		pinctrl-0 = <&rtc_int>;
+
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PB0 IRQ_TYPE_LEVEL_LOW>;
+		wakeup-source;
+	};
+};
+
+&i2c7 {
+	status = "disabled";
+};
+
+&i2c8 {
+	status = "disabled";
+};
+
+&iep {
+	status = "okay";
+};
+
+&iep_mmu {
+	status = "okay";
+};
+
+&jpegd {
+	status = "okay";
+};
+
+&jpegd_mmu {
+	status = "okay";
+};
+
+&jpege_ccu {
+	status = "okay";
+};
+
+&jpege0 {
+	status = "okay";
+};
+
+&jpege0_mmu {
+	status = "okay";
+};
+
+&jpege1 {
+	status = "okay";
+};
+
+&jpege1_mmu {
+	status = "okay";
+};
+
+&jpege2 {
+	status = "okay";
+};
+
+&jpege2_mmu {
+	status = "okay";
+};
+
+&jpege3 {
+	status = "okay";
+};
+
+&jpege3_mmu {
+	status = "okay";
+};
+
+&mpp_srv {
+	status = "okay";
+};
+
+&pcie2x1l1 {
+	reset-gpios = <&gpio1 RK_PA7 GPIO_ACTIVE_HIGH>;
+	rockchip,init-delay-ms = <100>;
+	vpcie3v3-supply = <&vcc_3v3_pcie20>;
+	status = "okay";
+};
+
+&pcie2x1l2 {
+	reset-gpios = <&gpio3 RK_PD1 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc_3v3_pcie20>;
+	status = "okay";
+};
+
+&pinctrl {
+	hym8563 {
+		rtc_int: rtc-int {
+			rockchip,pins = <0 RK_PB0 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	sdmmc {
+		sd_s0_pwr: sd-s0-pwr {
+			rockchip,pins = <4 RK_PB4 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	usb {
+		typec5v_pwren: typec5v-pwren {
+			rockchip,pins = <1 RK_PD2 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		/omit-if-no-ref/
+		usbc0_int: usbc0-int {
+			rockchip,pins = <0 RK_PD3 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+};
+
+&pwm3 {
+	compatible = "rockchip,remotectl-pwm";
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwm3m0_pins>;
+	remote_pwm_id = <3>;
+	handle_cpu_id = <1>;
+	remote_support_psci = <0>;
+	status = "okay";
+
+	ir_key1 {
+		rockchip,usercode = <0xc43b>;
+		/* /system/usr/keylayout/Generic.kl */
+		rockchip,key_table =
+			<0xff	KEY_POWER>,
+			<0xef	KEY_LEFT>,
+			<0xed	KEY_RIGHT>,
+			<0xf2	KEY_UP>,
+			<0xea	KEY_DOWN>,
+			<0xee	KEY_ENTER>,
+			<0xe9	KEY_MUTE>,
+			<0xf1	KEY_VOLUMEDOWN>,
+			<0xf3	KEY_VOLUMEUP>,
+			<0xae	KEY_MENU>,
+			<0xeb	172>,
+			<0xaf	KEY_BACK>,
+			<0xf7	204>,
+			<0xe5	KEY_SYSRQ>,
+			<0xf5	580>;
+	};
+};
+
+&rga3_core0 {
+	status = "okay";
+};
+
+&rga3_0_mmu {
+	status = "okay";
+};
+
+&rga3_core1 {
+	status = "okay";
+};
+
+&rga3_1_mmu {
+	status = "okay";
+};
+
+&rga2 {
+	status = "okay";
+};
+
+&rknpu {
+	rknpu-supply = <&vdd_npu_s0>;
+	mem-supply = <&vdd_npu_mem_s0>;
+	status = "okay";
+};
+
+&rknpu_mmu {
+	status = "okay";
+};
+
+&rkvdec_ccu {
+	status = "okay";
+};
+
+&rkvdec0 {
+	status = "okay";
+};
+
+&rkvdec0_mmu {
+	status = "okay";
+};
+
+&rkvdec1 {
+	status = "okay";
+};
+
+&rkvdec1_mmu {
+	status = "okay";
+};
+
+&rkvenc_ccu {
+	status = "okay";
+};
+
+&rkvenc0 {
+	status = "okay";
+};
+
+&rkvenc0_mmu {
+	status = "okay";
+};
+
+&rkvenc1 {
+	status = "okay";
+};
+
+&rkvenc1_mmu {
+	status = "okay";
+};
+
+&avcc_1v8_s0 {
+	regulator-state-mem {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <1800000>;
+	};
+};
+
+&vdd_log_s0 {
+	regulator-state-mem {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <750000>;
+	};
+};
+
+&rockchip_suspend {
+	status = "okay";
+	rockchip,sleep-debug-en = <1>;
+	rockchip,sleep-mode-config = <
+		(0
+		| RKPM_SLP_ARMOFF_DDRPD
+		)
+	>;
+	rockchip,wakeup-config = <
+		(0
+		| RKPM_CPU0_WKUP_EN
+		| RKPM_GPIO_WKUP_EN
+		)
+	>;
+};
+
+&route_hdmi0 {
+	status = "okay";
+	connect = <&vp0_out_hdmi0>;
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&avcc_1v8_s0>;
+};
+
+&sdhci {
+	bus-width = <8>;
+	no-sdio;
+	no-sd;
+	non-removable;
+	max-frequency = <200000000>;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	status = "okay";
+};
+
+&sdmmc {
+	max-frequency = <150000000>;
+	no-sdio;
+	no-mmc;
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	sd-uhs-sdr104;
+	vmmc-supply = <&vcc_3v3_sd_s0>;
+	vqmmc-supply = <&vccio_sd_s0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc_bus4 &sdmmc_clk &sdmmc_cmd &sdmmc_det>;
+	status = "okay";
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&u2phy0 {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	status = "okay";
+};
+
+&u2phy2 {
+	status = "okay";
+};
+
+&u2phy2_host {
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usbdp_phy0 {
+	status = "okay";
+};
+
+&usbdp_phy0_u3 {
+	status = "okay";
+};
+
+&usbdrd3_0 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	dr_mode = "otg";
+	extcon = <&u2phy0>;
+	status = "okay";
+};
+
+&usbhost3_0 {
+	status = "disabled";
+};
+
+&usbhost_dwc3_0 {
+	status = "disabled";
+};
+
+&vdpu {
+	status = "okay";
+};
+
+&vdpu_mmu {
+	status = "okay";
+};
+
+&vop {
+	assigned-clocks = <&cru ACLK_VOP>;
+	assigned-clock-rates = <800000000>;
+	status = "okay";
+	disable-win-move;
+};
+
+&vop_mmu {
+	status = "okay";
+};
+
+/* vp0 & vp1 splice for 8K output */
+&vp0 {
+	cursor-win-id=<ROCKCHIP_VOP2_ESMART0>;
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER0>;
+};
+
+&vp1 {
+	cursor-win-id=<ROCKCHIP_VOP2_ESMART1>;
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER1>;
+};
+
+&vp2 {
+	cursor-win-id=<ROCKCHIP_VOP2_ESMART2>;
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER2 | 1 << ROCKCHIP_VOP2_ESMART2)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER2>;
+};
+
+&vp3 {
+	cursor-win-id=<ROCKCHIP_VOP2_ESMART3>;
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER3>;
+};
+
+&display_subsystem {
+	clocks = <&hdptxphy_hdmi_clk0>;
+	clock-names = "hdmi0_phy_pll";
+};
\ No newline at end of file
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-nanopi-r6c.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-nanopi-r6c.dts
@@ -0,0 +1,28 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2023 FriendlyElec Computer Tech. Co., Ltd.
+ * (http://www.friendlyelec.com)
+ *
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ */
+
+/dts-v1/;
+
+#include "rk3588s-nanopi-r6s.dts"
+
+/ {
+	model = "FriendlyElec NanoPi R6C";
+	compatible = "friendlyelec,nanopi-r6c", "rockchip,rk3588";
+
+	aliases {
+		ethernet0 = &r8125_u25;
+	};
+};
+
+&lan2_led {
+	label = "user_led";
+};
+
+&pcie2x1l2 {
+	/delete-node/ pcie@40;
+};
\ No newline at end of file
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-nanopi-r6s.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-nanopi-r6s.dts
@@ -0,0 +1,178 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 FriendlyElec Computer Tech. Co., Ltd.
+ * (http://www.friendlyelec.com)
+ *
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ */
+
+ /dts-v1/;
+
+#include "rk3588s-nanopi-r6-common.dtsi"
+
+/ {
+	model = "FriendlyElec NanoPi R6S";
+	compatible = "friendlyelec,nanopi-r6s", "rockchip,rk3588";
+
+	aliases {
+		ethernet0 = &r8125_u25;
+	};
+
+	gpio_keys: gpio-keys {
+		compatible = "gpio-keys";
+		pinctrl-names = "default";
+		pinctrl-0 = <&key1_pin>;
+
+		button@1 {
+			debounce-interval = <50>;
+			gpios = <&gpio1 RK_PC0 GPIO_ACTIVE_LOW>;
+			label = "K1";
+			linux,code = <BTN_1>;
+			wakeup-source;
+		};
+	};
+
+	gpio_leds: gpio-leds {
+		compatible = "gpio-leds";
+
+		sys_led: led-0 {
+			gpios = <&gpio1 RK_PC1 GPIO_ACTIVE_HIGH>;
+			label = "sys_led";
+			linux,default-trigger = "heartbeat";
+			pinctrl-names = "default";
+			pinctrl-0 = <&sys_led_pin>;
+		};
+
+		wan_led: led-1 {
+			gpios = <&gpio1 RK_PC2 GPIO_ACTIVE_HIGH>;
+			label = "wan_led";
+			pinctrl-names = "default";
+			pinctrl-0 = <&wan_led_pin>;
+		};
+
+		lan1_led: led-2 {
+			gpios = <&gpio1 RK_PC3 GPIO_ACTIVE_HIGH>;
+			label = "lan1_led";
+			pinctrl-names = "default";
+			pinctrl-0 = <&lan1_led_pin>;
+		};
+
+		lan2_led: led-3 {
+			gpios = <&gpio1 RK_PC4 GPIO_ACTIVE_HIGH>;
+			label = "lan2_led";
+			pinctrl-names = "default";
+			pinctrl-0 = <&lan2_led_pin>;
+		};
+	};
+
+	vcc5v0_host_20: vcc5v0-host-20 {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio4 RK_PB5 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_host20_en>;
+		regulator-name = "vcc5v0_host_20";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc5v0_usb>;
+	};
+};
+
+&pcie2x1l1 {
+	pcie@30 {
+		reg = <0x00300000 0 0 0 0>;
+		#address-cells = <3>;
+		#size-cells = <2>;
+
+		r8125_u25: pcie@30,0 {
+			reg = <0x000000 0 0 0 0>;
+			local-mac-address = [ 00 00 00 00 00 00 ];
+		};
+	};
+};
+
+&pcie2x1l2 {
+	pcie@40 {
+		reg = <0x00400000 0 0 0 0>;
+		#address-cells = <3>;
+		#size-cells = <2>;
+
+		r8125_u40: pcie@40,0 {
+			reg = <0x000000 0 0 0 0>;
+			local-mac-address = [ 00 00 00 00 00 00 ];
+		};
+	};
+};
+
+&pinctrl {
+	gpio-key {
+		key1_pin: key1-pin {
+			rockchip,pins = <1 RK_PC0 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	gpio-leds {
+		sys_led_pin: sys-led-pin {
+			rockchip,pins =
+				<1 RK_PC1 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		wan_led_pin: wan-led-pin {
+			rockchip,pins =
+				<1 RK_PC2 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		lan1_led_pin: lan1-led-pin {
+			rockchip,pins =
+				<1 RK_PC3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		lan2_led_pin: lan2-led-pin {
+			rockchip,pins =
+				<1 RK_PC4 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	usb {
+		vcc5v0_host20_en: vcc5v0-host20-en {
+			rockchip,pins = <4 RK_PB5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+};
+
+&i2c6 {
+	clock-frequency = <200000>;
+	status = "okay";
+
+	eeprom@53 {
+		compatible = "microchip,24c02", "atmel,24c02";
+		reg = <0x53>;
+		#address-cells = <2>;
+		#size-cells = <0>;
+		pagesize = <16>;
+		size = <256>;
+
+		eui_48: eui-48@fa {
+			reg = <0xfa 0x06>;
+		};
+	};
+};
+
+&u2phy0 {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	phy-supply = <&vbus5v0_typec>;
+	status = "okay";
+};
+
+&u2phy2 {
+	status = "okay";
+};
+
+&u2phy2_host {
+	phy-supply = <&vcc5v0_host_20>;
+	status = "okay";
+};
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-orangepi-5-camera1.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-orangepi-5-camera1.dtsi
@@ -0,0 +1,170 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+&csi2_dphy0_hw {
+	status = "disabled";
+};
+
+&csi2_dphy0 {
+	status = "disabled";
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi_in_ucam0: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&ov13850_out2>;
+				data-lanes = <1 2>;
+			};
+
+			mipi_in_ucam1: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&ov13855_out2>;
+				data-lanes = <1 2>;
+			};
+		};
+		port@1 {
+		        reg = <1>;
+		        #address-cells = <1>;
+		        #size-cells = <0>;
+		        csidphy0_out: endpoint@0 {
+		                reg = <0>;
+		                remote-endpoint = <&mipi2_csi2_input>;
+		        };
+		};
+	};
+};
+
+&i2c7 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c7m0_xfer>;
+
+	vm149c_p1: vm149c-p1@c {
+		compatible = "silicon touch,vm149c";
+		status = "disabled";
+		reg = <0x0c>;
+		rockchip,camera-module-index = <1>;
+		rockchip,camera-module-facing = "back";
+	};
+
+	ov13850_1: ov13850-1@10 {
+		compatible = "ovti,ov13850";
+		status = "disabled";
+		reg = <0x10>;
+		clocks = <&cru CLK_MIPI_CAMARAOUT_M3>;
+		clock-names = "xvclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&mipim0_camera3_clk>;
+		reset-gpios = <&gpio3 RK_PC4 GPIO_ACTIVE_HIGH>;
+		pwdn-gpios = <&gpio3 RK_PC6 GPIO_ACTIVE_HIGH>;
+		rockchip,camera-module-index = <0>;
+		rockchip,camera-module-facing = "back";
+		rockchip,camera-module-name = "CMK-CT0116";
+		rockchip,camera-module-lens-name = "default";
+		lens-focus = <&vm149c_p1>;
+		port {
+			ov13850_out2: endpoint {
+				remote-endpoint = <&mipi_in_ucam0>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+
+	dw9714_p1: dw9714-p1@c {
+		compatible = "dongwoon,dw9714";
+		status = "disabled";
+		reg = <0x0c>;
+		rockchip,camera-module-index = <0>;
+		rockchip,vcm-start-current = <10>;
+		rockchip,vcm-rated-current = <85>;
+		rockchip,vcm-step-mode = <5>;
+		rockchip,camera-module-facing = "back";
+	};
+
+	ov13855_1: ov13855-1@36 {
+		compatible = "ovti,ov13855";
+		status = "disabled";
+		reg = <0x36>;
+		clocks = <&cru CLK_MIPI_CAMARAOUT_M3>;
+		clock-names = "xvclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&mipim0_camera3_clk>;
+		reset-gpios = <&gpio3 RK_PC4 GPIO_ACTIVE_HIGH>;
+		pwdn-gpios = <&gpio3 RK_PC6 GPIO_ACTIVE_HIGH>;
+		rockchip,camera-module-index = <0>;
+		rockchip,camera-module-facing = "back";
+		rockchip,camera-module-name = "CMK-OT2016-FV1";
+		rockchip,camera-module-lens-name = "default";
+		lens-focus = <&dw9714_p1>;
+		port {
+			ov13855_out2: endpoint {
+				remote-endpoint = <&mipi_in_ucam1>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+};
+
+&mipi2_csi2 {
+	status = "disabled";
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			mipi2_csi2_input: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&csidphy0_out>;
+			};
+		};
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			mipi2_csi2_output: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&cif_mipi_in2>;
+			};
+		};
+	};
+};
+
+&rkcif_mipi_lvds2 {
+	status = "disabled";
+	port {
+		cif_mipi_in2: endpoint {
+			remote-endpoint = <&mipi2_csi2_output>;
+		};
+	};
+};
+
+&rkcif_mipi_lvds2_sditf {
+	status = "disabled";
+	port {
+		mipi2_lvds_sditf: endpoint {
+			remote-endpoint = <&isp0_vir1>;
+		};
+	};
+};
+
+&rkisp0_vir1 {
+	status = "disabled";
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		isp0_vir1: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&mipi2_lvds_sditf>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-orangepi-5-camera2.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-orangepi-5-camera2.dtsi
@@ -0,0 +1,182 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+&csi2_dcphy0 {
+	status = "disabled";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi_in_cam0: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&ov13850_out>;
+				data-lanes = <1 2>;
+			};
+
+			mipi_in_cam1: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&ov13855_out>;
+				data-lanes = <1 2>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			csidcphy0_out: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&mipi0_csi2_input>;
+			};
+		};
+	};
+};
+
+&i2c7 {
+	status = "okay";
+        pinctrl-names = "default";
+        pinctrl-0 = <&i2c7m0_xfer>;
+
+	vm149c_p2: vm149c-p2@c {
+		compatible = "silicon touch,vm149c";
+		status = "disabled";
+		reg = <0x0c>;
+		rockchip,camera-module-index = <1>;
+		rockchip,camera-module-facing = "back";
+	};
+
+	ov13850_2: ov13850-2@10 {
+		compatible = "ovti,ov13850";
+		status = "disabled";
+		reg = <0x10>;
+		clocks = <&cru CLK_MIPI_CAMARAOUT_M4>;
+		clock-names = "xvclk";
+                power-domains = <&power RK3588_PD_VI>;
+		pinctrl-names = "default";
+                pinctrl-0 = <&mipim0_camera4_clk>;
+		rockchip,grf = <&sys_grf>;
+		reset-gpios = <&gpio1 RK_PB2 GPIO_ACTIVE_HIGH>;
+		pwdn-gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_HIGH>;
+		rockchip,camera-module-index = <0>;
+		rockchip,camera-module-facing = "back";
+		rockchip,camera-module-name = "CMK-CT0116";
+		rockchip,camera-module-lens-name = "default";
+		lens-focus = <&vm149c_p2>;
+		port {
+			ov13850_out: endpoint {
+				remote-endpoint = <&mipi_in_cam0>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+
+	dw9714_p2: dw9714-p2@c {
+		compatible = "dongwoon,dw9714";
+		status = "disabled";
+		reg = <0x0c>;
+		rockchip,camera-module-index = <0>;
+		rockchip,vcm-start-current = <10>;
+		rockchip,vcm-rated-current = <85>;
+		rockchip,vcm-step-mode = <5>;
+		rockchip,camera-module-facing = "back";
+	};
+
+	ov13855_2: ov13855-2@36 {
+		compatible = "ovti,ov13855";
+		status = "disabled";
+		reg = <0x36>;
+		clocks = <&cru CLK_MIPI_CAMARAOUT_M4>;
+		clock-names = "xvclk";
+		power-domains = <&power RK3588_PD_VI>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&mipim0_camera4_clk>;
+		rockchip,grf = <&sys_grf>;
+		reset-gpios = <&gpio1 RK_PB2 GPIO_ACTIVE_HIGH>;
+		pwdn-gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_HIGH>;
+		rockchip,camera-module-index = <0>;
+		rockchip,camera-module-facing = "back";
+		rockchip,camera-module-name = "CMK-OT2016-FV1";
+		rockchip,camera-module-lens-name = "default";
+		lens-focus = <&dw9714_p2>;
+		port {
+			ov13855_out: endpoint {
+				remote-endpoint = <&mipi_in_cam1>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+};
+
+&mipi0_csi2 {
+	status = "disabled";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi0_csi2_input: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&csidcphy0_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi0_csi2_output: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&cif_mipi_in0>;
+			};
+		};
+	};
+};
+
+&rkcif_mipi_lvds {
+	status = "disabled";
+
+	port {
+		cif_mipi_in0: endpoint {
+			remote-endpoint = <&mipi0_csi2_output>;
+		};
+	};
+};
+
+&rkcif_mipi_lvds_sditf {
+	status = "disabled";
+
+	port {
+		mipi_lvds_sditf: endpoint {
+			remote-endpoint = <&isp1_in1>;
+		};
+	};
+};
+
+&rkisp0_vir0 {
+	status = "disabled";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		isp1_in1: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&mipi_lvds_sditf>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-orangepi-5-camera3.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-orangepi-5-camera3.dtsi
@@ -0,0 +1,179 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+&csi2_dcphy1 {
+	status = "disabled";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi_in_dcphy0: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&ov13850_out1>;
+				data-lanes = <1 2>;
+			};
+
+			mipi_in_dcphy1: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&ov13855_out1>;
+				data-lanes = <1 2>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			csidcphy1_out: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&mipi1_csi2_input>;
+			};
+		};
+	};
+};
+
+&i2c2 {
+	status = "okay";
+
+	vm149cp1: vm149c@c {
+		compatible = "silicon touch,vm149c";
+		status = "disabled";
+		reg = <0x0c>;
+		rockchip,camera-module-index = <1>;
+		rockchip,camera-module-facing = "front";
+	};
+
+	ov13850_3: ov13850@10 {
+		compatible = "ovti,ov13850";
+		status = "disabled";
+		reg = <0x10>;
+		clocks = <&cru CLK_MIPI_CAMARAOUT_M4>;
+		clock-names = "xvclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&mipim0_camera4_clk>;
+		rockchip,grf = <&sys_grf>;
+		reset-gpios = <&gpio1 RK_PA6 GPIO_ACTIVE_HIGH>;
+		pwdn-gpios = <&gpio3 RK_PC5 GPIO_ACTIVE_HIGH>;
+		rockchip,camera-module-index = <1>;
+		rockchip,camera-module-facing = "front";
+		rockchip,camera-module-name = "CMK-CT0116";
+		rockchip,camera-module-lens-name = "default";
+		lens-focus = <&vm149cp1>;
+		port {
+			ov13850_out1: endpoint {
+				remote-endpoint = <&mipi_in_dcphy0>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+
+	dw9714: dw9714@c {
+		compatible = "dongwoon,dw9714";
+		status = "disabled";
+		reg = <0x0c>;
+		rockchip,camera-module-index = <0>;
+		rockchip,vcm-start-current = <10>;
+		rockchip,vcm-rated-current = <85>;
+		rockchip,vcm-step-mode = <5>;
+		rockchip,camera-module-facing = "front";
+	};
+
+	ov13855_3: ov13855@36 {
+		compatible = "ovti,ov13855";
+		status = "disabled";
+		reg = <0x36>;
+		clocks = <&cru CLK_MIPI_CAMARAOUT_M4>;
+		clock-names = "xvclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&mipim0_camera4_clk>;
+		rockchip,grf = <&sys_grf>;
+		reset-gpios = <&gpio1 RK_PA6 GPIO_ACTIVE_HIGH>;
+		pwdn-gpios = <&gpio3 RK_PC5 GPIO_ACTIVE_HIGH>;
+		rockchip,camera-module-index = <1>;
+		rockchip,camera-module-facing = "front";
+		rockchip,camera-module-name = "CMK-OT2016-FV1";
+		rockchip,camera-module-lens-name = "default";
+		lens-focus = <&dw9714>;
+		port {
+			ov13855_out1: endpoint {
+				remote-endpoint = <&mipi_in_dcphy1>;
+				data-lanes = <1 2>;
+			};
+		};
+	};
+};
+
+&mipi1_csi2 {
+	status = "disabled";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi1_csi2_input: endpoint@1 {
+				reg = <1>;
+				remote-endpoint = <&csidcphy1_out>;
+			};
+		};
+
+		port@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			mipi1_csi2_output: endpoint@0 {
+				reg = <0>;
+				remote-endpoint = <&cif_mipi_in1>;
+			};
+		};
+	};
+};
+
+&rkcif_mipi_lvds1 {
+	status = "disabled";
+
+	port {
+		cif_mipi_in1: endpoint {
+			remote-endpoint = <&mipi1_csi2_output>;
+		};
+	};
+};
+
+&rkcif_mipi_lvds1_sditf {
+	status = "disabled";
+
+        port {
+                mipi1_lvds_sditf: endpoint {
+                        remote-endpoint = <&isp1_in0>;
+                };
+        };
+};
+
+&rkisp1_vir0 {
+	status = "disabled";
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		isp1_in0: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&mipi1_lvds_sditf>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-orangepi-5-lcd.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-orangepi-5-lcd.dtsi
@@ -0,0 +1,101 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+
+&dsi0 {
+	status = "disabled";
+};
+
+&dsi0_panel {
+	status = "disabled";
+	reset-gpios = <&gpio1 RK_PB1 GPIO_ACTIVE_LOW>;
+	enable-gpios = <&gpio1 RK_PA0 GPIO_ACTIVE_HIGH>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&lcd0_rst_gpio>;
+};
+
+&dsi0_in_vp2 {
+	status = "disabled";
+};
+
+&dsi0_in_vp3 {
+	status = "disabled";
+};
+
+&route_dsi0 {
+	status = "disabled";
+	connect = <&vp3_out_dsi0>;
+};
+
+&mipi_dcphy0 {
+	status = "okay";
+};
+
+&i2c7 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c7m0_xfer>;
+
+	gt9xx_1: touchscreen@14 {
+		compatible = "goodix,gt9271";
+		reg = <0x14>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <RK_PB5 IRQ_TYPE_LEVEL_LOW>;
+		irq-gpios = <&gpio1 RK_PB5 IRQ_TYPE_LEVEL_LOW>;
+		reset-gpios = <&gpio1 RK_PB4 GPIO_ACTIVE_HIGH>;
+		touchscreen-inverted-x;
+		//touchscreen-inverted-y;
+		touchscreen-swapped-x-y;
+		touchscreen-size-x = <1280>;
+		touchscreen-size-y = <800>;
+		status = "okay";
+	};
+};
+
+
+
+&dsi1 {
+	status = "disabled";
+};
+
+&dsi1_panel {
+	status = "disabled";
+	reset-gpios = <&gpio1 RK_PB3 GPIO_ACTIVE_LOW>;
+	enable-gpios = <&gpio1 RK_PA1 GPIO_ACTIVE_HIGH>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&lcd1_rst_gpio>;
+};
+
+&dsi1_in_vp2 {
+	status = "disabled";
+};
+
+&dsi1_in_vp3 {
+	status = "disabled";
+};
+
+&route_dsi1 {
+	status = "disabled";
+	connect = <&vp3_out_dsi1>;
+};
+
+&mipi_dcphy1 {
+	status = "okay";
+};
+
+&i2c2 {
+	status = "okay";
+
+	gt9xx_0: touchscreen@14 {
+		compatible = "goodix,gt9271";
+		reg = <0x14>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <RK_PA7 IRQ_TYPE_LEVEL_LOW>;
+		irq-gpios = <&gpio1 RK_PA7 IRQ_TYPE_LEVEL_LOW>;
+		reset-gpios = <&gpio1 RK_PA4 GPIO_ACTIVE_HIGH>;
+		touchscreen-inverted-x;
+		//touchscreen-inverted-y;
+		touchscreen-swapped-x-y;
+		touchscreen-size-x = <1280>;
+		touchscreen-size-y = <800>;
+		status = "okay";
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-orangepi-5.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-orangepi-5.dts
@@ -0,0 +1,441 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+/dts-v1/;
+
+#include "rk3588s-orangepi-5.dtsi"
+#include "rk3588-linux.dtsi"
+#include "rk3588s-orangepi-5-lcd.dtsi"
+
+#include "rk3588s-orangepi-5-camera1.dtsi"
+#include "rk3588s-orangepi-5-camera2.dtsi"
+#include "rk3588s-orangepi-5-camera3.dtsi"
+
+/ {
+	model = "Orange Pi 5";
+	compatible = "rockchip,rk3588s-orangepi-5", "rockchip,rk3588";
+
+	/delete-node/ chosen;
+
+	vcc_3v3_sd_s0: vcc-3v3-sd-s0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_3v3_sd_s0";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		gpios = <&gpio4 RK_PB5 GPIO_ACTIVE_LOW>;
+		enable-active-low;
+		vin-supply = <&vcc_3v3_s3>;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vcc_1v1_nldo_s3: vcc-1v1-nldo-s3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_1v1_nldo_s3";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1100000>;
+		regulator-max-microvolt = <1100000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vcc3v3_pcie2x1l2: vcc3v3-pcie2x1l2 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_pcie2x1l2";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		enable-active-high;
+		regulator-boot-on;
+		regulator-always-on;
+		gpios = <&gpio0 RK_PC5 GPIO_ACTIVE_HIGH>;
+		startup-delay-us = <50000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	leds: gpio-leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+		pinctrl-0 =<&leds_gpio>;
+		status = "okay";
+
+		led@1 {
+			gpios = <&gpio1 RK_PA2 GPIO_ACTIVE_HIGH>;
+			label = "status_led";
+			linux,default-trigger = "heartbeat";
+			linux,default-trigger-delay-ms = <0>;
+		};
+	};
+
+	/* If hdmirx node is disabled, delete the reserved-memory node here. */
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* Reserve 256MB memory for hdmirx-controller@fdee0000 */
+		cma {
+			compatible = "shared-dma-pool";
+			reusable;
+			reg = <0x0 (256 * 0x100000) 0x0 (256 * 0x100000)>;
+			linux,cma-default;
+		};
+	};
+};
+
+&gmac1 {
+	/* Use rgmii-rxid mode to disable rx delay inside Soc */
+	phy-mode = "rgmii-rxid";
+	clock_in_out = "output";
+
+	snps,reset-gpio = <&gpio3 RK_PB2 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	/* Reset time is 20ms, 100ms for rtl8211f */
+	snps,reset-delays-us = <0 20000 100000>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac1_miim
+	             &gmac1_tx_bus2
+	             &gmac1_rx_bus2
+	             &gmac1_rgmii_clk
+	             &gmac1_rgmii_bus>;
+
+	tx_delay = <0x42>;
+	/* rx_delay = <0x3f>; */
+
+	phy-handle = <&rgmii_phy1>;
+	status = "okay";
+};
+
+&mdio1 {
+	rgmii_phy1: phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x1>;
+	};
+};
+
+&hdmi0 {
+	enable-gpios = <&gpio4 RK_PB6 GPIO_ACTIVE_HIGH>;
+	cec-enable;
+	status = "okay";
+};
+
+&hdmi0_in_vp0 {
+	status = "okay";
+};
+
+&hdmi0_sound {
+	status = "okay";
+};
+
+&hdptxphy_hdmi0 {
+	status = "okay";
+};
+
+&route_hdmi0{
+	status = "okay";
+};
+
+&i2s5_8ch {
+	status = "okay";
+};
+
+&i2s1_8ch {
+	status = "okay";
+	rockchip,i2s-tx-route = <3 2 1 0>;
+	rockchip,i2s-rx-route = <1 3 2 0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2s1m0_sclk
+	             &i2s1m0_lrck
+	             &i2s1m0_sdi1
+	             &i2s1m0_sdo3>;
+};
+
+&i2c0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0m2_xfer>;
+
+	vdd_cpu_big0_s0: vdd_cpu_big0_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big0_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vdd_cpu_big1_s0: vdd_cpu_big1_mem_s0: rk8603@43 {
+		compatible = "rockchip,rk8603";
+		reg = <0x43>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big1_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c2 {
+	status = "okay";
+
+	vdd_npu_s0: vdd_npu_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_npu_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <950000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+/*
+   pin3: GPIO1_B7
+   pin5: GPIO1_B6
+*/
+&i2c5 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c5m3_xfer>;
+};
+
+&uart1 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart1m1_xfer>;
+};
+
+&pwm13 {
+	status = "disabled";
+	pinctrl-names = "active";
+	pinctrl-0 = <&pwm13m2_pins>;
+};
+
+/*
+   pin7: GPIO1_C6
+*/
+&pwm15 {
+	status = "disabled";
+	pinctrl-names = "active";
+	pinctrl-0 = <&pwm15m2_pins>;
+};
+
+/*
+   pin11: GPIO4_B2
+   pin13: GPIO4_B3
+*/
+&pwm14 {
+	status = "disabled";
+	pinctrl-names = "active";
+	pinctrl-0 = <&pwm14m1_pins>;
+};
+
+&can1 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&can1m1_pins>;
+	assigned-clocks = <&cru CLK_CAN1>;
+	assigned-clock-rates = <200000000>;
+};
+
+/*
+   pin15: GPIO0_D4
+   pin12: GPIO0_D5
+*/
+&can2 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&can2m1_pins>;
+	assigned-clocks = <&cru CLK_CAN2>;
+	assigned-clock-rates = <200000000>;
+};
+
+/*
+   pin19: GPIO1_C1
+   pin21: GPIO1_C0
+   pin23: GPIO1_C2
+   pin24: GPIO1_C4
+*/
+&spi4 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi4m0_cs1 &spi4m0_pins>;
+	assigned-clocks = <&cru CLK_SPI4>;
+	assigned-clock-rates = <200000000>;
+	num-cs = <2>;
+
+	spi_dev@1 {
+		compatible = "rockchip,spidev";
+		reg = <1>;
+		spi-max-frequency = <50000000>;
+	};
+};
+
+&i2c3 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c3m0_xfer>;
+};
+
+&uart3 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart3m0_xfer>;
+};
+
+&pwm3 {
+	status = "disabled";
+	pinctrl-names = "active";
+	pinctrl-0 = <&pwm3m2_pins>;
+	//pinctrl-0 = <&pwm3m0_pins>;
+};
+
+/*
+   pin8:  GPIO4_A3
+   pin10: GPIO4_A4
+*/
+&uart0 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0m2_xfer>;
+};
+
+/*
+   pin16: GPIO1_D3
+   pin18: GPIO1_D2
+*/
+&uart4 {
+	status = "disabled";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart4m0_xfer>;
+};
+
+&i2c1 {
+	status = "disabled";
+	pinctrl-names = "default";
+	//pinctrl-0 = <&i2c1m4_xfer>;
+	pinctrl-0 = <&i2c1m2_xfer>;
+};
+
+&pwm0 {
+	status = "disabled";
+	pinctrl-names = "active";
+	pinctrl-0 = <&pwm0m1_pins>;
+};
+
+/*
+   pin26: GPIO1_A3
+*/
+&pwm1 {
+	status = "disabled";
+	pinctrl-names = "active";
+	//pinctrl-0 = <&pwm1m2_pins>;
+	pinctrl-0 = <&pwm1m1_pins>;
+};
+
+/* watchdog */
+&wdt {
+        status = "okay";
+};
+
+&sfc {
+	status = "okay";
+	max-freq = <100000000>;
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&fspim0_pins>;
+
+	spi_flash: spi-flash@0 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		compatible = "jedec,spi-nor";
+		reg = <0x0>;
+		spi-max-frequency = <100000000>;
+		spi-tx-bus-width = <1>;
+		spi-rx-bus-width = <4>;
+		status = "okay";
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			loader@0 {
+				label = "loader";
+				reg = <0x0 0x1000000>;
+			};
+		};
+	};
+};
+
+&mipi_dcphy0 {
+        status = "okay";
+};
+
+&mipi_dcphy1 {
+        status = "okay";
+};
+
+&rkcif {
+	status = "okay";
+};
+
+&rkcif_mmu {
+	status = "okay";
+};
+
+&rkisp0 {
+	status = "okay";
+};
+
+&isp0_mmu {
+	status = "okay";
+};
+
+&rkisp1 {
+	status = "okay";
+};
+
+&isp1_mmu {
+	status = "okay";
+};
+
+&sata0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&sata_reset>;
+	status = "disabled";
+};
+
+&pcie2x1l2 {
+	reset-gpios = <&gpio3 RK_PD1 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_pcie2x1l2>;
+	rockchip,skip-scan-in-resume;
+	status = "okay";
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-orangepi-5.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-orangepi-5.dtsi
@@ -0,0 +1,387 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+#include "dt-bindings/usb/pd.h"
+#include "rk3588s.dtsi"
+#include "rk3588s-orangepi.dtsi"
+#include "rk3588-rk806-single.dtsi"
+
+/ {
+	combophy_avdd0v85: combophy-avdd0v85 {
+		compatible = "regulator-fixed";
+		regulator-name = "combophy_avdd0v85";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <850000>;
+		regulator-max-microvolt = <850000>;
+		vin-supply = <&vdd_0v85_s0>;
+	};
+
+	combophy_avdd1v8: combophy-avdd1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "combophy_avdd1v8";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		vin-supply = <&avcc_1v8_s0>;
+	};
+
+	es8388_sound: es8388-sound {
+		status = "okay";
+		compatible = "rockchip,multicodecs-card";
+		rockchip,card-name = "rockchip-es8388";
+		hp-det-gpio = <&gpio1 RK_PD5 GPIO_ACTIVE_HIGH>;
+		io-channels = <&saradc 3>;
+		io-channel-names = "adc-detect";
+		keyup-threshold-microvolt = <1800000>;
+		poll-interval = <100>;
+		rockchip,format = "i2s";
+		rockchip,mclk-fs = <256>;
+		rockchip,cpu = <&i2s1_8ch>;
+		rockchip,codec = <&es8388>;
+		rockchip,audio-routing =
+			"Headphone", "LOUT1",
+			"Headphone", "ROUT1",
+			"Headphone", "Headphone Power",
+			"Headphone", "Headphone Power",
+			"LINPUT1", "Main Mic",
+			"LINPUT2", "Main Mic",
+			"RINPUT1", "Headset Mic",
+			"RINPUT2", "Headset Mic";
+		pinctrl-names = "default";
+		pinctrl-0 = <&hp_det>;
+		play-pause-key {
+			label = "playpause";
+			linux,code = <KEY_PLAYPAUSE>;
+			press-threshold-microvolt = <2000>;
+		};
+	};
+
+	wireless_bluetooth: wireless-bluetooth {
+		compatible = "bluetooth-platdata";
+		clocks = <&hym8563>;
+		clock-names = "ext_clock";
+		uart_rts_gpios = <&gpio3 RK_PD2 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default", "rts_gpio";
+		pinctrl-0 = <&uart9m2_rtsn>, <&bt_gpio>;
+		pinctrl-1 = <&uart9_gpios>;
+		BT,reset_gpio    = <&gpio3 RK_PA6 GPIO_ACTIVE_HIGH>;
+		BT,wake_gpio     = <&gpio0 RK_PC6 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+
+	wireless_wlan: wireless-wlan {
+		compatible = "wlan-platdata";
+		wifi_chip_type = "ap6275p";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_host_wake_irq>, <&wifi_poweren_gpio>;
+		WIFI,host_wake_irq = <&gpio0 RK_PA0 GPIO_ACTIVE_HIGH>;
+		WIFI,poweren_gpio = <&gpio0 RK_PD0 GPIO_ACTIVE_HIGH>;
+		status = "disabled";
+	};
+
+	vbus5v0_typec: vbus5v0-typec {
+		compatible = "regulator-fixed";
+		regulator-name = "vbus5v0_typec";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio3 RK_PC0 GPIO_ACTIVE_HIGH>;
+		vin-supply = <&vcc5v0_usb>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&typec5v_pwren>;
+	};
+};
+
+&pwm6 {
+	status = "okay";
+	pinctrl-names = "active";
+	pinctrl-0 = <&pwm6m0_pins>;
+};
+
+&pwm2 {
+	status = "okay";
+	pinctrl-names = "active";
+	pinctrl-0 = <&pwm2m0_pins>;
+};
+
+&backlight_1 {
+	pwms = <&pwm6 0 25000 0>;
+	status = "okay";
+};
+
+&backlight {
+	pwms = <&pwm2 0 25000 0>;
+	status = "okay";
+};
+
+&combphy0_ps {
+	status = "okay";
+};
+
+&dp0 {
+	status = "okay";
+};
+
+&dp0_in_vp1 {
+	status = "disabled";
+};
+
+&dp0_in_vp2 {
+	status = "okay";
+};
+
+&dp0_sound{
+	status = "okay";
+};
+
+&spdif_tx2{
+	status = "okay";
+};
+
+&mipi_dcphy0 {
+	status = "okay";
+};
+
+&mipi_dcphy1 {
+	status = "okay";
+};
+
+&i2c6 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c6m3_xfer>;
+
+	es8388: es8388@10 {
+		status = "okay";
+		#sound-dai-cells = <0>;
+		compatible = "everest,es8388", "everest,es8323";
+		reg = <0x10>;
+		clocks = <&mclkout_i2s1>;
+		clock-names = "mclk";
+		assigned-clocks = <&mclkout_i2s1>;
+		assigned-clock-rates = <12288000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s1m0_mclk>;
+	};
+
+	usbc0: fusb302@22 {
+		compatible = "fcs,fusb302";
+		reg = <0x22>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PD3 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&usbc0_int>;
+		vbus-supply = <&vbus5v0_typec>;
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				usbc0_role_sw: endpoint@0 {
+					remote-endpoint = <&dwc3_0_role_switch>;
+				};
+			};
+		};
+
+		usb_con: connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+			data-role = "dual";
+			power-role = "dual";
+			try-power-role = "sink";
+			op-sink-microwatt = <1000000>;
+			sink-pdos =
+				<PDO_FIXED(5000, 1000, PDO_FIXED_USB_COMM)>;
+			source-pdos =
+				<PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
+
+			altmodes {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				altmode@0 {
+					reg = <0>;
+					svid = <0xff01>;
+					vdo = <0xffffffff>;
+				};
+			};
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					usbc0_orien_sw: endpoint {
+						remote-endpoint = <&usbdp_phy0_orientation_switch>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					dp_altmode_mux: endpoint {
+						remote-endpoint = <&usbdp_phy0_dp_altmode_mux>;
+					};
+				};
+			};
+		};
+	};
+
+	hym8563: hym8563@51 {
+		compatible = "haoyu,hym8563";
+		reg = <0x51>;
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		clock-output-names = "hym8563";
+		pinctrl-names = "default";
+		pinctrl-0 = <&hym8563_int>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PB0 IRQ_TYPE_LEVEL_LOW>;
+		wakeup-source;
+	};
+};
+
+&pcie2x1l1 {
+	status = "disabled";
+};
+
+&pcie2x1l2 {
+	reset-gpios = <&gpio3 RK_PD1 GPIO_ACTIVE_HIGH>;
+	rockchip,skip-scan-in-resume;
+	status = "disabled";
+};
+
+&pinctrl {
+	sata {
+		sata_reset:sata-reset{
+			rockchip,pins = <3 RK_PD1 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	headphone {
+		hp_det: hp-det {
+			rockchip,pins = <1 RK_PD5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	hym8563 {
+		hym8563_int: hym8563-int {
+			rockchip,pins = <0 RK_PB0 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	lcd {
+		lcd0_rst_gpio: lcd0-rst-gpio {
+			rockchip,pins = <1 RK_PB1 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		lcd1_rst_gpio: lcd1-rst-gpio {
+			rockchip,pins = <1 RK_PB3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	gpio-func {
+		leds_gpio: leds-gpio {
+			rockchip,pins = <0 RK_PA2 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	usb-typec {
+		usbc0_int: usbc0-int {
+			rockchip,pins = <0 RK_PD3 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		typec5v_pwren: typec5v-pwren {
+			rockchip,pins = <3 RK_PC0 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	wireless-bluetooth {
+		uart9_gpios: uart9-gpios {
+			rockchip,pins = <3 RK_PD2 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		bt_gpio: bt-gpio {
+			rockchip,pins =
+				<3 RK_PA6 RK_FUNC_GPIO &pcfg_pull_none>,
+				<0 RK_PC6 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	wireless-wlan {
+		wifi_host_wake_irq: wifi-host-wake-irq {
+			rockchip,pins = <0 RK_PA0 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+
+		wifi_poweren_gpio: wifi-poweren-gpio {
+			rockchip,pins = <0 RK_PD0 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+};
+
+&u2phy0_otg {
+	rockchip,typec-vbus-det;
+	status = "okay";
+};
+
+&uart9 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart9m2_xfer &uart9m2_ctsn>;
+};
+
+&usbdp_phy0 {
+	orientation-switch;
+	svid = <0xff01>;
+	sbu1-dc-gpios = <&gpio4 RK_PA5 GPIO_ACTIVE_HIGH>;
+	sbu2-dc-gpios = <&gpio4 RK_PA7 GPIO_ACTIVE_HIGH>;
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		usbdp_phy0_orientation_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_orien_sw>;
+		};
+
+		usbdp_phy0_dp_altmode_mux: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&dp_altmode_mux>;
+		};
+	};
+};
+
+&usbdrd_dwc3_0 {
+	status = "okay";
+	dr_mode = "otg";
+	usb-role-switch;
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		dwc3_0_role_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_role_sw>;
+		};
+	};
+};
+
+&combphy2_psu {
+        status = "okay";
+};
+
+&usbhost3_0 {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&usbhost_dwc3_0 {
+	status = "okay";
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-orangepi-5b.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-orangepi-5b.dts
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+/dts-v1/;
+
+#include "rk3588s-orangepi-5.dts"
+
+/ {
+	model = "Orange Pi 5B";
+	compatible = "rockchip,rk3588s-orangepi-5", "rockchip,rk3588";
+};
+
+&sdhci {
+	status = "okay";
+};
+
+&sfc {
+	status = "disabled";
+};
+
+&wireless_bluetooth {
+	status = "okay";
+};
+
+&wireless_wlan {
+	status = "okay";
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-orangepi.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-orangepi.dtsi
@@ -0,0 +1,611 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2021 Rockchip Electronics Co., Ltd.
+ *
+ */
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/input/rk-input.h>
+#include <dt-bindings/display/drm_mipi_dsi.h>
+#include <dt-bindings/display/rockchip_vop.h>
+#include <dt-bindings/sensor-dev.h>
+
+/ {
+	adc_keys: adc-keys {
+		compatible = "adc-keys";
+		io-channels = <&saradc 1>;
+		io-channel-names = "buttons";
+		keyup-threshold-microvolt = <1800000>;
+		poll-interval = <100>;
+
+		vol-up-key {
+			label = "volume up";
+			linux,code = <KEY_VOLUMEUP>;
+			press-threshold-microvolt = <17000>;
+		};
+
+		vol-down-key {
+			label = "volume down";
+			linux,code = <KEY_VOLUMEDOWN>;
+			press-threshold-microvolt = <417000>;
+		};
+
+		menu-key {
+			label = "menu";
+			linux,code = <KEY_MENU>;
+			press-threshold-microvolt = <890000>;
+		};
+
+		back-key {
+			label = "back";
+			linux,code = <KEY_BACK>;
+			press-threshold-microvolt = <1235000>;
+		};
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		brightness-levels = <
+			  0  20  20  21  21  22  22  23
+			 23  24  24  25  25  26  26  27
+			 27  28  28  29  29  30  30  31
+			 31  32  32  33  33  34  34  35
+			 35  36  36  37  37  38  38  39
+			 40  41  42  43  44  45  46  47
+			 48  49  50  51  52  53  54  55
+			 56  57  58  59  60  61  62  63
+			 64  65  66  67  68  69  70  71
+			 72  73  74  75  76  77  78  79
+			 80  81  82  83  84  85  86  87
+			 88  89  90  91  92  93  94  95
+			 96  97  98  99 100 101 102 103
+			104 105 106 107 108 109 110 111
+			112 113 114 115 116 117 118 119
+			120 121 122 123 124 125 126 127
+			128 129 130 131 132 133 134 135
+			136 137 138 139 140 141 142 143
+			144 145 146 147 148 149 150 151
+			152 153 154 155 156 157 158 159
+			160 161 162 163 164 165 166 167
+			168 169 170 171 172 173 174 175
+			176 177 178 179 180 181 182 183
+			184 185 186 187 188 189 190 191
+			192 193 194 195 196 197 198 199
+			200 201 202 203 204 205 206 207
+			208 209 210 211 212 213 214 215
+			216 217 218 219 220 221 222 223
+			224 225 226 227 228 229 230 231
+			232 233 234 235 236 237 238 239
+			240 241 242 243 244 245 246 247
+			248 249 250 251 252 253 254 255
+		>;
+		default-brightness-level = <200>;
+	};
+
+	backlight_1: backlight_1 {
+		compatible = "pwm-backlight";
+		brightness-levels = <
+			  0  20  20  21  21  22  22  23
+			 23  24  24  25  25  26  26  27
+			 27  28  28  29  29  30  30  31
+			 31  32  32  33  33  34  34  35
+			 35  36  36  37  37  38  38  39
+			 40  41  42  43  44  45  46  47
+			 48  49  50  51  52  53  54  55
+			 56  57  58  59  60  61  62  63
+			 64  65  66  67  68  69  70  71
+			 72  73  74  75  76  77  78  79
+			 80  81  82  83  84  85  86  87
+			 88  89  90  91  92  93  94  95
+			 96  97  98  99 100 101 102 103
+			104 105 106 107 108 109 110 111
+			112 113 114 115 116 117 118 119
+			120 121 122 123 124 125 126 127
+			128 129 130 131 132 133 134 135
+			136 137 138 139 140 141 142 143
+			144 145 146 147 148 149 150 151
+			152 153 154 155 156 157 158 159
+			160 161 162 163 164 165 166 167
+			168 169 170 171 172 173 174 175
+			176 177 178 179 180 181 182 183
+			184 185 186 187 188 189 190 191
+			192 193 194 195 196 197 198 199
+			200 201 202 203 204 205 206 207
+			208 209 210 211 212 213 214 215
+			216 217 218 219 220 221 222 223
+			224 225 226 227 228 229 230 231
+			232 233 234 235 236 237 238 239
+			240 241 242 243 244 245 246 247
+			248 249 250 251 252 253 254 255
+		>;
+		default-brightness-level = <200>;
+	};
+
+	dp0_sound: dp0-sound {
+		status = "disabled";
+		compatible = "rockchip,hdmi";
+		rockchip,card-name= "rockchip-dp0";
+		rockchip,mclk-fs = <512>;
+		rockchip,cpu = <&spdif_tx2>;
+		rockchip,codec = <&dp0 1>;
+		rockchip,jack-det;
+	};
+
+	hdmi0_sound: hdmi0-sound {
+		status = "disabled";
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,card-name = "rockchip-hdmi0";
+		rockchip,cpu = <&i2s5_8ch>;
+		rockchip,codec = <&hdmi0>;
+		rockchip,jack-det;
+	};
+
+	spdif_tx1_dc: spdif-tx1-dc {
+		status = "disabled";
+		compatible = "linux,spdif-dit";
+		#sound-dai-cells = <0>;
+	};
+
+	spdif_tx1_sound: spdif-tx1-sound {
+		status = "disabled";
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "rockchip,spdif-tx1";
+		simple-audio-card,cpu {
+			sound-dai = <&spdif_tx1>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&spdif_tx1_dc>;
+		};
+	};
+
+	test-power {
+		status = "okay";
+	};
+
+	vcc12v_dcin: vcc12v-dcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc12v_dcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_usbdcin: vcc5v0-usbdcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_usbdcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_usb: vcc5v0-usb {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_usb";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc5v0_usbdcin>;
+	};
+};
+
+&av1d {
+	status = "okay";
+};
+
+&av1d_mmu {
+	status = "okay";
+};
+
+&combphy0_ps {
+	status = "okay";
+};
+
+&combphy2_psu {
+	status = "okay";
+};
+
+&cpu_l0 {
+	cpu-supply = <&vdd_cpu_lit_s0>;
+	mem-supply = <&vdd_cpu_lit_mem_s0>;
+};
+
+&cpu_b0 {
+	cpu-supply = <&vdd_cpu_big0_s0>;
+	mem-supply = <&vdd_cpu_big0_mem_s0>;
+};
+
+&cpu_b2 {
+	cpu-supply = <&vdd_cpu_big1_s0>;
+	mem-supply = <&vdd_cpu_big1_mem_s0>;
+};
+
+&dsi0 {
+	status = "okay";
+	//rockchip,lane-rate = <1000>;
+	dsi0_panel: panel@0 {
+		status = "okay";
+		compatible = "innolux,afj101-ba2131";
+		reg = <0>;
+		backlight = <&backlight>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				panel_in_dsi: endpoint {
+					remote-endpoint = <&dsi_out_panel>;
+				};
+			};
+		};
+	};
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@1 {
+			reg = <1>;
+			dsi_out_panel: endpoint {
+				remote-endpoint = <&panel_in_dsi>;
+			};
+		};
+	};
+
+};
+
+&dsi1 {
+	status = "okay";
+	//rockchip,lane-rate = <1000>;
+	dsi1_panel: panel@0 {
+		status = "okay";
+		compatible = "innolux,afj101-ba2131";
+		reg = <0>;
+		backlight = <&backlight_1>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+				panel_in_dsi1: endpoint {
+					remote-endpoint = <&dsi1_out_panel>;
+				};
+			};
+		};
+	};
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@1 {
+			reg = <1>;
+			dsi1_out_panel: endpoint {
+				remote-endpoint = <&panel_in_dsi1>;
+			};
+		};
+	};
+
+};
+
+&gpu {
+	mali-supply = <&vdd_gpu_s0>;
+	mem-supply = <&vdd_gpu_mem_s0>;
+	status = "okay";
+};
+
+&i2s0_8ch {
+	status = "okay";
+	pinctrl-0 = <&i2s0_lrck
+		     &i2s0_sclk
+		     &i2s0_sdi0
+		     &i2s0_sdo0>;
+};
+
+&iep {
+	status = "okay";
+};
+
+&iep_mmu {
+	status = "okay";
+};
+
+&jpegd {
+	status = "okay";
+};
+
+&jpegd_mmu {
+	status = "okay";
+};
+
+&jpege_ccu {
+	status = "okay";
+};
+
+&jpege0 {
+	status = "okay";
+};
+
+&jpege0_mmu {
+	status = "okay";
+};
+
+&jpege1 {
+	status = "okay";
+};
+
+&jpege1_mmu {
+	status = "okay";
+};
+
+&jpege2 {
+	status = "okay";
+};
+
+&jpege2_mmu {
+	status = "okay";
+};
+
+&jpege3 {
+	status = "okay";
+};
+
+&jpege3_mmu {
+	status = "okay";
+};
+
+&mpp_srv {
+	status = "okay";
+};
+
+&rga3_core0 {
+	status = "okay";
+};
+
+&rga3_0_mmu {
+	status = "okay";
+};
+
+&rga3_core1 {
+	status = "okay";
+};
+
+&rga3_1_mmu {
+	status = "okay";
+};
+
+&rga2 {
+	status = "okay";
+};
+
+&rknpu {
+	rknpu-supply = <&vdd_npu_s0>;
+	mem-supply = <&vdd_npu_mem_s0>;
+	status = "okay";
+};
+
+&rknpu_mmu {
+	status = "okay";
+};
+
+&rkvdec_ccu {
+	status = "okay";
+};
+
+&rkvdec0 {
+	status = "okay";
+};
+
+&rkvdec0_mmu {
+	status = "okay";
+};
+
+&rkvdec1 {
+	status = "okay";
+};
+
+&rkvdec1_mmu {
+	status = "okay";
+};
+
+&rkvenc_ccu {
+	status = "okay";
+};
+
+&rkvenc0 {
+	status = "okay";
+};
+
+&rkvenc0_mmu {
+	status = "okay";
+};
+
+&rkvenc1 {
+	status = "okay";
+};
+
+&rkvenc1_mmu {
+	status = "okay";
+};
+
+&rockchip_suspend {
+	status = "okay";
+	rockchip,sleep-debug-en = <1>;
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vcc_1v8_s0>;
+};
+
+&sdhci {
+	bus-width = <8>;
+	no-sdio;
+	no-sd;
+	non-removable;
+	max-frequency = <200000000>;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	status = "disabled";
+};
+
+&sdmmc {
+	max-frequency = <150000000>;
+	no-sdio;
+	no-mmc;
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	sd-uhs-sdr104;
+	vmmc-supply = <&vcc_3v3_sd_s0>;
+	vqmmc-supply = <&vccio_sd_s0>;
+	status = "okay";
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&u2phy0 {
+	status = "okay";
+};
+
+&u2phy2 {
+	status = "okay";
+};
+
+&u2phy3 {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	status = "okay";
+};
+
+&u2phy2_host {
+	status = "okay";
+};
+
+&u2phy3_host {
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&usbdp_phy0 {
+	status = "okay";
+};
+
+&usbdp_phy0_dp {
+	status = "okay";
+};
+
+&usbdp_phy0_u3 {
+	status = "okay";
+};
+
+&usbdrd3_0 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&usbhost3_0 {
+	status = "okay";
+};
+
+&usbhost_dwc3_0 {
+	status = "okay";
+};
+
+&vdpu {
+	status = "okay";
+};
+
+&vdpu_mmu {
+	status = "okay";
+};
+
+&vop {
+	status = "okay";
+	disable-win-move;
+	assigned-clocks = <&cru ACLK_VOP>;
+	assigned-clock-rates = <800000000>;
+};
+
+&vop_mmu {
+	status = "okay";
+};
+
+&vepu {
+	status = "okay";
+};
+
+/* vp0 & vp1 splice for 8K output */
+&vp0 {
+	cursor-win-id=<ROCKCHIP_VOP2_ESMART0>;
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER0>;
+};
+
+&vp1 {
+	cursor-win-id=<ROCKCHIP_VOP2_ESMART1>;
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER1>;
+};
+
+&vp2 {
+	cursor-win-id=<ROCKCHIP_VOP2_ESMART2>;
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER2 | 1 << ROCKCHIP_VOP2_ESMART2)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER2>;
+};
+
+&vp3 {
+	cursor-win-id=<ROCKCHIP_VOP2_ESMART3>;
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER3>;
+};
+
+/* Fix tty terminal out of screen, and most dclk of resolutions was not supported in hdmiphy clock from parent clock by default */
+&display_subsystem {
+	clocks = <&hdptxphy_hdmi_clk0>;
+	clock-names = "hdmi0_phy_pll";
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-radxa-cm5-io.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-radxa-cm5-io.dts
@@ -0,0 +1,536 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2023 Rockchip Electronics Co., Ltd.
+ * Copyright (c) 2023 Radxa Limited
+ *
+ */
+
+/dts-v1/;
+
+#include "rk3588s-radxa-cm5.dtsi"
+
+/ {
+	model = "Radxa CM5 IO";
+	compatible = "radxa,cm5-io", "radxa,cm5", "rockchip,rk3588";
+
+	/delete-node/ chosen;
+
+	vcc12v_dcin: vcc12v-dcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc12v_dcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vbus5v0_typec: vbus5v0-typec {
+		compatible = "regulator-fixed";
+		regulator-name = "vbus5v0_typec";
+		gpio = <&gpio0 RK_PD5 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vbus5v0_typec_en>;
+		enable-active-high;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vcc_1v1_nldo_s3: vcc-1v1-nldo-s3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_1v1_nldo_s3";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1100000>;
+		regulator-max-microvolt = <1100000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	hdmi0_sound: hdmi0-sound {
+		status = "okay";
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,card-name = "rockchip-hdmi0";
+		rockchip,cpu = <&i2s5_8ch>;
+		rockchip,codec = <&hdmi0>;
+		rockchip,jack-det;
+	};
+
+	es8316_sound: es8316-sound {
+		status = "okay";
+		compatible = "rockchip,multicodecs-card";
+		rockchip,card-name = "rockchip-es8316";
+		rockchip,format = "i2s";
+		rockchip,mclk-fs = <256>;
+		rockchip,cpu = <&i2s0_8ch>;
+		rockchip,codec = <&es8316>;
+		poll-interval = <100>;
+		io-channels = <&saradc 3>;
+		io-channel-names = "adc-detect";
+		keyup-threshold-microvolt = <1800000>;
+		pinctrl-0 = <&hp_det>;
+		pinctrl-names = "default";
+		hp-det-gpio = <&gpio1 RK_PC0 GPIO_ACTIVE_HIGH>;
+		play-pause-key {
+			label = "playpause";
+			linux,code = <164>;
+			press-threshold-microvolt = <2000>;
+		};
+	};
+
+	vcc3v3_sys: vcc3v3-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc5v0_host: vcc5v0-host-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_host";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio3 RK_PC6 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_host_en>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vcc3v3_pcie2x1l0: vcc3v3-pcie2x1l0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_pcie2x1l0";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		enable-active-high;
+		regulator-boot-on;
+		regulator-always-on;
+		gpios = <&gpio1 RK_PD3 GPIO_ACTIVE_HIGH>;
+		startup-delay-us = <50000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	wifi_disable: wifi-diable-gpio-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "wifi_disable";
+		enable-active-high;
+		gpio = <&gpio0 RK_PD4 GPIO_ACTIVE_HIGH>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	bt_wake: bt-wake-gpio-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "bt_wake";
+		enable-active-high;
+		gpio = <&gpio0 RK_PC6 GPIO_ACTIVE_HIGH>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+    gpio-leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+
+		user-led1 {
+			gpios = <&gpio4 RK_PB4 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "on";
+		};
+	};
+
+	fan0: pwm-fan {
+		compatible = "pwm-fan";
+		#cooling-cells = <2>;
+		cooling-levels = <100 160 190 200 215 235 255>;
+		pwms = <&pwm11 0 10000 0>;
+		rockchip,temp-trips = <
+			55000	1
+			60000	2
+			65000	3
+			70000	4
+			75000	5
+			80000	6
+		>;
+	};
+};
+
+&i2c6 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c6m3_xfer>;
+
+	usbc0: fusb302@22 {
+		compatible = "fcs,fusb302";
+		reg = <0x22>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PC4 IRQ_TYPE_LEVEL_LOW>;
+		int-n-gpios = <&gpio0 RK_PC4 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&usbc0_int>;
+		vbus-supply = <&vbus5v0_typec>;
+		status = "okay";
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			port@0 {
+			reg = <0>;
+			usbc0_role_sw: endpoint@0 {
+				remote-endpoint = <&dwc3_0_role_switch>;
+				};
+			};
+		};
+
+		usb_con: connector {
+			compatible = "usb-c-connector";
+			label = "USB-C";
+			data-role = "dual";
+			power-role = "dual";
+			try-power-role = "sink";
+			op-sink-microwatt = <1000000>;
+
+			sink-pdos =
+				<PDO_FIXED(5000, 1000, PDO_FIXED_USB_COMM)>;
+			source-pdos =
+				<PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
+
+			altmodes {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				altmode@0 {
+					reg = <0>;
+					svid = <0xff01>;
+					vdo = <0xffffffff>;
+				};
+			};
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					usbc0_orien_sw: endpoint {
+						remote-endpoint = <&usbdp_phy0_orientation_switch>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					dp_altmode_mux: endpoint {
+						remote-endpoint = <&usbdp_phy0_dp_altmode_mux>;
+					};
+				};
+			};
+		};
+	};
+
+	hym8563: hym8563@51 {
+		compatible = "haoyu,hym8563";
+		reg = <0x51>;
+		#clock-cells = <0>;
+		clock-frequency = <32768>;
+		clock-output-names = "hym8563";
+		pinctrl-names = "default";
+		pinctrl-0 = <&rtc_int>;
+		interrupt-parent = <&gpio0>;
+		interrupts = <RK_PB0 IRQ_TYPE_LEVEL_LOW>;
+	};
+};
+
+&usbdp_phy0 {
+	status = "okay";
+	orientation-switch;
+	svid = <0xff01>;
+	sbu1-dc-gpios = <&gpio3 RK_PC4 GPIO_ACTIVE_HIGH>;
+	sbu2-dc-gpios = <&gpio3 RK_PD4 GPIO_ACTIVE_HIGH>;
+
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		usbdp_phy0_orientation_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_orien_sw>;
+		};
+
+		usbdp_phy0_dp_altmode_mux: endpoint@1 {
+			reg = <1>;
+			remote-endpoint = <&dp_altmode_mux>;
+		};
+	};
+};
+
+&dp0 {
+	status = "okay";
+};
+
+&dp0_in_vp2 {
+	status = "okay";
+};
+
+&i2c8 {
+	status = "okay";
+	pinctrl-0 = <&i2c8m2_xfer>;
+
+	es8316: es8316@11 {
+		compatible = "everest,es8316";
+		reg = <0x11>;
+		clocks = <&mclkout_i2s0>;
+		clock-names = "mclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s0_mclk>;
+		#sound-dai-cells = <0>;
+		status = "okay";
+	};
+};
+
+&i2s0_8ch {
+	status = "okay";
+	rockchip,playback-channels = <2>;
+	rockchip,capture-channels = <2>;
+	#sound-dai-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2s0_lrck
+			 &i2s0_sclk
+			 &i2s0_sdi0
+			 &i2s0_sdo0>;
+};
+
+
+&pwm4 {
+	status = "okay";
+	pinctrl-0 = <&pwm4m0_pins>;
+};
+
+&pwm11 {
+	status = "okay";
+	pinctrl-0 = <&pwm11m3_pins>;
+};
+
+&sdhci {
+	status = "okay";
+};
+
+&hdmi0 {
+	status = "okay";
+};
+
+&hdmi0_in_vp0 {
+	status = "okay";
+};
+
+&route_hdmi0 {
+	status = "okay";
+};
+
+&hdptxphy_hdmi0 {
+	status = "okay";
+};
+
+&i2s5_8ch {
+	status = "okay";
+};
+
+&vop {
+	status = "okay";
+};
+
+&vop_mmu {
+	status = "okay";
+};
+
+&vp0 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER0>;
+	cursor-win-id = <ROCKCHIP_VOP2_ESMART0>;
+};
+
+&vp1 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER1>;
+	cursor-win-id = <ROCKCHIP_VOP2_ESMART1>;
+};
+
+&vp2 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER2 | 1 << ROCKCHIP_VOP2_ESMART2)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER2>;
+	cursor-win-id = <ROCKCHIP_VOP2_ESMART2>;
+};
+
+&vp3 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER3>;
+	cursor-win-id = <ROCKCHIP_VOP2_ESMART3>;
+};
+
+&display_subsystem {
+	clocks = <&hdptxphy_hdmi_clk0>;
+	clock-names = "hdmi0_phy_pll";
+};
+
+&hdptxphy_hdmi_clk0 {
+	status = "okay";
+};
+
+&pinctrl {
+
+	usb {
+		vcc5v0_host_en: vcc5v0-host-en {
+			rockchip,pins = <3 RK_PC6 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	headphone {
+		hp_det: hp-det {
+			rockchip,pins = <1 RK_PC0 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	fusb302 {
+		vbus5v0_typec_en: vbus5v0-typec-en {
+			rockchip,pins = <0 RK_PD5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		usbc0_int: usbc0-int {
+			rockchip,pins = <0 RK_PC4 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	hym8563 {
+		rtc_int: rtc-int {
+			rockchip,pins = <0 RK_PB0 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+};
+
+&pcie2x1l2 {
+	reset-gpios = <&gpio3 RK_PD1 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_pcie2x1l0>;
+	status = "okay";
+};
+
+&combphy0_ps {
+	status = "okay";
+};
+
+&combphy2_psu {
+	status = "okay";
+};
+
+&u2phy0 {
+	status = "okay";
+};
+
+&u2phy2 {
+	status = "okay";
+};
+
+&u2phy3 {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	rockchip,sel-pipe-phystatus;
+	rockchip,typec-vbus-det;
+	status = "okay";
+};
+
+&u2phy2_host {
+	status = "okay";
+};
+
+&u2phy3_host {
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&usbdp_phy0 {
+	status = "okay";
+};
+
+&usbdp_phy0_dp {
+	status = "okay";
+};
+
+&usbdp_phy0_u3 {
+	status = "okay";
+};
+
+&usbdrd3_0 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	dr_mode = "otg";
+	extcon = <&u2phy0>;
+	status = "okay";
+
+	usb-role-switch;
+	port {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		dwc3_0_role_switch: endpoint@0 {
+			reg = <0>;
+			remote-endpoint = <&usbc0_role_sw>;
+		};
+	};
+};
+
+&usbhost3_0 {
+	status = "okay";
+};
+
+&usbhost_dwc3_0 {
+	status = "okay";
+};
+
+&sdmmc {
+	max-frequency = <200000000>;
+	no-sdio;
+	no-mmc;
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	sd-uhs-sdr104;
+	vmmc-supply = <&vcc_3v3_s3>;
+	vqmmc-supply = <&vccio_sd_s0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc_bus4 &sdmmc_clk &sdmmc_cmd &sdmmc_det>;
+	status = "okay";
+};
+
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-radxa-cm5.dtsi
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-radxa-cm5.dtsi
@@ -0,0 +1,293 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2023 Rockchip Electronics Co., Ltd.
+ * Copyright (c) 2023 Radxa Limited
+ *
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/input/rk-input.h>
+#include <dt-bindings/display/drm_mipi_dsi.h>
+#include <dt-bindings/display/rockchip_vop.h>
+#include <dt-bindings/sensor-dev.h>
+#include "dt-bindings/usb/pd.h"
+#include "rk3588s.dtsi"
+#include "rk3588-rk806-single.dtsi"
+#include "rk3588-linux.dtsi"
+
+/ {
+	compatible = "radxa,cm5", "rockchip,rk3588";
+
+	aliases {
+		mmc0 = &sdhci;
+		mmc1 = &sdmmc;
+		mmc2 = &sdio;
+	};
+};
+
+&i2c0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0m2_xfer>;
+
+	vdd_cpu_big0_s0: vdd_cpu_big0_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big0_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vdd_cpu_big1_s0: vdd_cpu_big1_mem_s0: rk8603@43 {
+		compatible = "rockchip,rk8603";
+		reg = <0x43>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big1_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	eeprom:	at24c16@50 {
+		status = "okay";
+		compatible = "atmel,24c16";
+		reg = <0x50>;
+		pagesize = <16>;
+	};
+};
+
+&i2c2 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c2m0_xfer>;
+
+	vdd_npu_s0: vdd_npu_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_npu_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <950000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&cpu_l0 {
+	cpu-supply = <&vdd_cpu_lit_s0>;
+	mem-supply = <&vdd_cpu_lit_mem_s0>;
+};
+
+&cpu_b0 {
+	cpu-supply = <&vdd_cpu_big0_s0>;
+	mem-supply = <&vdd_cpu_big0_mem_s0>;
+};
+
+&cpu_b2 {
+	cpu-supply = <&vdd_cpu_big1_s0>;
+	mem-supply = <&vdd_cpu_big1_mem_s0>;
+};
+
+&gpu {
+	mali-supply = <&vdd_gpu_s0>;
+	mem-supply = <&vdd_gpu_mem_s0>;
+	status = "okay";
+};
+
+&rknpu {
+	rknpu-supply = <&vdd_npu_s0>;
+	mem-supply = <&vdd_npu_mem_s0>;
+	status = "okay";
+};
+
+&rknpu_mmu {
+	status = "okay";
+};
+
+&iep {
+	status = "okay";
+};
+
+&iep_mmu {
+	status = "okay";
+};
+
+&jpegd {
+	status = "okay";
+};
+
+&jpegd_mmu {
+	status = "okay";
+};
+
+&jpege_ccu {
+	status = "okay";
+};
+
+&jpege0 {
+	status = "okay";
+};
+
+&jpege0_mmu {
+	status = "okay";
+};
+
+&jpege1 {
+	status = "okay";
+};
+
+&jpege1_mmu {
+	status = "okay";
+};
+
+&jpege2 {
+	status = "okay";
+};
+
+&jpege2_mmu {
+	status = "okay";
+};
+
+&jpege3 {
+	status = "okay";
+};
+
+&jpege3_mmu {
+	status = "okay";
+};
+
+&mpp_srv {
+	status = "okay";
+};
+
+&rga3_core0 {
+	status = "okay";
+};
+
+&rga3_0_mmu {
+	status = "okay";
+};
+
+&rga3_core1 {
+	status = "okay";
+};
+
+&rga3_1_mmu {
+	status = "okay";
+};
+
+&rga2 {
+	status = "okay";
+};
+
+&rkvdec_ccu {
+	status = "okay";
+};
+
+&rkvdec0 {
+	status = "okay";
+};
+
+&rkvdec0_mmu {
+	status = "okay";
+};
+
+&rkvdec1 {
+	status = "okay";
+};
+
+&rkvdec1_mmu {
+	status = "okay";
+};
+
+&rkvenc_ccu {
+	status = "okay";
+};
+
+&rkvenc0 {
+	status = "okay";
+};
+
+&rkvenc0_mmu {
+	status = "okay";
+};
+
+&rkvenc1 {
+	status = "okay";
+};
+
+&rkvenc1_mmu {
+	status = "okay";
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&vcc_1v8_s0>;
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&sdhci {
+	bus-width = <8>;
+	non-removable;
+	max-frequency = <150000000>;
+	mmc-hs200-1_8v;
+};
+
+&mdio1 {
+	rgmii_phy1: phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x1>;
+	};
+};
+
+&gmac1 {
+	phy-mode = "rgmii";
+	clock_in_out = "output";
+
+	snps,reset-gpio = <&gpio3 RK_PB2 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	// Reset time is 20ms, 100ms for rtl8211f
+	snps,reset-delays-us = <0 20000 100000>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac1_miim
+		     &gmac1_tx_bus2
+		     &gmac1_rx_bus2
+		     &gmac1_rgmii_clk
+		     &gmac1_rgmii_bus>;
+
+	tx_delay = <0x41>;
+	rx_delay = <0x3a>;
+
+	phy-handle = <&rgmii_phy1>;
+	status = "okay";
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-rock-5a.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-rock-5a.dts
@@ -0,0 +1,1010 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Rockchip Electronics Co., Ltd.
+ * Copyright (c) 2022 Radxa Limited
+ *
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/leds/common.h>
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/input/rk-input.h>
+#include <dt-bindings/display/drm_mipi_dsi.h>
+#include <dt-bindings/display/rockchip_vop.h>
+#include <dt-bindings/sensor-dev.h>
+#include "rk3588s.dtsi"
+#include "rk3588-rk806-single.dtsi"
+#include "rk3588-linux.dtsi"
+
+/ {
+	model = "Radxa ROCK 5A";
+	compatible = "radxa,rock-5a", "rockchip,rk3588";
+
+	/delete-node/ chosen;
+
+	fan0: pwm-fan {
+		compatible = "pwm-fan";
+		#cooling-cells = <2>;
+		cooling-levels = <100 160 190 200 215 235 255>;
+		pwms = <&pwm3 0 10000 0>;
+	};
+
+	vcc12v_dcin: vcc12v-dcin {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc12v_dcin";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <12000000>;
+		regulator-max-microvolt = <12000000>;
+	};
+
+	vcc5v0_sys: vcc5v0-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_sys";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&vcc12v_dcin>;
+	};
+
+	vcc_5v0: vcc-5v0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_5v0";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-boot-on;
+		regulator-always-on;
+		enable-active-high;
+		gpio = <&gpio4 RK_PA3 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc_5v0_en>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vcc_1v1_nldo_s3: vcc-1v1-nldo-s3 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_1v1_nldo_s3";
+		regulator-always-on;
+		regulator-boot-on;
+		regulator-min-microvolt = <1100000>;
+		regulator-max-microvolt = <1100000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	hdmi0_sound: hdmi0-sound {
+		status = "okay";
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <128>;
+		rockchip,card-name = "rockchip-hdmi0";
+		rockchip,cpu = <&i2s5_8ch>;
+		rockchip,codec = <&hdmi0>;
+		rockchip,jack-det;
+	};
+
+	dp0_sound: dp0-sound {
+		status = "okay";
+		compatible = "rockchip,hdmi";
+		rockchip,mclk-fs = <512>;
+		rockchip,card-name= "rockchip-hdmi1";
+		rockchip,cpu = <&spdif_tx2>;
+		rockchip,codec = <&dp0 1>;
+		rockchip,jack-det;
+	};
+
+	es8316_sound: es8316-sound {
+		status = "okay";
+		compatible = "rockchip,multicodecs-card";
+		rockchip,card-name = "rockchip-es8316";
+		rockchip,format = "i2s";
+		rockchip,mclk-fs = <256>;
+		rockchip,cpu = <&i2s0_8ch >;
+		rockchip,codec = <&es8316>;
+		io-channels = <&saradc 3>;
+		io-channel-names = "adc-detect";
+		keyup-threshold-microvolt = <1800000>;
+		pinctrl-0 = <&hp_det>;
+		pinctrl-names = "default";
+		hp-det-gpio = <&gpio1 RK_PC4 GPIO_ACTIVE_HIGH>;
+		play-pause-key {
+			label = "playpause";
+			linux,code = <164>;
+			press-threshold-microvolt = <2000>;
+		};
+	};
+
+	vcc5v0_host: vcc5v0-host-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_host";
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio4 RK_PB5 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_host_en>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vcc5v0_otg: vcc5v0-otg-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc5v0_otg";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		enable-active-high;
+		gpio = <&gpio0 RK_PD4 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&vcc5v0_otg_en>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	vcc3v3_pcie: vcc3v3-pcie {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_pcie";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		startup-delay-us = <5000>;
+		vin-supply = <&vcc5v0_sys>;
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+		pinctrl-names = "default";
+
+		user-led1 {
+			gpios = <&gpio3 RK_PC4 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "default-on";
+			default-state = "on";
+		};
+
+		user-led2 {
+			gpios = <&gpio3 RK_PD5 GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "on";
+		};
+	};
+};
+
+&av1d_mmu {
+	status = "okay";
+};
+
+&i2c0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c0m2_xfer>;
+
+	vdd_cpu_big0_s0: vdd_cpu_big0_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big0_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vdd_cpu_big1_s0: vdd_cpu_big1_mem_s0: rk8603@43 {
+		compatible = "rockchip,rk8603";
+		reg = <0x43>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_cpu_big1_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <1050000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+&i2c2 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2c2m0_xfer>;
+
+	vdd_npu_s0: vdd_npu_mem_s0: rk8602@42 {
+		compatible = "rockchip,rk8602";
+		reg = <0x42>;
+		vin-supply = <&vcc5v0_sys>;
+		regulator-compatible = "rk860x-reg";
+		regulator-name = "vdd_npu_s0";
+		regulator-min-microvolt = <550000>;
+		regulator-max-microvolt = <950000>;
+		regulator-ramp-delay = <2300>;
+		rockchip,suspend-voltage-selector = <1>;
+		regulator-boot-on;
+		regulator-always-on;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+};
+
+/* CPU */
+
+&cpu_l0 {
+	cpu-supply = <&vdd_cpu_lit_s0>;
+	mem-supply = <&vdd_cpu_lit_mem_s0>;
+};
+
+&cpu_b0 {
+	cpu-supply = <&vdd_cpu_big0_s0>;
+	mem-supply = <&vdd_cpu_big0_mem_s0>;
+};
+
+&cpu_b2 {
+	cpu-supply = <&vdd_cpu_big1_s0>;
+	mem-supply = <&vdd_cpu_big1_mem_s0>;
+};
+
+/* GPU */
+
+&gpu {
+	mali-supply = <&vdd_gpu_s0>;
+	mem-supply = <&vdd_gpu_mem_s0>;
+	status = "okay";
+};
+
+/* NPU */
+
+&rknpu {
+	rknpu-supply = <&vdd_npu_s0>;
+	mem-supply = <&vdd_npu_mem_s0>;
+	status = "okay";
+};
+
+&dfi {
+	status = "okay";
+};
+
+&dmc {
+	status = "okay";
+	center-supply = <&vdd_ddr_s0>;
+	mem-supply = <&vdd_log_s0>;
+};
+
+&rknpu_mmu {
+	status = "okay";
+};
+
+&iep {
+	status = "okay";
+};
+
+&iep_mmu {
+	status = "okay";
+};
+
+&jpegd {
+	status = "okay";
+};
+
+&jpegd_mmu {
+	status = "okay";
+};
+
+&jpege_ccu {
+	status = "okay";
+};
+
+&jpege0 {
+	status = "okay";
+};
+
+&jpege0_mmu {
+	status = "okay";
+};
+
+&jpege1 {
+	status = "okay";
+};
+
+&jpege1_mmu {
+	status = "okay";
+};
+
+&jpege2 {
+	status = "okay";
+};
+
+&jpege2_mmu {
+	status = "okay";
+};
+
+&jpege3 {
+	status = "okay";
+};
+
+&jpege3_mmu {
+	status = "okay";
+};
+
+&mpp_srv {
+	status = "okay";
+};
+
+&rga3_core0 {
+	status = "okay";
+};
+
+&rga3_0_mmu {
+	status = "okay";
+};
+
+&rga3_core1 {
+	status = "okay";
+};
+
+&rga3_1_mmu {
+	status = "okay";
+};
+
+&rga2 {
+	status = "okay";
+};
+
+&rkvdec_ccu {
+	status = "okay";
+};
+
+&rkvdec0 {
+	status = "okay";
+};
+
+&rkvdec0_mmu {
+	status = "okay";
+};
+
+&rkvdec1 {
+	status = "okay";
+};
+
+&rkvdec1_mmu {
+	status = "okay";
+};
+
+&rkvenc_ccu {
+	status = "okay";
+};
+
+&rkvenc0 {
+	status = "okay";
+};
+
+&rkvenc0_mmu {
+	status = "okay";
+};
+
+&rkvenc1 {
+	status = "okay";
+};
+
+&rkvenc1_mmu {
+	status = "okay";
+};
+
+&saradc {
+	status = "okay";
+	vref-supply = <&avcc_1v8_s0>;
+};
+
+/* Storage */
+/* eMMC */
+
+&sdhci {
+	bus-width = <8>;
+	no-sdio;
+	no-sd;
+	non-removable;
+	max-frequency = <200000000>;
+	mmc-hs400-1_8v;
+	mmc-hs400-enhanced-strobe;
+	pinctrl-names = "default";
+	pinctrl-0 = <&emmc_rstnout &emmc_bus8 &emmc_clk &emmc_cmd &emmc_data_strobe>;
+	status = "okay";
+};
+
+/* SD */
+
+&sdmmc {
+	max-frequency = <200000000>;
+	no-sdio;
+	no-mmc;
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	sd-uhs-sdr104;
+	vmmc-supply = <&vcc_3v3_s0>;
+	vqmmc-supply = <&vccio_sd_s0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc_bus4 &sdmmc_clk &sdmmc_cmd &sdmmc_det>;
+	status = "okay";
+};
+
+/* ADC */
+
+&tsadc {
+	status = "okay";
+};
+
+/* HDMI */
+
+&hdmi0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&hdmim0_tx0_cec &hdmim1_tx0_hpd &hdmim0_tx0_scl &hdmim0_tx0_sda>;
+};
+
+&hdmi0_in_vp0 {
+	status = "okay";
+};
+
+&route_hdmi0 {
+	status = "okay";
+};
+
+&hdptxphy_hdmi0 {
+	status = "okay";
+};
+
+&i2s5_8ch {
+	status = "okay";
+};
+
+/* DP */
+
+&dp0 {
+	status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&dp0_hpd>;
+	hpd-gpios = <&gpio0 RK_PC4 GPIO_ACTIVE_HIGH>;
+};
+
+&dp0_in_vp2 {
+	status = "okay";
+};
+
+&route_dp0 {
+	status = "okay";
+	connect = <&vp2_out_dp0>;
+};
+
+&spdif_tx2 {
+	status = "okay";
+};
+
+&vdpu {
+	status = "okay";
+};
+
+&vdpu_mmu {
+	status = "okay";
+};
+
+/* Video Ports */
+
+&vop {
+	status = "okay";
+};
+
+&vop_mmu {
+	status = "okay";
+};
+
+&vepu {
+	status = "okay";
+};
+
+/* vp0 & vp1 splice for 8K output */
+&vp0 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER0>;
+	cursor-win-id = <ROCKCHIP_VOP2_ESMART0>;
+};
+
+&vp1 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER1>;
+	cursor-win-id = <ROCKCHIP_VOP2_ESMART1>;
+};
+
+&vp2 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER2 | 1 << ROCKCHIP_VOP2_ESMART2)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER2>;
+	cursor-win-id = <ROCKCHIP_VOP2_ESMART2>;
+};
+
+&vp3 {
+	rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>;
+	rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER3>;
+	cursor-win-id = <ROCKCHIP_VOP2_ESMART3>;
+};
+
+&display_subsystem {
+	clocks = <&hdptxphy_hdmi_clk0>;
+	clock-names = "hdmi0_phy_pll";
+};
+
+&hdptxphy_hdmi_clk0 {
+	status = "okay";
+};
+
+/* USB */
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&u2phy2 {
+	status = "okay";
+};
+
+&u2phy2_host {
+	status = "okay";
+	phy-supply = <&vcc5v0_host>;
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&u2phy3 {
+	status = "okay";
+};
+
+&u2phy3_host {
+	phy-supply = <&vcc5v0_host>;
+	status = "okay";
+};
+
+&usbhost3_0 {
+	status = "okay";
+};
+
+&usbhost_dwc3_0 {
+	status = "okay";
+};
+
+&combphy2_psu {
+	status = "okay";
+};
+
+&u2phy0 {
+	status = "okay";
+};
+
+&u2phy0_otg {
+	status = "okay";
+	vbus-supply = <&vcc5v0_otg>;
+};
+
+&usbdrd3_0 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&usbdp_phy0_u3 {
+	status = "okay";
+};
+
+&usbdp_phy0 {
+	status = "okay";
+	rockchip,dp-lane-mux = < 2 3 >;
+};
+
+&usbdp_phy0_dp {
+	status = "okay";
+};
+
+/* PCIe */
+
+&combphy0_ps {
+	status = "okay";
+};
+
+&pcie2x1l2 {
+	status = "okay";
+	reset-gpios = <&gpio3 RK_PD1 GPIO_ACTIVE_HIGH>;
+	vpcie3v3-supply = <&vcc3v3_pcie>;
+};
+
+/* Ethernet */
+
+&mdio1 {
+	rgmii_phy1: phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <0x1>;
+	};
+};
+
+&gmac1 {
+	status = "okay";
+	phy-mode = "rgmii";
+	clock_in_out = "output";
+
+	snps,reset-gpio = <&gpio3 RK_PB7 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	// Reset time is 20ms, 100ms for rtl8211f
+	snps,reset-delays-us = <0 20000 100000>;
+
+	pinctrl-names = "default";
+	pinctrl-0 = <&gmac1_miim
+		     &gmac1_tx_bus2
+		     &gmac1_rx_bus2
+		     &gmac1_rgmii_clk
+		     &gmac1_rgmii_bus>;
+
+	tx_delay = <0x3a>;
+	rx_delay = <0x3e>;
+
+	phy-handle = <&rgmii_phy1>;
+};
+
+/* I2C */
+
+&i2c7 {
+	status = "okay";
+
+	es8316: es8316@11 {
+		compatible = "everest,es8316";
+		reg = <0x11>;
+		clocks = <&mclkout_i2s0>;
+		clock-names = "mclk";
+		pinctrl-names = "default";
+		pinctrl-0 = <&i2s0_mclk>;
+		#sound-dai-cells = <0>;
+	};
+};
+
+&i2s0_8ch {
+	status = "okay";
+	rockchip,playback-channels = <2>;
+	rockchip,capture-channels = <2>;
+	#sound-dai-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&i2s0_lrck
+			 &i2s0_sclk
+			 &i2s0_sdi0
+			 &i2s0_sdo0>;
+};
+
+&pwm3 {
+	status = "okay";
+	pinctrl-0 = <&pwm3m1_pins>;
+};
+
+&threshold {
+	temperature = <60000>;
+};
+
+&soc_thermal {
+	sustainable-power = <5000>; /* milliwatts */
+	polling-delay = <1000>;
+	polling-delay-passive = <2000>;
+	trips {
+		trip0: trip-point@0 {
+			temperature = <55000>;
+			hysteresis = <5000>;
+			type = "active";
+		};
+		trip1: trip-point@1 {
+			temperature = <60000>;
+			hysteresis = <5000>;
+			type = "active";
+		};
+		trip2: trip-point@2 {
+			temperature = <65000>;
+			hysteresis = <5000>;
+			type = "active";
+		};
+		trip3: trip-point@3 {
+			temperature = <70000>;
+			hysteresis = <5000>;
+			type = "active";
+		};
+		trip4: trip-point@4 {
+			temperature = <75000>;
+			hysteresis = <5000>;
+			type = "active";
+		};
+		pcritical: trip-point@5 {
+			temperature = <80000>;
+			hysteresis = <1000>;
+			type = "active";
+		};
+	};
+	cooling-maps {
+		map0 {
+			trip = <&trip0>;
+			cooling-device = <&fan0 0 1>;
+			contribution = <1024>;
+		};
+		map1 {
+			trip = <&trip1>;
+			cooling-device = <&fan0 1 2>;
+			contribution = <1024>;
+		};
+		map2 {
+			trip = <&trip2>;
+			cooling-device = <&fan0 2 3>;
+			contribution = <1024>;
+		};
+		map3 {
+			trip = <&trip3>;
+			cooling-device = <&fan0 3 4>;
+			contribution = <1024>;
+		};
+		map4 {
+			trip = <&trip4>;
+			cooling-device = <&fan0 4 5>;
+			contribution = <1024>;
+		};
+		map5 {
+			trip = <&pcritical>;
+			cooling-device = <&fan0 5 6>;
+			contribution = <1024>;
+		};
+	};
+};
+
+&rockchip_suspend {
+	compatible = "rockchip,pm-rk3588";
+	status = "okay";
+	rockchip,sleep-debug-en = <1>;
+	rockchip,sleep-mode-config = <
+		(0
+		| RKPM_SLP_ARMOFF_DDRPD
+		)
+	>;
+	rockchip,wakeup-config = <
+		(0
+		| RKPM_GPIO_WKUP_EN
+		| RKPM_USB_WKUP_EN
+		)
+	>;
+};
+
+&avdd_0v75_s0 {
+	regulator-state-mem {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <837500>;
+	};
+};
+
+&avcc_1v8_s0 {
+	regulator-state-mem {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <1800000>;
+	};
+};
+
+&vcc_1v8_s0 {
+	regulator-state-mem {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <1800000>;
+	};
+};
+
+&vcc_3v3_s0 {
+	regulator-state-mem {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <3300000>;
+	};
+};
+
+&vdd_log_s0 {
+	regulator-state-mem {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <750000>;
+	};
+};
+
+&vdd_ddr_pll_s0 {
+	regulator-state-mem {
+		regulator-on-in-suspend;
+		regulator-suspend-microvolt = <850000>;
+	};
+};
+
+&pinctrl {
+
+	power {
+		vcc_5v0_en: vcc-5v0-en {
+			rockchip,pins = <4 RK_PA3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	usb {
+		vcc5v0_host_en: vcc5v0-host-en {
+			rockchip,pins = <4 RK_PB5 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		vcc5v0_otg_en: vcc5v0-otg-en {
+			rockchip,pins = <0 RK_PD4 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	wifibt {
+		wl_reset: wl-reset {
+			rockchip,pins = <0 RK_PD0 RK_FUNC_GPIO &pcfg_pull_up>;
+	    };
+
+		wl_dis: wl-dis {
+			rockchip,pins = <0 RK_PD5 RK_FUNC_GPIO &pcfg_output_high>;
+	    };
+
+		wl_wake_host: wl-wake-host {
+			rockchip,pins = <0 RK_PC7 RK_FUNC_GPIO &pcfg_pull_up>;
+	    };
+
+		bt_dis: bt-dis {
+			rockchip,pins = <0 RK_PD4 RK_FUNC_GPIO &pcfg_output_high>;
+	    };
+
+		bt_wake_host: bt-wake-host {
+			rockchip,pins = <0 RK_PC5 RK_FUNC_GPIO &pcfg_pull_up>;
+	    };
+	};
+
+	hym8563 {
+		rtc_int: rtc-int {
+			rockchip,pins = <0 RK_PB0 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	headphone {
+		hp_det: hp-det {
+			rockchip,pins = <1 RK_PC4 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+
+	dp {
+		dp0_hpd: dp0-hpd {
+			rockchip,pins = <0 RK_PC4 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+};
+
+&gpio0 {
+	gpio-line-names =
+		/* GPIO0_A0-A3 */
+		"", "", "", "",
+		/* GPIO0_A4-A7 */
+		"", "", "", "",
+
+		/* GPIO0_B0-B3 */
+		"", "", "", "",
+		/* GPIO0_B4-B7 */
+		"", "PIN_8", "PIN_10", "",
+
+		/* GPIO0_C0-C3 */
+		"", "", "", "",
+		/* GPIO0_C4-C7 */
+		"", "", "", "PIN_27",
+
+		/* GPIO0_D0-D3 */
+		"PIN_28", "", "", "",
+		/* GPIO0_D4-D7 */
+		"", "", "", "";
+};
+
+&gpio1 {
+	gpio-line-names =
+		/* GPIO1_A0-A3 */
+		"PIN_21", "PIN_19", "PIN_23", "PIN_24",
+		/* GPIO1_A4-A7 */
+		"PIN_26", "PIN_16", "", "",
+
+		/* GPIO1_B0-B3 */
+		"PIN_18", "PIN_31", "PIN_29", "PIN_7",
+		/* GPIO1_B4-B7 */
+		"PIN_33", "PIN_22", "", "",
+
+		/* GPIO1_C0-C3 */
+		"", "", "", "",
+		/* GPIO1_C4-C7 */
+		"", "", "", "",
+
+		/* GPIO1_D0-D3 */
+		"", "", "", "",
+		/* GPIO1_D4-D7 */
+		"", "", "PIN_5", "PIN_3";
+};
+
+&gpio2 {
+	gpio-line-names =
+		/* GPIO2_A0-A3 */
+		"", "", "", "",
+		/* GPIO2_A4-A7 */
+		"", "", "", "",
+
+		/* GPIO2_B0-B3 */
+		"", "", "", "",
+		/* GPIO2_B4-B7 */
+		"", "", "", "",
+
+		/* GPIO2_C0-C3 */
+		"", "", "", "",
+		/* GPIO2_C4-C7 */
+		"", "", "", "",
+
+		/* GPIO2_D0-D3 */
+		"", "", "", "",
+		/* GPIO2_D4-D7 */
+		"", "", "", "";
+};
+
+&gpio3 {
+	gpio-line-names =
+		/* GPIO3_A0-A3 */
+		"", "", "", "",
+		/* GPIO3_A4-A7 */
+		"", "", "", "",
+
+		/* GPIO3_B0-B3 */
+		"", "", "", "",
+		/* GPIO3_B4-B7 */
+		"", "", "", "",
+
+		/* GPIO3_C0-C3 */
+		"", "", "", "",
+		/* GPIO3_C4-C7 */
+		"", "", "", "",
+
+		/* GPIO3_D0-D3 */
+		"", "", "", "",
+		/* GPIO3_D4-D7 */
+		"", "", "", "";
+};
+
+&gpio4 {
+	gpio-line-names =
+		/* GPIO4_A0-A3 */
+		"PIN_35", "PIN_12", "PIN_36", "",
+		/* GPIO4_A4-A7 */
+		"", "PIN_38", "", "",
+
+		/* GPIO4_B0-B3 */
+		"PIN_32", "PIN_40", "PIN_13", "PIN_11",
+		/* GPIO4_B4-B7 */
+		"PIN_15", "", "", "",
+
+		/* GPIO4_C0-C3 */
+		"", "", "", "",
+		/* GPIO4_C4-C7 */
+		"", "", "", "",
+
+		/* GPIO4_D0-D3 */
+		"", "", "", "",
+		/* GPIO4_D4-D7 */
+		"", "", "", "";
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/Makefile
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/Makefile
@@ -0,0 +1,133 @@
+# SPDX-License-Identifier: GPL-2.0
+dtbo-$(CONFIG_ARCH_ROCKCHIP) += \
+	orangepi-5-lcd1.dtbo \
+	orangepi-5-lcd2.dtbo \
+	orangepi-5-sata.dtbo \
+	orangepi-5-ap6275p.dtbo \
+	orangepi-5-disable-led.dtbo \
+	orangepi-5-plus-disable-leds.dtbo \
+	orangepi-5-plus-hdmi2-8k.dtbo \
+	orangepi-5-plus-lcd.dtbo \
+	orangepi-5-plus-ov13850.dtbo \
+	orangepi-5-plus-ov13855.dtbo \
+	orangepi-5-plus-sata2.dtbo \
+	rock-5a-hdmi-8k.dtbo \
+	rock-5a-i2c5-rtc-hym8563.dtbo \
+	rock-5a-radxa-camera-4k.dtbo \
+	rock-5a-radxa-display-10hd.dtbo \
+	rock-5a-radxa-display-10fhd.dtbo \
+	rock-5a-radxa-display-8hd.dtbo \
+	rock-5a-spi-nor-flash.dtbo \
+	rock-5a-usb-otg.dtbo \
+	rock-5a-rpi-camera-v2.dtbo \
+	rock-5a-sata.dtbo \
+	rock-5b-hdmi1-8k.dtbo \
+	rock-5b-hdmi2-8k.dtbo \
+	rock-5b-pd-max-voltage-12v.dtbo \
+	rock-5b-radxa-display-10hd.dtbo \
+	rock-5b-radxa-display-8hd.dtbo \
+	rock-5b-radxa-display-10fhd.dtbo \
+	rock-5b-rpi-camera-v2.dtbo \
+	rock-5b-radxa-camera-4k.dtbo \
+	rock-5b-sata.dtbo \
+	mixtile-blade3-sata2.dtbo \
+	rockchip-rk3588-opp-oc-24ghz.dtbo \
+	rk3588-can0-m0.dtbo \
+	rk3588-can1-m0.dtbo \
+	rk3588-can1-m1.dtbo \
+	rk3588-can2-m1.dtbo \
+	rk3588-dwc3-host.dtbo \
+	rk3588-dwc3-peripheral.dtbo \
+	rk3588-i2c0-m1.dtbo \
+	rk3588-i2c1-m0.dtbo \
+	rk3588-i2c1-m2.dtbo \
+	rk3588-i2c1-m4.dtbo \
+	rk3588-i2c2-m0.dtbo \
+	rk3588-i2c2-m4.dtbo \
+	rk3588-i2c3-m0.dtbo \
+	rk3588-i2c3-m1.dtbo \
+	rk3588-i2c4-m3.dtbo \
+	rk3588-i2c5-m3.dtbo \
+	rk3588-i2c6-m0.dtbo \
+	rk3588-i2c6-m3.dtbo \
+	rk3588-i2c6-m4.dtbo \
+	rk3588-i2c7-m3.dtbo \
+	rk3588-i2c8-m2.dtbo \
+	rk3588-i2c8-m4.dtbo \
+	rk3588-ov13850-c1.dtbo \
+	rk3588-ov13850-c2.dtbo \
+	rk3588-ov13850-c3.dtbo \
+	rk3588-ov13855-c1.dtbo \
+	rk3588-ov13855-c2.dtbo \
+	rk3588-ov13855-c3.dtbo \
+	rk3588-pwm0-m0.dtbo \
+	rk3588-pwm0-m1.dtbo \
+	rk3588-pwm0-m2.dtbo \
+	rk3588-pwm10-m0.dtbo \
+	rk3588-pwm11-m0.dtbo \
+	rk3588-pwm11-m1.dtbo \
+	rk3588-pwm12-m0.dtbo \
+	rk3588-pwm13-m0.dtbo \
+	rk3588-pwm13-m2.dtbo \
+	rk3588-pwm14-m0.dtbo \
+	rk3588-pwm14-m1.dtbo \
+	rk3588-pwm14-m2.dtbo \
+	rk3588-pwm15-m0.dtbo \
+	rk3588-pwm15-m1.dtbo \
+	rk3588-pwm15-m2.dtbo \
+	rk3588-pwm15-m3.dtbo \
+	rk3588-pwm1-m0.dtbo \
+	rk3588-pwm1-m1.dtbo \
+	rk3588-pwm1-m2.dtbo \
+	rk3588-pwm2-m1.dtbo \
+	rk3588-pwm3-m0.dtbo \
+	rk3588-pwm3-m1.dtbo \
+	rk3588-pwm3-m2.dtbo \
+	rk3588-pwm3-m3.dtbo \
+	rk3588-pwm5-m2.dtbo \
+	rk3588-pwm6-m0.dtbo \
+	rk3588-pwm6-m2.dtbo \
+	rk3588-pwm7-m0.dtbo \
+	rk3588-pwm7-m3.dtbo \
+	rk3588-pwm8-m0.dtbo \
+	rk3588-spi0-m1-cs0-spidev.dtbo \
+	rk3588-spi0-m1-cs1-spidev.dtbo \
+	rk3588-spi0-m2-cs0-cs1-spidev.dtbo \
+	rk3588-spi0-m2-cs0-spidev.dtbo \
+	rk3588-spi0-m2-cs1-spidev.dtbo \
+	rk3588-spi1-m1-cs0-spidev.dtbo \
+	rk3588-spi1-m1-cs1-mcp2515-8mhz.dtbo \
+	rk3588-spi1-m1-cs1-spidev.dtbo \
+	rk3588-spi4-m0-cs1-spidev.dtbo \
+	rk3588-spi4-m1-cs0-cs1-spidev.dtbo \
+	rk3588-spi4-m1-cs0-spidev.dtbo \
+	rk3588-spi4-m1-cs1-spidev.dtbo \
+	rk3588-spi4-m2-cs0-spidev.dtbo \
+	rk3588-uart0-m2.dtbo \
+	rk3588-uart1-m1.dtbo \
+	rk3588-uart2-m0.dtbo \
+	rk3588-uart2-m2.dtbo \
+	rk3588-uart3-m0.dtbo \
+	rk3588-uart3-m1.dtbo \
+	rk3588-uart4-m0.dtbo \
+	rk3588-uart4-m2.dtbo \
+	rk3588-uart6-m1.dtbo \
+	rk3588-uart6-m1-full.dtbo \
+	rk3588-uart7-m1.dtbo \
+	rk3588-uart7-m1-full.dtbo \
+	rk3588-uart7-m2.dtbo \
+	rk3588-uart8-m0.dtbo \
+	rk3588-uart8-m0-full.dtbo \
+	rk3588-uart8-m1.dtbo \
+	rk3588-w1-gpio3-b3.dtbo \
+	rk3588-w1-gpio4-b1.dtbo
+
+
+dtbotxt-$(CONFIG_ARCH_ROCKCHIP) += \
+	README.rockchip-overlays
+
+targets += $(dtbo-y) $(dtbotxt-y)
+
+always-y		:= $(dtbo-y) $(dtbotxt-y)
+clean-files		:= *.dtbo
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/README.rockchip-overlays
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/README.rockchip-overlays
@@ -0,0 +1 @@
+## Introduction
\ No newline at end of file
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/mixtile-blade3-sata2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/mixtile-blade3-sata2.dts
@@ -0,0 +1,20 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&pcie2x1l1>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@1 {
+		target = <&sata2>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-ap6275p.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-ap6275p.dts
@@ -0,0 +1,19 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&wireless_bluetooth>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target = <&wireless_wlan>;
+		__overlay__ {
+			status = "okay";
+			wifi_chip_type = "ap6275p";
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-disable-led.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-disable-led.dts
@@ -0,0 +1,17 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&leds>;
+
+		__overlay__ {
+			status = "okay";
+
+			led@1 {
+				linux,default-trigger = "none";
+			};
+		};
+	};
+};
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-lcd1.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-lcd1.dts
@@ -0,0 +1,88 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&dsi1>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target = <&dsi1_panel>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&dsi1_in_vp3>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@3 {
+		target = <&hdmi0>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@4 {
+		target = <&hdmi0_sound>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@5 {
+		target = <&hdptxphy_hdmi0>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@6 {
+		target = <&route_hdmi0>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@7 {
+		target = <&dp0>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@8 {
+		target = <&dp0_in_vp1>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@9 {
+		target = <&dp0_in_vp2>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@10 {
+		target = <&dp0_sound>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@11 {
+		target = <&spdif_tx2>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-lcd2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-lcd2.dts
@@ -0,0 +1,88 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&dsi0>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target = <&dsi0_panel>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&dsi0_in_vp2>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@3 {
+		target = <&hdmi0>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@4 {
+		target = <&hdmi0_sound>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@5 {
+		target = <&hdptxphy_hdmi0>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@6 {
+		target = <&route_hdmi0>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@7 {
+		target = <&dp0>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@8 {
+		target = <&dp0_in_vp1>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@9 {
+		target = <&dp0_in_vp2>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@10 {
+		target = <&dp0_sound>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@11 {
+		target = <&spdif_tx2>;
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-plus-disable-leds.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-plus-disable-leds.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&leds>;
+
+		__overlay__ {
+			status = "okay";
+
+			blue_led@1 {
+				linux,default-trigger = "none";
+			};
+
+			green_led@2 {
+				linux,default-trigger = "none";
+			};
+		};
+	};
+};
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-plus-hdmi2-8k.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-plus-hdmi2-8k.dts
@@ -0,0 +1,37 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&hdmi0_in_vp0>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@1 {
+		target = <&hdmi0_in_vp1>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&hdmi1_in_vp0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@3 {
+		target = <&hdmi1_in_vp1>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+};
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-plus-lcd.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-plus-lcd.dts
@@ -0,0 +1,26 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&dsi1>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target = <&dsi1_panel>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&dsi1_in_vp3>;
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-plus-ov13850.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-plus-ov13850.dts
@@ -0,0 +1,101 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&csi2_dphy0_hw>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target = <&csi2_dphy0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&mipi2_csi2>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@3 {
+		target = <&rkcif_mipi_lvds2>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&rkcif_mipi_lvds2_sditf>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@5 {
+		target = <&rkisp0_vir1>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@6 {
+		target = <&i2c3>;
+
+		__overlay__ {
+			status = "okay";
+
+			vm149c-p1@c {
+				status = "okay";
+			};
+
+			ov13850-1@10 {
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@7 {
+		target = <&rkcif>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@8 {
+		target = <&rkcif_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@9 {
+		target = <&rkisp0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@10 {
+		target = <&isp0_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-plus-ov13855.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-plus-ov13855.dts
@@ -0,0 +1,101 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&csi2_dphy0_hw>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target = <&csi2_dphy0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&mipi2_csi2>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@3 {
+		target = <&rkcif_mipi_lvds2>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&rkcif_mipi_lvds2_sditf>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@5 {
+		target = <&rkisp0_vir1>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@6 {
+		target = <&i2c3>;
+
+		__overlay__ {
+			status = "okay";
+
+			dw9714-p1@c {
+				status = "okay";
+			};
+
+			ov13855-1@36 {
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@7 {
+		target = <&rkcif>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@8 {
+		target = <&rkcif_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@9 {
+		target = <&rkisp0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@10 {
+		target = <&isp0_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-plus-sata2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-plus-sata2.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&sata2>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target = <&pcie2x1l1>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+};
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-sata.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/orangepi-5-sata.dts
@@ -0,0 +1,20 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&sata0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target = <&pcie2x1l2>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-can0-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-can0-m0.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&can0>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "default";
+			pinctrl-0 = <&can0m0_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-can1-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-can1-m0.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&can1>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "default";
+			pinctrl-0 = <&can1m0_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-can1-m1.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-can1-m1.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&can1>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "default";
+			pinctrl-0 = <&can1m1_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-can2-m1.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-can2-m1.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&can2>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "default";
+			pinctrl-0 = <&can2m1_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-dwc3-host.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-dwc3-host.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Set OTG port to Host mode";
+		compatible = "rockchip,rk3588";
+		category = "misc";
+		exclusive = "usbdrd_dwc3-dr_mode";
+		description = "Set OTG port to Host mode.\nUse this when you want to connect USB devices.";
+	};
+
+	fragment@0 {
+		target = <&usbdrd_dwc3_0>;
+
+		__overlay__ {
+			status = "okay";
+			dr_mode = "host";
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-dwc3-peripheral.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-dwc3-peripheral.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Set OTG port to Peripheral mode";
+		compatible = "rockchip,rk3588";
+		category = "misc";
+		exclusive = "usbdrd_dwc3-dr_mode";
+		description = "Set OTG port to Peripheral mode.\nUse this when you want to connect to another computer.";
+	};
+
+	fragment@0 {
+		target = <&usbdrd_dwc3_0>;
+
+		__overlay__ {
+			status = "okay";
+			dr_mode = "peripheral";
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c0-m1.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c0-m1.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable I2C0-M1";
+		compatible = "radxa,rock-5b";
+		category = "misc";
+		exclusive = "GPIO4_C6", "GPIO4_C5";
+		description = "Enable I2C0-M1.\nOn Radxa ROCK 5B this is SDA pin 27 and this is SCL pin 28.";
+	};
+
+	fragment@0 {
+		target = <&i2c0>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&i2c0m1_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c1-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c1-m0.dts
@@ -0,0 +1,29 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable I2C1-M0";
+		compatible = "radxa,rock-5a", "radxa,rock-5b";
+		category = "misc";
+		exclusive = "GPIO0_B5", "GPIO0_B6";
+		description = "Enable I2C1-M0.\nOn Radxa ROCK 5A this is SDA pin 10 and SCL pin 8.\nOn Radxa ROCK 5B this is SDA pin 10 and SCL pin 8.";
+	};
+
+	fragment@0 {
+		target = <&fiq_debugger>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@1 {
+		target = <&i2c1>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&i2c1m0_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c1-m2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c1-m2.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&i2c1>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c1m2_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c1-m4.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c1-m4.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&i2c1>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c1m4_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c2-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c2-m0.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&i2c2>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c2m0_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c2-m4.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c2-m4.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&i2c2>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c2m4_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c3-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c3-m0.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&i2c3>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c3m0_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c3-m1.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c3-m1.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable I2C3-M1";
+		compatible = "radxa,rock-5b";
+		category = "misc";
+		exclusive = "GPIO3_B7", "GPIO3_C0";
+		description = "Enable I2C3-M1.\nOn Radxa ROCK 5B this is SDA pin 15 and this is SCL pin 13.";
+	};
+
+	fragment@0 {
+		target = <&i2c3>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&i2c3m1_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c4-m3.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c4-m3.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&i2c4>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c4m3_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c5-m3.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c5-m3.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&i2c5>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c5m3_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c6-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c6-m0.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable I2C6-M0";
+		compatible = "radxa,rock-5a";
+		category = "misc";
+		exclusive = "GPIO0_C7", "GPIO0_D0";
+		description = "Enable I2C6-M0.\nOn Radxa ROCK 5A this is SDA pin 27 and SCL pin 28.";
+	};
+
+	fragment@0 {
+		target = <&i2c6>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&i2c6m0_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c6-m3.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c6-m3.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable I2C6-M3";
+		compatible = "radxa,rock-5a";
+		category = "misc";
+		exclusive = "GPIO4_B0", "GPIO4_B1";
+		description = "Enable I2C6-M3.\nOn Radxa ROCK 5A this is SDA pin 32 and SCL pin 40.";
+	};
+
+	fragment@0 {
+		target = <&i2c6>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&i2c6m3_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c6-m4.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c6-m4.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&i2c6>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c6m4_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c7-m3.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c7-m3.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable I2C7-M3";
+		compatible = "unknown";
+		category = "misc";
+		exclusive = "GPIO4_B2", "GPIO4_B3";
+		description = "Enable I2C7-M3.";
+	};
+
+	fragment@0 {
+		target = <&i2c7>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&i2c7m3_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c8-m2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c8-m2.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&i2c8>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c8m2_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c8-m4.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-i2c8-m4.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable I2C8-M4";
+		compatible = "radxa,rock-5b";
+		category = "misc";
+		exclusive = "GPIO3_C3", "GPIO3_C2";
+		description = "Enable I2C8-M4.\nOn Radxa ROCK 5B this is SDA pin 7 and SCL pin 32.";
+	};
+
+	fragment@0 {
+		target = <&i2c8>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&i2c8m4_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-ov13850-c1.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-ov13850-c1.dts
@@ -0,0 +1,100 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&csi2_dphy0_hw>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target = <&csi2_dphy0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&mipi2_csi2>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@3 {
+		target = <&rkcif_mipi_lvds2>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&rkcif_mipi_lvds2_sditf>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@5 {
+		target = <&rkisp0_vir1>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@6 {
+		target = <&i2c7>;
+
+		__overlay__ {
+			status = "okay";
+
+			vm149c-p1@c {
+				status = "okay";
+			};
+
+			ov13850-1@10 {
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@7 {
+		target = <&rkcif>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@8 {
+		target = <&rkcif_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@9 {
+		target = <&rkisp0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@10 {
+		target = <&isp0_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-ov13850-c2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-ov13850-c2.dts
@@ -0,0 +1,94 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	compatible = "rockchip,rk3588s-orangepi-5", "rockchip,rk3588";
+
+	fragment@0 {
+		target = <&csi2_dcphy0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target = <&mipi0_csi2>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&rkcif_mipi_lvds>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@3 {
+		target = <&rkcif_mipi_lvds_sditf>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&rkisp0_vir0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@6 {
+		target = <&i2c7>;
+
+		__overlay__ {
+			status = "okay";
+
+			vm149c-p2@c {
+				status = "okay";
+			};
+
+			ov13850-2@10 {
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@7 {
+		target = <&rkcif>;
+
+		__overlay__ {
+		        status = "okay";
+		};
+	};
+
+	fragment@8 {
+		target = <&rkcif_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@9 {
+		target = <&rkisp0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@10 {
+		target = <&isp0_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-ov13850-c3.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-ov13850-c3.dts
@@ -0,0 +1,94 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	compatible = "rockchip,rk3588s-orangepi-5", "rockchip,rk3588";
+
+	fragment@0 {
+		target = <&csi2_dcphy1>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target = <&mipi1_csi2>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&rkcif_mipi_lvds1>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@3 {
+		target = <&rkcif_mipi_lvds1_sditf>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&rkisp1_vir0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@5 {
+		target = <&i2c2>;
+
+		__overlay__ {
+			status = "okay";
+
+			vm149c@c {
+				status = "okay";
+			};
+
+			ov13850@10 {
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@6 {
+		target = <&rkcif>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@7 {
+		target = <&rkcif_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@8 {
+		target = <&rkisp1>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@9 {
+		target = <&isp1_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-ov13855-c1.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-ov13855-c1.dts
@@ -0,0 +1,100 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&csi2_dphy0_hw>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target = <&csi2_dphy0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&mipi2_csi2>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@3 {
+		target = <&rkcif_mipi_lvds2>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&rkcif_mipi_lvds2_sditf>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@5 {
+		target = <&rkisp0_vir1>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@6 {
+		target = <&i2c7>;
+
+		__overlay__ {
+			status = "okay";
+
+			dw9714-p1@c {
+				status = "okay";
+			};
+
+			ov13855-1@36 {
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@7 {
+		target = <&rkcif>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@8 {
+		target = <&rkcif_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@9 {
+		target = <&rkisp0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@10 {
+		target = <&isp0_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-ov13855-c2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-ov13855-c2.dts
@@ -0,0 +1,94 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	compatible = "rockchip,rk3588s-orangepi-5", "rockchip,rk3588";
+
+	fragment@0 {
+		target = <&csi2_dcphy0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target = <&mipi0_csi2>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&rkcif_mipi_lvds>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@3 {
+		target = <&rkcif_mipi_lvds_sditf>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&rkisp0_vir0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@6 {
+		target = <&i2c7>;
+
+		__overlay__ {
+			status = "okay";
+
+			dw9714-p2@c {
+				status = "okay";
+			};
+
+			ov13855-2@36 {
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@7 {
+		target = <&rkcif>;
+
+		__overlay__ {
+		        status = "okay";
+		};
+	};
+
+	fragment@8 {
+		target = <&rkcif_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@9 {
+		target = <&rkisp0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@10 {
+		target = <&isp0_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-ov13855-c3.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-ov13855-c3.dts
@@ -0,0 +1,94 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	compatible = "rockchip,rk3588s-orangepi-5", "rockchip,rk3588";
+
+	fragment@0 {
+		target = <&csi2_dcphy1>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target = <&mipi1_csi2>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&rkcif_mipi_lvds1>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@3 {
+		target = <&rkcif_mipi_lvds1_sditf>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&rkisp1_vir0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@5 {
+		target = <&i2c2>;
+
+		__overlay__ {
+			status = "okay";
+
+			dw9714@c {
+				status = "okay";
+			};
+
+			ov13855@36 {
+				status = "okay";
+			};
+		};
+	};
+
+	fragment@6 {
+		target = <&rkcif>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@7 {
+		target = <&rkcif_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@8 {
+		target = <&rkisp1>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@9 {
+		target = <&isp1_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm0-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm0-m0.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&pwm0>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "active";
+			pinctrl-0 = <&pwm0m0_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm0-m1.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm0-m1.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&pwm0>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm0m1_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm0-m2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm0-m2.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&pwm0>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm0m2_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm1-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm1-m0.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&pwm1>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "active";
+			pinctrl-0 = <&pwm1m0_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm1-m1.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm1-m1.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&pwm1>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm1m1_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm1-m2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm1-m2.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&pwm1>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm1m2_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm10-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm10-m0.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&pwm10>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm10m0_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm11-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm11-m0.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&pwm11>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm11m0_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm11-m1.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm11-m1.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable PWM11-M1";
+		compatible = "radxa,rock-5a";
+		category = "misc";
+		exclusive = "GPIO4_B4";
+		description = "Enable PWM11-M1.\nOn Radxa ROCK 5A this is pin 15.";
+	};
+
+	fragment@0 {
+		target = <&pwm11>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm11m1_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm12-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm12-m0.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&pwm12>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm12m0_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm13-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm13-m0.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&pwm13>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm13m0_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm13-m2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm13-m2.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&pwm13>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm13m2_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm14-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm14-m0.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&pwm14>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "active";
+			pinctrl-0 = <&pwm14m0_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm14-m1.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm14-m1.dts
@@ -0,0 +1,14 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&pwm14>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "active";
+			pinctrl-0 = <&pwm14m1_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm14-m2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm14-m2.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&pwm14>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm14m2_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm15-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm15-m0.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable PWM15-M0";
+		compatible = "radxa,rock-5b";
+		category = "misc";
+		exclusive = "GPIO3_C3";
+		description = "Enable PWM15-M0.\nOn Radxa ROCK 5B this is pin 7.";
+	};
+
+	fragment@0 {
+		target = <&pwm15>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm15m0_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm15-m1.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm15-m1.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&pwm15>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm15m1_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm15-m2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm15-m2.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&pwm15>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm15m2_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm15-m3.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm15-m3.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable PWM15-M3";
+		compatible = "radxa,rock-5a", "radxa,rock-5b";
+		category = "misc";
+		exclusive = "GPIO1_D7";
+		description = "Enable PWM15-M3.\nOn Radxa ROCK 5A this is pin 3.\nOn Radxa ROCK 5B this is pin 29.";
+	};
+
+	fragment@0 {
+		target = <&pwm15>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm15m3_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm2-m1.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm2-m1.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable PWM2-M1";
+		compatible = "radxa,rock-5b";
+		category = "misc";
+		exclusive = "GPIO3_B1";
+		description = "Enable PWM2-M1.\nOn Radxa ROCK 5B this is pin 36.";
+	};
+
+	fragment@0 {
+		target = <&pwm2>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm2m1_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm3-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm3-m0.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&pwm3>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm3m0_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm3-m1.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm3-m1.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable PWM3-M1";
+		compatible = "radxa,rock-5b";
+		category = "misc";
+		exclusive = "GPIO3_B2";
+		description = "Enable PWM3-M1.\nOn Radxa ROCK 5B this is pin 38.";
+	};
+
+	fragment@0 {
+		target = <&pwm3>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm3m1_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm3-m2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm3-m2.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&pwm3>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm3m2_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm3-m3.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm3-m3.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&pwm3>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm3m3_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm5-m2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm5-m2.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable PWM5-M2";
+		compatible = "radxa,rock-5b";
+		category = "misc";
+		exclusive = "GPIO4_C4";
+		description = "Enable PWM5-M2.\nOn Radxa ROCK 5B this is pin 18.";
+	};
+
+	fragment@0 {
+		target = <&pwm5>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm5m2_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm6-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm6-m0.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable PWM6-M0";
+		compatible = "radxa,rock-5a";
+		category = "misc";
+		exclusive = "GPIO0_C7";
+		description = "Enable PWM6-M0.\nOn Radxa ROCK 5A this is pin 27.";
+	};
+
+	fragment@0 {
+		target = <&pwm6>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm6m0_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm6-m2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm6-m2.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable PWM6-M2";
+		compatible = "radxa,rock-5b";
+		category = "misc";
+		exclusive = "GPIO4_C5";
+		description = "Enable PWM6-M2.\nOn Radxa ROCK 5B this is pin 28.";
+	};
+
+	fragment@0 {
+		target = <&pwm6>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm6m2_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm7-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm7-m0.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable PWM7-M0";
+		compatible = "radxa,rock-5a";
+		category = "misc";
+		exclusive = "GPIO0_D0";
+		description = "Enable PWM7-M0.\nOn Radxa ROCK 5A this is pin 28.";
+	};
+
+	fragment@0 {
+		target = <&pwm7>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm7m0_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm7-m3.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm7-m3.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable PWM7-M3";
+		compatible = "radxa,rock-5b";
+		category = "misc";
+		exclusive = "GPIO4_C6";
+		description = "Enable PWM7-M3.\nOn Radxa ROCK 5B this is pin 27.";
+	};
+
+	fragment@0 {
+		target = <&pwm7>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm7m3_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm8-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-pwm8-m0.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable PWM8-M0";
+		compatible = "radxa,rock-5b";
+		category = "misc";
+		exclusive = "GPIO3_A7";
+		description = "Enable PWM8-M0.\nOn Radxa ROCK 5B this is pin 33.";
+	};
+
+	fragment@0 {
+		target = <&pwm8>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&pwm8m0_pins>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi0-m1-cs0-spidev.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi0-m1-cs0-spidev.dts
@@ -0,0 +1,32 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable spidev on SPI0-M1 over CS0";
+		compatible = "radxa,rock-5a";
+		category = "misc";
+		exclusive = "GPIO4_A2", "GPIO4_A1", "GPIO4_A0", "GPIO4_B2";
+		description = "Enable spidev on SPI0-M1 over CS0.";
+	};
+
+	fragment@0 {
+		target = <&spi0>;
+
+		__overlay__ {
+			status = "okay";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi0m1_cs0 &spi0m1_pins>;
+			max-freq = <50000000>;
+
+			spidev@0 {
+				compatible = "rockchip,spidev";
+				status = "okay";
+				reg = <0>;
+				spi-max-frequency = <50000000>;
+			};
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi0-m1-cs1-spidev.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi0-m1-cs1-spidev.dts
@@ -0,0 +1,32 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable spidev on SPI0-M1 over CS1";
+		compatible = "radxa,rock-5a";
+		category = "misc";
+		exclusive = "GPIO4_A2", "GPIO4_A1", "GPIO4_A0", "GPIO4_B1";
+		description = "Enable spidev on SPI0-M1 over CS1.";
+	};
+
+	fragment@0 {
+		target = <&spi0>;
+
+		__overlay__ {
+			status = "okay";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi0m1_cs1 &spi0m1_pins>;
+			max-freq = <50000000>;
+
+			spidev@0 {
+				compatible = "rockchip,spidev";
+				status = "okay";
+				reg = <0>;
+				spi-max-frequency = <50000000>;
+			};
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi0-m2-cs0-cs1-spidev.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi0-m2-cs0-cs1-spidev.dts
@@ -0,0 +1,31 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&spi0>;
+
+		__overlay__ {
+			status = "okay";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi0m2_cs0 &spi0m2_cs1 &spi0m2_pins>;
+			max-freq = <50000000>;
+
+			spidev@0 {
+				compatible = "rockchip,spidev";
+				status = "okay";
+				reg = <0>;
+				spi-max-frequency = <50000000>;
+			};
+
+			spidev@1 {
+				compatible = "rockchip,spidev";
+				status = "okay";
+				reg = <1>;
+				spi-max-frequency = <50000000>;
+			};
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi0-m2-cs0-spidev.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi0-m2-cs0-spidev.dts
@@ -0,0 +1,24 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&spi0>;
+
+		__overlay__ {
+			status = "okay";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi0m2_cs0 &spi0m2_pins>;
+			max-freq = <50000000>;
+
+			spidev@0 {
+				compatible = "rockchip,spidev";
+				status = "okay";
+				reg = <0>;
+				spi-max-frequency = <50000000>;
+			};
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi0-m2-cs1-spidev.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi0-m2-cs1-spidev.dts
@@ -0,0 +1,24 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&spi0>;
+
+		__overlay__ {
+			status = "okay";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi0m2_cs1 &spi0m2_pins>;
+			max-freq = <50000000>;
+
+			spidev@1 {
+				compatible = "rockchip,spidev";
+				status = "okay";
+				reg = <1>;
+				spi-max-frequency = <50000000>;
+			};
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi1-m1-cs0-spidev.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi1-m1-cs0-spidev.dts
@@ -0,0 +1,32 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable spidev on SPI1-M1 over CS0";
+		compatible = "radxa,rock-5b";
+		category = "misc";
+		exclusive = "GPIO3_C2", "GPIO3_C1", "GPIO3_B7", "GPIO3_C0";
+		description = "Enable spidev on SPI1-M1 over CS0.";
+	};
+
+	fragment@0 {
+		target = <&spi1>;
+
+		__overlay__ {
+			status = "okay";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi1m1_cs0 &spi1m1_pins>;
+			max-freq = <50000000>;
+
+			spidev@0 {
+				compatible = "rockchip,spidev";
+				status = "okay";
+				reg = <0>;
+				spi-max-frequency = <50000000>;
+			};
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi1-m1-cs1-mcp2515-8mhz.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi1-m1-cs1-mcp2515-8mhz.dts
@@ -0,0 +1,60 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	metadata {
+		title = "Enable MCP2515 with 8MHz external clock on SPI1-M1 over CS1";
+		compatible = "unknown";
+		category = "misc";
+		description = "Provide support for Microchip MCP2515 SPI CAN controller.\nAssumes 8MHz external clock.\nUses Pin 19 (GPIOI1_B2) for INT.";
+	};
+
+	fragment@0 {
+		target = <&spi1>;
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi1m1_pins &spi1m1_cs0 &spi1m1_cs1>;
+
+			can0: mcp2515@1 {
+				compatible = "microchip,mcp2515";
+				reg = <1>;
+				spi-max-frequency = <10000000>;
+
+				pinctrl-names = "default";
+				pinctrl-0 = <&mcp2515_int_pins>;
+
+				interrupt-parent = <&gpio1>;
+				interrupts = <RK_PB2 IRQ_TYPE_EDGE_FALLING>;
+
+				clocks = <&can0_osc>;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&pinctrl>;
+		__overlay__ {
+			mcp2515 {
+				mcp2515_int_pins: mcp2515-int-pins {
+					rockchip,pins = <1 RK_PB2 RK_FUNC_GPIO &pcfg_pull_up>;
+				};
+			};
+		};
+	};
+
+	fragment@2 {
+		target-path = "/";
+		__overlay__ {
+			can0_osc: can0-osc {
+				compatible = "fixed-clock";
+				#clock-cells = <0>;
+				clock-frequency  = <8000000>;
+			};
+		};
+	};
+};
\ No newline at end of file
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi1-m1-cs1-spidev.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi1-m1-cs1-spidev.dts
@@ -0,0 +1,32 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable spidev on SPI1-M1 over CS1";
+		compatible = "radxa,rock-5b";
+		category = "misc";
+		exclusive = "GPIO3_C3", "GPIO3_C1", "GPIO3_B7", "GPIO3_C0";
+		description = "Enable spidev on SPI1-M1 over CS1.";
+	};
+
+	fragment@0 {
+		target = <&spi1>;
+
+		__overlay__ {
+			status = "okay";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi1m1_cs1 &spi1m1_pins>;
+			max-freq = <50000000>;
+
+			spidev@1 {
+				compatible = "rockchip,spidev";
+				status = "okay";
+				reg = <1>;
+				spi-max-frequency = <50000000>;
+			};
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi4-m0-cs1-spidev.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi4-m0-cs1-spidev.dts
@@ -0,0 +1,23 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&spi4>;
+
+		__overlay__ {
+			status = "okay";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi4m0_cs1 &spi4m0_pins>;
+
+			spidev@1 {
+				compatible = "rockchip,spidev";
+				status = "okay";
+				reg = <1>;
+				spi-max-frequency = <50000000>;
+			};
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi4-m1-cs0-cs1-spidev.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi4-m1-cs0-cs1-spidev.dts
@@ -0,0 +1,30 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&spi4>;
+
+		__overlay__ {
+			status = "okay";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi4m1_cs0 &spi4m1_cs1 &spi4m1_pins>;
+
+			spidev@0 {
+				compatible = "rockchip,spidev";
+				status = "okay";
+				reg = <0>;
+				spi-max-frequency = <50000000>;
+			};
+
+			spidev@1 {
+				compatible = "rockchip,spidev";
+				status = "okay";
+				reg = <1>;
+				spi-max-frequency = <50000000>;
+			};
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi4-m1-cs0-spidev.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi4-m1-cs0-spidev.dts
@@ -0,0 +1,23 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&spi4>;
+
+		__overlay__ {
+			status = "okay";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi4m1_cs0 &spi4m1_pins>;
+
+			spidev@0 {
+				compatible = "rockchip,spidev";
+				status = "okay";
+				reg = <0>;
+				spi-max-frequency = <50000000>;
+			};
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi4-m1-cs1-spidev.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi4-m1-cs1-spidev.dts
@@ -0,0 +1,23 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&spi4>;
+
+		__overlay__ {
+			status = "okay";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi4m1_cs1 &spi4m1_pins>;
+
+			spidev@1 {
+				compatible = "rockchip,spidev";
+				status = "okay";
+				reg = <1>;
+				spi-max-frequency = <50000000>;
+			};
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi4-m2-cs0-spidev.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-spi4-m2-cs0-spidev.dts
@@ -0,0 +1,23 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&spi4>;
+
+		__overlay__ {
+			status = "okay";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi4m2_cs0 &spi4m2_pins>;
+
+			spidev@0 {
+				compatible = "rockchip,spidev";
+				status = "okay";
+				reg = <0>;
+				spi-max-frequency = <50000000>;
+			};
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart0-m2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart0-m2.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&uart0>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&uart0m2_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart1-m1.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart1-m1.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&uart1>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&uart1m1_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart2-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart2-m0.dts
@@ -0,0 +1,29 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable UART2-M0";
+		compatible = "radxa,rock-5a", "radxa,rock-5b";
+		category = "misc";
+		exclusive = "GPIO0_B5", "GPIO0_B6";
+		description = "Enable UART2-M0.\nOn Radxa ROCK 5A this is TX pin 8 and RX pin 10.\nOn Radxa ROCK 5B this is TX pin 8 and this is RX pin 10.";
+	};
+
+	fragment@0 {
+		target = <&uart2>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&uart2m0_xfer>;
+		};
+	};
+
+	fragment@1 {
+		target = <&fiq_debugger>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart2-m2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart2-m2.dts
@@ -0,0 +1,30 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable UART2-M2";
+		compatible = "radxa,rock-5b";
+		category = "misc";
+		exclusive = "GPIO3_B1", "GPIO3_B2";
+		description = "Enable UART2-M2.\nOn Radxa ROCK 5B this is TX pin 36 and this is RX pin 38.";
+	};
+
+	fragment@0 {
+		target = <&fiq_debugger>;
+
+		__overlay__ {
+			status = "okay";
+			rockchip,serial-id = <0xffffffff>;
+		};
+	};
+
+	fragment1 {
+		target = <&uart2>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&uart2m2_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart3-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart3-m0.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&uart3>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&uart3m0_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart3-m1.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart3-m1.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&uart3>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&uart3m1_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart4-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart4-m0.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&uart4>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&uart4m0_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart4-m2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart4-m2.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&uart4>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&uart4m2_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart6-m1-full.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart6-m1-full.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable UART6-M1 with Hardware Follow Control";
+		compatible = "unknown";
+		category = "misc";
+		exclusive = "GPIO1_A1", "GPIO1_A0", "GPIO1_A2", "GPIO1_A3";
+		description = "Enable UART6-M1 with hardware follow control.\nOn Radxa ROCK 5A this is CTSN pin 24, RTSN pin 23, TX pin 19, and RX pin 21.";
+	};
+
+	fragment@0 {
+		target = <&uart6>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&uart6m1_xfer &uart6m1_ctsn &uart6m1_rtsn>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart6-m1.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart6-m1.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&uart6>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&uart6m1_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart7-m1-full.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart7-m1-full.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable UART7-M1 with Hardware Flow Control";
+		compatible = "unknown";
+		category = "misc";
+		exclusive = "GPIO3_C3", "GPIO3_C1", "GPIO3_C0", "GPIO3_C2";
+		description = "Enable UART7-M1 with hardware flow control.\nOn Radxa ROCK 5B this is CTSN pin 7, RTSN pin 32, RX pin 11, and TX pin 15.";
+	};
+
+	fragment@0 {
+		target = <&uart7>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&uart7m1_xfer &uart7m1_ctsn &uart7m1_rtsn>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart7-m1.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart7-m1.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable UART7-M1";
+		compatible = "radxa,rock-5b";
+		category = "misc";
+		exclusive = "GPIO3_C1", "GPIO3_C0";
+		description = "Enable UART7-M1.\nOn Radxa ROCK 5B this is RX pin 11 and TX pin 15.";
+	};
+
+	fragment@0 {
+		target = <&uart7>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&uart7m1_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart7-m2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart7-m2.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable UART7-M2";
+		compatible = "radxa,rock-5a", "radxa,rock-5b";
+		category = "misc";
+		exclusive= "GPIO1_B5", "GPIO1_B4";
+		description = "Enable UART7-M2.\nOn Radxa ROCK 5A this is TX pin 22 and RX pin 33.\nOn Radxa ROCK 5B this is TX pin 26 and this RX pin 24.";
+	};
+
+	fragment@0 {
+		target = <&uart7>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&uart7m2_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart8-m0-full.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart8-m0-full.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable UART8-M0 with Hardware Follow Control";
+		compatible = "unknown";
+		category = "misc";
+		exclusive = "GPIO4_B3", "GPIO4_B2", "GPIO4_B0", "GPIO4_B1";
+		description = "Enable UART8-M0 with hardware follow control.\nOn Radxa ROCK 5A this is CTSN pin 11, RTSN pin 13, TX pin 32, and RX pin 40.";
+	};
+
+	fragment@0 {
+		target = <&uart8>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&uart8m0_xfer &uart8m0_ctsn &uart8m0_rtsn>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart8-m0.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart8-m0.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable UART8-M0";
+		compatible = "radxa,rock-5a";
+		category = "misc";
+		exclusive= "GPIO4_B0", "GPIO4_B1";
+		description = "Enable UART8-M0.\nOn Radxa ROCK 5A this is TX pin 32 and RX pin 40.";
+	};
+
+	fragment@0 {
+		target = <&uart8>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&uart8m0_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart8-m1.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-uart8-m1.dts
@@ -0,0 +1,13 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	fragment@0 {
+		target = <&uart8>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-0 = <&uart8m1_xfer>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-w1-gpio3-b3.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-w1-gpio3-b3.dts
@@ -0,0 +1,27 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+
+/ {
+	metadata {
+		title = "Enable 1-Wire on GPIO3_B3";
+		compatible = "radxa,rock-5b";
+		category = "misc";
+		exclusive = "GPIO3_B3";
+		description = "Enable 1-Wire on GPIO3_B3.\nOn Radxa ROCK 5B this is pin 40.";
+	};
+
+	fragment@0 {
+		target-path = "/";
+
+		__overlay__ {
+			w1: onewire@0 {
+				compatible = "w1-gpio";
+				gpios = <&gpio3 RK_PB3 GPIO_ACTIVE_HIGH>;
+				status = "okay";
+			};
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-w1-gpio4-b1.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rk3588-w1-gpio4-b1.dts
@@ -0,0 +1,27 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+
+/ {
+	metadata {
+		title = "Enable 1-Wire on GPIO4_B1";
+		compatible = "radxa,rock-5a";
+		category = "misc";
+		exclusive = "GPIO4_B1";
+		description = "Enable 1-Wire on GPIO4_B1.\nOn Radxa ROCK 5A this is pin 40.";
+	};
+
+	fragment@0 {
+		target-path = "/";
+
+		__overlay__ {
+			w1: onewire@0 {
+				compatible = "w1-gpio";
+				gpios = <&gpio4 RK_PB1 GPIO_ACTIVE_HIGH>;
+				status = "okay";
+			};
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5a-hdmi-8k.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5a-hdmi-8k.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+#include <dt-bindings/clock/rk3588-cru.h>
+
+/ {
+	metadata {
+		title ="Enable 8K output on ROCK 5A";
+		compatible = "radxa,rock-5b", "rockchip,rk3588";
+		category = "display";
+		description = "Enable 8K output on ROCK 5A";
+	};
+
+	fragment@0 {
+		target = <&vop>;
+
+		__overlay__ {
+			assigned-clocks = <&cru ACLK_VOP>;
+			assigned-clock-rates = <800000000>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5a-i2c5-rtc-hym8563.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5a-i2c5-rtc-hym8563.dts
@@ -0,0 +1,51 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+
+/ {
+	metadata {
+		title ="Enable RTC Hym8563 on I2C-5 bus on ROCK 5A";
+		compatible = "radxa,rock-5a", "rockchip,rk3588";
+		category = "misc";
+		description = "Enable RTC Hym8563 on I2C-5 bus on ROCK 5A";
+	};
+
+	fragment@0 {
+		target = <&i2c5>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c5m2_xfer>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			hym8563: hym8563@51 {
+				compatible = "haoyu,hym8563";
+				reg = <0x51>;
+				#clock-cells = <0>;
+				clock-frequency = <32768>;
+				clock-output-names = "hym8563";
+				pinctrl-names = "default";
+				pinctrl-0 = <&rtc_int>;
+
+				interrupt-parent = <&gpio0>;
+				interrupts = <RK_PB0 IRQ_TYPE_LEVEL_LOW>;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&pinctrl>;
+
+		__overlay__ {
+			hym8563 {
+				rtc_int: rtc-int {
+					rockchip,pins = <0 RK_PB0 RK_FUNC_GPIO &pcfg_pull_up>;
+				};
+			};
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5a-radxa-camera-4k.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5a-radxa-camera-4k.dts
@@ -0,0 +1,208 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/clock/rk3588-cru.h>
+#include <dt-bindings/power/rk3588-power.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+
+/ {
+	metadata {
+		title ="Enable Radxa Camera 4K";
+		compatible = "radxa,rock-5a";
+		category = "camera";
+		exclusive = "csi2_dphy0";
+		description = "Enable Radxa Camera 4K.";
+	};
+
+	fragment@0 {
+		target = <&i2c3>;
+
+		__overlay__ {
+			status = "okay";
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			imx415: imx415@1a {
+				status = "okay";
+				compatible = "sony,imx415";
+				reg = <0x1a>;
+				clocks = <&cru CLK_MIPI_CAMARAOUT_M2>;
+				clock-names = "xvclk";
+				pinctrl-names = "default";
+				pinctrl-0 = <&mipim0_camera2_clk>;
+				power-domains = <&power RK3588_PD_VI>;
+				pwdn-gpios = <&gpio1 RK_PD3 GPIO_ACTIVE_HIGH>;
+				reset-gpios = <&gpio1 RK_PD2 GPIO_ACTIVE_LOW>;
+				rockchip,camera-module-index = <0>;
+				rockchip,camera-module-facing = "back";
+				rockchip,camera-module-name = "RADXA-CAMERA-4K";
+				rockchip,camera-module-lens-name = "DEFAULT";
+				port {
+					imx415_out0: endpoint {
+						remote-endpoint = <&mipidphy0_in_ucam0>;
+						data-lanes = <1 2 3 4>;
+					};
+				};
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&csi2_dphy0_hw>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&csi2_dphy0>;
+
+		__overlay__ {
+			status = "okay";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					mipidphy0_in_ucam0: endpoint@1 {
+						reg = <1>;
+						remote-endpoint = <&imx415_out0>;
+						data-lanes = <1 2 3 4>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					csidphy0_out: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&mipi2_csi2_input>;
+					};
+				};
+			};
+		};
+	};
+
+	fragment@3 {
+		target = <&mipi2_csi2>;
+
+		__overlay__ {
+			status = "okay";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					mipi2_csi2_input: endpoint@1 {
+						reg = <1>;
+						remote-endpoint = <&csidphy0_out>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					mipi2_csi2_output: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&cif_mipi2_in0>;
+					};
+				};
+			};
+		};
+	};
+
+	fragment@4 {
+		target = <&rkcif>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@5 {
+		target = <&rkcif_mipi_lvds2>;
+
+		__overlay__ {
+			status = "okay";
+
+			port {
+				cif_mipi2_in0: endpoint {
+					remote-endpoint = <&mipi2_csi2_output>;
+				};
+			};
+		};
+	};
+
+	fragment@6 {
+		target = <&rkcif_mipi_lvds2_sditf>;
+
+		__overlay__ {
+			status = "okay";
+
+			port {
+				mipi_lvds2_sditf: endpoint {
+					remote-endpoint = <&isp0_vir0>;
+				};
+			};
+		};
+	};
+
+	fragment@7 {
+		target = <&rkcif_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@8 {
+		target = <&isp0_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@9 {
+		target = <&rkisp0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@10 {
+		target = <&rkisp0_vir0>;
+
+		__overlay__ {
+			status = "okay";
+
+			port {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				isp0_vir0: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&mipi_lvds2_sditf>;
+				};
+			};
+		};
+	};
+};
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5a-radxa-display-10fhd.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5a-radxa-display-10fhd.dts
@@ -0,0 +1,85 @@
+// ROCK 5A Radxa Display 10FHD
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable Radxa Display 10FHD";
+		compatible = "unknown";
+		category = "display";
+		exclusive = "dsi0";
+		description = "Enable Radxa Display 10FHD.";
+	};
+
+	fragment@0 {
+		target = <&vcc_lcd_mipi0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target = <&dsi0_backlight>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&pwm10>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@3 {
+		target = <&dsi0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&dsi0_panel>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@5 {
+		target = <&mipi_dcphy0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@6 {
+		target = <&route_dsi0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@7 {
+		target = <&dsi0_in_vp2>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@8 {
+		target = <&dsi0_in_vp3>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5a-radxa-display-10hd.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5a-radxa-display-10hd.dts
@@ -0,0 +1,228 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+
+/ {
+	metadata {
+		title ="Enable Radxa Display 10HD";
+		compatible = "radxa,rock-5a";
+		category = "display";
+		exclusive = "dsi0";
+		description = "Enable Radxa Display 10HD.";
+	};
+
+	fragment@0 {
+		target-path = "/";
+
+		__overlay__ {
+			vcc_tp: vcc-tp {
+				status = "okay";
+				compatible = "regulator-fixed";
+				regulator-name = "vcc_tp";
+				gpio = <&gpio0 RK_PD5 GPIO_ACTIVE_LOW>;
+				enable-active-low;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vcc_lcd_mipi0: vcc-lcd-mipi0 {
+				status = "okay";
+				compatible = "regulator-fixed";
+				regulator-name = "vcc_lcd_mipi0";
+				gpio = <&gpio4 RK_PA4 GPIO_ACTIVE_HIGH>;
+				enable-active-high;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			dsi0_backlight: dsi0-backlight {
+				status = "okay";
+				compatible = "pwm-backlight";
+				pwms = <&pwm10 0 25000 0>;
+				brightness-levels = <
+					255 254 253 252 251 250 249 248
+					247 246 245 244 243 242 241 240
+					239 238 237 236 235 234 233 232
+					231 230 229 228 227 226 225 224
+					223 222 221 220 219 218 217 216
+					215 214 213 212 211 210 209 208
+					207 206 205 204 203 202 201 200
+					199 198 197 196 195 194 193 192
+					191 190 189 188 187 186 185 184
+					183 182 181 180 179 178 177 176
+					175 174 173 172 171 170 169 168
+					167 166 165 164 163 162 161 160
+					159 158 157 156 155 154 153 152
+					151 150 149 148 147 146 145 144
+					143 142 141 140 139 138 137 136
+					135 134 133 132 131 130 129 128
+					127 126 125 124 123 122 121 120
+					119 118 117 116 115 114 113 112
+					111 110 109 108 107 106 105 104
+					103 102 101 100  99  98  97  96
+					 95  94  93  92  91  90  89  88
+					 87  86  85  84  83  82  81  80
+					 79  78  77  76  75  74  73  72
+					 71  70  69  68  67  66  65  64
+					 63  62  61  60  59  58  57  56
+					 55  54  53  52  51  50  49  48
+					 47  46  45  44  43  42  41  40
+					 39  38  38  37  37  36  36  35
+					 35  34  34  33  33  32  32  31
+					 31  30  30  29  29  28  28  27
+					 27  26  26  25  25  24  24  23
+					 23  22  22  21  21  20  20   0
+				>;
+				default-brightness-level = <200>;
+				enable-gpios = <&gpio3 RK_PD2 GPIO_ACTIVE_HIGH>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&dsi0_backlight_en>;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&pwm10>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "active";
+			pinctrl-0 = <&pwm10m2_pins>;
+		};
+	};
+
+	fragment@2 {
+		target = <&dsi0>;
+
+		__overlay__ {
+			status = "okay";
+			rockchip,lane-rate = <480>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			dsi0_panel: panel@0 {
+				status = "okay";
+				compatible = "radxa,display-10hd-ad001";
+				reg = <0>;
+				backlight = <&dsi0_backlight>;
+
+				vdd-supply = <&vcc_lcd_mipi0>;
+				vccio-supply = <&vcc_1v8_s0>;
+				reset-gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_HIGH>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&dsi0_lcd_rst_gpio>;
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					port@0 {
+						reg = <0>;
+						panel_in_dsi0: endpoint {
+							remote-endpoint = <&dsi0_out_panel>;
+						};
+					};
+				};
+			};
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@1 {
+					reg = <1>;
+					dsi0_out_panel: endpoint {
+						remote-endpoint = <&panel_in_dsi0>;
+					};
+				};
+			};
+		};
+	};
+
+	fragment@3 {
+		target = <&mipi_dcphy0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&route_dsi0>;
+
+		__overlay__ {
+			status = "okay";
+			connect = <&vp3_out_dsi0>;
+		};
+	};
+
+	fragment@5 {
+		target = <&dsi0_in_vp2>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@6 {
+		target = <&dsi0_in_vp3>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@7 {
+		target = <&i2c5>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c5m2_xfer>;
+			clock-frequency = <400000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			focaltech: focaltech@38 {
+				status = "okay";
+				compatible = "focaltech,fts";
+				reg = <0x38>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&focaltech_gpio>;
+				focaltech,irq-gpio = <&gpio3 RK_PC6 IRQ_TYPE_LEVEL_LOW>;
+				focaltech,reset-gpio = <&gpio3 RK_PC5 GPIO_ACTIVE_HIGH>;
+				focaltech,display-coords = <0 0 799 1279>;
+			};
+		};
+	};
+
+	fragment@8 {
+		target = <&pinctrl>;
+
+		__overlay__ {
+			dsi0-lcd {
+				dsi0_lcd_rst_gpio: dsi0-lcd-rst-gpio {
+					rockchip,pins = <3 RK_PC1 RK_FUNC_GPIO &pcfg_pull_up>;
+				};
+
+				dsi0_backlight_en: dsi0-backlight-en {
+					rockchip,pins = <3 RK_PD2 RK_FUNC_GPIO &pcfg_pull_up>;
+				};
+			};
+
+			focaltech {
+				focaltech_gpio: focaltech-gpio {
+					rockchip,pins =
+						<3 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>,
+						<3 RK_PC6 RK_FUNC_GPIO &pcfg_pull_up>;
+				};
+			};
+		};
+	};
+};
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5a-radxa-display-8hd.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5a-radxa-display-8hd.dts
@@ -0,0 +1,231 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+
+/ {
+	metadata {
+		title ="Enable Radxa Display 8HD";
+		compatible = "radxa,rock-5a";
+		category = "display";
+		exclusive = "dsi0";
+		description = "Enable Radxa Display 8HD.";
+	};
+
+	fragment@0 {
+		target-path = "/";
+
+		__overlay__ {
+			vcc_tp: vcc-tp {
+				status = "okay";
+				compatible = "regulator-fixed";
+				regulator-name = "vcc_tp";
+				gpio = <&gpio0 RK_PD5 GPIO_ACTIVE_LOW>;
+				enable-active-low;
+				regulator-boot-on;
+				regulator-always-on;
+			};
+
+			vcc_lcd_mipi0: vcc-lcd-mipi0 {
+				status = "okay";
+				compatible = "regulator-fixed";
+				regulator-name = "vcc_lcd_mipi0";
+				gpio = <&gpio4 RK_PA4 GPIO_ACTIVE_HIGH>;
+				enable-active-high;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			dsi0_backlight: dsi0-backlight {
+				status = "okay";
+				compatible = "pwm-backlight";
+				pwms = <&pwm10 0 25000 0>;
+				brightness-levels = <
+					255 254 253 252 251 250 249 248
+					247 246 245 244 243 242 241 240
+					239 238 237 236 235 234 233 232
+					231 230 229 228 227 226 225 224
+					223 222 221 220 219 218 217 216
+					215 214 213 212 211 210 209 208
+					207 206 205 204 203 202 201 200
+					199 198 197 196 195 194 193 192
+					191 190 189 188 187 186 185 184
+					183 182 181 180 179 178 177 176
+					175 174 173 172 171 170 169 168
+					167 166 165 164 163 162 161 160
+					159 158 157 156 155 154 153 152
+					151 150 149 148 147 146 145 144
+					143 142 141 140 139 138 137 136
+					135 134 133 132 131 130 129 128
+					127 126 125 124 123 122 121 120
+					119 118 117 116 115 114 113 112
+					111 110 109 108 107 106 105 104
+					103 102 101 100  99  98  97  96
+					 95  94  93  92  91  90  89  88
+					 87  86  85  84  83  82  81  80
+					 79  78  77  76  75  74  73  72
+					 71  70  69  68  67  66  65  64
+					 63  62  61  60  59  58  57  56
+					 55  54  53  52  51  50  49  48
+					 47  46  45  44  43  42  41  40
+					 39  38  38  37  37  36  36  35
+					 35  34  34  33  33  32  32  31
+					 31  30  30  29  29  28  28  27
+					 27  26  26  25  25  24  24  23
+					 23  22  22  21  21  20  20   0
+				>;
+				default-brightness-level = <200>;
+				enable-gpios = <&gpio3 RK_PD2 GPIO_ACTIVE_HIGH>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&dsi0_backlight_en>;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&pwm10>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "active";
+			pinctrl-0 = <&pwm10m2_pins>;
+		};
+	};
+
+	fragment@2 {
+		target = <&dsi0>;
+
+		__overlay__ {
+			status = "okay";
+			rockchip,lane-rate = <480>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			dsi0_panel: panel@0 {
+				status = "okay";
+				compatible ="radxa,display-8hd";
+				reg = <0>;
+				backlight = <&dsi0_backlight>;
+
+				vdd-supply = <&vcc_lcd_mipi0>;
+				vccio-supply = <&vcc_1v8_s0>;
+				reset-gpios = <&gpio3 RK_PC1 GPIO_ACTIVE_HIGH>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&dsi0_lcd_rst_gpio>;
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					port@0 {
+						reg = <0>;
+						panel_in_dsi0: endpoint {
+							remote-endpoint = <&dsi0_out_panel>;
+						};
+					};
+				};
+			};
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@1 {
+					reg = <1>;
+					dsi0_out_panel: endpoint {
+						remote-endpoint = <&panel_in_dsi0>;
+					};
+				};
+			};
+		};
+	};
+
+	fragment@3 {
+		target = <&mipi_dcphy0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&route_dsi0>;
+
+		__overlay__ {
+			status = "okay";
+			connect = <&vp3_out_dsi0>;
+		};
+	};
+
+	fragment@5 {
+		target = <&dsi0_in_vp2>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@6 {
+		target = <&dsi0_in_vp3>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@7 {
+		target = <&i2c5>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c5m2_xfer>;
+			clock-frequency = <400000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			gt9xx: gt9xx@14 {
+				status = "okay";
+				compatible = "goodix,gt9xx";
+				reg = <0x14>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&gt9xx_gpio>;
+				touch-gpio = <&gpio3 RK_PC6 IRQ_TYPE_LEVEL_HIGH>;
+				reset-gpio = <&gpio3 RK_PC5 GPIO_ACTIVE_HIGH>;
+				max-x = <800>;
+				max-y = <1280>;
+				tp-size = <9112>;
+				tp-supply = <&vcc_tp>;
+			};
+		};
+	};
+
+	fragment@8 {
+		target = <&pinctrl>;
+
+		__overlay__ {
+			dsi0-lcd {
+				dsi0_lcd_rst_gpio: dsi0-lcd-rst-gpio {
+					rockchip,pins = <3 RK_PC1 RK_FUNC_GPIO &pcfg_pull_up>;
+				};
+
+				dsi0_backlight_en: dsi0-backlight-en {
+					rockchip,pins = <3 RK_PD2 RK_FUNC_GPIO &pcfg_pull_up>;
+				};
+			};
+
+			gt9xx {
+				gt9xx_gpio: gt9xx-gpio {
+					rockchip,pins =
+						<3 RK_PC5 RK_FUNC_GPIO &pcfg_pull_none>,
+						<3 RK_PC6 RK_FUNC_GPIO &pcfg_pull_up>;
+				};
+			};
+		};
+	};
+};
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5a-rpi-camera-v2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5a-rpi-camera-v2.dts
@@ -0,0 +1,237 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+
+/ {
+	metadata {
+		title ="Enable Raspberry Pi Camera V2";
+		compatible = "radxa,rock-5a";
+		category = "camera";
+		exclusive = "csi2_dphy0";
+		description = "Enable Raspberry Pi Camera V2.";
+	};
+
+
+	fragment@0 {
+		target-path = "/";
+
+		__overlay__ {
+			camera_pwdn_gpio: camera-pwdn-gpio {
+				compatible = "regulator-fixed";
+				regulator-name = "camera_pwdn_gpio";
+				regulator-always-on;
+				regulator-boot-on;
+				enable-active-high;
+				gpio = <&gpio1 RK_PD3 GPIO_ACTIVE_HIGH>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&cam_pwdn_gpio>;
+			};
+
+			clk_cam_24m: external-camera-clock-24m {
+				compatible = "fixed-clock";
+				clock-frequency = <24000000>;
+				clock-output-names = "clk_cam_24m";
+				#clock-cells = <0>;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&i2c3>;
+
+		__overlay__ {
+			status = "okay";
+
+			camera_imx219: camera-imx219@10 {
+				compatible = "sony,imx219";
+				reg = <0x10>;
+
+				clocks = <&clk_cam_24m>;
+				clock-names = "xvclk";
+
+				rockchip,camera-module-index = <0>;
+				rockchip,camera-module-facing = "back";
+				rockchip,camera-module-name = "rpi-camera-v2";
+				rockchip,camera-module-lens-name = "default";
+
+				port {
+					imx219_out0: endpoint {
+						remote-endpoint = <&mipidphy0_in_ucam1>;
+						data-lanes = <1 2>;
+					};
+				};
+			};
+		};
+	};
+
+	fragment@2 {
+		target = <&csi2_dphy0_hw>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@3 {
+		target = <&csi2_dphy0>;
+
+		__overlay__ {
+			status = "okay";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					mipidphy0_in_ucam1: endpoint@2 {
+						reg = <2>;
+						remote-endpoint = <&imx219_out0>;
+						data-lanes = <1 2>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					csidphy0_out: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&mipi2_csi2_input>;
+					};
+				};
+			};
+		};
+	};
+
+	fragment@4 {
+		target = <&mipi2_csi2>;
+
+		__overlay__ {
+			status = "okay";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					mipi2_csi2_input: endpoint@1 {
+						reg = <1>;
+						remote-endpoint = <&csidphy0_out>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					mipi2_csi2_output: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&cif_mipi2_in0>;
+					};
+				};
+			};
+		};
+	};
+
+	fragment@5 {
+		target = <&rkcif>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@6 {
+		target = <&rkcif_mipi_lvds2>;
+
+		__overlay__ {
+			status = "okay";
+
+			port {
+				cif_mipi2_in0: endpoint {
+				remote-endpoint = <&mipi2_csi2_output>;
+				};
+			};
+		};
+	};
+
+	fragment@7 {
+		target = <&rkcif_mipi_lvds2_sditf>;
+
+		__overlay__ {
+			status = "okay";
+
+			port {
+				mipi_lvds2_sditf: endpoint {
+					remote-endpoint = <&isp0_vir0>;
+				};
+			};
+		};
+	};
+
+	fragment@8 {
+		target = <&rkcif_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@9 {
+		target = <&isp0_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@10 {
+		target = <&rkisp0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@11 {
+		target = <&rkisp0_vir0>;
+
+		__overlay__ {
+			status = "okay";
+
+			port {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				isp0_vir0: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&mipi_lvds2_sditf>;
+				};
+			};
+		};
+	};
+
+	fragment@12 {
+		target = <&pinctrl>;
+
+		__overlay__ {
+			camera {
+				cam_pwdn_gpio: cam-pwdn-gpio {
+					rockchip,pins = <1 RK_PD3 RK_FUNC_GPIO &pcfg_pull_up>;
+				};
+			};
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5a-sata.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5a-sata.dts
@@ -0,0 +1,29 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+
+	metadata {
+		title = "Enable SATA0";
+		compatible = "radxa,rock-5a";
+		category = "misc";
+		exclusive = "combphy0_ps";
+		description = "Enable SATA0.\nWhen SATA0 is enabled, PCIe cannot be enabled on the same port.";
+	};
+
+	fragment@0 {
+		target = <&pcie2x1l2>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@1 {
+		target = <&sata0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5a-spi-nor-flash.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5a-spi-nor-flash.dts
@@ -0,0 +1,54 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title ="Enable SPI Nor Flash on ROCK 5A";
+		compatible = "radxa,rock-5a", "rockchip,rk3588";
+		category = "misc";
+		description = "Enable SPI Nor Flash on ROCK 5A";
+	};
+
+	fragment@0 {
+		target = <&sfc>;
+
+		__overlay__ {
+			status = "okay";
+			max-freq = <50000000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&fspim0_pins>;
+
+			spi_flash: spi-flash@0 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "jedec,spi-nor";
+				reg = <0x0>;
+				spi-max-frequency = <50000000>;
+				spi-tx-bus-width = <1>;
+				spi-rx-bus-width = <4>;
+				status = "okay";
+
+				partitions {
+					compatible = "fixed-partitions";
+					#address-cells = <1>;
+					#size-cells = <1>;
+
+					loader@0 {
+						label = "loader";
+						reg = <0x0 0x1000000>;
+					};
+				};
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&sdhci>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5a-usb-otg.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5a-usb-otg.dts
@@ -0,0 +1,21 @@
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title ="Set Type-A OTG port in OTG mode for ROCK 5A";
+		compatible = "radxa,rock-5a", "rockchip,rk3588";
+		category = "misc";
+		description = "Set Type-A OTG port in OTG mode for ROCK 5A";
+	};
+
+	fragment@0 {
+		target = <&usbdrd_dwc3_0>;
+
+		__overlay__ {
+			dr_mode = "otg";
+			extcon = <&u2phy0>;
+			status = "okay";
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5b-hdmi1-8k.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5b-hdmi1-8k.dts
@@ -0,0 +1,63 @@
+/dts-v1/;
+/plugin/;
+#include <dt-bindings/clock/rk3588-cru.h>
+
+/ {
+	metadata {
+		title = "Enable 8K output on HDMI1";
+		compatible = "radxa,rock-5b";
+		category = "display";
+		description = "Enable 8K output on HDMI1.\n8K cannot be enabled on HDMI1 and HDMI2 at the same time.";
+	};
+
+	fragment@0 {
+		target = <&route_hdmi1>;
+
+		__overlay__ {
+			connect = <&vp2_out_hdmi1>;
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target = <&hdmi1_in_vp1>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@2 {
+		target = <&hdmi1_in_vp2>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@3 {
+		target = <&route_hdmi0>;
+
+		__overlay__ {
+			connect = <&vp0_out_hdmi0>;
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&hdmi0_in_vp0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@5 {
+		target = <&vop>;
+
+		__overlay__ {
+			assigned-clocks = <&cru ACLK_VOP>;
+			assigned-clock-rates = <800000000>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5b-hdmi2-8k.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5b-hdmi2-8k.dts
@@ -0,0 +1,79 @@
+/dts-v1/;
+/plugin/;
+#include <dt-bindings/clock/rk3588-cru.h>
+
+/ {
+	metadata {
+		title = "Enable 8K output on HDMI2";
+		compatible = "radxa,rock-5b";
+		category = "display";
+		description = "Enable 8K output on HDMI2.\n8K cannot be enabled on HDMI1 and HDMI2 at the same time.";
+	};
+
+	fragment@0 {
+		target = <&route_hdmi1>;
+
+		__overlay__ {
+			connect = <&vp0_out_hdmi1>;
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target = <&hdmi1_in_vp1>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@2 {
+		target = <&hdmi1_in_vp0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@3 {
+		target = <&route_hdmi0>;
+
+		__overlay__ {
+			connect = <&vp2_out_hdmi0>;
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&hdmi0_in_vp2>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@5 {
+		target = <&hdmi0_in_vp1>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@6 {
+		target = <&hdmi0_in_vp0>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@7 {
+		target = <&vop>;
+
+		__overlay__ {
+			assigned-clocks = <&cru ACLK_VOP>;
+			assigned-clock-rates = <800000000>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5b-pd-max-voltage-12v.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5b-pd-max-voltage-12v.dts
@@ -0,0 +1,24 @@
+/dts-v1/;
+/plugin/;
+
+#include "dt-bindings/usb/pd.h"
+
+/ {
+	metadata {
+		title ="Power Supply PD 12V on ROCK 5B";
+		compatible = "radxa,rock-5b", "rockchip,rk3588";
+		category = "misc";
+		description = "Power Supply PD 12V on ROCK 5B.";
+	};
+
+	fragment@0 {
+		target = <&usb_con>;
+
+		__overlay__ {
+			sink-pdos =
+				<PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)
+				PDO_FIXED(9000, 3000, PDO_FIXED_USB_COMM)
+				PDO_FIXED(12000, 1500, PDO_FIXED_USB_COMM)>;
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5b-radxa-camera-4k.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5b-radxa-camera-4k.dts
@@ -0,0 +1,208 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/clock/rk3588-cru.h>
+#include <dt-bindings/power/rk3588-power.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+
+/ {
+	metadata {
+		title ="Enable Radxa Camera 4K";
+		compatible = "radxa,rock-5b";
+		category = "camera";
+		exclusive = "csi2_dphy0";
+		description = "Enable Radxa Camera 4K.";
+	};
+
+	fragment@0 {
+		target = <&i2c3>;
+
+		__overlay__ {
+			status = "okay";
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			imx415: imx415@1a {
+				status = "okay";
+				compatible = "sony,imx415";
+				reg = <0x1a>;
+				clocks = <&cru CLK_MIPI_CAMARAOUT_M3>;
+				clock-names = "xvclk";
+				pinctrl-names = "default";
+				pinctrl-0 = <&mipim0_camera3_clk>;
+				power-domains = <&power RK3588_PD_VI>;
+				pwdn-gpios = <&gpio1 RK_PB0 GPIO_ACTIVE_HIGH>;
+				reset-gpios = <&gpio4 RK_PA0 GPIO_ACTIVE_LOW>;
+				rockchip,camera-module-index = <0>;
+				rockchip,camera-module-facing = "back";
+				rockchip,camera-module-name = "RADXA-CAMERA-4K";
+				rockchip,camera-module-lens-name = "DEFAULT";
+				port {
+					imx415_out0: endpoint {
+						remote-endpoint = <&mipidphy0_in_ucam0>;
+						data-lanes = <1 2 3 4>;
+					};
+				};
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&csi2_dphy0_hw>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&csi2_dphy0>;
+
+		__overlay__ {
+			status = "okay";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					mipidphy0_in_ucam0: endpoint@1 {
+						reg = <1>;
+						remote-endpoint = <&imx415_out0>;
+						data-lanes = <1 2 3 4>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					csidphy0_out: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&mipi2_csi2_input>;
+					};
+				};
+			};
+		};
+	};
+
+	fragment@3 {
+		target = <&mipi2_csi2>;
+
+		__overlay__ {
+			status = "okay";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					mipi2_csi2_input: endpoint@1 {
+						reg = <1>;
+						remote-endpoint = <&csidphy0_out>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					mipi2_csi2_output: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&cif_mipi2_in0>;
+					};
+				};
+			};
+		};
+	};
+
+	fragment@4 {
+		target = <&rkcif>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@5 {
+		target = <&rkcif_mipi_lvds2>;
+
+		__overlay__ {
+			status = "okay";
+
+			port {
+				cif_mipi2_in0: endpoint {
+					remote-endpoint = <&mipi2_csi2_output>;
+				};
+			};
+		};
+	};
+
+	fragment@6 {
+		target = <&rkcif_mipi_lvds2_sditf>;
+
+		__overlay__ {
+			status = "okay";
+
+			port {
+				mipi_lvds2_sditf: endpoint {
+					remote-endpoint = <&isp0_vir0>;
+				};
+			};
+		};
+	};
+
+	fragment@7 {
+		target = <&rkcif_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@8 {
+		target = <&isp0_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@9 {
+		target = <&rkisp0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@10 {
+		target = <&rkisp0_vir0>;
+
+		__overlay__ {
+			status = "okay";
+
+			port {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				isp0_vir0: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&mipi_lvds2_sditf>;
+				};
+			};
+		};
+	};
+};
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5b-radxa-display-10fhd.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5b-radxa-display-10fhd.dts
@@ -0,0 +1,85 @@
+// ROCK 5B Radxa Display 10FHD
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable Radxa Display 10FHD";
+		compatible = "unknown";
+		category = "display";
+		exclusive = "dsi1";
+		description = "Enable Radxa Display 10FHD.";
+	};
+
+	fragment@0 {
+		target = <&vcc_lcd_mipi1>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@1 {
+		target = <&dsi1_backlight>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@2 {
+		target = <&pwm2>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@3 {
+		target = <&dsi1>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&dsi1_panel>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@5 {
+		target = <&mipi_dcphy1>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@6 {
+		target = <&route_dsi1>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@7 {
+		target = <&dsi1_in_vp2>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@8 {
+		target = <&dsi1_in_vp3>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5b-radxa-display-10hd.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5b-radxa-display-10hd.dts
@@ -0,0 +1,221 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+
+/ {
+	metadata {
+		title ="Enable Radxa Display 10HD";
+		compatible = "radxa,rock-5b";
+		category = "display";
+		exclusive = "dsi1";
+		description = "Enable Radxa Display 10HD.";
+	};
+
+	fragment@0 {
+		target-path = "/";
+
+		__overlay__ {
+			vcc_lcd_mipi1: vcc-lcd-mipi1 {
+				status = "okay";
+				compatible = "regulator-fixed";
+				regulator-name = "vcc_lcd_mipi1";
+				gpio = <&gpio1 RK_PC4 GPIO_ACTIVE_HIGH>;
+				enable-active-high;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			dsi1_backlight: dsi1-backlight {
+				status = "okay";
+				compatible = "pwm-backlight";
+				pwms = <&pwm2 0 25000 0>;
+				brightness-levels = <
+					255 254 253 252 251 250 249 248
+					247 246 245 244 243 242 241 240
+					239 238 237 236 235 234 233 232
+					231 230 229 228 227 226 225 224
+					223 222 221 220 219 218 217 216
+					215 214 213 212 211 210 209 208
+					207 206 205 204 203 202 201 200
+					199 198 197 196 195 194 193 192
+					191 190 189 188 187 186 185 184
+					183 182 181 180 179 178 177 176
+					175 174 173 172 171 170 169 168
+					167 166 165 164 163 162 161 160
+					159 158 157 156 155 154 153 152
+					151 150 149 148 147 146 145 144
+					143 142 141 140 139 138 137 136
+					135 134 133 132 131 130 129 128
+					127 126 125 124 123 122 121 120
+					119 118 117 116 115 114 113 112
+					111 110 109 108 107 106 105 104
+					103 102 101 100  99  98  97  96
+					 95  94  93  92  91  90  89  88
+					 87  86  85  84  83  82  81  80
+					 79  78  77  76  75  74  73  72
+					 71  70  69  68  67  66  65  64
+					 63  62  61  60  59  58  57  56
+					 55  54  53  52  51  50  49  48
+					 47  46  45  44  43  42  41  40
+					 39  38  38  37  37  36  36  35
+					 35  34  34  33  33  32  32  31
+					 31  30  30  29  29  28  28  27
+					 27  26  26  25  25  24  24  23
+					 23  22  22  21  21  20  20   0
+				>;
+				default-brightness-level = <200>;
+				enable-gpios = <&gpio2 RK_PC2 GPIO_ACTIVE_HIGH>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&dsi1_backlight_en>;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&pwm2>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "active";
+			pinctrl-0 = <&pwm2m2_pins>;
+		};
+	};
+
+	fragment@2 {
+		target = <&dsi1>;
+
+		__overlay__ {
+			status = "okay";
+			rockchip,lane-rate = <480>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			dsi1_panel: panel@0 {
+				status = "okay";
+				compatible = "chongzhou,cz101b4001";
+				reg = <0>;
+				backlight = <&dsi1_backlight>;
+
+				vdd-supply = <&vcc_lcd_mipi1>;
+				vccio-supply = <&vcc_1v8_s0>;
+				reset-gpios = <&gpio2 RK_PC1 GPIO_ACTIVE_HIGH>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&dsi1_lcd_rst_gpio>;
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					port@0 {
+						reg = <0>;
+						panel_in_dsi1: endpoint {
+							remote-endpoint = <&dsi1_out_panel>;
+						};
+					};
+				};
+			};
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@1 {
+					reg = <1>;
+					dsi1_out_panel: endpoint {
+						remote-endpoint = <&panel_in_dsi1>;
+					};
+				};
+			};
+		};
+	};
+
+	fragment@3 {
+		target = <&mipi_dcphy1>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&i2c6>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c6m0_xfer>;
+			clock-frequency = <400000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			focaltech: focaltech@38 {
+				status = "okay";
+				compatible = "focaltech,fts";
+				reg = <0x38>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&focaltech_gpio>;
+				focaltech,irq-gpio = <&gpio0 RK_PD3 IRQ_TYPE_LEVEL_LOW>;
+				focaltech,reset-gpio = <&gpio0 RK_PC6 GPIO_ACTIVE_HIGH>;
+				focaltech,display-coords = <0 0 799 1279>;
+			};
+		};
+	};
+
+
+
+
+	fragment@5 {
+		target = <&route_dsi1>;
+
+		__overlay__ {
+			status = "okay";
+			connect = <&vp3_out_dsi1>;
+		};
+	};
+
+	fragment@6 {
+		target = <&dsi1_in_vp2>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@7 {
+		target = <&dsi1_in_vp3>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+
+	fragment@8 {
+		target = <&pinctrl>;
+
+		__overlay__ {
+			dsi1-lcd {
+				dsi1_lcd_rst_gpio: dsi1-lcd-rst-gpio {
+					rockchip,pins = <2 RK_PC1 RK_FUNC_GPIO &pcfg_pull_up>;
+				};
+
+				dsi1_backlight_en: dsi1-backlight-en {
+					rockchip,pins = <2 RK_PC2 RK_FUNC_GPIO &pcfg_pull_up>;
+				};
+			};
+
+			focaltech {
+				focaltech_gpio: focaltech-gpio {
+					rockchip,pins =
+						<0 RK_PC6 RK_FUNC_GPIO &pcfg_pull_none>,
+						<0 RK_PD3 RK_FUNC_GPIO &pcfg_pull_up>;
+				};
+			};
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5b-radxa-display-8hd.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5b-radxa-display-8hd.dts
@@ -0,0 +1,219 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/interrupt-controller/irq.h>
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+
+/ {
+	metadata {
+		title ="Enable Radxa Display 8HD";
+		compatible = "radxa,rock-5b";
+		category = "display";
+		exclusive = "dsi1";
+		description = "Enable Radxa Display 8HD.";
+	};
+
+	fragment@0 {
+		target-path = "/";
+
+		__overlay__ {
+			vcc_lcd_mipi1: vcc-lcd-mipi1 {
+				status = "okay";
+				compatible = "regulator-fixed";
+				regulator-name = "vcc_lcd_mipi1";
+				gpio = <&gpio1 RK_PC4 GPIO_ACTIVE_HIGH>;
+				enable-active-high;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			dsi1_backlight: dsi1-backlight {
+				status = "okay";
+				compatible = "pwm-backlight";
+				pwms = <&pwm2 0 25000 0>;
+				brightness-levels = <
+					255 254 253 252 251 250 249 248
+					247 246 245 244 243 242 241 240
+					239 238 237 236 235 234 233 232
+					231 230 229 228 227 226 225 224
+					223 222 221 220 219 218 217 216
+					215 214 213 212 211 210 209 208
+					207 206 205 204 203 202 201 200
+					199 198 197 196 195 194 193 192
+					191 190 189 188 187 186 185 184
+					183 182 181 180 179 178 177 176
+					175 174 173 172 171 170 169 168
+					167 166 165 164 163 162 161 160
+					159 158 157 156 155 154 153 152
+					151 150 149 148 147 146 145 144
+					143 142 141 140 139 138 137 136
+					135 134 133 132 131 130 129 128
+					127 126 125 124 123 122 121 120
+					119 118 117 116 115 114 113 112
+					111 110 109 108 107 106 105 104
+					103 102 101 100  99  98  97  96
+					 95  94  93  92  91  90  89  88
+					 87  86  85  84  83  82  81  80
+					 79  78  77  76  75  74  73  72
+					 71  70  69  68  67  66  65  64
+					 63  62  61  60  59  58  57  56
+					 55  54  53  52  51  50  49  48
+					 47  46  45  44  43  42  41  40
+					 39  38  38  37  37  36  36  35
+					 35  34  34  33  33  32  32  31
+					 31  30  30  29  29  28  28  27
+					 27  26  26  25  25  24  24  23
+					 23  22  22  21  21  20  20   0
+				>;
+				default-brightness-level = <200>;
+				enable-gpios = <&gpio2 RK_PC2 GPIO_ACTIVE_HIGH>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&dsi1_backlight_en>;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&pwm2>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "active";
+			pinctrl-0 = <&pwm2m2_pins>;
+		};
+	};
+
+	fragment@2 {
+		target = <&dsi1>;
+
+		__overlay__ {
+			status = "okay";
+			rockchip,lane-rate = <480>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			dsi1_panel: panel@0 {
+				status = "okay";
+				compatible = "radxa,display-8hd";
+				reg = <0>;
+				backlight = <&dsi1_backlight>;
+
+				vdd-supply = <&vcc_lcd_mipi1>;
+				vccio-supply = <&vcc_1v8_s0>;
+				reset-gpios = <&gpio2 RK_PC1 GPIO_ACTIVE_HIGH>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&dsi1_lcd_rst_gpio>;
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					port@0 {
+						reg = <0>;
+						panel_in_dsi1: endpoint {
+							remote-endpoint = <&dsi1_out_panel>;
+						};
+					};
+				};
+			};
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@1 {
+					reg = <1>;
+					dsi1_out_panel: endpoint {
+						remote-endpoint = <&panel_in_dsi1>;
+					};
+				};
+			};
+		};
+	};
+
+	fragment@3 {
+		target = <&mipi_dcphy1>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@4 {
+		target = <&route_dsi1>;
+
+		__overlay__ {
+			status = "okay";
+			connect = <&vp3_out_dsi1>;
+		};
+	};
+
+	fragment@5 {
+		target = <&dsi1_in_vp2>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@6 {
+		target = <&dsi1_in_vp3>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@7 {
+		target = <&i2c6>;
+
+		__overlay__ {
+			status = "okay";
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c6m0_xfer>;
+			clock-frequency = <400000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			gt9xx: gt9xx@14 {
+				compatible = "goodix,gt9xx";
+				reg = <0x14>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&gt9xx_gpio>;
+				touch-gpio = <&gpio0 RK_PD3 IRQ_TYPE_LEVEL_HIGH>;
+				reset-gpio = <&gpio0 RK_PC6 GPIO_ACTIVE_HIGH>;
+				max-x = <800>;
+				max-y = <1280>;
+				tp-size = <9112>;
+				tp-supply = <&vcc_lcd_mipi1>;
+			};
+		};
+	};
+
+	fragment@8 {
+		target = <&pinctrl>;
+
+		__overlay__ {
+			dsi1-lcd {
+				dsi1_lcd_rst_gpio: dsi1-lcd-rst-gpio {
+					rockchip,pins = <2 RK_PC1 RK_FUNC_GPIO &pcfg_pull_up>;
+				};
+
+				dsi1_backlight_en: dsi1-backlight-en {
+					rockchip,pins = <2 RK_PC2 RK_FUNC_GPIO &pcfg_pull_up>;
+				};
+			};
+
+			gt9xx {
+				gt9xx_gpio: gt9xx-gpio {
+					rockchip,pins =
+						<0 RK_PC6 RK_FUNC_GPIO &pcfg_pull_none>,
+						<0 RK_PD3 RK_FUNC_GPIO &pcfg_pull_up>;
+				};
+			};
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5b-rpi-camera-v2.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5b-rpi-camera-v2.dts
@@ -0,0 +1,237 @@
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pinctrl/rockchip.h>
+
+/ {
+	metadata {
+		title ="Enable Raspberry Pi Camera V2";
+		compatible = "radxa,rock-5b";
+		category = "camera";
+		exclusive = "csi2_dphy0";
+		description = "Enable Raspberry Pi Camera V2.";
+	};
+
+
+	fragment@0 {
+		target-path = "/";
+
+		__overlay__ {
+			camera_pwdn_gpio: camera-pwdn-gpio {
+				compatible = "regulator-fixed";
+				regulator-name = "camera_pwdn_gpio";
+				regulator-always-on;
+				regulator-boot-on;
+				enable-active-high;
+				gpio = <&gpio1 RK_PB0 GPIO_ACTIVE_HIGH>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&cam_pwdn_gpio>;
+			};
+
+			clk_cam_24m: external-camera-clock-24m {
+				compatible = "fixed-clock";
+				clock-frequency = <24000000>;
+				clock-output-names = "clk_cam_24m";
+				#clock-cells = <0>;
+			};
+		};
+	};
+
+	fragment@1 {
+		target = <&i2c3>;
+
+		__overlay__ {
+			status = "okay";
+
+			camera_imx219: camera-imx219@10 {
+				compatible = "sony,imx219";
+				reg = <0x10>;
+
+				clocks = <&clk_cam_24m>;
+				clock-names = "xvclk";
+
+				rockchip,camera-module-index = <0>;
+				rockchip,camera-module-facing = "back";
+				rockchip,camera-module-name = "rpi-camera-v2";
+				rockchip,camera-module-lens-name = "default";
+
+				port {
+					imx219_out0: endpoint {
+						remote-endpoint = <&mipidphy0_in_ucam1>;
+						data-lanes = <1 2>;
+					};
+				};
+			};
+		};
+	};
+
+	fragment@2 {
+		target = <&csi2_dphy0_hw>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@3 {
+		target = <&csi2_dphy0>;
+
+		__overlay__ {
+			status = "okay";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					mipidphy0_in_ucam1: endpoint@2 {
+						reg = <2>;
+						remote-endpoint = <&imx219_out0>;
+						data-lanes = <1 2>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					csidphy0_out: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&mipi2_csi2_input>;
+					};
+				};
+			};
+		};
+	};
+
+	fragment@4 {
+		target = <&mipi2_csi2>;
+
+		__overlay__ {
+			status = "okay";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				port@0 {
+					reg = <0>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					mipi2_csi2_input: endpoint@1 {
+						reg = <1>;
+						remote-endpoint = <&csidphy0_out>;
+					};
+				};
+
+				port@1 {
+					reg = <1>;
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					mipi2_csi2_output: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&cif_mipi2_in0>;
+					};
+				};
+			};
+		};
+	};
+
+	fragment@5 {
+		target = <&rkcif>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@6 {
+		target = <&rkcif_mipi_lvds2>;
+
+		__overlay__ {
+			status = "okay";
+
+			port {
+				cif_mipi2_in0: endpoint {
+				remote-endpoint = <&mipi2_csi2_output>;
+				};
+			};
+		};
+	};
+
+	fragment@7 {
+		target = <&rkcif_mipi_lvds2_sditf>;
+
+		__overlay__ {
+			status = "okay";
+
+			port {
+				mipi_lvds2_sditf: endpoint {
+					remote-endpoint = <&isp0_vir0>;
+				};
+			};
+		};
+	};
+
+	fragment@8 {
+		target = <&rkcif_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@9 {
+		target = <&isp0_mmu>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@10 {
+		target = <&rkisp0>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+
+	fragment@11 {
+		target = <&rkisp0_vir0>;
+
+		__overlay__ {
+			status = "okay";
+
+			port {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				isp0_vir0: endpoint@0 {
+					reg = <0>;
+					remote-endpoint = <&mipi_lvds2_sditf>;
+				};
+			};
+		};
+	};
+
+	fragment@12 {
+		target = <&pinctrl>;
+
+		__overlay__ {
+			camera {
+				cam_pwdn_gpio: cam-pwdn-gpio {
+					rockchip,pins = <1 RK_PB0 RK_FUNC_GPIO &pcfg_pull_up>;
+				};
+			};
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5b-sata.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rock-5b-sata.dts
@@ -0,0 +1,44 @@
+// ROCK 5B Pcie M.2 to sata
+/dts-v1/;
+/plugin/;
+
+/ {
+	metadata {
+		title = "Enable SATA1";
+		compatible = "radxa,rock-5b";
+		category = "misc";
+		description = "Enable SATA1.\nWhen SATA1 is enabled, PCIe cannot be enabled on the same port.";
+	};
+
+	fragment@0 {
+		target = <&wifi_disable>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@1 {
+		target = <&bt_wake>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@2 {
+		target = <&pcie2x1l0>;
+
+		__overlay__ {
+			status = "disabled";
+		};
+	};
+
+	fragment@3 {
+		target = <&sata1>;
+
+		__overlay__ {
+			status = "okay";
+		};
+	};
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rockchip-rk3588-opp-oc-24ghz.dts
===================================================================
--- /dev/null
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/overlay/rockchip-rk3588-opp-oc-24ghz.dts
@@ -0,0 +1,355 @@
+// RK3588 CPU Overclock to 2.4 GHz
+
+/dts-v1/;
+/plugin/;
+
+/ {
+    metadata {
+		title ="Overclock Big Cores to 2.4 GHz on RK3588/RK3588S boards";
+		compatible = "rockchip,rk3588";
+		category = "misc";
+		description = "Overclock Big Cores to 2.4 GHz on RK3588/RK3588S boards";
+	};
+
+    fragment@0 {
+        target = <&cluster1_opp_table>;
+        __overlay__ {
+		    opp-408000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <408000000>;
+			    opp-microvolt = <675000 675000 1050000>,
+			    		<675000 675000 1050000>;
+			    clock-latency-ns = <40000>;
+			    opp-suspend;
+		    };
+		    opp-600000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <600000000>;
+			    opp-microvolt = <675000 675000 1050000>,
+			    		<675000 675000 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-816000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <816000000>;
+			    opp-microvolt = <675000 675000 1050000>,
+			    		<675000 675000 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-1008000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <1008000000>;
+			    opp-microvolt = <675000 675000 1050000>,
+			    		<675000 675000 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-1200000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <1200000000>;
+			    opp-microvolt = <675000 675000 1050000>,
+			    		    <675000 675000 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-1416000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <1416000000>;
+			    opp-microvolt = <725000 725000 1050000>,
+			    		    <725000 725000 1050000>;
+			    opp-microvolt-L2 = <712500 712500 1050000>,
+			    		   <712500 712500 1050000>;
+			    opp-microvolt-L3 = <700000 700000 1050000>,
+			    		   <700000 700000 1050000>;
+			    opp-microvolt-L4 = <700000 700000 1050000>,
+			    		   <700000 700000 1050000>;
+			    opp-microvolt-L5 = <687500 687500 1050000>,
+			    		   <687500 687500 1050000>;
+			    opp-microvolt-L6 = <675000 675000 1050000>,
+			    		   <675000 675000 1050000>;
+			    opp-microvolt-L7 = <675000 675000 1050000>,
+			    		   <675000 675000 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-1608000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <1608000000>;
+			    opp-microvolt = <762500 762500 1050000>,
+			    		    <762500 762500 1050000>;
+			    opp-microvolt-L2 = <750000 750000 1050000>,
+					        <750000 750000 1050000>;
+			    opp-microvolt-L3 = <737500 737500 1050000>,
+					        <737500 737500 1050000>;
+			    opp-microvolt-L4 = <725000 725000 1050000>,
+					        <725000 725000 1050000>;
+			    opp-microvolt-L5 = <712500 712500 1050000>,
+					        <712500 712500 1050000>;
+			    opp-microvolt-L6 = <700000 700000 1050000>,
+					        <700000 700000 1050000>;
+			    opp-microvolt-L7 = <700000 700000 1050000>,
+					        <700000 700000 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-1800000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <1800000000>;
+			    opp-microvolt = <850000 850000 1050000>,
+					        <850000 850000 1050000>;
+			    opp-microvolt-L1 = <837500 837500 1050000>,
+					        <837500 837500 1050000>;
+			    opp-microvolt-L2 = <825000 825000 1050000>,
+					        <825000 825000 1050000>;
+			    opp-microvolt-L3 = <812500 812500 1050000>,
+					        <812500 812500 1050000>;
+			    opp-microvolt-L4 = <800000 800000 1050000>,
+					        <800000 800000 1050000>;
+			    opp-microvolt-L5 = <787500 787500 1050000>,
+					        <787500 787500 1050000>;
+			    opp-microvolt-L6 = <775000 775000 1050000>,
+					        <775000 775000 1050000>;
+			    opp-microvolt-L7 = <762500 762500 1050000>,
+					        <762500 762500 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-2016000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <2016000000>;
+			    opp-microvolt = <925000 925000 1050000>,
+					        <925000 925000 1050000>;
+			    opp-microvolt-L1 = <912500 912500 1050000>,
+					        <912500 912500 1050000>;
+			    opp-microvolt-L2 = <900000 900000 1050000>,
+					        <900000 900000 1050000>;
+			    opp-microvolt-L3 = <887500 887500 1050000>,
+					        <887500 887500 1050000>;
+			    opp-microvolt-L4 = <875000 875000 1050000>,
+					        <875000 875000 1050000>;
+			    opp-microvolt-L5 = <862500 862500 1050000>,
+					        <862500 862500 1050000>;
+			    opp-microvolt-L6 = <850000 850000 1050000>,
+					        <850000 850000 1050000>;
+			    opp-microvolt-L7 = <837500 837500 1050000>,
+					        <837500 837500 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-2208000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <2208000000>;
+			    opp-microvolt = <987500 987500 1050000>,
+					        <987500 987500 1050000>;
+			    opp-microvolt-L1 = <975000 975000 1050000>,
+					        <975000 975000 1050000>;
+			    opp-microvolt-L2 = <962500 962500 1050000>,
+					        <962500 962500 1050000>;
+			    opp-microvolt-L3 = <950000 950000 1050000>,
+					        <950000 950000 1050000>;
+			    opp-microvolt-L4 = <962500 962500 1050000>,
+					        <962500 962500 1050000>;
+			    opp-microvolt-L5 = <950000 950000 1050000>,
+					        <950000 950000 1050000>;
+			    opp-microvolt-L6 = <925000 925000 1050000>,
+					        <925000 925000 1050000>;
+			    opp-microvolt-L7 = <912500 912500 1050000>,
+					        <912500 912500 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-2256000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <2256000000>;
+			    opp-microvolt = <1000000 1000000 1050000>,
+					        <1000000 1000000 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-2304000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <2304000000>;
+			    opp-microvolt = <1030000 1000000 1050000>,
+			    		    <1030000 1000000 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-2352000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <2352000000>;
+			    opp-microvolt = <1040000 1010000 1050000>,
+					        <1040000 1010000 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-2400000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <2400000000>;
+			    opp-microvolt = <1050000 1020000 1050000>,
+					        <1050000 1020000 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+        };
+    };
+
+    fragment@1 {
+        target = <&cluster2_opp_table>;
+        __overlay__ {
+		    opp-408000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <408000000>;
+			    opp-microvolt = <675000 675000 1050000>,
+					        <675000 675000 1050000>;
+			    clock-latency-ns = <40000>;
+			    opp-suspend;
+		    };
+		    opp-600000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <600000000>;
+			    opp-microvolt = <675000 675000 1050000>,
+					        <675000 675000 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-816000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <816000000>;
+			    opp-microvolt = <675000 675000 1050000>,
+					        <675000 675000 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-1008000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <1008000000>;
+			    opp-microvolt = <675000 675000 1050000>,
+					        <675000 675000 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-1200000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <1200000000>;
+			    opp-microvolt = <675000 675000 1050000>,
+					        <675000 675000 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-1416000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <1416000000>;
+			    opp-microvolt = <725000 725000 1050000>,
+					        <725000 725000 1050000>;
+			    opp-microvolt-L2 = <712500 712500 1050000>,
+					        <712500 712500 1050000>;
+			    opp-microvolt-L3 = <700000 700000 1050000>,
+					        <700000 700000 1050000>;
+			    opp-microvolt-L4 = <700000 700000 1050000>,
+					        <700000 700000 1050000>;
+			    opp-microvolt-L5 = <687500 687500 1050000>,
+					        <687500 687500 1050000>;
+			    opp-microvolt-L6 = <675000 675000 1050000>,
+					        <675000 675000 1050000>;
+			    opp-microvolt-L7 = <675000 675000 1050000>,
+					        <675000 675000 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-1608000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <1608000000>;
+			    opp-microvolt = <762500 762500 1050000>,
+					        <762500 762500 1050000>;
+			    opp-microvolt-L2 = <750000 750000 1050000>,
+					        <750000 750000 1050000>;
+			    opp-microvolt-L3 = <737500 737500 1050000>,
+					        <737500 737500 1050000>;
+			    opp-microvolt-L4 = <725000 725000 1050000>,
+					        <725000 725000 1050000>;
+			    opp-microvolt-L5 = <712500 712500 1050000>,
+					        <712500 712500 1050000>;
+			    opp-microvolt-L6 = <700000 700000 1050000>,
+					        <700000 700000 1050000>;
+			    opp-microvolt-L7 = <700000 700000 1050000>,
+					        <700000 700000 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-1800000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <1800000000>;
+			    opp-microvolt = <850000 850000 1050000>,
+					        <850000 850000 1050000>;
+			    opp-microvolt-L1 = <837500 837500 1050000>,
+					        <837500 837500 1050000>;
+			    opp-microvolt-L2 = <825000 825000 1050000>,
+					        <825000 825000 1050000>;
+			    opp-microvolt-L3 = <812500 812500 1050000>,
+					        <812500 812500 1050000>;
+			    opp-microvolt-L4 = <800000 800000 1050000>,
+					        <800000 800000 1050000>;
+			    opp-microvolt-L5 = <787500 787500 1050000>,
+					        <787500 787500 1050000>;
+			    opp-microvolt-L6 = <775000 775000 1050000>,
+					        <775000 775000 1050000>;
+			    opp-microvolt-L7 = <762500 762500 1050000>,
+					        <762500 762500 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-2016000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <2016000000>;
+			    opp-microvolt = <925000 925000 1050000>,
+					        <925000 925000 1050000>;
+			    opp-microvolt-L1 = <912500 912500 1050000>,
+					        <912500 912500 1050000>;
+			    opp-microvolt-L2 = <900000 900000 1050000>,
+					        <900000 900000 1050000>;
+			    opp-microvolt-L3 = <887500 887500 1050000>,
+					        <887500 887500 1050000>;
+			    opp-microvolt-L4 = <875000 875000 1050000>,
+					        <875000 875000 1050000>;
+			    opp-microvolt-L5 = <862500 862500 1050000>,
+					        <862500 862500 1050000>;
+			    opp-microvolt-L6 = <850000 850000 1050000>,
+					        <850000 850000 1050000>;
+			    opp-microvolt-L7 = <837500 837500 1050000>,
+					        <837500 837500 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-2208000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <2208000000>;
+			    opp-microvolt = <987500 987500 1050000>,
+					        <987500 987500 1050000>;
+			    opp-microvolt-L1 = <975000 975000 1050000>,
+					        <975000 975000 1050000>;
+			    opp-microvolt-L2 = <962500 962500 1050000>,
+					        <962500 962500 1050000>;
+			    opp-microvolt-L3 = <950000 950000 1050000>,
+					        <950000 950000 1050000>;
+			    opp-microvolt-L4 = <962500 962500 1050000>,
+					        <962500 962500 1050000>;
+			    opp-microvolt-L5 = <950000 950000 1050000>,
+					        <950000 950000 1050000>;
+			    opp-microvolt-L6 = <925000 925000 1050000>,
+					        <925000 925000 1050000>;
+			    opp-microvolt-L7 = <912500 912500 1050000>,
+					        <912500 912500 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-2256000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <2256000000>;
+			    opp-microvolt = <1000000 1000000 1050000>,
+					        <1000000 1000000 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-2304000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <2304000000>;
+			    opp-microvolt = <1030000 1000000 1050000>,
+					        <1030000 1000000 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-2352000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <2352000000>;
+			    opp-microvolt = <1040000 1010000 1050000>,
+					        <1040000 1010000 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+		    opp-2400000000 {
+			    opp-supported-hw = <0xff 0xffff>;
+			    opp-hz = /bits/ 64 <2400000000>;
+			    opp-microvolt = <1050000 1020000 1050000>,
+					        <1050000 1020000 1050000>;
+			    clock-latency-ns = <40000>;
+		    };
+        };
+    };
+};
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/Makefile
===================================================================
--- kernel-rockchip.orig/arch/arm64/boot/dts/rockchip/Makefile
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/Makefile
@@ -269,3 +269,26 @@ dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588s-e
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588s-tablet-rk806-single-v10.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588s-tablet-v10.dtb
 dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588s-tablet-v11.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-radxa-e25.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3568-rock-3a.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588-blade3-v101-linux.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588-blueberry-edge-v10-linux.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588-blueberry-edge-v12-linux.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588-blueberry-edge-v12-maizhuo-linux.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588-blueberry-edge-v14-linux.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588-blueberry-minipc-linux.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588-blueberry-minipc-mizhuo-linux.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588-hinlink-h88k.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588-nanopc-t6.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588-orangepi-5-plus.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588-rock-5b.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588s-9tripod-linux.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588s-khadas-edge2.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588s-nanopi-r6c.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588s-nanopi-r6s.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588s-orangepi-5.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588s-orangepi-5b.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588s-radxa-cm5-io.dtb
+dtb-$(CONFIG_ARCH_ROCKCHIP) += rk3588s-rock-5a.dtb
+
+subdir-y := $(dts-dirs) overlay
Index: kernel-rockchip/drivers/block/Kconfig
===================================================================
--- kernel-rockchip.orig/drivers/block/Kconfig
+++ kernel-rockchip/drivers/block/Kconfig
@@ -245,7 +245,7 @@ config BLK_DEV_CRYPTOLOOP
 	select CRYPTO_CBC
 	depends on BLK_DEV_LOOP
 	help
-	  Say Y here if you want to be able to use the ciphers that are 
+	  Say Y here if you want to be able to use the ciphers that are
 	  provided by the CryptoAPI as loop transformation. This might be
 	  used as hard disk encryption.
 
@@ -293,6 +293,15 @@ config BLK_DEV_SKD
 
 	Use device /dev/skd$N amd /dev/skd$Np$M.
 
+config BLK_DEV_SX8
+  tristate "Promise SATA SX8 support"
+  depends on PCI
+  help
+    Saying Y or M here will enable support for the
+    Promise SATA SX8 controllers.
+
+    Use devices /dev/sx8/$N and /dev/sx8/$Np$M.
+
 config BLK_DEV_RAM
 	tristate "RAM block device support"
 	help
Index: kernel-rockchip/drivers/block/Makefile
===================================================================
--- kernel-rockchip.orig/drivers/block/Makefile
+++ kernel-rockchip/drivers/block/Makefile
@@ -4,7 +4,7 @@
 #
 # 12 June 2000, Christoph Hellwig <hch@infradead.org>
 # Rewritten to use lists instead of if-statements.
-# 
+#
 
 # needed for trace events
 ccflags-y				+= -I$(src)
@@ -29,6 +29,8 @@ obj-$(CONFIG_BLK_DEV_NBD)	+= nbd.o
 obj-$(CONFIG_BLK_DEV_CRYPTOLOOP) += cryptoloop.o
 obj-$(CONFIG_VIRTIO_BLK)	+= virtio_blk.o
 
+obj-$(CONFIG_BLK_DEV_SX8) += sx8.o
+
 obj-$(CONFIG_XEN_BLKDEV_FRONTEND)	+= xen-blkfront.o
 obj-$(CONFIG_XEN_BLKDEV_BACKEND)	+= xen-blkback/
 obj-$(CONFIG_BLK_DEV_DRBD)     += drbd/
Index: kernel-rockchip/drivers/block/sx8.c
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/block/sx8.c
@@ -0,0 +1,1586 @@
+/*
+ *  sx8.c: Driver for Promise SATA SX8 looks-like-I2O hardware
+ *
+ *  Copyright 2004-2005 Red Hat, Inc.
+ *
+ *  Author/maintainer:  Jeff Garzik <jgarzik@pobox.com>
+ *
+ *  This file is subject to the terms and conditions of the GNU General Public
+ *  License.  See the file "COPYING" in the main directory of this archive
+ *  for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/blk-mq.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/compiler.h>
+#include <linux/workqueue.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/ktime.h>
+#include <linux/hdreg.h>
+#include <linux/dma-mapping.h>
+#include <linux/completion.h>
+#include <linux/scatterlist.h>
+#include <asm/io.h>
+#include <linux/uaccess.h>
+
+#if 0
+#define CARM_DEBUG
+#define CARM_VERBOSE_DEBUG
+#else
+#undef CARM_DEBUG
+#undef CARM_VERBOSE_DEBUG
+#endif
+#undef CARM_NDEBUG
+
+#define DRV_NAME "sx8"
+#define DRV_VERSION "1.0"
+#define PFX DRV_NAME ": "
+
+MODULE_AUTHOR("Jeff Garzik");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Promise SATA SX8 block driver");
+MODULE_VERSION(DRV_VERSION);
+
+/*
+ * SX8 hardware has a single message queue for all ATA ports.
+ * When this driver was written, the hardware (firmware?) would
+ * corrupt data eventually, if more than one request was outstanding.
+ * As one can imagine, having 8 ports bottlenecking on a single
+ * command hurts performance.
+ *
+ * Based on user reports, later versions of the hardware (firmware?)
+ * seem to be able to survive with more than one command queued.
+ *
+ * Therefore, we default to the safe option -- 1 command -- but
+ * allow the user to increase this.
+ *
+ * SX8 should be able to support up to ~60 queued commands (CARM_MAX_REQ),
+ * but problems seem to occur when you exceed ~30, even on newer hardware.
+ */
+static int max_queue = 1;
+module_param(max_queue, int, 0444);
+MODULE_PARM_DESC(max_queue, "Maximum number of queued commands. (min==1, max==30, safe==1)");
+
+
+#define NEXT_RESP(idx)	((idx + 1) % RMSG_Q_LEN)
+
+/* 0xf is just arbitrary, non-zero noise; this is sorta like poisoning */
+#define TAG_ENCODE(tag)	(((tag) << 16) | 0xf)
+#define TAG_DECODE(tag)	(((tag) >> 16) & 0x1f)
+#define TAG_VALID(tag)	((((tag) & 0xf) == 0xf) && (TAG_DECODE(tag) < 32))
+
+/* note: prints function name for you */
+#ifdef CARM_DEBUG
+#define DPRINTK(fmt, args...) printk(KERN_ERR "%s: " fmt, __func__, ## args)
+#ifdef CARM_VERBOSE_DEBUG
+#define VPRINTK(fmt, args...) printk(KERN_ERR "%s: " fmt, __func__, ## args)
+#else
+#define VPRINTK(fmt, args...)
+#endif	/* CARM_VERBOSE_DEBUG */
+#else
+#define DPRINTK(fmt, args...)
+#define VPRINTK(fmt, args...)
+#endif	/* CARM_DEBUG */
+
+#ifdef CARM_NDEBUG
+#define assert(expr)
+#else
+#define assert(expr) \
+        if(unlikely(!(expr))) {                                   \
+        printk(KERN_ERR "Assertion failed! %s,%s,%s,line=%d\n", \
+	#expr, __FILE__, __func__, __LINE__);          \
+        }
+#endif
+
+/* defines only for the constants which don't work well as enums */
+struct carm_host;
+
+enum {
+	/* adapter-wide limits */
+	CARM_MAX_PORTS		= 8,
+	CARM_SHM_SIZE		= (4096 << 7),
+	CARM_MINORS_PER_MAJOR	= 256 / CARM_MAX_PORTS,
+	CARM_MAX_WAIT_Q		= CARM_MAX_PORTS + 1,
+
+	/* command message queue limits */
+	CARM_MAX_REQ		= 64,	       /* max command msgs per host */
+	CARM_MSG_LOW_WATER	= (CARM_MAX_REQ / 4),	     /* refill mark */
+
+	/* S/G limits, host-wide and per-request */
+	CARM_MAX_REQ_SG		= 32,	     /* max s/g entries per request */
+	CARM_MAX_HOST_SG	= 600,		/* max s/g entries per host */
+	CARM_SG_LOW_WATER	= (CARM_MAX_HOST_SG / 4),   /* re-fill mark */
+
+	/* hardware registers */
+	CARM_IHQP		= 0x1c,
+	CARM_INT_STAT		= 0x10, /* interrupt status */
+	CARM_INT_MASK		= 0x14, /* interrupt mask */
+	CARM_HMUC		= 0x18, /* host message unit control */
+	RBUF_ADDR_LO		= 0x20, /* response msg DMA buf low 32 bits */
+	RBUF_ADDR_HI		= 0x24, /* response msg DMA buf high 32 bits */
+	RBUF_BYTE_SZ		= 0x28,
+	CARM_RESP_IDX		= 0x2c,
+	CARM_CMS0		= 0x30, /* command message size reg 0 */
+	CARM_LMUC		= 0x48,
+	CARM_HMPHA		= 0x6c,
+	CARM_INITC		= 0xb5,
+
+	/* bits in CARM_INT_{STAT,MASK} */
+	INT_RESERVED		= 0xfffffff0,
+	INT_WATCHDOG		= (1 << 3),	/* watchdog timer */
+	INT_Q_OVERFLOW		= (1 << 2),	/* cmd msg q overflow */
+	INT_Q_AVAILABLE		= (1 << 1),	/* cmd msg q has free space */
+	INT_RESPONSE		= (1 << 0),	/* response msg available */
+	INT_ACK_MASK		= INT_WATCHDOG | INT_Q_OVERFLOW,
+	INT_DEF_MASK		= INT_RESERVED | INT_Q_OVERFLOW |
+				  INT_RESPONSE,
+
+	/* command messages, and related register bits */
+	CARM_HAVE_RESP		= 0x01,
+	CARM_MSG_READ		= 1,
+	CARM_MSG_WRITE		= 2,
+	CARM_MSG_VERIFY		= 3,
+	CARM_MSG_GET_CAPACITY	= 4,
+	CARM_MSG_FLUSH		= 5,
+	CARM_MSG_IOCTL		= 6,
+	CARM_MSG_ARRAY		= 8,
+	CARM_MSG_MISC		= 9,
+	CARM_CME		= (1 << 2),
+	CARM_RME		= (1 << 1),
+	CARM_WZBC		= (1 << 0),
+	CARM_RMI		= (1 << 0),
+	CARM_Q_FULL		= (1 << 3),
+	CARM_MSG_SIZE		= 288,
+	CARM_Q_LEN		= 48,
+
+	/* CARM_MSG_IOCTL messages */
+	CARM_IOC_SCAN_CHAN	= 5,	/* scan channels for devices */
+	CARM_IOC_GET_TCQ	= 13,	/* get tcq/ncq depth */
+	CARM_IOC_SET_TCQ	= 14,	/* set tcq/ncq depth */
+
+	IOC_SCAN_CHAN_NODEV	= 0x1f,
+	IOC_SCAN_CHAN_OFFSET	= 0x40,
+
+	/* CARM_MSG_ARRAY messages */
+	CARM_ARRAY_INFO		= 0,
+
+	ARRAY_NO_EXIST		= (1 << 31),
+
+	/* response messages */
+	RMSG_SZ			= 8,	/* sizeof(struct carm_response) */
+	RMSG_Q_LEN		= 48,	/* resp. msg list length */
+	RMSG_OK			= 1,	/* bit indicating msg was successful */
+					/* length of entire resp. msg buffer */
+	RBUF_LEN		= RMSG_SZ * RMSG_Q_LEN,
+
+	PDC_SHM_SIZE		= (4096 << 7), /* length of entire h/w buffer */
+
+	/* CARM_MSG_MISC messages */
+	MISC_GET_FW_VER		= 2,
+	MISC_ALLOC_MEM		= 3,
+	MISC_SET_TIME		= 5,
+
+	/* MISC_GET_FW_VER feature bits */
+	FW_VER_4PORT		= (1 << 2), /* 1=4 ports, 0=8 ports */
+	FW_VER_NON_RAID		= (1 << 1), /* 1=non-RAID firmware, 0=RAID */
+	FW_VER_ZCR		= (1 << 0), /* zero channel RAID (whatever that is) */
+
+	/* carm_host flags */
+	FL_NON_RAID		= FW_VER_NON_RAID,
+	FL_4PORT		= FW_VER_4PORT,
+	FL_FW_VER_MASK		= (FW_VER_NON_RAID | FW_VER_4PORT),
+	FL_DYN_MAJOR		= (1 << 17),
+};
+
+enum {
+	CARM_SG_BOUNDARY	= 0xffffUL,	    /* s/g segment boundary */
+};
+
+enum scatter_gather_types {
+	SGT_32BIT		= 0,
+	SGT_64BIT		= 1,
+};
+
+enum host_states {
+	HST_INVALID,		/* invalid state; never used */
+	HST_ALLOC_BUF,		/* setting up master SHM area */
+	HST_ERROR,		/* we never leave here */
+	HST_PORT_SCAN,		/* start dev scan */
+	HST_DEV_SCAN_START,	/* start per-device probe */
+	HST_DEV_SCAN,		/* continue per-device probe */
+	HST_DEV_ACTIVATE,	/* activate devices we found */
+	HST_PROBE_FINISHED,	/* probe is complete */
+	HST_PROBE_START,	/* initiate probe */
+	HST_SYNC_TIME,		/* tell firmware what time it is */
+	HST_GET_FW_VER,		/* get firmware version, adapter port cnt */
+};
+
+#ifdef CARM_DEBUG
+static const char *state_name[] = {
+	"HST_INVALID",
+	"HST_ALLOC_BUF",
+	"HST_ERROR",
+	"HST_PORT_SCAN",
+	"HST_DEV_SCAN_START",
+	"HST_DEV_SCAN",
+	"HST_DEV_ACTIVATE",
+	"HST_PROBE_FINISHED",
+	"HST_PROBE_START",
+	"HST_SYNC_TIME",
+	"HST_GET_FW_VER",
+};
+#endif
+
+struct carm_port {
+	unsigned int			port_no;
+	struct gendisk			*disk;
+	struct carm_host		*host;
+
+	/* attached device characteristics */
+	u64				capacity;
+	char				name[41];
+	u16				dev_geom_head;
+	u16				dev_geom_sect;
+	u16				dev_geom_cyl;
+};
+
+struct carm_request {
+	int				n_elem;
+	unsigned int			msg_type;
+	unsigned int			msg_subtype;
+	unsigned int			msg_bucket;
+	struct scatterlist		sg[CARM_MAX_REQ_SG];
+};
+
+struct carm_host {
+	unsigned long			flags;
+	void				__iomem *mmio;
+	void				*shm;
+	dma_addr_t			shm_dma;
+
+	int				major;
+	int				id;
+	char				name[32];
+
+	spinlock_t			lock;
+	struct pci_dev			*pdev;
+	unsigned int			state;
+	u32				fw_ver;
+
+	struct blk_mq_tag_set		tag_set;
+	struct request_queue		*oob_q;
+	unsigned int			n_oob;
+
+	unsigned int			hw_sg_used;
+
+	unsigned int			resp_idx;
+
+	unsigned int			wait_q_prod;
+	unsigned int			wait_q_cons;
+	struct request_queue		*wait_q[CARM_MAX_WAIT_Q];
+
+	void				*msg_base;
+	dma_addr_t			msg_dma;
+
+	int				cur_scan_dev;
+	unsigned long			dev_active;
+	unsigned long			dev_present;
+	struct carm_port		port[CARM_MAX_PORTS];
+
+	struct work_struct		fsm_task;
+
+	struct completion		probe_comp;
+};
+
+struct carm_response {
+	__le32 ret_handle;
+	__le32 status;
+}  __attribute__((packed));
+
+struct carm_msg_sg {
+	__le32 start;
+	__le32 len;
+}  __attribute__((packed));
+
+struct carm_msg_rw {
+	u8 type;
+	u8 id;
+	u8 sg_count;
+	u8 sg_type;
+	__le32 handle;
+	__le32 lba;
+	__le16 lba_count;
+	__le16 lba_high;
+	struct carm_msg_sg sg[32];
+}  __attribute__((packed));
+
+struct carm_msg_allocbuf {
+	u8 type;
+	u8 subtype;
+	u8 n_sg;
+	u8 sg_type;
+	__le32 handle;
+	__le32 addr;
+	__le32 len;
+	__le32 evt_pool;
+	__le32 n_evt;
+	__le32 rbuf_pool;
+	__le32 n_rbuf;
+	__le32 msg_pool;
+	__le32 n_msg;
+	struct carm_msg_sg sg[8];
+}  __attribute__((packed));
+
+struct carm_msg_ioctl {
+	u8 type;
+	u8 subtype;
+	u8 array_id;
+	u8 reserved1;
+	__le32 handle;
+	__le32 data_addr;
+	u32 reserved2;
+}  __attribute__((packed));
+
+struct carm_msg_sync_time {
+	u8 type;
+	u8 subtype;
+	u16 reserved1;
+	__le32 handle;
+	u32 reserved2;
+	__le32 timestamp;
+}  __attribute__((packed));
+
+struct carm_msg_get_fw_ver {
+	u8 type;
+	u8 subtype;
+	u16 reserved1;
+	__le32 handle;
+	__le32 data_addr;
+	u32 reserved2;
+}  __attribute__((packed));
+
+struct carm_fw_ver {
+	__le32 version;
+	u8 features;
+	u8 reserved1;
+	u16 reserved2;
+}  __attribute__((packed));
+
+struct carm_array_info {
+	__le32 size;
+
+	__le16 size_hi;
+	__le16 stripe_size;
+
+	__le32 mode;
+
+	__le16 stripe_blk_sz;
+	__le16 reserved1;
+
+	__le16 cyl;
+	__le16 head;
+
+	__le16 sect;
+	u8 array_id;
+	u8 reserved2;
+
+	char name[40];
+
+	__le32 array_status;
+
+	/* device list continues beyond this point? */
+}  __attribute__((packed));
+
+static int carm_init_one (struct pci_dev *pdev, const struct pci_device_id *ent);
+static void carm_remove_one (struct pci_dev *pdev);
+static int carm_bdev_getgeo(struct block_device *bdev, struct hd_geometry *geo);
+
+static const struct pci_device_id carm_pci_tbl[] = {
+	{ PCI_VENDOR_ID_PROMISE, 0x8000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{ PCI_VENDOR_ID_PROMISE, 0x8002, PCI_ANY_ID, PCI_ANY_ID, 0, 0, },
+	{ }	/* terminate list */
+};
+MODULE_DEVICE_TABLE(pci, carm_pci_tbl);
+
+static struct pci_driver carm_driver = {
+	.name		= DRV_NAME,
+	.id_table	= carm_pci_tbl,
+	.probe		= carm_init_one,
+	.remove		= carm_remove_one,
+};
+
+static const struct block_device_operations carm_bd_ops = {
+	.owner		= THIS_MODULE,
+	.getgeo		= carm_bdev_getgeo,
+};
+
+static unsigned int carm_host_id;
+static unsigned long carm_major_alloc;
+
+
+
+static int carm_bdev_getgeo(struct block_device *bdev, struct hd_geometry *geo)
+{
+	struct carm_port *port = bdev->bd_disk->private_data;
+
+	geo->heads = (u8) port->dev_geom_head;
+	geo->sectors = (u8) port->dev_geom_sect;
+	geo->cylinders = port->dev_geom_cyl;
+	return 0;
+}
+
+static const u32 msg_sizes[] = { 32, 64, 128, CARM_MSG_SIZE };
+
+static inline int carm_lookup_bucket(u32 msg_size)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(msg_sizes); i++)
+		if (msg_size <= msg_sizes[i])
+			return i;
+
+	return -ENOENT;
+}
+
+static void carm_init_buckets(void __iomem *mmio)
+{
+	unsigned int i;
+
+	for (i = 0; i < ARRAY_SIZE(msg_sizes); i++)
+		writel(msg_sizes[i], mmio + CARM_CMS0 + (4 * i));
+}
+
+static inline void *carm_ref_msg(struct carm_host *host,
+				 unsigned int msg_idx)
+{
+	return host->msg_base + (msg_idx * CARM_MSG_SIZE);
+}
+
+static inline dma_addr_t carm_ref_msg_dma(struct carm_host *host,
+					  unsigned int msg_idx)
+{
+	return host->msg_dma + (msg_idx * CARM_MSG_SIZE);
+}
+
+static int carm_send_msg(struct carm_host *host,
+			 struct carm_request *crq, unsigned tag)
+{
+	void __iomem *mmio = host->mmio;
+	u32 msg = (u32) carm_ref_msg_dma(host, tag);
+	u32 cm_bucket = crq->msg_bucket;
+	u32 tmp;
+	int rc = 0;
+
+	VPRINTK("ENTER\n");
+
+	tmp = readl(mmio + CARM_HMUC);
+	if (tmp & CARM_Q_FULL) {
+#if 0
+		tmp = readl(mmio + CARM_INT_MASK);
+		tmp |= INT_Q_AVAILABLE;
+		writel(tmp, mmio + CARM_INT_MASK);
+		readl(mmio + CARM_INT_MASK);	/* flush */
+#endif
+		DPRINTK("host msg queue full\n");
+		rc = -EBUSY;
+	} else {
+		writel(msg | (cm_bucket << 1), mmio + CARM_IHQP);
+		readl(mmio + CARM_IHQP);	/* flush */
+	}
+
+	return rc;
+}
+
+static int carm_array_info (struct carm_host *host, unsigned int array_idx)
+{
+	struct carm_msg_ioctl *ioc;
+	u32 msg_data;
+	dma_addr_t msg_dma;
+	struct carm_request *crq;
+	struct request *rq;
+	int rc;
+
+	rq = blk_mq_alloc_request(host->oob_q, REQ_OP_DRV_OUT, 0);
+	if (IS_ERR(rq)) {
+		rc = -ENOMEM;
+		goto err_out;
+	}
+	crq = blk_mq_rq_to_pdu(rq);
+
+	ioc = carm_ref_msg(host, rq->tag);
+	msg_dma = carm_ref_msg_dma(host, rq->tag);
+	msg_data = (u32) (msg_dma + sizeof(struct carm_array_info));
+
+	crq->msg_type = CARM_MSG_ARRAY;
+	crq->msg_subtype = CARM_ARRAY_INFO;
+	rc = carm_lookup_bucket(sizeof(struct carm_msg_ioctl) +
+				sizeof(struct carm_array_info));
+	BUG_ON(rc < 0);
+	crq->msg_bucket = (u32) rc;
+
+	memset(ioc, 0, sizeof(*ioc));
+	ioc->type	= CARM_MSG_ARRAY;
+	ioc->subtype	= CARM_ARRAY_INFO;
+	ioc->array_id	= (u8) array_idx;
+	ioc->handle	= cpu_to_le32(TAG_ENCODE(rq->tag));
+	ioc->data_addr	= cpu_to_le32(msg_data);
+
+	spin_lock_irq(&host->lock);
+	assert(host->state == HST_DEV_SCAN_START ||
+	       host->state == HST_DEV_SCAN);
+	spin_unlock_irq(&host->lock);
+
+	DPRINTK("blk_execute_rq_nowait, tag == %u\n", rq->tag);
+	blk_execute_rq_nowait(host->oob_q, NULL, rq, true, NULL);
+
+	return 0;
+
+err_out:
+	spin_lock_irq(&host->lock);
+	host->state = HST_ERROR;
+	spin_unlock_irq(&host->lock);
+	return rc;
+}
+
+typedef unsigned int (*carm_sspc_t)(struct carm_host *, unsigned int, void *);
+
+static int carm_send_special (struct carm_host *host, carm_sspc_t func)
+{
+	struct request *rq;
+	struct carm_request *crq;
+	struct carm_msg_ioctl *ioc;
+	void *mem;
+	unsigned int msg_size;
+	int rc;
+
+	rq = blk_mq_alloc_request(host->oob_q, REQ_OP_DRV_OUT, 0);
+	if (IS_ERR(rq))
+		return -ENOMEM;
+	crq = blk_mq_rq_to_pdu(rq);
+
+	mem = carm_ref_msg(host, rq->tag);
+
+	msg_size = func(host, rq->tag, mem);
+
+	ioc = mem;
+	crq->msg_type = ioc->type;
+	crq->msg_subtype = ioc->subtype;
+	rc = carm_lookup_bucket(msg_size);
+	BUG_ON(rc < 0);
+	crq->msg_bucket = (u32) rc;
+
+	DPRINTK("blk_execute_rq_nowait, tag == %u\n", rq->tag);
+	blk_execute_rq_nowait(host->oob_q, NULL, rq, true, NULL);
+
+	return 0;
+}
+
+static unsigned int carm_fill_sync_time(struct carm_host *host,
+					unsigned int idx, void *mem)
+{
+	struct carm_msg_sync_time *st = mem;
+
+	time64_t tv = ktime_get_real_seconds();
+
+	memset(st, 0, sizeof(*st));
+	st->type	= CARM_MSG_MISC;
+	st->subtype	= MISC_SET_TIME;
+	st->handle	= cpu_to_le32(TAG_ENCODE(idx));
+	st->timestamp	= cpu_to_le32(tv);
+
+	return sizeof(struct carm_msg_sync_time);
+}
+
+static unsigned int carm_fill_alloc_buf(struct carm_host *host,
+					unsigned int idx, void *mem)
+{
+	struct carm_msg_allocbuf *ab = mem;
+
+	memset(ab, 0, sizeof(*ab));
+	ab->type	= CARM_MSG_MISC;
+	ab->subtype	= MISC_ALLOC_MEM;
+	ab->handle	= cpu_to_le32(TAG_ENCODE(idx));
+	ab->n_sg	= 1;
+	ab->sg_type	= SGT_32BIT;
+	ab->addr	= cpu_to_le32(host->shm_dma + (PDC_SHM_SIZE >> 1));
+	ab->len		= cpu_to_le32(PDC_SHM_SIZE >> 1);
+	ab->evt_pool	= cpu_to_le32(host->shm_dma + (16 * 1024));
+	ab->n_evt	= cpu_to_le32(1024);
+	ab->rbuf_pool	= cpu_to_le32(host->shm_dma);
+	ab->n_rbuf	= cpu_to_le32(RMSG_Q_LEN);
+	ab->msg_pool	= cpu_to_le32(host->shm_dma + RBUF_LEN);
+	ab->n_msg	= cpu_to_le32(CARM_Q_LEN);
+	ab->sg[0].start	= cpu_to_le32(host->shm_dma + (PDC_SHM_SIZE >> 1));
+	ab->sg[0].len	= cpu_to_le32(65536);
+
+	return sizeof(struct carm_msg_allocbuf);
+}
+
+static unsigned int carm_fill_scan_channels(struct carm_host *host,
+					    unsigned int idx, void *mem)
+{
+	struct carm_msg_ioctl *ioc = mem;
+	u32 msg_data = (u32) (carm_ref_msg_dma(host, idx) +
+			      IOC_SCAN_CHAN_OFFSET);
+
+	memset(ioc, 0, sizeof(*ioc));
+	ioc->type	= CARM_MSG_IOCTL;
+	ioc->subtype	= CARM_IOC_SCAN_CHAN;
+	ioc->handle	= cpu_to_le32(TAG_ENCODE(idx));
+	ioc->data_addr	= cpu_to_le32(msg_data);
+
+	/* fill output data area with "no device" default values */
+	mem += IOC_SCAN_CHAN_OFFSET;
+	memset(mem, IOC_SCAN_CHAN_NODEV, CARM_MAX_PORTS);
+
+	return IOC_SCAN_CHAN_OFFSET + CARM_MAX_PORTS;
+}
+
+static unsigned int carm_fill_get_fw_ver(struct carm_host *host,
+					 unsigned int idx, void *mem)
+{
+	struct carm_msg_get_fw_ver *ioc = mem;
+	u32 msg_data = (u32) (carm_ref_msg_dma(host, idx) + sizeof(*ioc));
+
+	memset(ioc, 0, sizeof(*ioc));
+	ioc->type	= CARM_MSG_MISC;
+	ioc->subtype	= MISC_GET_FW_VER;
+	ioc->handle	= cpu_to_le32(TAG_ENCODE(idx));
+	ioc->data_addr	= cpu_to_le32(msg_data);
+
+	return sizeof(struct carm_msg_get_fw_ver) +
+	       sizeof(struct carm_fw_ver);
+}
+
+static inline void carm_push_q (struct carm_host *host, struct request_queue *q)
+{
+	unsigned int idx = host->wait_q_prod % CARM_MAX_WAIT_Q;
+
+	blk_mq_stop_hw_queues(q);
+	VPRINTK("STOPPED QUEUE %p\n", q);
+
+	host->wait_q[idx] = q;
+	host->wait_q_prod++;
+	BUG_ON(host->wait_q_prod == host->wait_q_cons); /* overrun */
+}
+
+static inline struct request_queue *carm_pop_q(struct carm_host *host)
+{
+	unsigned int idx;
+
+	if (host->wait_q_prod == host->wait_q_cons)
+		return NULL;
+
+	idx = host->wait_q_cons % CARM_MAX_WAIT_Q;
+	host->wait_q_cons++;
+
+	return host->wait_q[idx];
+}
+
+static inline void carm_round_robin(struct carm_host *host)
+{
+	struct request_queue *q = carm_pop_q(host);
+	if (q) {
+		blk_mq_start_hw_queues(q);
+		VPRINTK("STARTED QUEUE %p\n", q);
+	}
+}
+
+static inline enum dma_data_direction carm_rq_dir(struct request *rq)
+{
+	return op_is_write(req_op(rq)) ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
+}
+
+static blk_status_t carm_queue_rq(struct blk_mq_hw_ctx *hctx,
+				  const struct blk_mq_queue_data *bd)
+{
+	struct request_queue *q = hctx->queue;
+	struct request *rq = bd->rq;
+	struct carm_port *port = q->queuedata;
+	struct carm_host *host = port->host;
+	struct carm_request *crq = blk_mq_rq_to_pdu(rq);
+	struct carm_msg_rw *msg;
+	struct scatterlist *sg;
+	int i, n_elem = 0, rc;
+	unsigned int msg_size;
+	u32 tmp;
+
+	crq->n_elem = 0;
+	sg_init_table(crq->sg, CARM_MAX_REQ_SG);
+
+	blk_mq_start_request(rq);
+
+	spin_lock_irq(&host->lock);
+	if (req_op(rq) == REQ_OP_DRV_OUT)
+		goto send_msg;
+
+	/* get scatterlist from block layer */
+	sg = &crq->sg[0];
+	n_elem = blk_rq_map_sg(q, rq, sg);
+	if (n_elem <= 0)
+		goto out_ioerr;
+
+	/* map scatterlist to PCI bus addresses */
+	n_elem = dma_map_sg(&host->pdev->dev, sg, n_elem, carm_rq_dir(rq));
+	if (n_elem <= 0)
+		goto out_ioerr;
+
+	/* obey global hardware limit on S/G entries */
+	if (host->hw_sg_used >= CARM_MAX_HOST_SG - n_elem)
+		goto out_resource;
+
+	crq->n_elem = n_elem;
+	host->hw_sg_used += n_elem;
+
+	/*
+	 * build read/write message
+	 */
+
+	VPRINTK("build msg\n");
+	msg = (struct carm_msg_rw *) carm_ref_msg(host, rq->tag);
+
+	if (rq_data_dir(rq) == WRITE) {
+		msg->type = CARM_MSG_WRITE;
+		crq->msg_type = CARM_MSG_WRITE;
+	} else {
+		msg->type = CARM_MSG_READ;
+		crq->msg_type = CARM_MSG_READ;
+	}
+
+	msg->id		= port->port_no;
+	msg->sg_count	= n_elem;
+	msg->sg_type	= SGT_32BIT;
+	msg->handle	= cpu_to_le32(TAG_ENCODE(rq->tag));
+	msg->lba	= cpu_to_le32(blk_rq_pos(rq) & 0xffffffff);
+	tmp		= (blk_rq_pos(rq) >> 16) >> 16;
+	msg->lba_high	= cpu_to_le16( (u16) tmp );
+	msg->lba_count	= cpu_to_le16(blk_rq_sectors(rq));
+
+	msg_size = sizeof(struct carm_msg_rw) - sizeof(msg->sg);
+	for (i = 0; i < n_elem; i++) {
+		struct carm_msg_sg *carm_sg = &msg->sg[i];
+		carm_sg->start = cpu_to_le32(sg_dma_address(&crq->sg[i]));
+		carm_sg->len = cpu_to_le32(sg_dma_len(&crq->sg[i]));
+		msg_size += sizeof(struct carm_msg_sg);
+	}
+
+	rc = carm_lookup_bucket(msg_size);
+	BUG_ON(rc < 0);
+	crq->msg_bucket = (u32) rc;
+send_msg:
+	/*
+	 * queue read/write message to hardware
+	 */
+	VPRINTK("send msg, tag == %u\n", rq->tag);
+	rc = carm_send_msg(host, crq, rq->tag);
+	if (rc) {
+		host->hw_sg_used -= n_elem;
+		goto out_resource;
+	}
+
+	spin_unlock_irq(&host->lock);
+	return BLK_STS_OK;
+out_resource:
+	dma_unmap_sg(&host->pdev->dev, &crq->sg[0], n_elem, carm_rq_dir(rq));
+	carm_push_q(host, q);
+	spin_unlock_irq(&host->lock);
+	return BLK_STS_DEV_RESOURCE;
+out_ioerr:
+	carm_round_robin(host);
+	spin_unlock_irq(&host->lock);
+	return BLK_STS_IOERR;
+}
+
+static void carm_handle_array_info(struct carm_host *host,
+				   struct carm_request *crq, u8 *mem,
+				   blk_status_t error)
+{
+	struct carm_port *port;
+	u8 *msg_data = mem + sizeof(struct carm_array_info);
+	struct carm_array_info *desc = (struct carm_array_info *) msg_data;
+	u64 lo, hi;
+	int cur_port;
+	size_t slen;
+
+	DPRINTK("ENTER\n");
+
+	if (error)
+		goto out;
+	if (le32_to_cpu(desc->array_status) & ARRAY_NO_EXIST)
+		goto out;
+
+	cur_port = host->cur_scan_dev;
+
+	/* should never occur */
+	if ((cur_port < 0) || (cur_port >= CARM_MAX_PORTS)) {
+		printk(KERN_ERR PFX "BUG: cur_scan_dev==%d, array_id==%d\n",
+		       cur_port, (int) desc->array_id);
+		goto out;
+	}
+
+	port = &host->port[cur_port];
+
+	lo = (u64) le32_to_cpu(desc->size);
+	hi = (u64) le16_to_cpu(desc->size_hi);
+
+	port->capacity = lo | (hi << 32);
+	port->dev_geom_head = le16_to_cpu(desc->head);
+	port->dev_geom_sect = le16_to_cpu(desc->sect);
+	port->dev_geom_cyl = le16_to_cpu(desc->cyl);
+
+	host->dev_active |= (1 << cur_port);
+
+	strncpy(port->name, desc->name, sizeof(port->name));
+	port->name[sizeof(port->name) - 1] = 0;
+	slen = strlen(port->name);
+	while (slen && (port->name[slen - 1] == ' ')) {
+		port->name[slen - 1] = 0;
+		slen--;
+	}
+
+	printk(KERN_INFO DRV_NAME "(%s): port %u device %Lu sectors\n",
+	       pci_name(host->pdev), port->port_no,
+	       (unsigned long long) port->capacity);
+	printk(KERN_INFO DRV_NAME "(%s): port %u device \"%s\"\n",
+	       pci_name(host->pdev), port->port_no, port->name);
+
+out:
+	assert(host->state == HST_DEV_SCAN);
+	schedule_work(&host->fsm_task);
+}
+
+static void carm_handle_scan_chan(struct carm_host *host,
+				  struct carm_request *crq, u8 *mem,
+				  blk_status_t error)
+{
+	u8 *msg_data = mem + IOC_SCAN_CHAN_OFFSET;
+	unsigned int i, dev_count = 0;
+	int new_state = HST_DEV_SCAN_START;
+
+	DPRINTK("ENTER\n");
+
+	if (error) {
+		new_state = HST_ERROR;
+		goto out;
+	}
+
+	/* TODO: scan and support non-disk devices */
+	for (i = 0; i < 8; i++)
+		if (msg_data[i] == 0) { /* direct-access device (disk) */
+			host->dev_present |= (1 << i);
+			dev_count++;
+		}
+
+	printk(KERN_INFO DRV_NAME "(%s): found %u interesting devices\n",
+	       pci_name(host->pdev), dev_count);
+
+out:
+	assert(host->state == HST_PORT_SCAN);
+	host->state = new_state;
+	schedule_work(&host->fsm_task);
+}
+
+static void carm_handle_generic(struct carm_host *host,
+				struct carm_request *crq, blk_status_t error,
+				int cur_state, int next_state)
+{
+	DPRINTK("ENTER\n");
+
+	assert(host->state == cur_state);
+	if (error)
+		host->state = HST_ERROR;
+	else
+		host->state = next_state;
+	schedule_work(&host->fsm_task);
+}
+
+static inline void carm_handle_resp(struct carm_host *host,
+				    __le32 ret_handle_le, u32 status)
+{
+	u32 handle = le32_to_cpu(ret_handle_le);
+	unsigned int msg_idx;
+	struct request *rq;
+	struct carm_request *crq;
+	blk_status_t error = (status == RMSG_OK) ? 0 : BLK_STS_IOERR;
+	u8 *mem;
+
+	VPRINTK("ENTER, handle == 0x%x\n", handle);
+
+	if (unlikely(!TAG_VALID(handle))) {
+		printk(KERN_ERR DRV_NAME "(%s): BUG: invalid tag 0x%x\n",
+		       pci_name(host->pdev), handle);
+		return;
+	}
+
+	msg_idx = TAG_DECODE(handle);
+	VPRINTK("tag == %u\n", msg_idx);
+
+	rq = blk_mq_tag_to_rq(host->tag_set.tags[0], msg_idx);
+	crq = blk_mq_rq_to_pdu(rq);
+
+	/* fast path */
+	if (likely(crq->msg_type == CARM_MSG_READ ||
+		   crq->msg_type == CARM_MSG_WRITE)) {
+		dma_unmap_sg(&host->pdev->dev, &crq->sg[0], crq->n_elem,
+			     carm_rq_dir(rq));
+		goto done;
+	}
+
+	mem = carm_ref_msg(host, msg_idx);
+
+	switch (crq->msg_type) {
+	case CARM_MSG_IOCTL: {
+		switch (crq->msg_subtype) {
+		case CARM_IOC_SCAN_CHAN:
+			carm_handle_scan_chan(host, crq, mem, error);
+			goto done;
+		default:
+			/* unknown / invalid response */
+			goto err_out;
+		}
+		break;
+	}
+
+	case CARM_MSG_MISC: {
+		switch (crq->msg_subtype) {
+		case MISC_ALLOC_MEM:
+			carm_handle_generic(host, crq, error,
+					    HST_ALLOC_BUF, HST_SYNC_TIME);
+			goto done;
+		case MISC_SET_TIME:
+			carm_handle_generic(host, crq, error,
+					    HST_SYNC_TIME, HST_GET_FW_VER);
+			goto done;
+		case MISC_GET_FW_VER: {
+			struct carm_fw_ver *ver = (struct carm_fw_ver *)
+				(mem + sizeof(struct carm_msg_get_fw_ver));
+			if (!error) {
+				host->fw_ver = le32_to_cpu(ver->version);
+				host->flags |= (ver->features & FL_FW_VER_MASK);
+			}
+			carm_handle_generic(host, crq, error,
+					    HST_GET_FW_VER, HST_PORT_SCAN);
+			goto done;
+		}
+		default:
+			/* unknown / invalid response */
+			goto err_out;
+		}
+		break;
+	}
+
+	case CARM_MSG_ARRAY: {
+		switch (crq->msg_subtype) {
+		case CARM_ARRAY_INFO:
+			carm_handle_array_info(host, crq, mem, error);
+			break;
+		default:
+			/* unknown / invalid response */
+			goto err_out;
+		}
+		break;
+	}
+
+	default:
+		/* unknown / invalid response */
+		goto err_out;
+	}
+
+	return;
+
+err_out:
+	printk(KERN_WARNING DRV_NAME "(%s): BUG: unhandled message type %d/%d\n",
+	       pci_name(host->pdev), crq->msg_type, crq->msg_subtype);
+	error = BLK_STS_IOERR;
+done:
+	host->hw_sg_used -= crq->n_elem;
+	blk_mq_end_request(blk_mq_rq_from_pdu(crq), error);
+
+	if (host->hw_sg_used <= CARM_SG_LOW_WATER)
+		carm_round_robin(host);
+}
+
+static inline void carm_handle_responses(struct carm_host *host)
+{
+	void __iomem *mmio = host->mmio;
+	struct carm_response *resp = (struct carm_response *) host->shm;
+	unsigned int work = 0;
+	unsigned int idx = host->resp_idx % RMSG_Q_LEN;
+
+	while (1) {
+		u32 status = le32_to_cpu(resp[idx].status);
+
+		if (status == 0xffffffff) {
+			VPRINTK("ending response on index %u\n", idx);
+			writel(idx << 3, mmio + CARM_RESP_IDX);
+			break;
+		}
+
+		/* response to a message we sent */
+		else if ((status & (1 << 31)) == 0) {
+			VPRINTK("handling msg response on index %u\n", idx);
+			carm_handle_resp(host, resp[idx].ret_handle, status);
+			resp[idx].status = cpu_to_le32(0xffffffff);
+		}
+
+		/* asynchronous events the hardware throws our way */
+		else if ((status & 0xff000000) == (1 << 31)) {
+			u8 *evt_type_ptr = (u8 *) &resp[idx];
+			u8 evt_type = *evt_type_ptr;
+			printk(KERN_WARNING DRV_NAME "(%s): unhandled event type %d\n",
+			       pci_name(host->pdev), (int) evt_type);
+			resp[idx].status = cpu_to_le32(0xffffffff);
+		}
+
+		idx = NEXT_RESP(idx);
+		work++;
+	}
+
+	VPRINTK("EXIT, work==%u\n", work);
+	host->resp_idx += work;
+}
+
+static irqreturn_t carm_interrupt(int irq, void *__host)
+{
+	struct carm_host *host = __host;
+	void __iomem *mmio;
+	u32 mask;
+	int handled = 0;
+	unsigned long flags;
+
+	if (!host) {
+		VPRINTK("no host\n");
+		return IRQ_NONE;
+	}
+
+	spin_lock_irqsave(&host->lock, flags);
+
+	mmio = host->mmio;
+
+	/* reading should also clear interrupts */
+	mask = readl(mmio + CARM_INT_STAT);
+
+	if (mask == 0 || mask == 0xffffffff) {
+		VPRINTK("no work, mask == 0x%x\n", mask);
+		goto out;
+	}
+
+	if (mask & INT_ACK_MASK)
+		writel(mask, mmio + CARM_INT_STAT);
+
+	if (unlikely(host->state == HST_INVALID)) {
+		VPRINTK("not initialized yet, mask = 0x%x\n", mask);
+		goto out;
+	}
+
+	if (mask & CARM_HAVE_RESP) {
+		handled = 1;
+		carm_handle_responses(host);
+	}
+
+out:
+	spin_unlock_irqrestore(&host->lock, flags);
+	VPRINTK("EXIT\n");
+	return IRQ_RETVAL(handled);
+}
+
+static void carm_fsm_task (struct work_struct *work)
+{
+	struct carm_host *host =
+		container_of(work, struct carm_host, fsm_task);
+	unsigned long flags;
+	unsigned int state;
+	int rc, i, next_dev;
+	int reschedule = 0;
+	int new_state = HST_INVALID;
+
+	spin_lock_irqsave(&host->lock, flags);
+	state = host->state;
+	spin_unlock_irqrestore(&host->lock, flags);
+
+	DPRINTK("ENTER, state == %s\n", state_name[state]);
+
+	switch (state) {
+	case HST_PROBE_START:
+		new_state = HST_ALLOC_BUF;
+		reschedule = 1;
+		break;
+
+	case HST_ALLOC_BUF:
+		rc = carm_send_special(host, carm_fill_alloc_buf);
+		if (rc) {
+			new_state = HST_ERROR;
+			reschedule = 1;
+		}
+		break;
+
+	case HST_SYNC_TIME:
+		rc = carm_send_special(host, carm_fill_sync_time);
+		if (rc) {
+			new_state = HST_ERROR;
+			reschedule = 1;
+		}
+		break;
+
+	case HST_GET_FW_VER:
+		rc = carm_send_special(host, carm_fill_get_fw_ver);
+		if (rc) {
+			new_state = HST_ERROR;
+			reschedule = 1;
+		}
+		break;
+
+	case HST_PORT_SCAN:
+		rc = carm_send_special(host, carm_fill_scan_channels);
+		if (rc) {
+			new_state = HST_ERROR;
+			reschedule = 1;
+		}
+		break;
+
+	case HST_DEV_SCAN_START:
+		host->cur_scan_dev = -1;
+		new_state = HST_DEV_SCAN;
+		reschedule = 1;
+		break;
+
+	case HST_DEV_SCAN:
+		next_dev = -1;
+		for (i = host->cur_scan_dev + 1; i < CARM_MAX_PORTS; i++)
+			if (host->dev_present & (1 << i)) {
+				next_dev = i;
+				break;
+			}
+
+		if (next_dev >= 0) {
+			host->cur_scan_dev = next_dev;
+			rc = carm_array_info(host, next_dev);
+			if (rc) {
+				new_state = HST_ERROR;
+				reschedule = 1;
+			}
+		} else {
+			new_state = HST_DEV_ACTIVATE;
+			reschedule = 1;
+		}
+		break;
+
+	case HST_DEV_ACTIVATE: {
+		int activated = 0;
+		for (i = 0; i < CARM_MAX_PORTS; i++)
+			if (host->dev_active & (1 << i)) {
+				struct carm_port *port = &host->port[i];
+				struct gendisk *disk = port->disk;
+
+				set_capacity(disk, port->capacity);
+				add_disk(disk);
+				activated++;
+			}
+
+		printk(KERN_INFO DRV_NAME "(%s): %d ports activated\n",
+		       pci_name(host->pdev), activated);
+
+		new_state = HST_PROBE_FINISHED;
+		reschedule = 1;
+		break;
+	}
+
+	case HST_PROBE_FINISHED:
+		complete(&host->probe_comp);
+		break;
+
+	case HST_ERROR:
+		/* FIXME: TODO */
+		break;
+
+	default:
+		/* should never occur */
+		printk(KERN_ERR PFX "BUG: unknown state %d\n", state);
+		assert(0);
+		break;
+	}
+
+	if (new_state != HST_INVALID) {
+		spin_lock_irqsave(&host->lock, flags);
+		host->state = new_state;
+		spin_unlock_irqrestore(&host->lock, flags);
+	}
+	if (reschedule)
+		schedule_work(&host->fsm_task);
+}
+
+static int carm_init_wait(void __iomem *mmio, u32 bits, unsigned int test_bit)
+{
+	unsigned int i;
+
+	for (i = 0; i < 50000; i++) {
+		u32 tmp = readl(mmio + CARM_LMUC);
+		udelay(100);
+
+		if (test_bit) {
+			if ((tmp & bits) == bits)
+				return 0;
+		} else {
+			if ((tmp & bits) == 0)
+				return 0;
+		}
+
+		cond_resched();
+	}
+
+	printk(KERN_ERR PFX "carm_init_wait timeout, bits == 0x%x, test_bit == %s\n",
+	       bits, test_bit ? "yes" : "no");
+	return -EBUSY;
+}
+
+static void carm_init_responses(struct carm_host *host)
+{
+	void __iomem *mmio = host->mmio;
+	unsigned int i;
+	struct carm_response *resp = (struct carm_response *) host->shm;
+
+	for (i = 0; i < RMSG_Q_LEN; i++)
+		resp[i].status = cpu_to_le32(0xffffffff);
+
+	writel(0, mmio + CARM_RESP_IDX);
+}
+
+static int carm_init_host(struct carm_host *host)
+{
+	void __iomem *mmio = host->mmio;
+	u32 tmp;
+	u8 tmp8;
+	int rc;
+
+	DPRINTK("ENTER\n");
+
+	writel(0, mmio + CARM_INT_MASK);
+
+	tmp8 = readb(mmio + CARM_INITC);
+	if (tmp8 & 0x01) {
+		tmp8 &= ~0x01;
+		writeb(tmp8, mmio + CARM_INITC);
+		readb(mmio + CARM_INITC);	/* flush */
+
+		DPRINTK("snooze...\n");
+		msleep(5000);
+	}
+
+	tmp = readl(mmio + CARM_HMUC);
+	if (tmp & CARM_CME) {
+		DPRINTK("CME bit present, waiting\n");
+		rc = carm_init_wait(mmio, CARM_CME, 1);
+		if (rc) {
+			DPRINTK("EXIT, carm_init_wait 1 failed\n");
+			return rc;
+		}
+	}
+	if (tmp & CARM_RME) {
+		DPRINTK("RME bit present, waiting\n");
+		rc = carm_init_wait(mmio, CARM_RME, 1);
+		if (rc) {
+			DPRINTK("EXIT, carm_init_wait 2 failed\n");
+			return rc;
+		}
+	}
+
+	tmp &= ~(CARM_RME | CARM_CME);
+	writel(tmp, mmio + CARM_HMUC);
+	readl(mmio + CARM_HMUC);	/* flush */
+
+	rc = carm_init_wait(mmio, CARM_RME | CARM_CME, 0);
+	if (rc) {
+		DPRINTK("EXIT, carm_init_wait 3 failed\n");
+		return rc;
+	}
+
+	carm_init_buckets(mmio);
+
+	writel(host->shm_dma & 0xffffffff, mmio + RBUF_ADDR_LO);
+	writel((host->shm_dma >> 16) >> 16, mmio + RBUF_ADDR_HI);
+	writel(RBUF_LEN, mmio + RBUF_BYTE_SZ);
+
+	tmp = readl(mmio + CARM_HMUC);
+	tmp |= (CARM_RME | CARM_CME | CARM_WZBC);
+	writel(tmp, mmio + CARM_HMUC);
+	readl(mmio + CARM_HMUC);	/* flush */
+
+	rc = carm_init_wait(mmio, CARM_RME | CARM_CME, 1);
+	if (rc) {
+		DPRINTK("EXIT, carm_init_wait 4 failed\n");
+		return rc;
+	}
+
+	writel(0, mmio + CARM_HMPHA);
+	writel(INT_DEF_MASK, mmio + CARM_INT_MASK);
+
+	carm_init_responses(host);
+
+	/* start initialization, probing state machine */
+	spin_lock_irq(&host->lock);
+	assert(host->state == HST_INVALID);
+	host->state = HST_PROBE_START;
+	spin_unlock_irq(&host->lock);
+	schedule_work(&host->fsm_task);
+
+	DPRINTK("EXIT\n");
+	return 0;
+}
+
+static const struct blk_mq_ops carm_mq_ops = {
+	.queue_rq	= carm_queue_rq,
+};
+
+static int carm_init_disk(struct carm_host *host, unsigned int port_no)
+{
+	struct carm_port *port = &host->port[port_no];
+	struct gendisk *disk;
+	struct request_queue *q;
+
+	port->host = host;
+	port->port_no = port_no;
+
+	disk = alloc_disk(CARM_MINORS_PER_MAJOR);
+	if (!disk)
+		return -ENOMEM;
+
+	port->disk = disk;
+	sprintf(disk->disk_name, DRV_NAME "/%u",
+		(unsigned int)host->id * CARM_MAX_PORTS + port_no);
+	disk->major = host->major;
+	disk->first_minor = port_no * CARM_MINORS_PER_MAJOR;
+	disk->fops = &carm_bd_ops;
+	disk->private_data = port;
+
+	q = blk_mq_init_queue(&host->tag_set);
+	if (IS_ERR(q))
+		return PTR_ERR(q);
+
+	blk_queue_max_segments(q, CARM_MAX_REQ_SG);
+	blk_queue_segment_boundary(q, CARM_SG_BOUNDARY);
+
+	q->queuedata = port;
+	disk->queue = q;
+	return 0;
+}
+
+static void carm_free_disk(struct carm_host *host, unsigned int port_no)
+{
+	struct carm_port *port = &host->port[port_no];
+	struct gendisk *disk = port->disk;
+
+	if (!disk)
+		return;
+
+	if (disk->flags & GENHD_FL_UP)
+		del_gendisk(disk);
+	if (disk->queue)
+		blk_cleanup_queue(disk->queue);
+	put_disk(disk);
+}
+
+static int carm_init_shm(struct carm_host *host)
+{
+	host->shm = dma_alloc_coherent(&host->pdev->dev, CARM_SHM_SIZE,
+				       &host->shm_dma, GFP_KERNEL);
+	if (!host->shm)
+		return -ENOMEM;
+
+	host->msg_base = host->shm + RBUF_LEN;
+	host->msg_dma = host->shm_dma + RBUF_LEN;
+
+	memset(host->shm, 0xff, RBUF_LEN);
+	memset(host->msg_base, 0, PDC_SHM_SIZE - RBUF_LEN);
+
+	return 0;
+}
+
+static int carm_init_one (struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	struct carm_host *host;
+	int rc;
+	struct request_queue *q;
+	unsigned int i;
+
+	printk_once(KERN_DEBUG DRV_NAME " version " DRV_VERSION "\n");
+
+	rc = pci_enable_device(pdev);
+	if (rc)
+		return rc;
+
+	rc = pci_request_regions(pdev, DRV_NAME);
+	if (rc)
+		goto err_out;
+
+	rc = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
+	if (rc) {
+		printk(KERN_ERR DRV_NAME "(%s): DMA mask failure\n",
+			pci_name(pdev));
+		goto err_out_regions;
+	}
+
+	host = kzalloc(sizeof(*host), GFP_KERNEL);
+	if (!host) {
+		printk(KERN_ERR DRV_NAME "(%s): memory alloc failure\n",
+		       pci_name(pdev));
+		rc = -ENOMEM;
+		goto err_out_regions;
+	}
+
+	host->pdev = pdev;
+	spin_lock_init(&host->lock);
+	INIT_WORK(&host->fsm_task, carm_fsm_task);
+	init_completion(&host->probe_comp);
+
+	host->mmio = ioremap(pci_resource_start(pdev, 0),
+			     pci_resource_len(pdev, 0));
+	if (!host->mmio) {
+		printk(KERN_ERR DRV_NAME "(%s): MMIO alloc failure\n",
+		       pci_name(pdev));
+		rc = -ENOMEM;
+		goto err_out_kfree;
+	}
+
+	rc = carm_init_shm(host);
+	if (rc) {
+		printk(KERN_ERR DRV_NAME "(%s): DMA SHM alloc failure\n",
+		       pci_name(pdev));
+		goto err_out_iounmap;
+	}
+
+	memset(&host->tag_set, 0, sizeof(host->tag_set));
+	host->tag_set.ops = &carm_mq_ops;
+	host->tag_set.cmd_size = sizeof(struct carm_request);
+	host->tag_set.nr_hw_queues = 1;
+	host->tag_set.nr_maps = 1;
+	host->tag_set.queue_depth = max_queue;
+	host->tag_set.numa_node = NUMA_NO_NODE;
+	host->tag_set.flags = BLK_MQ_F_SHOULD_MERGE;
+
+	rc = blk_mq_alloc_tag_set(&host->tag_set);
+	if (rc)
+		goto err_out_dma_free;
+
+	q = blk_mq_init_queue(&host->tag_set);
+	if (IS_ERR(q)) {
+		rc = PTR_ERR(q);
+		blk_mq_free_tag_set(&host->tag_set);
+		goto err_out_dma_free;
+	}
+
+	host->oob_q = q;
+	q->queuedata = host;
+
+	/*
+	 * Figure out which major to use: 160, 161, or dynamic
+	 */
+	if (!test_and_set_bit(0, &carm_major_alloc))
+		host->major = 160;
+	else if (!test_and_set_bit(1, &carm_major_alloc))
+		host->major = 161;
+	else
+		host->flags |= FL_DYN_MAJOR;
+
+	host->id = carm_host_id;
+	sprintf(host->name, DRV_NAME "%d", carm_host_id);
+
+	rc = register_blkdev(host->major, host->name);
+	if (rc < 0)
+		goto err_out_free_majors;
+	if (host->flags & FL_DYN_MAJOR)
+		host->major = rc;
+
+	for (i = 0; i < CARM_MAX_PORTS; i++) {
+		rc = carm_init_disk(host, i);
+		if (rc)
+			goto err_out_blkdev_disks;
+	}
+
+	pci_set_master(pdev);
+
+	rc = request_irq(pdev->irq, carm_interrupt, IRQF_SHARED, DRV_NAME, host);
+	if (rc) {
+		printk(KERN_ERR DRV_NAME "(%s): irq alloc failure\n",
+		       pci_name(pdev));
+		goto err_out_blkdev_disks;
+	}
+
+	rc = carm_init_host(host);
+	if (rc)
+		goto err_out_free_irq;
+
+	DPRINTK("waiting for probe_comp\n");
+	wait_for_completion(&host->probe_comp);
+
+	printk(KERN_INFO "%s: pci %s, ports %d, io %llx, irq %u, major %d\n",
+	       host->name, pci_name(pdev), (int) CARM_MAX_PORTS,
+	       (unsigned long long)pci_resource_start(pdev, 0),
+		   pdev->irq, host->major);
+
+	carm_host_id++;
+	pci_set_drvdata(pdev, host);
+	return 0;
+
+err_out_free_irq:
+	free_irq(pdev->irq, host);
+err_out_blkdev_disks:
+	for (i = 0; i < CARM_MAX_PORTS; i++)
+		carm_free_disk(host, i);
+	unregister_blkdev(host->major, host->name);
+err_out_free_majors:
+	if (host->major == 160)
+		clear_bit(0, &carm_major_alloc);
+	else if (host->major == 161)
+		clear_bit(1, &carm_major_alloc);
+	blk_cleanup_queue(host->oob_q);
+	blk_mq_free_tag_set(&host->tag_set);
+err_out_dma_free:
+	dma_free_coherent(&pdev->dev, CARM_SHM_SIZE, host->shm, host->shm_dma);
+err_out_iounmap:
+	iounmap(host->mmio);
+err_out_kfree:
+	kfree(host);
+err_out_regions:
+	pci_release_regions(pdev);
+err_out:
+	pci_disable_device(pdev);
+	return rc;
+}
+
+static void carm_remove_one (struct pci_dev *pdev)
+{
+	struct carm_host *host = pci_get_drvdata(pdev);
+	unsigned int i;
+
+	if (!host) {
+		printk(KERN_ERR PFX "BUG: no host data for PCI(%s)\n",
+		       pci_name(pdev));
+		return;
+	}
+
+	free_irq(pdev->irq, host);
+	for (i = 0; i < CARM_MAX_PORTS; i++)
+		carm_free_disk(host, i);
+	unregister_blkdev(host->major, host->name);
+	if (host->major == 160)
+		clear_bit(0, &carm_major_alloc);
+	else if (host->major == 161)
+		clear_bit(1, &carm_major_alloc);
+	blk_cleanup_queue(host->oob_q);
+	blk_mq_free_tag_set(&host->tag_set);
+	dma_free_coherent(&pdev->dev, CARM_SHM_SIZE, host->shm, host->shm_dma);
+	iounmap(host->mmio);
+	kfree(host);
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+}
+
+module_pci_driver(carm_driver);
Index: kernel-rockchip/drivers/char/lcd_vk2c21.c
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/char/lcd_vk2c21.c
@@ -0,0 +1,707 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/mm.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+#include <asm/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/io.h>
+#include <linux/workqueue.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/uaccess.h>
+
+#define LCD_EXT_DEBUG_INFO
+#ifdef LCD_EXT_DEBUG_INFO
+#define DBG_PRINT(...)		printk(__VA_ARGS__)
+#else
+#define DBG_PRINT(...)
+#endif
+#define DEVICE_NAME  "lcd_vk2c21"
+/* ioctrl magic set */
+#define CH455_IOC_MAGIC 'h'
+#define IOCTL_CHAR_DISPLAY 	_IOWR(CH455_IOC_MAGIC, 0x10, unsigned char)
+#define IOCTL_DOT_DISPLAY  	_IOWR(CH455_IOC_MAGIC, 0x11, unsigned char)
+#define IOCTL_COLON_DISPLAY 	_IOWR(CH455_IOC_MAGIC, 0x12, unsigned char)
+#define IOCTL_PWR_DISPLAY	_IOWR(CH455_IOC_MAGIC, 0x13, unsigned char)
+#define IOCTL_LAN_DISPLAY	_IOWR(CH455_IOC_MAGIC, 0x14, unsigned char)
+#define IOCTL_LAN_OFF	_IOWR(CH455_IOC_MAGIC, 0x15, unsigned char)
+#define IOCTL_WIFI_LOW_DISPLAY	_IOWR(CH455_IOC_MAGIC, 0x16, unsigned char)
+#define IOCTL_WIFI_FINE_DISPLAY	_IOWR(CH455_IOC_MAGIC, 0x17, unsigned char)
+#define IOCTL_WIFI_OFF	_IOWR(CH455_IOC_MAGIC, 0x18, unsigned char)
+#define IOCTL_LED_ON		_IOWR(CH455_IOC_MAGIC, 0x19, unsigned char)
+#define	IOCTL_LED_OFF		_IOWR(CH455_IOC_MAGIC, 0x1a, unsigned char)
+
+//
+#define Vk2c21_SCL_H() 				gpio_set_value(gpio_i2c_scl,1)
+#define Vk2c21_SCL_L() 				gpio_set_value(gpio_i2c_scl,0)
+
+#define Vk2c21_SDA_H() 				gpio_set_value(gpio_i2c_sda,1)
+#define Vk2c21_SDA_L() 				gpio_set_value(gpio_i2c_sda,0)
+
+#define Vk2c21_GET_SDA() 			gpio_get_value(gpio_i2c_sda)
+#define Vk2c21_SET_SDA_IN() 		gpio_direction_input(gpio_i2c_sda)
+#define Vk2c21_SET_SDA_OUT() 		gpio_direction_output(gpio_i2c_sda, 1)
+
+static int gpio_i2c_scl,gpio_i2c_sda;
+/**
+******************************************************************************
+* @file    vk2c21.c
+* @author  kevin_guo
+* @version V1.2
+* @date    05-17-2020
+* @brief   This file contains all the vk2c21 functions.
+*           VK2c21
+******************************************************************************
+* @attention
+******************************************************************************
+*/
+#include "lcd_vk2c21.h"
+
+#define VK2c21_CLK 100 //SCL,delay_nus 50->10kHz 10->50kHz 5->100kHz
+//seg
+//4com
+//VK2C21A/B/C/D
+#define 	Vk2c21_SEGNUM				13
+#define 	Vk2c21A_MAXSEGNUM			20
+#define 	Vk2c21B_MAXSEGNUM			16
+#define 	Vk2c21C_MAXSEGNUM			12
+#define 	Vk2c21D_MAXSEGNUM			8
+
+//segtab[]LCD-VK2c21
+//4com
+//Vk2c21A
+unsigned char vk2c21_segtab[Vk2c21_SEGNUM]={
+	18,17,16,15,14,13,12,11,10,
+	9,8,7,6
+};
+
+//4com
+unsigned char vk2c21_dispram[Vk2c21_SEGNUM/2];//4COM2SEG
+//8com
+//unsigned char vk2c21_dispram[Vk2c21_SEGNUM];//8COM1SEG
+
+unsigned char shuzi_zimo[15]= //
+{
+	//0    1    2    3    4    5    6    7    8    9    -    L    o    H    i
+	0xf5,0x05,0xb6,0x97,0x47,0xd3,0xf3,0x85,0xf7,0xd7,0x02,0x70,0x33,0x67,0x50
+};
+unsigned char vk2c21_segi,vk2c21_comi;
+unsigned char vk2c21_maxcom;//comVK2C23A4com8com
+unsigned char vk2c21_maxseg;//Vk2c21A=20 Vk2c21B=16 Vk2c21C=12 Vk2c21D=8
+/* Private function prototypes -----------------------------------------------*/
+unsigned char Vk2c21_InitSequence(void);
+/* Private function ----------------------------------------------------------*/
+
+
+/*******************************************************************************
+* Function Name  : delay_nus
+* Description    : 1uS
+* Input          : n->nuS
+* Output         : None
+* Return         : None
+*******************************************************************************/
+static void delay_nus(unsigned int n)
+{
+	ndelay(n);
+}
+/*******************************************************************************
+* Function Name			  : I2CStart   I2CStop  I2CSlaveAck
+* I2CStart Description    : I2C
+* I2CStop Description	  : I2C
+* I2CSlaveAck Description : I2C
+*******************************************************************************/
+static void Vk2c21_I2CStart( void )
+{
+  Vk2c21_SCL_H();
+  Vk2c21_SDA_H();
+  delay_nus(VK2c21_CLK);
+  Vk2c21_SDA_L();
+  delay_nus(VK2c21_CLK);
+}
+
+static void Vk2c21_I2CStop( void )
+{
+  Vk2c21_SCL_H();
+  Vk2c21_SDA_L();
+  delay_nus(VK2c21_CLK);
+  Vk2c21_SDA_H();
+  delay_nus(VK2c21_CLK);
+}
+
+static unsigned char Vk2c21_I2CSlaveAck( void )
+{
+  unsigned int TimeOut;
+  unsigned char RetValue;
+
+  Vk2c21_SCL_L();
+	//SDAIO
+	Vk2c21_SET_SDA_IN();
+  delay_nus(VK2c21_CLK);
+  Vk2c21_SCL_H();//9sclk
+
+  TimeOut = 10000;
+  while( TimeOut-- > 0 )
+  {
+    if( Vk2c21_GET_SDA()!=0 )//ack
+    {
+      RetValue = 1;
+    }
+    else
+    {
+      RetValue = 0;
+      break;
+    }
+  }
+	Vk2c21_SCL_L();
+	//SDAIO
+	Vk2c21_SET_SDA_OUT();
+  //printk("---%s----ret=%d------\n",__func__,RetValue);
+  return RetValue;
+}
+/*******************************************************************************
+* Function Name  : I2CWriteByte
+* Description    : I2C,
+* Input          : byte-
+* Output         : None
+* Return         : None
+*******************************************************************************/
+static void Vk2c21_I2CWriteByte( unsigned char byte )
+{
+	unsigned char i=8;
+	while (i--)
+	{
+		Vk2c21_SCL_L();
+		if(byte&0x80)
+			Vk2c21_SDA_H();
+		else
+			Vk2c21_SDA_L();
+		byte<<=1;
+		delay_nus(VK2c21_CLK);
+		Vk2c21_SCL_H();
+		delay_nus(VK2c21_CLK);
+	}
+}
+
+/*************************************************************
+*: WriteCmdVk2c21
+*: Vk2C231
+*: addr  Dmod
+           data  
+*SET: RESET:
+*    
+**************************************************************/
+static unsigned char WriteCmdVk2c21(unsigned char cmd, unsigned char data )
+{
+	Vk2c21_I2CStart();
+
+	Vk2c21_I2CWriteByte( Vk2c21_ADDR|0x00 );
+	if( 1 == Vk2c21_I2CSlaveAck() )
+	{
+		Vk2c21_I2CStop();
+		return 0;
+	}
+	Vk2c21_I2CWriteByte( cmd );
+	if( 1 == Vk2c21_I2CSlaveAck() )
+	{
+		Vk2c21_I2CStop();
+		return 0;
+	}
+	Vk2c21_I2CWriteByte( data );
+	if( 1 == Vk2c21_I2CSlaveAck() )
+	{
+		Vk2c21_I2CStop();
+		return 0;
+	}
+  Vk2c21_I2CStop();
+
+  return 0;    //
+}
+/*******************************************************************************
+* Function Name  : Write1Data
+* Description    : 1RAM
+* Input          : Addr-ram
+*                : Dat->ram
+* Output         : None
+* Return         : 0-ok 1-fail
+*******************************************************************************/
+static unsigned char Write1DataVk2c21(unsigned char Addr,unsigned char Dat)
+{
+	//START 
+	Vk2c21_I2CStart();
+	//SLAVE
+	Vk2c21_I2CWriteByte(Vk2c21_ADDR);
+	if( 1 == Vk2c21_I2CSlaveAck() )
+	{
+		Vk2c21_I2CStop();
+		return 1;
+	}
+	//RAM
+	Vk2c21_I2CWriteByte(Vk2c21_RWRAM);
+	if( 1 == Vk2c21_I2CSlaveAck() )
+	{
+		Vk2c21_I2CStop();
+		return 0;
+	}
+	//RAM
+	Vk2c21_I2CWriteByte(Addr);
+	if( 1 == Vk2c21_I2CSlaveAck() )
+	{
+		Vk2c21_I2CStop();
+		return 1;
+	}
+	//12SEG
+	Vk2c21_I2CWriteByte(Dat);
+	if( Vk2c21_I2CSlaveAck()==1 )
+	{
+		Vk2c21_I2CStop();
+		return 1;
+	}
+	//STOP
+ Vk2c21_I2CStop();
+ return 0;
+}
+/*******************************************************************************
+* Function Name  : WritenData
+* Description    : RAM
+* Input          : Addr-ram
+*                : Databuf->rambuffer
+*                : Cnt->ram
+* Output         : None
+* Return         : 0-ok 1-fail
+*******************************************************************************/
+static unsigned char  WritenDataVk2c21(unsigned char Addr,unsigned char *Databuf,unsigned char Cnt)
+{
+	unsigned char n;
+
+	//START
+	Vk2c21_I2CStart();
+	//SLAVE
+	Vk2c21_I2CWriteByte(Vk2c21_ADDR);
+	if( 1 == Vk2c21_I2CSlaveAck() )
+	{
+		Vk2c21_I2CStop();
+		return 0;
+	}
+	//RAM
+	Vk2c21_I2CWriteByte(Vk2c21_RWRAM);
+	if( 1 == Vk2c21_I2CSlaveAck() )
+	{
+		Vk2c21_I2CStop();
+		return 0;
+	}
+	//RAM
+	Vk2c21_I2CWriteByte(Addr);
+	if( 1 == Vk2c21_I2CSlaveAck() )
+	{
+		Vk2c21_I2CStop();
+		return 0;
+	}
+	//CntRAM
+	for(n=0;n<Cnt;n++)
+	{
+		Vk2c21_I2CWriteByte(*Databuf++);
+		if( Vk2c21_I2CSlaveAck()==1 )
+		{
+			Vk2c21_I2CStop();
+			return 0;
+		}
+	}
+	//STOP
+	 Vk2c21_I2CStop();
+	 return 0;
+}
+/*******************************************************************************
+* Function Name  : Vk2c21_DisAll
+* Description    : SEGbit7/bit3-COM3 bit6/bit2-COM2 bit5/bit1-COM1 bit4/bit0-COM0
+* 					     : 0xff 0x00 0x55 0xaa 0x33
+* Input          dat->ram(12SEG)
+* Output         : None
+* Return         : None
+*******************************************************************************/
+static void Vk2c21_DisAll(unsigned char dat)
+{
+	unsigned char segi;
+	unsigned char dispram[16];
+
+	if(vk2c21_maxcom==4)
+	{
+		for(segi=0;segi<10;segi++)
+		{
+			dispram[segi]=dat;
+		}
+		WritenDataVk2c21(0,dispram,10);//8bit2SEG8bit181ACK
+	}
+	else
+	{
+		for(segi=0;segi<16;segi++)
+		{
+			dispram[segi]=dat;
+		}
+		WritenDataVk2c21(0,dispram,16);//8bit1SEG8bit181ACK
+	}
+}
+/*******************************************************************************
+* Function Name  : DisSegComOn
+* Description    : 1(1seg1com)
+* Input          seg->seg
+* 		           com->com
+* Output         : None
+* Return         : None
+*******************************************************************************/
+static void Vk2c21_DisSegComOn(unsigned char seg,unsigned char com)
+{
+	if(vk2c21_maxcom==4)
+	{
+		if(seg%2==0)
+			Write1DataVk2c21(seg/2,(1<<(com)));//84bit8bit181ACK)
+		else
+			Write1DataVk2c21(seg/2,(1<<(4+com)));//84bit8bit181ACK
+	}
+	else
+	{
+		Write1DataVk2c21(seg,(1<<(com)));//84bit8bit181ACK
+	}
+}
+/*******************************************************************************
+* Function Name  : DisSegComOff
+* Description    : 1(1seg1com)
+* Input          seg->seg
+* 		           com->com
+* Output         : None
+* Return         : None
+*******************************************************************************/
+static void Vk2c21_DisSegComOff(unsigned char seg,unsigned char com)
+{
+	if(vk2c21_maxcom==4)
+	{
+		if(seg%2==0)
+			Write1DataVk2c21(seg/2,~(1<<com));//84bit8bit181ACK
+		else
+			Write1DataVk2c21(seg/2,~(1<<(4+com)));//84bit8bit181ACK
+	}
+	else
+	{
+		Write1DataVk2c21(seg,~(1<<com));//84bit8bit181ACK
+	}
+}
+
+static void disp_3num(unsigned int dat)
+{
+	unsigned dat8;
+
+	if(vk2c21_maxcom==4)
+	{
+		dat8=dat/100%10;	//
+		vk2c21_dispram[0]&=0xf0;
+		vk2c21_dispram[0]|=shuzi_zimo[dat8]&0x0f;
+		vk2c21_dispram[0]&=0x8f;
+		vk2c21_dispram[0]|=shuzi_zimo[dat8]&0xf0;
+
+		dat8=dat/10%10; 	//
+		vk2c21_dispram[1]&=0xf0;
+		vk2c21_dispram[1]|=shuzi_zimo[dat8]&0x0f;
+		vk2c21_dispram[1]&=0x8f;
+		vk2c21_dispram[1]|=shuzi_zimo[dat8]&0xf0;
+
+		dat8=dat%10;			//
+		vk2c21_dispram[2]&=0xf0;
+		vk2c21_dispram[2]|=shuzi_zimo[dat8]&0x0f;
+		vk2c21_dispram[2]&=0x8f;
+		vk2c21_dispram[2]|=shuzi_zimo[dat8]&0xf0;
+
+		if(dat<100)				//100
+		{
+			vk2c21_dispram[0]&=0xf0;
+			vk2c21_dispram[0]&=0x8f;
+		}
+		if(dat<10) 	//10
+		{
+			vk2c21_dispram[1]&=0xf0;
+			vk2c21_dispram[1]&=0x8f;
+		}
+		//SEG11
+		Write1DataVk2c21(vk2c21_segtab[2]/2,vk2c21_dispram[0]);
+		Write1DataVk2c21(vk2c21_segtab[4]/2,vk2c21_dispram[1]);
+		Write1DataVk2c21(vk2c21_segtab[6]/2,vk2c21_dispram[2]);
+		Write1DataVk2c21(vk2c21_segtab[8]/2,vk2c21_dispram[0]);
+		Write1DataVk2c21(vk2c21_segtab[10]/2,vk2c21_dispram[1]);
+		Write1DataVk2c21(vk2c21_segtab[12]/2,vk2c21_dispram[2]);
+		//SEG
+	}
+	else
+	{
+		dat8=dat/100%10;	//
+		vk2c21_dispram[8]&=0x80;
+		vk2c21_dispram[8]|=shuzi_zimo[dat8];
+
+		dat8=dat/10%10; 	//
+		vk2c21_dispram[9]&=0x80;
+		vk2c21_dispram[9]|=shuzi_zimo[dat8];
+
+		dat8=dat%10;			//
+		vk2c21_dispram[15]&=0x80;
+		vk2c21_dispram[15]|=shuzi_zimo[dat8];
+
+		if(dat<100)				//100
+		{
+			vk2c21_dispram[8]&=0x80;
+		}
+		if(dat<10) 	//10
+		{
+			vk2c21_dispram[9]&=0x80;
+		}
+		//SEG11
+		Write1DataVk2c21(8,vk2c21_dispram[8]);
+		Write1DataVk2c21(9,vk2c21_dispram[9]);
+		Write1DataVk2c21(15,vk2c21_dispram[15]);
+		//SEG
+	}
+}
+
+/*******************************************************************************
+* Function Name  : Init
+* Description    : 
+* Input          None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+static int Vk2c21_Init(void)
+{
+	int ret=0;
+	WriteCmdVk2c21(Vk2c21_MODESET,CCOM_1_3__4); 	//  1/3 Bais 1/4 Duty
+	//WriteCmdVk2c21(Vk2c21_MODESET,CCOM_1_4__4); //  1/4 Bais 1/4 Duty
+	vk2c21_maxcom=4;
+	vk2c21_maxseg=Vk2c21A_MAXSEGNUM;//Vk2c21A=20 Vk2c21B=16 Vk2c21C=12 Vk2c21D=8
+//	WriteCmdVk2c21(Vk2c21_MODESET,CCOM_1_3__8); //  1/3 Bais 1/8 Duty
+//	WriteCmdVk2c21(Vk2c21_MODESET,CCOM_1_4__8); //  1/4 Bais 1/8 Duty
+//	vk2c21_maxcom=8;
+//	vk2c21_maxseg=Vk2c21A_MAXSEGNUM;//Vk2c21A=16 Vk2c21B=12 Vk2c21C=8 Vk2c21D=4
+	WriteCmdVk2c21(Vk2c21_SYSSET,SYSON_LCDON); 		//lcd
+	WriteCmdVk2c21(Vk2c21_FRAMESET,FRAME_80HZ); 	//80Hz
+//	WriteCmdVk2c21(Vk2c21_FRAMESET,FRAME_160HZ);//160Hz
+	WriteCmdVk2c21(Vk2c21_BLINKSET,BLINK_OFF); 		//
+//	WriteCmdVk2c21(Vk2c21_BLINKSET,BLINK_2HZ); 		//2HZ
+//	WriteCmdVk2c21(Vk2c21_BLINKSET,BLINK_1HZ); 		//1HZ
+//	WriteCmdVk2c21(Vk2c21_BLINKSET,BLINK_0D5HZ); 	//0.5HZ
+	//SEG/VLCDVLCD,VLCDVDDVR=0=VDD
+	//WriteCmdVk2c21(Vk2c21_IVASET,VLCDSEL_IVAOFF_R0);
+	//SEG/VLCDVLCD,VLCDVDDVR>0=VLCD
+	WriteCmdVk2c21(Vk2c21_IVASET,VLCDSEL_IVAOFF_R1);
+	//SEG/VLCDSEG1/3bias=0.652VDD 1/4bias=0.714VDD
+	//WriteCmdVk2c21(Vk2c21_IVASET,SEGSEL_IVA02H);
+
+	//test
+	Vk2c21_DisAll(0x00);
+	disp_3num(456);
+	//Vk2c21_DisAll(0xff);			//LCD
+	//disp_3num(1234);
+	return ret;
+}
+
+static int Vk2c21_open(struct inode *inode, struct file *file)
+{
+	int ret;
+	ret = nonseekable_open(inode, file);
+	if(ret < 0)
+		return ret;
+	return 0;
+}
+
+static int Vk2c21_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static long Vk2c21_ioctl(struct file *file, unsigned int cmd, unsigned long args)
+{
+	int ret = 0 , i=0,pos_temp=0;
+	void __user *argp = (void __user *)args;
+	unsigned char display_arg[6]={0};
+	switch (cmd){
+		case IOCTL_CHAR_DISPLAY:
+			if (args) {
+				ret = copy_from_user(display_arg, argp,sizeof(display_arg)/sizeof(display_arg[0]));
+			}
+			for(i=0;i<6;i++)
+			{
+				if(display_arg[i] <= '9' && display_arg[i] >= '0')
+				{
+					pos_temp = display_arg[i] - '0';
+					vk2c21_dispram[i]&=0xf0;
+					vk2c21_dispram[i]|=shuzi_zimo[pos_temp]&0x0f;
+					vk2c21_dispram[i]&=0x8f;
+					vk2c21_dispram[i]|=shuzi_zimo[pos_temp]&0xf0;
+					Write1DataVk2c21(vk2c21_segtab[2*i+2]/2,vk2c21_dispram[i]);
+				}else if(display_arg[i] <= 'z' && display_arg[i] >= 'a'){
+				}else if(display_arg[i] <= 'Z' && display_arg[i] >= 'A'){
+				}
+			}
+			break;
+		case IOCTL_DOT_DISPLAY:
+			break;
+		case IOCTL_COLON_DISPLAY:
+			break;
+		case IOCTL_PWR_DISPLAY:
+			break;
+		case IOCTL_LAN_DISPLAY:
+			Vk2c21_DisSegComOn(vk2c21_segtab[6],0x1);
+			break;
+		case IOCTL_LAN_OFF:
+			Vk2c21_DisSegComOff(vk2c21_segtab[6],0x1);
+			break;
+		case IOCTL_WIFI_LOW_DISPLAY:
+			break;
+		case IOCTL_WIFI_FINE_DISPLAY:
+			break;
+		case IOCTL_WIFI_OFF:
+			break;
+		case IOCTL_LED_ON:
+			Vk2c21_DisAll(0xff);			//LCD
+			break;
+		case IOCTL_LED_OFF:
+			Vk2c21_DisAll(0x00);			//LCD
+			break;
+		default:
+			printk("ERROR: IOCTL CMD NOT FOUND!!!\n");
+			break;
+	}
+	return 0;
+}
+static struct file_operations Vk2c21_fops ={
+	.owner =THIS_MODULE,
+	.open  =Vk2c21_open,
+	.release =Vk2c21_release,
+	.unlocked_ioctl =Vk2c21_ioctl,
+};
+
+
+
+static int Vk2c21_probe(struct platform_device *pdev)
+{
+	static struct class * scull_class;
+	struct device_node *node = pdev->dev.of_node;
+	enum of_gpio_flags flags;
+	int ret;
+
+	ret =register_chrdev(0,DEVICE_NAME,&Vk2c21_fops);
+	if(ret<0){
+		printk("can't register device lcd_vk2c21.\n");
+		return ret;
+	}
+	printk("register device lcd_vk2c21 success.\n");
+
+	scull_class = class_create(THIS_MODULE,DEVICE_NAME);
+	if(IS_ERR(scull_class))
+	{
+		printk(KERN_ALERT "Err:faile in scull_class!\n");
+		return -1;
+	}
+	device_create(scull_class, NULL, MKDEV(ret,0), NULL, DEVICE_NAME);
+
+
+	//---------------------------
+	gpio_i2c_scl = of_get_named_gpio_flags(node, "i2c_scl", 0, &flags);
+	if (gpio_is_valid(gpio_i2c_scl)){
+		if (gpio_request(gpio_i2c_scl, "i2c_scl_gpio")<0) {
+			printk("%s: failed to get gpio_i2c_scl.\n", __func__);
+			return -1;
+		}
+		gpio_direction_output(gpio_i2c_scl, 1);
+		printk("%s: get property: gpio,i2c_scl = %d\n", __func__, gpio_i2c_scl);
+	}else{
+		printk("get property gpio,i2c vk2c21 failed \n");
+		return -1;
+	}
+
+	gpio_i2c_sda = of_get_named_gpio_flags(node, "i2c_sda", 0, &flags);
+
+	if (gpio_is_valid(gpio_i2c_sda)){
+		if (gpio_request(gpio_i2c_sda, "i2c_sda_gpio")<0) {
+			printk("%s: failed to get gpio_i2c_sda.\n", __func__);
+			return -1;
+		}
+		gpio_direction_output(gpio_i2c_sda, 1);
+		printk("%s: get property: gpio,i2c_sda = %d\n", __func__, gpio_i2c_sda);
+	}else{
+		printk("get property gpio,i2c vk2c21 failed \n");
+		return -1;
+	}
+
+	printk("==========%s probe ok========\n", DEVICE_NAME);
+
+	ret = Vk2c21_Init();
+	if(ret < 0)
+		return -1;
+
+
+	return 0;
+}
+
+static int Vk2c21_remove(struct platform_device *pdev)
+{
+	unregister_chrdev(0,DEVICE_NAME);
+	return 0;
+}
+
+
+static void Vk2c21_shutdown (struct platform_device *pdev)
+{
+		WriteCmdVk2c21(Vk2c21_SYSSET,SYSOFF_LCDOFF);
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id Vk2c21_dt_match[]={
+	{ .compatible = "lcd_vk2c21",},
+	{}
+};
+MODULE_DEVICE_TABLE(of, Vk2c21_dt_match);
+#endif
+
+static struct platform_driver Vk2c21_driver = {
+	.probe  = Vk2c21_probe,
+	.remove = Vk2c21_remove,
+	.shutdown     = Vk2c21_shutdown,
+	.driver = {
+		.name  = DEVICE_NAME,
+		.owner = THIS_MODULE,
+#ifdef CONFIG_OF
+		.of_match_table = of_match_ptr(Vk2c21_dt_match),
+#endif
+	},
+};
+
+
+static int __init led_vk2c21_init(void)
+{
+	int ret;
+	DBG_PRINT("%s\n=============================================\n", __FUNCTION__);
+	ret = platform_driver_register(&Vk2c21_driver);
+	if (ret) {
+		printk("[error] %s failed to register vk2c21 driver module\n", __FUNCTION__);
+		return -ENODEV;
+	}
+	return ret;
+}
+
+static void __exit led_vk2c21_exit(void)
+{
+	platform_driver_unregister(&Vk2c21_driver);
+}
+
+module_init(led_vk2c21_init);
+module_exit(led_vk2c21_exit);
+
+MODULE_AUTHOR("Hugsun");
+MODULE_DESCRIPTION("LCD Extern driver for lcd_vk2c21");
+MODULE_LICENSE("GPL");
Index: kernel-rockchip/drivers/char/lcd_vk2c21.h
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/char/lcd_vk2c21.h
@@ -0,0 +1,63 @@
+#ifndef __LCD_VK2C21_H__
+#define __LCD_VK2C21_H__
+
+#define Vk2c21_ADDR   			0x70    // IIC
+//
+#define Vk2c21_RWRAM				0x80    // RAM
+#define Vk2c21_MODESET		  0x82    // BIAS,COM
+#define CCOM_1_3__4 			0x00  	// 1/3bias 4com
+#define CCOM_1_4__4 			0x01  	// 1/4bias 4com
+#define CCOM_1_3__8 			0x02  	// 1/3bias 8com
+#define CCOM_1_4__8 			0x03  	// 1/4bias 8com
+#define Vk2c21_SYSSET				0x84    // IRC,LCD
+#define SYSOFF_LCDOFF  		0x00  	// IRC off,LCD off
+#define SYSON_LCDOFF  		0x02  	// IRC on,LCD off
+#define SYSON_LCDON  			0x03  	// IRC on,LCD on
+#define Vk2c21_FRAMESET			0x86    // 
+#define FRAME_80HZ  			0x00  	// 80HZ
+#define FRAME_160HZ  			0x01  	// 160HZ
+#define Vk2c21_BLINKSET			0x88    // 
+#define BLINK_OFF  				0x00  	// 
+#define BLINK_2HZ  				0x01  	// 2HZ
+#define BLINK_1HZ  				0x02  	// 1HZ
+#define BLINK_0D5HZ  			0x03  	// 0.5HZ
+#define Vk2c21_IVASET				0x8A    // SEG/VLCD
+#define VLCDSEL_IVAOFF_R0 0x00  	// SEG/VLCDVLCD,VLCDVDDVR=0=VDD
+#define VLCDSEL_IVAOFF_R1 0x0F  	// SEG/VLCDVLCD,VLCDVDDVR>0=VLCD
+
+#define VLCDSEL_IVA00H 		0x10  	// SEG/VLCDVLCD1/3bias=VDD 			1/4bias=VDD
+#define VLCDSEL_IVA01H 		0x11  	// SEG/VLCDVLCD1/3bias=0.944VDD 1/4bias=0.957VDD
+#define VLCDSEL_IVA02H 		0x12  	// SEG/VLCDVLCD1/3bias=0.894VDD 1/4bias=0.918VDD
+#define VLCDSEL_IVA03H 		0x13  	// SEG/VLCDVLCD1/3bias=0.849VDD 1/4bias=0.882VDD
+#define VLCDSEL_IVA04H 		0x14  	// SEG/VLCDVLCD1/3bias=0.808VDD 1/4bias=0.849VDD
+#define VLCDSEL_IVA05H 		0x15  	// SEG/VLCDVLCD1/3bias=0.771VDD 1/4bias=0.818VDD
+#define VLCDSEL_IVA06H 		0x16  	// SEG/VLCDVLCD1/3bias=0.738VDD 1/4bias=0.789VDD
+#define VLCDSEL_IVA07H 		0x17  	// SEG/VLCDVLCD1/3bias=0.707VDD 1/4bias=0.763VDD
+#define VLCDSEL_IVA08H 		0x18  	// SEG/VLCDVLCD1/3bias=0.678VDD 1/4bias=0.738VDD
+#define VLCDSEL_IVA09H 		0x19  	// SEG/VLCDVLCD1/3bias=0.652VDD 1/4bias=0.714VDD
+#define VLCDSEL_IVA0AH 		0x1A  	// SEG/VLCDVLCD1/3bias=0.628VDD 1/4bias=0.692VDD
+#define VLCDSEL_IVA0BH 		0x1B  	// SEG/VLCDVLCD1/3bias=0.605VDD 1/4bias=0.672VDD
+#define VLCDSEL_IVA0CH 		0x1C  	// SEG/VLCDVLCD1/3bias=0.584VDD 1/4bias=0.652VDD
+#define VLCDSEL_IVA0DH 		0x1D  	// SEG/VLCDVLCD1/3bias=0.565VDD 1/4bias=0.634VDD
+#define VLCDSEL_IVA0EH 		0x1E  	// SEG/VLCDVLCD1/3bias=0.547VDD 1/4bias=0.616VDD
+#define VLCDSEL_IVA0FH 		0x1F  	// SEG/VLCDVLCD1/3bias=0.529VDD 1/4bias=0.600VDD
+
+#define SEGSEL_IVAOFF			0x20  	// SEG/VLCDSEG,VDD
+#define SEGSEL_IVA00H 		0x30  	// SEG/VLCDSEG1/3bias=VDD 			1/4bias=VDD
+#define SEGSEL_IVA01H 		0x31  	// SEG/VLCDSEG1/3bias=0.944VDD 1/4bias=0.957VDD
+#define SEGSEL_IVA02H 		0x32  	// SEG/VLCDSEG1/3bias=0.894VDD 1/4bias=0.918VDD
+#define SEGSEL_IVA03H 		0x33  	// SEG/VLCDSEG1/3bias=0.849VDD 1/4bias=0.882VDD
+#define SEGSEL_IVA04H 		0x34  	// SEG/VLCDSEG1/3bias=0.808VDD 1/4bias=0.849VDD
+#define SEGSEL_IVA05H 		0x35  	// SEG/VLCDSEG1/3bias=0.771VDD 1/4bias=0.818VDD
+#define SEGSEL_IVA06H 		0x36  	// SEG/VLCDSEG1/3bias=0.738VDD 1/4bias=0.789VDD
+#define SEGSEL_IVA07H 		0x37  	// SEG/VLCDSEG1/3bias=0.707VDD 1/4bias=0.763VDD
+#define SEGSEL_IVA08H 		0x38  	// SEG/VLCDSEG1/3bias=0.678VDD 1/4bias=0.738VDD
+#define SEGSEL_IVA09H 		0x39  	// SEG/VLCDSEG1/3bias=0.652VDD 1/4bias=0.714VDD
+#define SEGSEL_IVA0AH 		0x3A  	// SEG/VLCDSEG1/3bias=0.628VDD 1/4bias=0.692VDD
+#define SEGSEL_IVA0BH 		0x3B  	// SEG/VLCDSEG1/3bias=0.605VDD 1/4bias=0.672VDD
+#define SEGSEL_IVA0CH 		0x3C  	// SEG/VLCDSEG1/3bias=0.584VDD 1/4bias=0.652VDD
+#define SEGSEL_IVA0DH 		0x3D  	// SEG/VLCDSEG1/3bias=0.565VDD 1/4bias=0.634VDD
+#define SEGSEL_IVA0EH 		0x3E  	// SEG/VLCDSEG1/3bias=0.547VDD 1/4bias=0.616VDD
+#define SEGSEL_IVA0FH 		0x3F  	// SEG/VLCDSEG1/3bias=0.529VDD 1/4bias=0.600VDD
+
+#endif
Index: kernel-rockchip/drivers/char/Makefile
===================================================================
--- kernel-rockchip.orig/drivers/char/Makefile
+++ kernel-rockchip/drivers/char/Makefile
@@ -47,3 +47,4 @@ obj-$(CONFIG_PS3_FLASH)		+= ps3flash.o
 obj-$(CONFIG_XILLYBUS)		+= xillybus/
 obj-$(CONFIG_POWERNV_OP_PANEL)	+= powernv-op-panel.o
 obj-$(CONFIG_ADI)		+= adi.o
+obj-y += lcd_vk2c21.o
Index: kernel-rockchip/drivers/extcon/Kconfig
===================================================================
--- kernel-rockchip.orig/drivers/extcon/Kconfig
+++ kernel-rockchip/drivers/extcon/Kconfig
@@ -186,4 +186,14 @@ config EXTCON_USBC_CROS_EC
 	  Say Y here to enable USB Type C cable detection extcon support when
 	  using Chrome OS EC based USB Type-C ports.
 
+config EXTCON_USBC_VIRTUAL_PD
+  tristate "Virtual Type-C PD EXTCON support"
+  depends on GPIOLIB || COMPILE_TEST
+  help
+    Say Y here to enable Virtual Type-C PD extcon driver support, if
+    hardware platform designed Type-C modes separately.
+
+    Example, of designing Display Port separately from Type-C Altmode
+    instead of accessing Altmode Display Port in Type-C connector.
+
 endif
Index: kernel-rockchip/drivers/extcon/Makefile
===================================================================
--- kernel-rockchip.orig/drivers/extcon/Makefile
+++ kernel-rockchip/drivers/extcon/Makefile
@@ -25,3 +25,4 @@ obj-$(CONFIG_EXTCON_RT8973A)	+= extcon-r
 obj-$(CONFIG_EXTCON_SM5502)	+= extcon-sm5502.o
 obj-$(CONFIG_EXTCON_USB_GPIO)	+= extcon-usb-gpio.o
 obj-$(CONFIG_EXTCON_USBC_CROS_EC) += extcon-usbc-cros-ec.o
+obj-$(CONFIG_EXTCON_USBC_VIRTUAL_PD) += extcon-pd-virtual.o
Index: kernel-rockchip/drivers/extcon/extcon-pd-virtual.c
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/extcon/extcon-pd-virtual.c
@@ -0,0 +1,429 @@
+/*
+ * Copyright (c) 2016, Fuzhou Rockchip Electronics Co., Ltd
+ * Copyright (c) 2019 Radxa Limited
+ * Copyright (c) 2019 Amarula Solutions(India)
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/extcon-provider.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/regulator/consumer.h>
+
+struct virtual_pd {
+	struct extcon_dev *extcon;
+	struct gpio_desc *gpio_irq;
+	struct regulator *dp_pwr;
+	struct device *dev;
+	bool flip;
+	bool usb_ss;
+	bool enable;
+	u8 mode;
+	int irq;
+	int enable_irq;
+	u8 plug_state;
+	struct workqueue_struct *virtual_pd_wq;
+	spinlock_t irq_lock;
+	struct delayed_work irq_work;
+	int shake_lev;
+};
+
+static const unsigned int vpd_cable[] = {
+	EXTCON_USB,
+	EXTCON_USB_HOST,
+	EXTCON_USB_VBUS_EN,
+	EXTCON_CHG_USB_SDP,
+	EXTCON_CHG_USB_CDP,
+	EXTCON_CHG_USB_DCP,
+/*
+  FIXME: There's no real pd phy, control the charging is very
+  dangerous, just rely on the BC detection. We don't use slow
+  and fast.
+*/
+	EXTCON_CHG_USB_SLOW,
+	EXTCON_CHG_USB_FAST,
+	EXTCON_DISP_DP,
+	EXTCON_NONE,
+};
+
+enum vpd_mode {
+	VPD_DFP = 0,
+	VPD_UFP,
+	VPD_DP,
+	VPD_DP_UFP,
+};
+
+static void vpd_set_vbus_enable(struct virtual_pd *vpd, bool enable)
+{
+	extcon_set_state(vpd->extcon, EXTCON_USB_VBUS_EN, enable);
+	extcon_sync(vpd->extcon, EXTCON_USB_VBUS_EN);
+}
+
+static void vpd_extcon_notify(struct virtual_pd *vpd, bool flip, bool usb_ss,
+			      bool dfp, bool ufp, bool dp)
+{
+	union extcon_property_value property;
+
+	property.intval = flip;
+	extcon_set_property(vpd->extcon, EXTCON_USB,
+			    EXTCON_PROP_USB_TYPEC_POLARITY, property);
+	extcon_set_property(vpd->extcon, EXTCON_USB_HOST,
+			    EXTCON_PROP_USB_TYPEC_POLARITY, property);
+	extcon_set_property(vpd->extcon, EXTCON_DISP_DP,
+			    EXTCON_PROP_USB_TYPEC_POLARITY, property);
+
+	property.intval = usb_ss;
+	extcon_set_property(vpd->extcon, EXTCON_USB,
+			    EXTCON_PROP_USB_SS, property);
+	extcon_set_property(vpd->extcon, EXTCON_USB_HOST,
+			    EXTCON_PROP_USB_SS, property);
+	extcon_set_property(vpd->extcon, EXTCON_DISP_DP,
+			    EXTCON_PROP_USB_SS, property);
+	extcon_set_state(vpd->extcon, EXTCON_USB, ufp);
+	extcon_set_state(vpd->extcon, EXTCON_USB_HOST, dfp);
+	extcon_set_state(vpd->extcon, EXTCON_DISP_DP, dp);
+	extcon_sync(vpd->extcon, EXTCON_USB);
+	extcon_sync(vpd->extcon, EXTCON_USB_HOST);
+	extcon_sync(vpd->extcon, EXTCON_DISP_DP);
+}
+
+static void vpd_extcon_notify_set(struct virtual_pd *vpd)
+{
+	bool flip = vpd->flip, usb_ss = vpd->usb_ss;
+	bool dfp = 0, ufp = 0, dp = 0;
+
+	switch (vpd->mode) {
+	case VPD_DFP:
+		dfp = 1;
+		break;
+	case VPD_DP:
+		dp = 1;
+		dfp = 1;
+		break;
+	case VPD_DP_UFP:
+		dp = 1;
+		ufp = 1;
+		break;
+	case VPD_UFP:
+		/* fall through */
+	default:
+		ufp = 1;
+		break;
+	}
+
+	vpd_set_vbus_enable(vpd, !ufp);
+	vpd_extcon_notify(vpd, flip, usb_ss, dfp, ufp, dp);
+}
+
+static void vpd_extcon_notify_clr(struct virtual_pd *vpd)
+{
+	vpd_set_vbus_enable(vpd, 0);
+	vpd_extcon_notify(vpd, vpd->flip, vpd->usb_ss, 0, 0, 0);
+}
+
+void vpd_irq_disable(struct virtual_pd *vpd)
+{
+	unsigned long irqflags = 0;
+
+	spin_lock_irqsave(&vpd->irq_lock, irqflags);
+	if (!vpd->enable_irq) {
+		disable_irq_nosync(vpd->irq);
+		vpd->enable_irq = 1;
+	} else {
+		dev_warn(vpd->dev, "irq have already disabled\n");
+	}
+	spin_unlock_irqrestore(&vpd->irq_lock, irqflags);
+}
+
+void vpd_irq_enable(struct virtual_pd *vpd)
+{
+	unsigned long irqflags = 0;
+
+	spin_lock_irqsave(&vpd->irq_lock, irqflags);
+	if (vpd->enable_irq) {
+		enable_irq(vpd->irq);
+		vpd->enable_irq = 0;
+	}
+	spin_unlock_irqrestore(&vpd->irq_lock, irqflags);
+}
+
+static void extcon_pd_delay_irq_work(struct work_struct *work)
+{
+	struct virtual_pd *vpd =
+		container_of(work, struct virtual_pd, irq_work.work);
+	int lev;
+
+	lev = gpiod_get_raw_value(vpd->gpio_irq);
+
+	if (vpd->shake_lev != lev) {
+		vpd_irq_enable(vpd);
+		return;
+	}
+
+    switch (vpd->plug_state) {
+		case 1:
+			if (lev == 0) {
+				vpd->enable = false;
+				vpd_extcon_notify_clr(vpd);
+				vpd->plug_state=0;
+			}
+			break;
+		case 0:
+			if (lev == 1) {
+				vpd->enable = true;
+				vpd_extcon_notify_set(vpd);
+				vpd->plug_state=1;
+			}
+			break;
+		default:
+			break;
+	}
+	vpd_irq_enable(vpd);
+}
+
+static irqreturn_t dp_det_irq_handler(int irq, void *dev_id)
+{
+    struct virtual_pd *vpd = dev_id;
+	int lev;
+	lev = gpiod_get_raw_value(vpd->gpio_irq);
+	vpd->shake_lev = lev;
+	schedule_delayed_work(&vpd->irq_work, msecs_to_jiffies(10));
+	vpd_irq_disable(vpd);
+	return IRQ_HANDLED;
+}
+
+static void vpd_extcon_init(struct virtual_pd *vpd)
+{
+	struct device *dev = vpd->dev;
+	u32 tmp = 0;
+	int ret = 0;
+
+	ret = device_property_read_u32(dev, "vpd,init-flip", &tmp);
+	if (ret < 0)
+		vpd->flip = 0;
+	else
+		vpd->flip = tmp;
+	dev_dbg(dev, "init-flip = %d\n", vpd->flip);
+
+	ret = device_property_read_u32(dev, "vpd,init-ss", &tmp);
+	if (ret < 0)
+		vpd->usb_ss = 0;
+	else
+		vpd->usb_ss = tmp;
+	dev_dbg(dev, "init-ss = %d\n", vpd->usb_ss);
+
+	ret = device_property_read_u32(dev, "vpd,init-mode", &tmp);
+	if (ret < 0)
+		vpd->mode = 0;
+	else
+		vpd->mode = tmp;
+	dev_dbg(dev, "init-mode = %d\n", vpd->mode);
+
+	if(gpiod_get_raw_value(vpd->gpio_irq)) {
+		vpd_extcon_notify_set(vpd);
+		vpd->plug_state=1;
+	}
+}
+
+static int vpd_extcon_probe(struct platform_device *pdev)
+{
+	struct virtual_pd *vpd;
+	struct device *dev = &pdev->dev;
+	int ret = 0;
+
+	dev_info(dev, "probe start\n");
+
+	vpd = devm_kzalloc(dev, sizeof(*vpd), GFP_KERNEL);
+	if (!vpd)
+		return -ENOMEM;
+
+	vpd->dev = dev;
+	dev_set_drvdata(dev, vpd);
+	vpd->enable = 1;
+
+	vpd->extcon = devm_extcon_dev_allocate(dev, vpd_cable);
+	if (IS_ERR(vpd->extcon)) {
+		dev_err(dev, "allocat extcon failed\n");
+		return PTR_ERR(vpd->extcon);
+	}
+
+	ret = devm_extcon_dev_register(dev, vpd->extcon);
+	if (ret) {
+		dev_err(dev, "register extcon failed: %d\n", ret);
+		return ret;
+	}
+
+	vpd->gpio_irq = devm_gpiod_get_optional(dev,"hpd", GPIOD_IN);
+	if (IS_ERR(vpd->gpio_irq)) {
+		dev_warn(dev, "maybe miss named GPIO for hpd\n");
+		vpd->gpio_irq = NULL;
+	}
+
+	vpd->dp_pwr = devm_regulator_get_optional(dev, "dp-pwr");
+	if (IS_ERR(vpd->dp_pwr)) {
+		dev_warn(dev, "failed to get dp-pwr\n");
+		vpd->dp_pwr = NULL;
+	}
+
+	ret = regulator_enable(vpd->dp_pwr);
+	if (ret)
+		dev_warn(dev, "failed to enable dp-pwr\n");
+
+	ret = extcon_set_property_capability(vpd->extcon, EXTCON_USB,
+					     EXTCON_PROP_USB_TYPEC_POLARITY);
+	if (ret) {
+		dev_err(dev,
+			"set USB property capability failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = extcon_set_property_capability(vpd->extcon, EXTCON_USB_HOST,
+					     EXTCON_PROP_USB_TYPEC_POLARITY);
+	if (ret) {
+		dev_err(dev,
+			"set USB_HOST property capability failed: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = extcon_set_property_capability(vpd->extcon, EXTCON_DISP_DP,
+					     EXTCON_PROP_USB_TYPEC_POLARITY);
+	if (ret) {
+		dev_err(dev,
+			"set DISP_DP property capability failed: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = extcon_set_property_capability(vpd->extcon, EXTCON_USB,
+					     EXTCON_PROP_USB_SS);
+	if (ret) {
+		dev_err(dev,
+			"set USB USB_SS property capability failed: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = extcon_set_property_capability(vpd->extcon, EXTCON_USB_HOST,
+					     EXTCON_PROP_USB_SS);
+	if (ret) {
+		dev_err(dev,
+			"set USB_HOST USB_SS property capability failed: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = extcon_set_property_capability(vpd->extcon, EXTCON_DISP_DP,
+					     EXTCON_PROP_USB_SS);
+	if (ret) {
+		dev_err(dev,
+			"set DISP_DP USB_SS property capability failed: %d\n",
+			ret);
+		return ret;
+	}
+
+	ret = extcon_set_property_capability(vpd->extcon, EXTCON_CHG_USB_FAST,
+					     EXTCON_PROP_USB_TYPEC_POLARITY);
+	if (ret) {
+		dev_err(dev,
+			"set USB_PD property capability failed: %d\n", ret);
+		return ret;
+	}
+
+	vpd_extcon_init(vpd);
+	INIT_DELAYED_WORK(&vpd->irq_work, extcon_pd_delay_irq_work);
+
+	vpd->irq=gpiod_to_irq(vpd->gpio_irq);
+	if (vpd->irq){
+		ret = devm_request_threaded_irq(dev,
+                        vpd->irq,
+                        NULL,
+                        dp_det_irq_handler,
+                        IRQF_TRIGGER_FALLING |IRQF_TRIGGER_RISING | IRQF_ONESHOT ,
+                        NULL,
+                        vpd);
+	}
+	else
+		dev_err(dev,"gpio can not be irq !\n");
+
+	vpd->virtual_pd_wq = create_workqueue("virtual_pd_wq");
+
+	dev_info(dev, "probe success\n");
+
+	return 0;
+}
+
+static int vpd_extcon_remove(struct platform_device *pdev)
+{
+	struct virtual_pd *vpd = platform_get_drvdata(pdev);
+
+	regulator_disable(vpd->dp_pwr);
+	return 0;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int vpd_extcon_suspend(struct device *dev)
+{
+	struct virtual_pd *vpd = dev_get_drvdata(dev);
+
+	int lev=0;
+	lev = gpiod_get_raw_value(vpd->gpio_irq);
+	cancel_delayed_work_sync(&vpd->irq_work);
+	vpd_irq_disable(vpd);
+	return 0;
+}
+
+static int vpd_extcon_resume(struct device *dev)
+{
+	struct virtual_pd *vpd = dev_get_drvdata(dev);
+	vpd_irq_enable(vpd);
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(vpd_extcon_pm_ops,
+			 vpd_extcon_suspend, vpd_extcon_resume);
+
+static const struct of_device_id vpd_extcon_dt_match[] = {
+	{ .compatible = "linux,extcon-pd-virtual", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, vpd_extcon_dt_match);
+
+static struct platform_driver vpd_extcon_driver = {
+	.probe		= vpd_extcon_probe,
+	.remove		= vpd_extcon_remove,
+	.driver		= {
+		.name	= "extcon-pd-virtual",
+		.pm	= &vpd_extcon_pm_ops,
+		.of_match_table = vpd_extcon_dt_match,
+	},
+};
+
+static int __init __vpd_extcon_init(void)
+{
+	return platform_driver_register(&vpd_extcon_driver);
+}
+
+static void __exit __vpd_extcon_exit(void)
+{
+	platform_driver_unregister(&vpd_extcon_driver);
+}
+
+module_init(__vpd_extcon_init);
+module_exit(__vpd_extcon_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("rockchip");
+MODULE_DESCRIPTION("Virtual Typec-pd extcon driver");
\ No newline at end of file
Index: kernel-rockchip/drivers/gpu/drm/panel/Kconfig
===================================================================
--- kernel-rockchip.orig/drivers/gpu/drm/panel/Kconfig
+++ kernel-rockchip/drivers/gpu/drm/panel/Kconfig
@@ -516,4 +516,34 @@ config DRM_PANEL_XINPENG_XPP055C272
 	  Say Y here if you want to enable support for the Xinpeng
 	  XPP055C272 controller for 720x1280 LCD panels with MIPI/RGB/SPI
 	  system interfaces.
+
+config DRM_PANEL_INNOLUX_AFJ101_BA2131
+  tristate "Innolux AFJ101 BA2131 panel"
+  depends on OF
+  depends on DRM_MIPI_DSI
+  depends on BACKLIGHT_CLASS_DEVICE
+  help
+    Say Y here if you want to enable support for Innolux BA2131
+    TFT-LCD modules. The panel has a 800x1280 resolution and uses
+    24 bit RGB per pixel. It provides a MIPI DSI interface to
+    the host and has a built-in LED backlight.
+
+config DRM_PANEL_JADARD_JD9365DA_H3
+  tristate "Jadard JD9365DA-H3 WXGA DSI panel"
+  depends on OF
+  depends on DRM_MIPI_DSI
+  depends on BACKLIGHT_CLASS_DEVICE
+  help
+    Say Y here if you want to enable support for Jadard JD9365DA-H3
+    WXGA MIPI DSI panel. The panel support TFT dot matrix LCD with
+    800RGBx1280 dots at maximum.
+
+config DRM_PANEL_RADXA_DISPLAY_8HD
+  tristate "Radxa Display 8HD panel"
+  depends on OF
+  depends on DRM_MIPI_DSI
+  depends on BACKLIGHT_CLASS_DEVICE
+  help
+    Say Y here if you want to enable support for Radxa Display 8HD panel.
+    The panel support TFT dot matrix LCD with 800RGBx1280 dots at maximum.
 endmenu
Index: kernel-rockchip/drivers/gpu/drm/panel/Makefile
===================================================================
--- kernel-rockchip.orig/drivers/gpu/drm/panel/Makefile
+++ kernel-rockchip/drivers/gpu/drm/panel/Makefile
@@ -55,3 +55,6 @@ obj-$(CONFIG_DRM_PANEL_TPO_TPG110) += pa
 obj-$(CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA) += panel-truly-nt35597.o
 obj-$(CONFIG_DRM_PANEL_VISIONOX_RM69299) += panel-visionox-rm69299.o
 obj-$(CONFIG_DRM_PANEL_XINPENG_XPP055C272) += panel-xinpeng-xpp055c272.o
+obj-$(CONFIG_DRM_PANEL_INNOLUX_AFJ101_BA2131) += panel-innolux-afj101-ba2131.o
+obj-$(CONFIG_DRM_PANEL_JADARD_JD9365DA_H3) += panel-jadard-jd9365da-h3.o
+obj-$(CONFIG_DRM_PANEL_RADXA_DISPLAY_8HD) += panel-radxa-display-8hd.o
Index: kernel-rockchip/drivers/gpu/drm/panel/panel-innolux-afj101-ba2131.c
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/gpu/drm/panel/panel-innolux-afj101-ba2131.c
@@ -0,0 +1,492 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2019-2020 Kali Prasad <kprasadvnsi@protonmail.com>
+ */
+
+#include <linux/gpio/consumer.h>
+#include <linux/delay.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+#include <video/mipi_display.h>
+
+#define _INIT_CMD(...) { \
+	.len = sizeof((char[]){__VA_ARGS__}), \
+	.data = (char[]){__VA_ARGS__} }
+
+struct panel_init_cmd {
+	u8 dtype;
+	u8 wait;
+	u8 dlen;
+	const char *data;
+};
+
+static const char * const regulator_names[] = {
+	"dvdd",
+	"avdd",
+	"cvdd"
+};
+
+struct afj101_ba2131 {
+	struct drm_panel	panel;
+	struct mipi_dsi_device	*dsi;
+
+	struct regulator_bulk_data supplies[ARRAY_SIZE(regulator_names)];
+	struct gpio_desc	*reset;
+	struct gpio_desc	*enable;
+};
+
+static inline struct afj101_ba2131 *panel_to_sl101_pn27d1665(struct drm_panel *panel)
+{
+	return container_of(panel, struct afj101_ba2131, panel);
+}
+
+/*
+ * Display manufacturer failed to provide init sequencing according to
+ * https://chromium-review.googlesource.com/c/chromiumos/third_party/coreboot/+/892065/
+ * so the init sequence stems from a register dump of a working panel.
+ */
+static const struct panel_init_cmd afj101_ba2131_init_cmds[] = {
+	{ .dtype = 0x39, .wait =  0x00, .dlen =  0x04, .data = (char[]){ 0xFF, 0x98, 0x81, 0x03 }},
+
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x01, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x02, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x03, 0x53 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x04, 0xD3 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x05, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x06, 0x0D }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x07, 0x08 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x08, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x09, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x0a, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x0b, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x0c, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x0d, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x0e, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x0f, 0x28 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x10, 0x28 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x11, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x12, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x13, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x14, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x15, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x16, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x17, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x18, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x19, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x1a, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x1b, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x1c, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x1d, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x1e, 0x40 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x1f, 0x80 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x20, 0x06 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x21, 0x01 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x22, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x23, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x24, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x25, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x26, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x27, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x28, 0x33 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x29, 0x33 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x2a, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x2b, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x2c, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x2d, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x2e, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x2f, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x30, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x31, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x32, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x33, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x34, 0x03 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x35, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x36, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x37, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x38, 0x96 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x39, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x3a, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x3b, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x3c, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x3d, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x3e, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x3f, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x40, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x41, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x42, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x43, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x44, 0x00 }},
+
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x50, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x51, 0x23 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x52, 0x45 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x53, 0x67 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x54, 0x89 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x55, 0xAB }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x56, 0x01 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x57, 0x23 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x58, 0x45 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x59, 0x67 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x5a, 0x89 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x5b, 0xAB }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x5c, 0xCD }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x5d, 0xEF }},
+
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x5e, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x5f, 0x08 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x60, 0x08 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x61, 0x06 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x62, 0x06 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x63, 0x01 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x64, 0x01 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x65, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x66, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x67, 0x02 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x68, 0x15 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x69, 0x15 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x6a, 0x14 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x6b, 0x14 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x6c, 0x0D }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x6d, 0x0D }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x6e, 0x0C }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x6f, 0x0C }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x70, 0x0F }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x71, 0x0F }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x72, 0x0E }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x73, 0x0E }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x74, 0x02 }},
+
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x75, 0x08 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x76, 0x08 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x77, 0x06 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x78, 0x06 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x79, 0x01 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x7a, 0x01 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x7b, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x7c, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x7d, 0x02 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x7e, 0x15 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x7f, 0x15 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x80, 0x14 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x81, 0x14 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x82, 0x0D }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x83, 0x0D }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x84, 0x0C }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x85, 0x0C }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x86, 0x0F }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x87, 0x0F }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x88, 0x0E }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x89, 0x0E }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x8A, 0x02 }},
+
+	{ .dtype = 0x39, .wait =  0x00, .dlen =  0x04, .data = (char[]){ 0xFF, 0x98, 0x81, 0x04 }},
+
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x6E, 0x2B }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x6F, 0x37 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x3A, 0xA4 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x8D, 0x1A }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x87, 0xBA }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xB2, 0xD1 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x88, 0x0B }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x38, 0x01 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x39, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xB5, 0x07 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x31, 0x75 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x3B, 0x98 }},
+
+	{ .dtype = 0x39, .wait =  0x00, .dlen =  0x04, .data = (char[]){ 0xFF, 0x98, 0x81, 0x01 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x43, 0x33 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x22, 0x0A }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x31, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x53, 0x48 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x55, 0x48 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x50, 0x99 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x51, 0x94 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x60, 0x10 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x62, 0x20 }},
+
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xA0, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xA1, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xA2, 0x15 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xA3, 0x14 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xA4, 0x1B }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xA5, 0x2F }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xA6, 0x25 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xA7, 0x24 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xA8, 0x80 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xA9, 0x1F }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xAA, 0x2C }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xAB, 0x6C }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xAC, 0x16 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xAD, 0x14 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xAE, 0x4D }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xAF, 0x20 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xB0, 0x29 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xB1, 0x4F }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xB2, 0x5F }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xB3, 0x23 }},
+
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xC0, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xC1, 0x2E }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xC2, 0x3B }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xC3, 0x15 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xC4, 0x16 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xC5, 0x28 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xC6, 0x1A }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xC7, 0x1C }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xC8, 0xA7 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xC9, 0x1B }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xCA, 0x28 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xCB, 0x92 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xCC, 0x1F }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xCD, 0x1C }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xCE, 0x4B }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xCF, 0x1F }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xD0, 0x28 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xD1, 0x4E }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xD2, 0x5C }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0xD3, 0x23 }},
+
+	{ .dtype = 0x39, .wait =  0x00, .dlen =  0x04, .data = (char[]){ 0xFF, 0x98, 0x81, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x11, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x78, .dlen =  0x02, .data = (char[]){ 0x29, 0x00 }},
+	{ .dtype = 0x15, .wait =  0x00, .dlen =  0x02, .data = (char[]){ 0x35, 0x00 }},
+};
+
+
+static int afj101_ba2131_prepare(struct drm_panel *panel)
+{
+	struct afj101_ba2131 *ctx = panel_to_sl101_pn27d1665(panel);
+	struct mipi_dsi_device *dsi = ctx->dsi;
+	unsigned int i;
+	int ret;
+
+	gpiod_set_value(ctx->enable, 1);
+	msleep(25);
+
+	gpiod_set_value(ctx->reset, 1);
+	msleep(25);
+
+	gpiod_set_value(ctx->reset, 0);
+	msleep(200);
+
+	for (i = 0; i < ARRAY_SIZE(afj101_ba2131_init_cmds); i++) {
+		const struct panel_init_cmd *cmd = &afj101_ba2131_init_cmds[i];
+
+		switch (cmd->dtype) {
+			case MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM:
+			case MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM:
+			case MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM:
+			case MIPI_DSI_GENERIC_LONG_WRITE:
+				ret = mipi_dsi_generic_write(dsi, cmd->data,
+								cmd->dlen);
+				break;
+			case MIPI_DSI_DCS_SHORT_WRITE:
+			case MIPI_DSI_DCS_SHORT_WRITE_PARAM:
+			case MIPI_DSI_DCS_LONG_WRITE:
+				ret = mipi_dsi_dcs_write_buffer(dsi, cmd->data,
+								cmd->dlen);
+				break;
+			default:
+				return -EINVAL;
+		}
+
+		if (ret < 0)
+			goto powerdown;
+
+		if (cmd->wait)
+				msleep(cmd->wait);
+	}
+
+	return 0;
+
+powerdown:
+	gpiod_set_value(ctx->reset, 1);
+	msleep(50);
+
+	// return regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	return 0;
+}
+
+static int afj101_ba2131_enable(struct drm_panel *panel)
+{
+	struct afj101_ba2131 *ctx = panel_to_sl101_pn27d1665(panel);
+	int ret;
+
+	msleep(150);
+
+	ret = mipi_dsi_dcs_set_display_on(ctx->dsi);
+	if (ret < 0)
+		return ret;
+
+	msleep(50);
+
+	return 0;
+}
+
+static int afj101_ba2131_disable(struct drm_panel *panel)
+{
+	struct afj101_ba2131 *ctx = panel_to_sl101_pn27d1665(panel);
+
+	return mipi_dsi_dcs_set_display_off(ctx->dsi);
+}
+
+static int afj101_ba2131_unprepare(struct drm_panel *panel)
+{
+	struct afj101_ba2131 *ctx = panel_to_sl101_pn27d1665(panel);
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(ctx->dsi);
+	if (ret < 0)
+		dev_err(panel->dev, "failed to set display off: %d\n", ret);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(ctx->dsi);
+	if (ret < 0)
+		dev_err(panel->dev, "failed to enter sleep mode: %d\n", ret);
+
+	msleep(200);
+
+	gpiod_set_value(ctx->reset, 1);
+	msleep(20);
+
+	gpiod_set_value(ctx->enable, 0);
+	msleep(20);
+
+	// return regulator_bulk_disable(ARRAY_SIZE(ctx->supplies), ctx->supplies);
+	return 0;
+}
+
+static const struct drm_display_mode afj101_ba2131_default_mode = {
+	.clock = 62100,
+
+	.hdisplay    = 800,
+	.hsync_start = 800 + 40,
+	.hsync_end   = 800 + 40 + 5,
+	.htotal      = 800 + 40 + 5 + 20,
+
+	.vdisplay    = 1280,
+	.vsync_start = 1280 + 30,
+	.vsync_end   = 1280 + 30 + 5,
+	.vtotal      = 1280 + 30 + 5 + 12,
+
+	.type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,
+	.width_mm	= 136,
+	.height_mm	= 217,
+};
+
+static int afj101_ba2131_get_modes(struct drm_panel *panel,
+				  struct drm_connector *connector)
+{
+	struct afj101_ba2131 *ctx = panel_to_sl101_pn27d1665(panel);
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, &afj101_ba2131_default_mode);
+	if (!mode) {
+		dev_err(&ctx->dsi->dev, "failed to add mode %ux%u@%u\n",
+			afj101_ba2131_default_mode.hdisplay,
+			afj101_ba2131_default_mode.vdisplay,
+			drm_mode_vrefresh(&afj101_ba2131_default_mode));
+		return -ENOMEM;
+	}
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+	drm_mode_probed_add(connector, mode);
+
+	return 1;
+}
+
+static const struct drm_panel_funcs afj101_ba2131_funcs = {
+	.disable = afj101_ba2131_disable,
+	.unprepare = afj101_ba2131_unprepare,
+	.prepare = afj101_ba2131_prepare,
+	.enable = afj101_ba2131_enable,
+	.get_modes = afj101_ba2131_get_modes,
+};
+
+static int afj101_ba2131_dsi_probe(struct mipi_dsi_device *dsi)
+{
+	struct afj101_ba2131 *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(&dsi->dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	mipi_dsi_set_drvdata(dsi, ctx);
+	ctx->dsi = dsi;
+
+	ctx->enable = devm_gpiod_get(&dsi->dev, "enable", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->enable)) {
+		dev_err(&dsi->dev, "Couldn't get our enable GPIO\n");
+		return PTR_ERR(ctx->enable);
+	}
+
+	ctx->reset = devm_gpiod_get(&dsi->dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->reset)) {
+		dev_err(&dsi->dev, "Couldn't get our reset GPIO\n");
+		return PTR_ERR(ctx->reset);
+	}
+
+	drm_panel_init(&ctx->panel, &dsi->dev, &afj101_ba2131_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret){
+		return ret;
+	}
+
+	drm_panel_add(&ctx->panel);
+
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST | MIPI_DSI_MODE_LPM;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->lanes = 4;
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int afj101_ba2131_dsi_remove(struct mipi_dsi_device *dsi)
+{
+	struct afj101_ba2131 *ctx = mipi_dsi_get_drvdata(dsi);
+
+	mipi_dsi_detach(dsi);
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct of_device_id afj101_ba2131_of_match[] = {
+	{ .compatible = "innolux,afj101-ba2131", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, afj101_ba2131_of_match);
+
+static struct mipi_dsi_driver afj101_ba2131_driver = {
+	.probe = afj101_ba2131_dsi_probe,
+	.remove = afj101_ba2131_dsi_remove,
+	.driver = {
+		.name = "innolux-afj101-ba2131",
+		.of_match_table = afj101_ba2131_of_match,
+	},
+};
+module_mipi_dsi_driver(afj101_ba2131_driver);
+
+MODULE_AUTHOR("Kali Prasad <kprasadvnsi@protonmail.com>");
+MODULE_DESCRIPTION("Innolux AFJ101 BA2131 MIPI-DSI LCD panel");
+MODULE_LICENSE("GPL");
Index: kernel-rockchip/drivers/gpu/drm/panel/panel-jadard-jd9365da-h3.c
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/gpu/drm/panel/panel-jadard-jd9365da-h3.c
@@ -0,0 +1,691 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (c) 2019 Radxa Limited
+ * Copyright (c) 2022 Edgeble AI Technologies Pvt. Ltd.
+ *
+ * Author:
+ * - Jagan Teki <jagan@amarulasolutions.com>
+ * - Stephen Chen <stephen@radxa.com>
+ */
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_print.h>
+
+#include <linux/gpio/consumer.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/regulator/consumer.h>
+
+#define JD9365DA_INIT_CMD_LEN		2
+
+struct jadard_init_cmd {
+	u8 data[JD9365DA_INIT_CMD_LEN];
+};
+
+struct jadard_panel_desc {
+	const struct drm_display_mode mode;
+	unsigned int lanes;
+	enum mipi_dsi_pixel_format format;
+	const struct jadard_init_cmd *init_cmds;
+	u32 num_init_cmds;
+};
+
+struct jadard {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	const struct jadard_panel_desc *desc;
+
+	struct regulator *vdd;
+	struct regulator *vccio;
+	struct gpio_desc *reset;
+};
+
+static inline struct jadard *panel_to_jadard(struct drm_panel *panel)
+{
+	return container_of(panel, struct jadard, panel);
+}
+
+static int jadard_enable(struct drm_panel *panel)
+{
+	struct device *dev = panel->dev;
+	struct jadard *jadard = panel_to_jadard(panel);
+	const struct jadard_panel_desc *desc = jadard->desc;
+	struct mipi_dsi_device *dsi = jadard->dsi;
+	unsigned int i;
+	int err;
+
+	msleep(10);
+
+	for (i = 0; i < desc->num_init_cmds; i++) {
+		const struct jadard_init_cmd *cmd = &desc->init_cmds[i];
+
+		err = mipi_dsi_dcs_write_buffer(dsi, cmd->data, JD9365DA_INIT_CMD_LEN);
+		if (err < 0)
+			return err;
+	}
+
+	msleep(120);
+
+	err = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (err < 0)
+		DRM_DEV_ERROR(dev, "failed to exit sleep mode ret = %d\n", err);
+
+	err =  mipi_dsi_dcs_set_display_on(dsi);
+	if (err < 0)
+		DRM_DEV_ERROR(dev, "failed to set display on ret = %d\n", err);
+
+	return 0;
+}
+
+static int jadard_disable(struct drm_panel *panel)
+{
+	struct device *dev = panel->dev;
+	struct jadard *jadard = panel_to_jadard(panel);
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(jadard->dsi);
+	if (ret < 0)
+		DRM_DEV_ERROR(dev, "failed to set display off: %d\n", ret);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(jadard->dsi);
+	if (ret < 0)
+		DRM_DEV_ERROR(dev, "failed to enter sleep mode: %d\n", ret);
+
+	return 0;
+}
+
+static int jadard_prepare(struct drm_panel *panel)
+{
+	struct jadard *jadard = panel_to_jadard(panel);
+	int ret;
+
+	ret = regulator_enable(jadard->vccio);
+	if (ret)
+		return ret;
+
+	ret = regulator_enable(jadard->vdd);
+	if (ret)
+		return ret;
+
+	gpiod_set_value(jadard->reset, 1);
+	msleep(120);
+
+	return 0;
+}
+
+static int jadard_unprepare(struct drm_panel *panel)
+{
+	struct jadard *jadard = panel_to_jadard(panel);
+
+	gpiod_set_value(jadard->reset, 1);
+	msleep(120);
+
+	regulator_disable(jadard->vdd);
+	regulator_disable(jadard->vccio);
+
+	return 0;
+}
+
+static int jadard_get_modes(struct drm_panel *panel,
+			    struct drm_connector *connector)
+{
+	struct jadard *jadard = panel_to_jadard(panel);
+	const struct drm_display_mode *desc_mode = &jadard->desc->mode;
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, desc_mode);
+	if (!mode) {
+		DRM_DEV_ERROR(&jadard->dsi->dev, "failed to add mode %ux%ux@%u\n",
+			      desc_mode->hdisplay, desc_mode->vdisplay,
+			      drm_mode_vrefresh(desc_mode));
+		return -ENOMEM;
+	}
+
+	drm_mode_set_name(mode);
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+
+	return 1;
+}
+
+static const struct drm_panel_funcs jadard_funcs = {
+	.disable = jadard_disable,
+	.unprepare = jadard_unprepare,
+	.prepare = jadard_prepare,
+	.enable = jadard_enable,
+	.get_modes = jadard_get_modes,
+};
+
+static const struct jadard_init_cmd cz101b4001_init_cmds[] = {
+	{ .data = { 0xE0, 0x00 } },
+	{ .data = { 0xE1, 0x93 } },
+	{ .data = { 0xE2, 0x65 } },
+	{ .data = { 0xE3, 0xF8 } },
+	{ .data = { 0x80, 0x03 } },
+	{ .data = { 0xE0, 0x01 } },
+	{ .data = { 0x00, 0x00 } },
+	{ .data = { 0x01, 0x3B } },
+	{ .data = { 0x0C, 0x74 } },
+	{ .data = { 0x17, 0x00 } },
+	{ .data = { 0x18, 0xAF } },
+	{ .data = { 0x19, 0x00 } },
+	{ .data = { 0x1A, 0x00 } },
+	{ .data = { 0x1B, 0xAF } },
+	{ .data = { 0x1C, 0x00 } },
+	{ .data = { 0x35, 0x26 } },
+	{ .data = { 0x37, 0x09 } },
+	{ .data = { 0x38, 0x04 } },
+	{ .data = { 0x39, 0x00 } },
+	{ .data = { 0x3A, 0x01 } },
+	{ .data = { 0x3C, 0x78 } },
+	{ .data = { 0x3D, 0xFF } },
+	{ .data = { 0x3E, 0xFF } },
+	{ .data = { 0x3F, 0x7F } },
+	{ .data = { 0x40, 0x06 } },
+	{ .data = { 0x41, 0xA0 } },
+	{ .data = { 0x42, 0x81 } },
+	{ .data = { 0x43, 0x14 } },
+	{ .data = { 0x44, 0x23 } },
+	{ .data = { 0x45, 0x28 } },
+	{ .data = { 0x55, 0x02 } },
+	{ .data = { 0x57, 0x69 } },
+	{ .data = { 0x59, 0x0A } },
+	{ .data = { 0x5A, 0x2A } },
+	{ .data = { 0x5B, 0x17 } },
+	{ .data = { 0x5D, 0x7F } },
+	{ .data = { 0x5E, 0x6B } },
+	{ .data = { 0x5F, 0x5C } },
+	{ .data = { 0x60, 0x4F } },
+	{ .data = { 0x61, 0x4D } },
+	{ .data = { 0x62, 0x3F } },
+	{ .data = { 0x63, 0x42 } },
+	{ .data = { 0x64, 0x2B } },
+	{ .data = { 0x65, 0x44 } },
+	{ .data = { 0x66, 0x43 } },
+	{ .data = { 0x67, 0x43 } },
+	{ .data = { 0x68, 0x63 } },
+	{ .data = { 0x69, 0x52 } },
+	{ .data = { 0x6A, 0x5A } },
+	{ .data = { 0x6B, 0x4F } },
+	{ .data = { 0x6C, 0x4E } },
+	{ .data = { 0x6D, 0x20 } },
+	{ .data = { 0x6E, 0x0F } },
+	{ .data = { 0x6F, 0x00 } },
+	{ .data = { 0x70, 0x7F } },
+	{ .data = { 0x71, 0x6B } },
+	{ .data = { 0x72, 0x5C } },
+	{ .data = { 0x73, 0x4F } },
+	{ .data = { 0x74, 0x4D } },
+	{ .data = { 0x75, 0x3F } },
+	{ .data = { 0x76, 0x42 } },
+	{ .data = { 0x77, 0x2B } },
+	{ .data = { 0x78, 0x44 } },
+	{ .data = { 0x79, 0x43 } },
+	{ .data = { 0x7A, 0x43 } },
+	{ .data = { 0x7B, 0x63 } },
+	{ .data = { 0x7C, 0x52 } },
+	{ .data = { 0x7D, 0x5A } },
+	{ .data = { 0x7E, 0x4F } },
+	{ .data = { 0x7F, 0x4E } },
+	{ .data = { 0x80, 0x20 } },
+	{ .data = { 0x81, 0x0F } },
+	{ .data = { 0x82, 0x00 } },
+	{ .data = { 0xE0, 0x02 } },
+	{ .data = { 0x00, 0x02 } },
+	{ .data = { 0x01, 0x02 } },
+	{ .data = { 0x02, 0x00 } },
+	{ .data = { 0x03, 0x00 } },
+	{ .data = { 0x04, 0x1E } },
+	{ .data = { 0x05, 0x1E } },
+	{ .data = { 0x06, 0x1F } },
+	{ .data = { 0x07, 0x1F } },
+	{ .data = { 0x08, 0x1F } },
+	{ .data = { 0x09, 0x17 } },
+	{ .data = { 0x0A, 0x17 } },
+	{ .data = { 0x0B, 0x37 } },
+	{ .data = { 0x0C, 0x37 } },
+	{ .data = { 0x0D, 0x47 } },
+	{ .data = { 0x0E, 0x47 } },
+	{ .data = { 0x0F, 0x45 } },
+	{ .data = { 0x10, 0x45 } },
+	{ .data = { 0x11, 0x4B } },
+	{ .data = { 0x12, 0x4B } },
+	{ .data = { 0x13, 0x49 } },
+	{ .data = { 0x14, 0x49 } },
+	{ .data = { 0x15, 0x1F } },
+	{ .data = { 0x16, 0x01 } },
+	{ .data = { 0x17, 0x01 } },
+	{ .data = { 0x18, 0x00 } },
+	{ .data = { 0x19, 0x00 } },
+	{ .data = { 0x1A, 0x1E } },
+	{ .data = { 0x1B, 0x1E } },
+	{ .data = { 0x1C, 0x1F } },
+	{ .data = { 0x1D, 0x1F } },
+	{ .data = { 0x1E, 0x1F } },
+	{ .data = { 0x1F, 0x17 } },
+	{ .data = { 0x20, 0x17 } },
+	{ .data = { 0x21, 0x37 } },
+	{ .data = { 0x22, 0x37 } },
+	{ .data = { 0x23, 0x46 } },
+	{ .data = { 0x24, 0x46 } },
+	{ .data = { 0x25, 0x44 } },
+	{ .data = { 0x26, 0x44 } },
+	{ .data = { 0x27, 0x4A } },
+	{ .data = { 0x28, 0x4A } },
+	{ .data = { 0x29, 0x48 } },
+	{ .data = { 0x2A, 0x48 } },
+	{ .data = { 0x2B, 0x1F } },
+	{ .data = { 0x2C, 0x01 } },
+	{ .data = { 0x2D, 0x01 } },
+	{ .data = { 0x2E, 0x00 } },
+	{ .data = { 0x2F, 0x00 } },
+	{ .data = { 0x30, 0x1F } },
+	{ .data = { 0x31, 0x1F } },
+	{ .data = { 0x32, 0x1E } },
+	{ .data = { 0x33, 0x1E } },
+	{ .data = { 0x34, 0x1F } },
+	{ .data = { 0x35, 0x17 } },
+	{ .data = { 0x36, 0x17 } },
+	{ .data = { 0x37, 0x37 } },
+	{ .data = { 0x38, 0x37 } },
+	{ .data = { 0x39, 0x08 } },
+	{ .data = { 0x3A, 0x08 } },
+	{ .data = { 0x3B, 0x0A } },
+	{ .data = { 0x3C, 0x0A } },
+	{ .data = { 0x3D, 0x04 } },
+	{ .data = { 0x3E, 0x04 } },
+	{ .data = { 0x3F, 0x06 } },
+	{ .data = { 0x40, 0x06 } },
+	{ .data = { 0x41, 0x1F } },
+	{ .data = { 0x42, 0x02 } },
+	{ .data = { 0x43, 0x02 } },
+	{ .data = { 0x44, 0x00 } },
+	{ .data = { 0x45, 0x00 } },
+	{ .data = { 0x46, 0x1F } },
+	{ .data = { 0x47, 0x1F } },
+	{ .data = { 0x48, 0x1E } },
+	{ .data = { 0x49, 0x1E } },
+	{ .data = { 0x4A, 0x1F } },
+	{ .data = { 0x4B, 0x17 } },
+	{ .data = { 0x4C, 0x17 } },
+	{ .data = { 0x4D, 0x37 } },
+	{ .data = { 0x4E, 0x37 } },
+	{ .data = { 0x4F, 0x09 } },
+	{ .data = { 0x50, 0x09 } },
+	{ .data = { 0x51, 0x0B } },
+	{ .data = { 0x52, 0x0B } },
+	{ .data = { 0x53, 0x05 } },
+	{ .data = { 0x54, 0x05 } },
+	{ .data = { 0x55, 0x07 } },
+	{ .data = { 0x56, 0x07 } },
+	{ .data = { 0x57, 0x1F } },
+	{ .data = { 0x58, 0x40 } },
+	{ .data = { 0x5B, 0x30 } },
+	{ .data = { 0x5C, 0x16 } },
+	{ .data = { 0x5D, 0x34 } },
+	{ .data = { 0x5E, 0x05 } },
+	{ .data = { 0x5F, 0x02 } },
+	{ .data = { 0x63, 0x00 } },
+	{ .data = { 0x64, 0x6A } },
+	{ .data = { 0x67, 0x73 } },
+	{ .data = { 0x68, 0x1D } },
+	{ .data = { 0x69, 0x08 } },
+	{ .data = { 0x6A, 0x6A } },
+	{ .data = { 0x6B, 0x08 } },
+	{ .data = { 0x6C, 0x00 } },
+	{ .data = { 0x6D, 0x00 } },
+	{ .data = { 0x6E, 0x00 } },
+	{ .data = { 0x6F, 0x88 } },
+	{ .data = { 0x75, 0xFF } },
+	{ .data = { 0x77, 0xDD } },
+	{ .data = { 0x78, 0x3F } },
+	{ .data = { 0x79, 0x15 } },
+	{ .data = { 0x7A, 0x17 } },
+	{ .data = { 0x7D, 0x14 } },
+	{ .data = { 0x7E, 0x82 } },
+	{ .data = { 0xE0, 0x04 } },
+	{ .data = { 0x00, 0x0E } },
+	{ .data = { 0x02, 0xB3 } },
+	{ .data = { 0x09, 0x61 } },
+	{ .data = { 0x0E, 0x48 } },
+	{ .data = { 0xE0, 0x00 } },
+	{ .data = { 0xE6, 0x02 } },
+	{ .data = { 0xE7, 0x0C } },
+};
+
+static const struct jadard_panel_desc cz101b4001_desc = {
+	.mode = {
+		.clock		= 70000,
+
+		.hdisplay	= 800,
+		.hsync_start	= 800 + 40,
+		.hsync_end	= 800 + 40 + 18,
+		.htotal		= 800 + 40 + 18 + 20,
+
+		.vdisplay	= 1280,
+		.vsync_start	= 1280 + 20,
+		.vsync_end	= 1280 + 20 + 4,
+		.vtotal		= 1280 + 20 + 4 + 20,
+
+		.width_mm	= 62,
+		.height_mm	= 110,
+		.type		= DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,
+	},
+	.lanes = 4,
+	.format = MIPI_DSI_FMT_RGB888,
+	.init_cmds = cz101b4001_init_cmds,
+	.num_init_cmds = ARRAY_SIZE(cz101b4001_init_cmds),
+};
+
+static const struct jadard_init_cmd radxa_display_10hd_ad001_init_cmds[] = {
+	{ .data = { 0xE0, 0x00 } },
+	{ .data = { 0xE1, 0x93 } },
+	{ .data = { 0xE2, 0x65 } },
+	{ .data = { 0xE3, 0xF8 } },
+	{ .data = { 0x80, 0x03 } },
+	{ .data = { 0xE0, 0x01 } },
+	{ .data = { 0x00, 0x00 } },
+	{ .data = { 0x01, 0x3B } },
+	{ .data = { 0x0C, 0x74 } },
+	{ .data = { 0x17, 0x00 } },
+	{ .data = { 0x18, 0xAF } },
+	{ .data = { 0x19, 0x00 } },
+	{ .data = { 0x1A, 0x00 } },
+	{ .data = { 0x1B, 0xAF } },
+	{ .data = { 0x1C, 0x00 } },
+	{ .data = { 0x35, 0x26 } },
+	{ .data = { 0x37, 0x09 } },
+	{ .data = { 0x38, 0x04 } },
+	{ .data = { 0x39, 0x00 } },
+	{ .data = { 0x3A, 0x01 } },
+	{ .data = { 0x3C, 0x78 } },
+	{ .data = { 0x3D, 0xFF } },
+	{ .data = { 0x3E, 0xFF } },
+	{ .data = { 0x3F, 0x7F } },
+	{ .data = { 0x40, 0x06 } },
+	{ .data = { 0x41, 0xA0 } },
+	{ .data = { 0x42, 0x81 } },
+	{ .data = { 0x43, 0x14 } },
+	{ .data = { 0x44, 0x23 } },
+	{ .data = { 0x45, 0x28 } },
+	{ .data = { 0x55, 0x02 } },
+	{ .data = { 0x57, 0x69 } },
+	{ .data = { 0x59, 0x0A } },
+	{ .data = { 0x5A, 0x2A } },
+	{ .data = { 0x5B, 0x17 } },
+	{ .data = { 0x5D, 0x7F } },
+	{ .data = { 0x5E, 0x6B } },
+	{ .data = { 0x5F, 0x5C } },
+	{ .data = { 0x60, 0x4F } },
+	{ .data = { 0x61, 0x4D } },
+	{ .data = { 0x62, 0x3F } },
+	{ .data = { 0x63, 0x42 } },
+	{ .data = { 0x64, 0x2B } },
+	{ .data = { 0x65, 0x44 } },
+	{ .data = { 0x66, 0x43 } },
+	{ .data = { 0x67, 0x43 } },
+	{ .data = { 0x68, 0x63 } },
+	{ .data = { 0x69, 0x52 } },
+	{ .data = { 0x6A, 0x5A } },
+	{ .data = { 0x6B, 0x4F } },
+	{ .data = { 0x6C, 0x4E } },
+	{ .data = { 0x6D, 0x20 } },
+	{ .data = { 0x6E, 0x0F } },
+	{ .data = { 0x6F, 0x00 } },
+	{ .data = { 0x70, 0x7F } },
+	{ .data = { 0x71, 0x6B } },
+	{ .data = { 0x72, 0x5C } },
+	{ .data = { 0x73, 0x4F } },
+	{ .data = { 0x74, 0x4D } },
+	{ .data = { 0x75, 0x3F } },
+	{ .data = { 0x76, 0x42 } },
+	{ .data = { 0x77, 0x2B } },
+	{ .data = { 0x78, 0x44 } },
+	{ .data = { 0x79, 0x43 } },
+	{ .data = { 0x7A, 0x43 } },
+	{ .data = { 0x7B, 0x63 } },
+	{ .data = { 0x7C, 0x52 } },
+	{ .data = { 0x7D, 0x5A } },
+	{ .data = { 0x7E, 0x4F } },
+	{ .data = { 0x7F, 0x4E } },
+	{ .data = { 0x80, 0x20 } },
+	{ .data = { 0x81, 0x0F } },
+	{ .data = { 0x82, 0x00 } },
+	{ .data = { 0xE0, 0x02 } },
+	{ .data = { 0x00, 0x02 } },
+	{ .data = { 0x01, 0x02 } },
+	{ .data = { 0x02, 0x00 } },
+	{ .data = { 0x03, 0x00 } },
+	{ .data = { 0x04, 0x1E } },
+	{ .data = { 0x05, 0x1E } },
+	{ .data = { 0x06, 0x1F } },
+	{ .data = { 0x07, 0x1F } },
+	{ .data = { 0x08, 0x1F } },
+	{ .data = { 0x09, 0x17 } },
+	{ .data = { 0x0A, 0x17 } },
+	{ .data = { 0x0B, 0x37 } },
+	{ .data = { 0x0C, 0x37 } },
+	{ .data = { 0x0D, 0x47 } },
+	{ .data = { 0x0E, 0x47 } },
+	{ .data = { 0x0F, 0x45 } },
+	{ .data = { 0x10, 0x45 } },
+	{ .data = { 0x11, 0x4B } },
+	{ .data = { 0x12, 0x4B } },
+	{ .data = { 0x13, 0x49 } },
+	{ .data = { 0x14, 0x49 } },
+	{ .data = { 0x15, 0x1F } },
+	{ .data = { 0x16, 0x01 } },
+	{ .data = { 0x17, 0x01 } },
+	{ .data = { 0x18, 0x00 } },
+	{ .data = { 0x19, 0x00 } },
+	{ .data = { 0x1A, 0x1E } },
+	{ .data = { 0x1B, 0x1E } },
+	{ .data = { 0x1C, 0x1F } },
+	{ .data = { 0x1D, 0x1F } },
+	{ .data = { 0x1E, 0x1F } },
+	{ .data = { 0x1F, 0x17 } },
+	{ .data = { 0x20, 0x17 } },
+	{ .data = { 0x21, 0x37 } },
+	{ .data = { 0x22, 0x37 } },
+	{ .data = { 0x23, 0x46 } },
+	{ .data = { 0x24, 0x46 } },
+	{ .data = { 0x25, 0x44 } },
+	{ .data = { 0x26, 0x44 } },
+	{ .data = { 0x27, 0x4A } },
+	{ .data = { 0x28, 0x4A } },
+	{ .data = { 0x29, 0x48 } },
+	{ .data = { 0x2A, 0x48 } },
+	{ .data = { 0x2B, 0x1F } },
+	{ .data = { 0x2C, 0x01 } },
+	{ .data = { 0x2D, 0x01 } },
+	{ .data = { 0x2E, 0x00 } },
+	{ .data = { 0x2F, 0x00 } },
+	{ .data = { 0x30, 0x1F } },
+	{ .data = { 0x31, 0x1F } },
+	{ .data = { 0x32, 0x1E } },
+	{ .data = { 0x33, 0x1E } },
+	{ .data = { 0x34, 0x1F } },
+	{ .data = { 0x35, 0x17 } },
+	{ .data = { 0x36, 0x17 } },
+	{ .data = { 0x37, 0x37 } },
+	{ .data = { 0x38, 0x37 } },
+	{ .data = { 0x39, 0x08 } },
+	{ .data = { 0x3A, 0x08 } },
+	{ .data = { 0x3B, 0x0A } },
+	{ .data = { 0x3C, 0x0A } },
+	{ .data = { 0x3D, 0x04 } },
+	{ .data = { 0x3E, 0x04 } },
+	{ .data = { 0x3F, 0x06 } },
+	{ .data = { 0x40, 0x06 } },
+	{ .data = { 0x41, 0x1F } },
+	{ .data = { 0x42, 0x02 } },
+	{ .data = { 0x43, 0x02 } },
+	{ .data = { 0x44, 0x00 } },
+	{ .data = { 0x45, 0x00 } },
+	{ .data = { 0x46, 0x1F } },
+	{ .data = { 0x47, 0x1F } },
+	{ .data = { 0x48, 0x1E } },
+	{ .data = { 0x49, 0x1E } },
+	{ .data = { 0x4A, 0x1F } },
+	{ .data = { 0x4B, 0x17 } },
+	{ .data = { 0x4C, 0x17 } },
+	{ .data = { 0x4D, 0x37 } },
+	{ .data = { 0x4E, 0x37 } },
+	{ .data = { 0x4F, 0x09 } },
+	{ .data = { 0x50, 0x09 } },
+	{ .data = { 0x51, 0x0B } },
+	{ .data = { 0x52, 0x0B } },
+	{ .data = { 0x53, 0x05 } },
+	{ .data = { 0x54, 0x05 } },
+	{ .data = { 0x55, 0x07 } },
+	{ .data = { 0x56, 0x07 } },
+	{ .data = { 0x57, 0x1F } },
+	{ .data = { 0x58, 0x40 } },
+	{ .data = { 0x5B, 0x30 } },
+	{ .data = { 0x5C, 0x16 } },
+	{ .data = { 0x5D, 0x34 } },
+	{ .data = { 0x5E, 0x05 } },
+	{ .data = { 0x5F, 0x02 } },
+	{ .data = { 0x63, 0x00 } },
+	{ .data = { 0x64, 0x6A } },
+	{ .data = { 0x67, 0x73 } },
+	{ .data = { 0x68, 0x1D } },
+	{ .data = { 0x69, 0x08 } },
+	{ .data = { 0x6A, 0x6A } },
+	{ .data = { 0x6B, 0x08 } },
+	{ .data = { 0x6C, 0x00 } },
+	{ .data = { 0x6D, 0x00 } },
+	{ .data = { 0x6E, 0x00 } },
+	{ .data = { 0x6F, 0x88 } },
+	{ .data = { 0x75, 0xFF } },
+	{ .data = { 0x77, 0xDD } },
+	{ .data = { 0x78, 0x3F } },
+	{ .data = { 0x79, 0x15 } },
+	{ .data = { 0x7A, 0x17 } },
+	{ .data = { 0x7D, 0x14 } },
+	{ .data = { 0x7E, 0x82 } },
+	{ .data = { 0xE0, 0x04 } },
+	{ .data = { 0x00, 0x0E } },
+	{ .data = { 0x02, 0xB3 } },
+	{ .data = { 0x09, 0x61 } },
+	{ .data = { 0x0E, 0x48 } },
+	{ .data = { 0xE0, 0x00 } },
+	{ .data = { 0xE6, 0x02 } },
+	{ .data = { 0xE7, 0x0C } },
+};
+
+static const struct jadard_panel_desc radxa_display_10hd_ad001_desc = {
+	.mode = {
+		.clock		= 70000,
+
+		.hdisplay	= 800,
+		.hsync_start	= 800 + 40,
+		.hsync_end	= 800 + 40 + 18,
+		.htotal		= 800 + 40 + 18 + 20,
+
+		.vdisplay	= 1280,
+		.vsync_start	= 1280 + 20,
+		.vsync_end	= 1280 + 20 + 4,
+		.vtotal		= 1280 + 20 + 4 + 20,
+
+		.width_mm	= 135,
+		.height_mm	= 216,
+		.type		= DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,
+	},
+	.lanes = 4,
+	.format = MIPI_DSI_FMT_RGB888,
+	.init_cmds = cz101b4001_init_cmds,
+	.num_init_cmds = ARRAY_SIZE(radxa_display_10hd_ad001_init_cmds),
+};
+
+static int jadard_dsi_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct jadard_panel_desc *desc;
+	struct jadard *jadard;
+	int ret;
+
+	jadard = devm_kzalloc(&dsi->dev, sizeof(*jadard), GFP_KERNEL);
+	if (!jadard)
+		return -ENOMEM;
+
+	desc = of_device_get_match_data(dev);
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_EOT_PACKET;
+	dsi->format = desc->format;
+	dsi->lanes = desc->lanes;
+
+	jadard->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(jadard->reset)) {
+		DRM_DEV_ERROR(&dsi->dev, "failed to get our reset GPIO\n");
+		return PTR_ERR(jadard->reset);
+	}
+
+	jadard->vdd = devm_regulator_get(dev, "vdd");
+	if (IS_ERR(jadard->vdd)) {
+		DRM_DEV_ERROR(&dsi->dev, "failed to get vdd regulator\n");
+		return PTR_ERR(jadard->vdd);
+	}
+
+	jadard->vccio = devm_regulator_get(dev, "vccio");
+	if (IS_ERR(jadard->vccio)) {
+		DRM_DEV_ERROR(&dsi->dev, "failed to get vccio regulator\n");
+		return PTR_ERR(jadard->vccio);
+	}
+
+	drm_panel_init(&jadard->panel, dev, &jadard_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&jadard->panel);
+	if (ret)
+		return ret;
+
+	drm_panel_add(&jadard->panel);
+
+	mipi_dsi_set_drvdata(dsi, jadard);
+	jadard->dsi = dsi;
+	jadard->desc = desc;
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0)
+		drm_panel_remove(&jadard->panel);
+
+	return ret;
+}
+
+static int jadard_dsi_remove(struct mipi_dsi_device *dsi)
+{
+	struct jadard *jadard = mipi_dsi_get_drvdata(dsi);
+
+	mipi_dsi_detach(dsi);
+	drm_panel_remove(&jadard->panel);
+
+	return 0;
+}
+
+static const struct of_device_id jadard_of_match[] = {
+	{ .compatible = "chongzhou,cz101b4001", .data = &cz101b4001_desc },
+	{ .compatible = "radxa,display-10hd-ad001", .data = &radxa_display_10hd_ad001_desc },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, jadard_of_match);
+
+static struct mipi_dsi_driver jadard_driver = {
+	.probe = jadard_dsi_probe,
+	.remove = jadard_dsi_remove,
+	.driver = {
+		.name = "jadard-jd9365da",
+		.of_match_table = jadard_of_match,
+	},
+};
+module_mipi_dsi_driver(jadard_driver);
+
+MODULE_AUTHOR("Jagan Teki <jagan@edgeble.ai>");
+MODULE_AUTHOR("Stephen Chen <stephen@radxa.com>");
+MODULE_DESCRIPTION("Jadard JD9365DA-H3 WXGA DSI panel");
+MODULE_LICENSE("GPL");
Index: kernel-rockchip/drivers/gpu/drm/panel/panel-radxa-display-8hd.c
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/gpu/drm/panel/panel-radxa-display-8hd.c
@@ -0,0 +1,441 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (c) 2022 Radxa Limited
+ *
+ * Author:
+ * - Stephen Chen <stephen@radxa.com>
+ */
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_print.h>
+
+#include <linux/gpio/consumer.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/regulator/consumer.h>
+
+#define JADARD_JD9365DA_INIT_CMD_LEN	2
+
+struct jadard_jd9365da_init_cmd {
+	u8 data[JADARD_JD9365DA_INIT_CMD_LEN];
+};
+
+struct jadard_jd9365da_panel_desc {
+	const struct drm_display_mode mode;
+	unsigned int lanes;
+	enum mipi_dsi_pixel_format format;
+	const struct jadard_jd9365da_init_cmd *init_cmds;
+	u32 num_init_cmds;
+};
+
+struct jadard_jd9365da {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	const struct jadard_jd9365da_panel_desc *desc;
+
+	struct regulator *vdd;
+	struct regulator *vccio;
+	struct gpio_desc *reset;
+};
+
+static inline struct jadard_jd9365da *panel_to_jadard_jd9365da(struct drm_panel *panel)
+{
+	return container_of(panel, struct jadard_jd9365da, panel);
+}
+
+static int jadard_jd9365da_prepare(struct drm_panel *panel)
+{
+	struct jadard_jd9365da *jadard_jd9365da = panel_to_jadard_jd9365da(panel);
+	int ret;
+
+	ret = regulator_enable(jadard_jd9365da->vccio);
+	if (ret)
+		return ret;
+
+	ret = regulator_enable(jadard_jd9365da->vdd);
+	if (ret)
+		return ret;
+
+	gpiod_set_value(jadard_jd9365da->reset, 1);
+	msleep(120);
+
+	return 0;
+}
+
+static int jadard_jd9365da_enable(struct drm_panel *panel)
+{
+	struct device *dev = panel->dev;
+	struct jadard_jd9365da *jadard_jd9365da = panel_to_jadard_jd9365da(panel);
+	const struct jadard_jd9365da_panel_desc *desc = jadard_jd9365da->desc;
+	struct mipi_dsi_device *dsi = jadard_jd9365da->dsi;
+	unsigned int i;
+	int err;
+
+	msleep(10);
+
+	for (i = 0; i < desc->num_init_cmds; i++) {
+		const struct jadard_jd9365da_init_cmd *cmd = &desc->init_cmds[i];
+
+		err = mipi_dsi_dcs_write_buffer(dsi, cmd->data, JADARD_JD9365DA_INIT_CMD_LEN);
+		if (err < 0)
+			return err;
+	}
+
+	msleep(120);
+
+	err = mipi_dsi_dcs_exit_sleep_mode(dsi);
+	if (err < 0)
+		DRM_DEV_ERROR(dev, "failed to exit sleep mode ret = %d\n", err);
+
+	err =  mipi_dsi_dcs_set_display_on(dsi);
+	if (err < 0)
+		DRM_DEV_ERROR(dev, "failed to set display on ret = %d\n", err);
+
+	return 0;
+}
+
+static int jadard_jd9365da_disable(struct drm_panel *panel)
+{
+	struct device *dev = panel->dev;
+	struct jadard_jd9365da *jadard_jd9365da = panel_to_jadard_jd9365da(panel);
+	int ret;
+
+	ret = mipi_dsi_dcs_set_display_off(jadard_jd9365da->dsi);
+	if (ret < 0)
+		DRM_DEV_ERROR(dev, "failed to set display off: %d\n", ret);
+
+	ret = mipi_dsi_dcs_enter_sleep_mode(jadard_jd9365da->dsi);
+	if (ret < 0)
+		DRM_DEV_ERROR(dev, "failed to enter sleep mode: %d\n", ret);
+
+	return 0;
+}
+
+static int jadard_jd9365da_unprepare(struct drm_panel *panel)
+{
+	struct jadard_jd9365da *jadard_jd9365da = panel_to_jadard_jd9365da(panel);
+
+	gpiod_set_value(jadard_jd9365da->reset, 1);
+	msleep(120);
+
+	regulator_disable(jadard_jd9365da->vdd);
+	regulator_disable(jadard_jd9365da->vccio);
+
+	return 0;
+}
+
+static int jadard_jd9365da_get_modes(struct drm_panel *panel,
+			    struct drm_connector *connector)
+{
+	struct jadard_jd9365da *jadard_jd9365da = panel_to_jadard_jd9365da(panel);
+	const struct drm_display_mode *desc_mode = &jadard_jd9365da->desc->mode;
+	struct drm_display_mode *mode;
+
+	mode = drm_mode_duplicate(connector->dev, desc_mode);
+	if (!mode) {
+		DRM_DEV_ERROR(&jadard_jd9365da->dsi->dev, "failed to add mode %ux%ux@%u\n",
+			      desc_mode->hdisplay, desc_mode->vdisplay,
+			      drm_mode_vrefresh(desc_mode));
+		return -ENOMEM;
+	}
+
+	drm_mode_set_name(mode);
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+
+	return 1;
+}
+
+static const struct drm_panel_funcs jadard_jd9365da_funcs = {
+	.prepare = jadard_jd9365da_prepare,
+	.enable = jadard_jd9365da_enable,
+	.disable = jadard_jd9365da_disable,
+	.unprepare = jadard_jd9365da_unprepare,
+	.get_modes = jadard_jd9365da_get_modes,
+};
+
+static const struct jadard_jd9365da_init_cmd radxa_display_8hd_init_cmds[] = {
+	{ .data = { 0xE0, 0x00 } },
+	{ .data = { 0xE1, 0x93 } },
+	{ .data = { 0xE2, 0x65 } },
+	{ .data = { 0xE3, 0xF8 } },
+	{ .data = { 0x80, 0x03 } },
+	{ .data = { 0xE0, 0x01 } },
+	{ .data = { 0x00, 0x00 } },
+	{ .data = { 0x01, 0x7E } },
+	{ .data = { 0x03, 0x00 } },
+	{ .data = { 0x04, 0x65 } },
+	{ .data = { 0x0C, 0x74 } },
+	{ .data = { 0x17, 0x00 } },
+	{ .data = { 0x18, 0xB7 } },
+	{ .data = { 0x19, 0x00 } },
+	{ .data = { 0x1A, 0x00 } },
+	{ .data = { 0x1B, 0xB7 } },
+	{ .data = { 0x1C, 0x00 } },
+	{ .data = { 0x24, 0xFE } },
+	{ .data = { 0x37, 0x19 } },
+	{ .data = { 0x38, 0x05 } },
+	{ .data = { 0x39, 0x00 } },
+	{ .data = { 0x3A, 0x01 } },
+	{ .data = { 0x3B, 0x01 } },
+	{ .data = { 0x3C, 0x70 } },
+	{ .data = { 0x3D, 0xFF } },
+	{ .data = { 0x3E, 0xFF } },
+	{ .data = { 0x3F, 0xFF } },
+	{ .data = { 0x40, 0x06 } },
+	{ .data = { 0x41, 0xA0 } },
+	{ .data = { 0x43, 0x1E } },
+	{ .data = { 0x44, 0x0F } },
+	{ .data = { 0x45, 0x28 } },
+	{ .data = { 0x4B, 0x04 } },
+	{ .data = { 0x55, 0x02 } },
+	{ .data = { 0x56, 0x01 } },
+	{ .data = { 0x57, 0xA9 } },
+	{ .data = { 0x58, 0x0A } },
+	{ .data = { 0x59, 0x0A } },
+	{ .data = { 0x5A, 0x37 } },
+	{ .data = { 0x5B, 0x19 } },
+	{ .data = { 0x5D, 0x78 } },
+	{ .data = { 0x5E, 0x63 } },
+	{ .data = { 0x5F, 0x54 } },
+	{ .data = { 0x60, 0x49 } },
+	{ .data = { 0x61, 0x45 } },
+	{ .data = { 0x62, 0x38 } },
+	{ .data = { 0x63, 0x3D } },
+	{ .data = { 0x64, 0x28 } },
+	{ .data = { 0x65, 0x43 } },
+	{ .data = { 0x66, 0x41 } },
+	{ .data = { 0x67, 0x43 } },
+	{ .data = { 0x68, 0x62 } },
+	{ .data = { 0x69, 0x50 } },
+	{ .data = { 0x6A, 0x57 } },
+	{ .data = { 0x6B, 0x49 } },
+	{ .data = { 0x6C, 0x44 } },
+	{ .data = { 0x6D, 0x37 } },
+	{ .data = { 0x6E, 0x23 } },
+	{ .data = { 0x6F, 0x10 } },
+	{ .data = { 0x70, 0x78 } },
+	{ .data = { 0x71, 0x63 } },
+	{ .data = { 0x72, 0x54 } },
+	{ .data = { 0x73, 0x49 } },
+	{ .data = { 0x74, 0x45 } },
+	{ .data = { 0x75, 0x38 } },
+	{ .data = { 0x76, 0x3D } },
+	{ .data = { 0x77, 0x28 } },
+	{ .data = { 0x78, 0x43 } },
+	{ .data = { 0x79, 0x41 } },
+	{ .data = { 0x7A, 0x43 } },
+	{ .data = { 0x7B, 0x62 } },
+	{ .data = { 0x7C, 0x50 } },
+	{ .data = { 0x7D, 0x57 } },
+	{ .data = { 0x7E, 0x49 } },
+	{ .data = { 0x7F, 0x44 } },
+	{ .data = { 0x80, 0x37 } },
+	{ .data = { 0x81, 0x23 } },
+	{ .data = { 0x82, 0x10 } },
+	{ .data = { 0xE0, 0x02 } },
+	{ .data = { 0x00, 0x47 } },
+	{ .data = { 0x01, 0x47 } },
+	{ .data = { 0x02, 0x45 } },
+	{ .data = { 0x03, 0x45 } },
+	{ .data = { 0x04, 0x4B } },
+	{ .data = { 0x05, 0x4B } },
+	{ .data = { 0x06, 0x49 } },
+	{ .data = { 0x07, 0x49 } },
+	{ .data = { 0x08, 0x41 } },
+	{ .data = { 0x09, 0x1F } },
+	{ .data = { 0x0A, 0x1F } },
+	{ .data = { 0x0B, 0x1F } },
+	{ .data = { 0x0C, 0x1F } },
+	{ .data = { 0x0D, 0x1F } },
+	{ .data = { 0x0E, 0x1F } },
+	{ .data = { 0x0F, 0x5F } },
+	{ .data = { 0x10, 0x5F } },
+	{ .data = { 0x11, 0x57 } },
+	{ .data = { 0x12, 0x77 } },
+	{ .data = { 0x13, 0x35 } },
+	{ .data = { 0x14, 0x1F } },
+	{ .data = { 0x15, 0x1F } },
+	{ .data = { 0x16, 0x46 } },
+	{ .data = { 0x17, 0x46 } },
+	{ .data = { 0x18, 0x44 } },
+	{ .data = { 0x19, 0x44 } },
+	{ .data = { 0x1A, 0x4A } },
+	{ .data = { 0x1B, 0x4A } },
+	{ .data = { 0x1C, 0x48 } },
+	{ .data = { 0x1D, 0x48 } },
+	{ .data = { 0x1E, 0x40 } },
+	{ .data = { 0x1F, 0x1F } },
+	{ .data = { 0x20, 0x1F } },
+	{ .data = { 0x21, 0x1F } },
+	{ .data = { 0x22, 0x1F } },
+	{ .data = { 0x23, 0x1F } },
+	{ .data = { 0x24, 0x1F } },
+	{ .data = { 0x25, 0x5F } },
+	{ .data = { 0x26, 0x5F } },
+	{ .data = { 0x27, 0x57 } },
+	{ .data = { 0x28, 0x77 } },
+	{ .data = { 0x29, 0x35 } },
+	{ .data = { 0x2A, 0x1F } },
+	{ .data = { 0x2B, 0x1F } },
+	{ .data = { 0x58, 0x40 } },
+	{ .data = { 0x59, 0x00 } },
+	{ .data = { 0x5A, 0x00 } },
+	{ .data = { 0x5B, 0x10 } },
+	{ .data = { 0x5C, 0x06 } },
+	{ .data = { 0x5D, 0x40 } },
+	{ .data = { 0x5E, 0x01 } },
+	{ .data = { 0x5F, 0x02 } },
+	{ .data = { 0x60, 0x30 } },
+	{ .data = { 0x61, 0x01 } },
+	{ .data = { 0x62, 0x02 } },
+	{ .data = { 0x63, 0x03 } },
+	{ .data = { 0x64, 0x6B } },
+	{ .data = { 0x65, 0x05 } },
+	{ .data = { 0x66, 0x0C } },
+	{ .data = { 0x67, 0x73 } },
+	{ .data = { 0x68, 0x09 } },
+	{ .data = { 0x69, 0x03 } },
+	{ .data = { 0x6A, 0x56 } },
+	{ .data = { 0x6B, 0x08 } },
+	{ .data = { 0x6C, 0x00 } },
+	{ .data = { 0x6D, 0x04 } },
+	{ .data = { 0x6E, 0x04 } },
+	{ .data = { 0x6F, 0x88 } },
+	{ .data = { 0x70, 0x00 } },
+	{ .data = { 0x71, 0x00 } },
+	{ .data = { 0x72, 0x06 } },
+	{ .data = { 0x73, 0x7B } },
+	{ .data = { 0x74, 0x00 } },
+	{ .data = { 0x75, 0xF8 } },
+	{ .data = { 0x76, 0x00 } },
+	{ .data = { 0x77, 0xD5 } },
+	{ .data = { 0x78, 0x2E } },
+	{ .data = { 0x79, 0x12 } },
+	{ .data = { 0x7A, 0x03 } },
+	{ .data = { 0x7B, 0x00 } },
+	{ .data = { 0x7C, 0x00 } },
+	{ .data = { 0x7D, 0x03 } },
+	{ .data = { 0x7E, 0x7B } },
+	{ .data = { 0xE0, 0x04 } },
+	{ .data = { 0x00, 0x0E } },
+	{ .data = { 0x02, 0xB3 } },
+	{ .data = { 0x09, 0x60 } },
+	{ .data = { 0x0E, 0x2A } },
+	{ .data = { 0x36, 0x59 } },
+	{ .data = { 0xE0, 0x00 } },
+};
+
+static const struct jadard_jd9365da_panel_desc radxa_display_8hd_desc = {
+	.mode = {
+		.clock		= 70000,
+
+		.hdisplay	= 800,
+		.hsync_start	= 800 + 40,
+		.hsync_end	= 800 + 40 + 18,
+		.htotal		= 800 + 40 + 18 + 20,
+
+		.vdisplay	= 1280,
+		.vsync_start	= 1280 + 20,
+		.vsync_end	= 1280 + 20 + 4,
+		.vtotal		= 1280 + 20 + 4 + 20,
+
+		.width_mm	= 127,
+		.height_mm	= 199,
+		.type		= DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED,
+	},
+	.lanes = 4,
+	.format = MIPI_DSI_FMT_RGB888,
+	.init_cmds = radxa_display_8hd_init_cmds,
+	.num_init_cmds = ARRAY_SIZE(radxa_display_8hd_init_cmds),
+};
+
+static int radxa_display_8hd_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	const struct jadard_jd9365da_panel_desc *desc;
+	struct jadard_jd9365da *jadard_jd9365da;
+	int ret;
+
+	jadard_jd9365da = devm_kzalloc(&dsi->dev, sizeof(jadard_jd9365da), GFP_KERNEL);
+	if (!jadard_jd9365da)
+		return -ENOMEM;
+
+	desc = of_device_get_match_data(dev);
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_MODE_EOT_PACKET;
+	dsi->format = desc->format;
+	dsi->lanes = desc->lanes;
+
+	jadard_jd9365da->reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(jadard_jd9365da->reset)) {
+		DRM_DEV_ERROR(&dsi->dev, "failed to get reset GPIO\n");
+		return PTR_ERR(jadard_jd9365da->reset);
+	}
+
+	jadard_jd9365da->vdd = devm_regulator_get(dev, "vdd");
+	if (IS_ERR(jadard_jd9365da->vdd)) {
+		DRM_DEV_ERROR(&dsi->dev, "failed to get vdd regulator\n");
+		return PTR_ERR(jadard_jd9365da->vdd);
+	}
+
+	jadard_jd9365da->vccio = devm_regulator_get(dev, "vccio");
+	if (IS_ERR(jadard_jd9365da->vccio)) {
+		DRM_DEV_ERROR(&dsi->dev, "failed to get vccio regulator");
+		return PTR_ERR(jadard_jd9365da->vccio);
+	}
+
+	drm_panel_init(&jadard_jd9365da->panel, dev, &jadard_jd9365da_funcs,
+				DRM_MODE_CONNECTOR_DSI);
+
+	ret = drm_panel_of_backlight(&jadard_jd9365da->panel);
+	if (ret)
+		return ret;
+
+	drm_panel_add(&jadard_jd9365da->panel);
+
+	mipi_dsi_set_drvdata(dsi, jadard_jd9365da);
+	jadard_jd9365da->dsi = dsi;
+	jadard_jd9365da->desc = desc;
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0)
+		drm_panel_remove(&jadard_jd9365da->panel);
+
+	return ret;
+}
+
+static int radxa_display_8hd_remove(struct mipi_dsi_device *dsi)
+{
+	struct jadard_jd9365da *jadard_jd9365da = mipi_dsi_get_drvdata(dsi);
+
+	mipi_dsi_detach(dsi);
+	drm_panel_remove(&jadard_jd9365da->panel);
+
+	return 0;
+}
+
+static const struct of_device_id radxa_display_8hd_of_match[] = {
+	{ .compatible = "radxa,display-8hd", .data = &radxa_display_8hd_desc },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, radxa_display_8hd_of_match);
+
+static struct mipi_dsi_driver radxa_display_8hd_driver = {
+	.probe = radxa_display_8hd_probe,
+	.remove = radxa_display_8hd_remove,
+	.driver = {
+		.name = "radxa_display_8hd",
+		.of_match_table = radxa_display_8hd_of_match,
+	},
+};
+module_mipi_dsi_driver(radxa_display_8hd_driver);
+
+MODULE_AUTHOR("Stephen Chen <stephen@radxa.com>");
+MODULE_DESCRIPTION("Radxa Display 8HD panel driver");
+MODULE_LICENSE("GPL v2");
Index: kernel-rockchip/drivers/input/touchscreen/gt9xx/CJ080258_GT911_Config_20221117_085548.cfg
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/input/touchscreen/gt9xx/CJ080258_GT911_Config_20221117_085548.cfg
@@ -0,0 +1 @@
+0x62,0x20,0x03,0x00,0x05,0x0A,0x05,0x00,0x01,0x08,0x28,0x05,0x50,0x32,0x03,0x05,0x00,0x00,0x00,0x00,0x55,0x55,0x00,0x00,0x00,0x00,0x00,0x8C,0x2A,0x0E,0x17,0x15,0x31,0x0D,0x00,0x00,0x01,0x9A,0x04,0x1D,0x00,0x00,0x00,0x00,0x00,0x03,0x64,0x32,0x00,0x00,0x00,0x0F,0x36,0x94,0xC5,0x02,0x07,0x00,0x00,0x04,0x9B,0x11,0x00,0x7B,0x16,0x00,0x64,0x1C,0x00,0x4F,0x25,0x00,0x41,0x2F,0x00,0x41,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1C,0x1A,0x18,0x16,0x14,0x12,0x10,0x0E,0x0C,0x0A,0x08,0x06,0x04,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x24,0x22,0x21,0x20,0x1F,0x1E,0x1D,0x1C,0x18,0x16,0x14,0x13,0x12,0x10,0x0F,0x0C,0x0A,0x08,0x06,0x04,0x02,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x72,0x01
\ No newline at end of file
Index: kernel-rockchip/drivers/input/touchscreen/gt9xx/gt9xx_cfg.h
===================================================================
--- kernel-rockchip.orig/drivers/input/touchscreen/gt9xx/gt9xx_cfg.h
+++ kernel-rockchip/drivers/input/touchscreen/gt9xx/gt9xx_cfg.h
@@ -33,6 +33,11 @@ static u8 gtp_dat_gt9111[] = {
 	#include "HLS-0102-1398V1-1060-GT911_Config_20201204_V66.cfg"
 };
 
+u8 gtp_dat_gt9112[] = {
+  /* <800, 1280> */
+  #include "CJ080258_GT911_Config_20221117_085548.cfg"
+};
+
 static u8 gtp_dat_8_9[] = {
 	/* TODO:Puts your update firmware data here! */
 	/* <1920, 1200> 8.9 */
Index: kernel-rockchip/drivers/input/touchscreen/Kconfig
===================================================================
--- kernel-rockchip.orig/drivers/input/touchscreen/Kconfig
+++ kernel-rockchip/drivers/input/touchscreen/Kconfig
@@ -1374,4 +1374,9 @@ config TOUCHSCREEN_ZINITIX
 	  To compile this driver as a module, choose M here: the
 	  module will be called zinitix.
 
+config TOUCHSCREEN_RASPITS_FT5426
+  tristate "Raspberry Pi 7 inch touchscreen touch control IC FT5426"
+  depends on I2C
+  help
+    Control FT5426 touch IC.
 endif
Index: kernel-rockchip/drivers/input/touchscreen/Makefile
===================================================================
--- kernel-rockchip.orig/drivers/input/touchscreen/Makefile
+++ kernel-rockchip/drivers/input/touchscreen/Makefile
@@ -122,3 +122,4 @@ obj-$(CONFIG_TOUCHSCREEN_ROHM_BU21023)	+
 obj-$(CONFIG_TOUCHSCREEN_RASPBERRYPI_FW)	+= raspberrypi-ts.o
 obj-$(CONFIG_TOUCHSCREEN_IQS5XX)	+= iqs5xx.o
 obj-$(CONFIG_TOUCHSCREEN_ZINITIX)	+= zinitix.o
+obj-$(CONFIG_TOUCHSCREEN_RASPITS_FT5426)  += raspits_ft5426.o
Index: kernel-rockchip/drivers/input/touchscreen/raspits_ft5426.c
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/input/touchscreen/raspits_ft5426.c
@@ -0,0 +1,309 @@
+/*
+ *
+ * Raspberry Pi 7 inch Touchscreen FT5426 touch driver.
+ *
+ * Copyright (c) 2016 ASUSTek Computer Inc.
+ * Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/input/mt.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include "raspits_ft5426.h"
+
+static int fts_i2c_read(struct i2c_client *client, char *writebuf,
+			   int writelen, char *readbuf, int readlen)
+{
+	int ret;
+
+	if (writelen > 0) {
+		struct i2c_msg msgs[] = {
+			{
+				 .addr = client->addr,
+				 .flags = 0,
+				 .len = writelen,
+				 .buf = writebuf,
+			 },
+			{
+				 .addr = client->addr,
+				 .flags = I2C_M_RD,
+				 .len = readlen,
+				 .buf = readbuf,
+			 },
+		};
+		ret = i2c_transfer(client->adapter, msgs, 2);
+		if (ret < 0)
+			LOG_ERR("i2c read error, %d\n", ret);
+	} else {
+		struct i2c_msg msgs[] = {
+			{
+				 .addr = client->addr,
+				 .flags = I2C_M_RD,
+				 .len = readlen,
+				 .buf = readbuf,
+			 },
+		};
+		ret = i2c_transfer(client->adapter, msgs, 1);
+		if (ret < 0)
+			LOG_ERR("i2c read error, %d\n", ret);
+	}
+
+	return ret;
+}
+
+static int fts_read_reg(struct i2c_client *client, u8 addr, u8 *val)
+{
+	return fts_i2c_read(client, &addr, 1, val, 1);
+}
+
+static int fts_check_fw_ver(struct i2c_client *client)
+{
+	u8 reg_addr, fw_ver[3];
+	int ret;
+
+	reg_addr = FT_REG_FW_VER;
+	ret = fts_i2c_read(client, &reg_addr, 1, &fw_ver[0], 1);
+	if (ret < 0)
+		goto error;
+
+	reg_addr = FT_REG_FW_MIN_VER;
+	ret = fts_i2c_read(client, &reg_addr, 1, &fw_ver[1], 1);
+	if (ret < 0)
+		goto error;
+
+	reg_addr = FT_REG_FW_SUB_MIN_VER;
+	ret = fts_i2c_read(client, &reg_addr, 1, &fw_ver[2], 1);
+	if (ret < 0)
+		goto error;
+
+	LOG_INFO("Firmware version = %d.%d.%d\n", fw_ver[0], fw_ver[1], fw_ver[2]);
+	return 0;
+
+error:
+	return ret;
+}
+
+static int fts_read_td_status(struct raspits_ft5426_data *ts_data)
+{
+	u8 td_status;
+	int ret = -1;
+	ret = fts_read_reg(ts_data->client, FT_TD_STATUS_REG, &td_status);
+	if (ret < 0) {
+		LOG_ERR("get reg td_status failed, %d\n", ret);
+		return ret;
+	}
+	return (int)td_status;
+}
+
+static int fts_read_touchdata(struct raspits_ft5426_data *ts_data)
+{
+	struct ts_event *event = &ts_data->event;
+	int ret = -1, i;
+	u8 buf[FT_ONE_TCH_LEN-2] = { 0 };
+	u8 reg_addr, pointid = FT_MAX_ID;
+
+	for (i = 0; i < event->touch_point && i < MAX_TOUCH_POINTS; i++) {
+		reg_addr = FT_TOUCH_X_H_REG + (i * FT_ONE_TCH_LEN);
+		ret = fts_i2c_read(ts_data->client, &reg_addr, 1, buf, FT_ONE_TCH_LEN-2);
+		if (ret < 0) {
+			LOG_ERR("read touchdata failed.\n");
+			return ret;
+		}
+
+		pointid = (buf[FT_TOUCH_ID]) >> 4;
+		if (pointid >= MAX_TOUCH_POINTS)
+			break;
+		event->au8_finger_id[i] = pointid;
+		event->au16_x[i] = (s16) (buf[FT_TOUCH_X_H] & 0x0F) << 8 | (s16) buf[FT_TOUCH_X_L];
+		event->au16_y[i] = (s16) (buf[FT_TOUCH_Y_H] & 0x0F) << 8 | (s16) buf[FT_TOUCH_Y_L];
+		event->au8_touch_event[i] = buf[FT_TOUCH_EVENT] >> 6;
+
+#if XY_REVERSE
+		event->au16_x[i] = SCREEN_WIDTH - event->au16_x[i] - 1;
+		event->au16_y[i] = SCREEN_HEIGHT - event->au16_y[i] - 1;
+#endif
+	}
+	event->pressure = FT_PRESS;
+
+	return 0;
+}
+
+static void fts_report_value(struct raspits_ft5426_data *ts_data)
+{
+	struct ts_event *event = &ts_data->event;
+	int i, modified_ids = 0, released_ids;
+
+	for (i = 0; i < event->touch_point && i < MAX_TOUCH_POINTS; i++) {
+		if (event->au8_touch_event[i]== FT_TOUCH_DOWN
+				|| event->au8_touch_event[i] == FT_TOUCH_CONTACT)
+		{
+			modified_ids |= 1 << event->au8_finger_id[i];
+			input_mt_slot(ts_data->input_dev, event->au8_finger_id[i]);
+			input_mt_report_slot_state(ts_data->input_dev, MT_TOOL_FINGER,
+				true);
+			input_report_abs(ts_data->input_dev, ABS_MT_TOUCH_MAJOR,
+					event->pressure);
+			input_report_abs(ts_data->input_dev, ABS_MT_POSITION_X,
+					event->au16_x[i]);
+			input_report_abs(ts_data->input_dev, ABS_MT_POSITION_Y,
+					event->au16_y[i]);
+
+			if(!((1 << event->au8_finger_id[i]) & ts_data->known_ids))
+				LOG_DBG("Touch id-%d: x = %d, y = %d\n",
+					event->au8_finger_id[i], event->au16_x[i], event->au16_y[i]);
+		}
+	}
+
+	released_ids = ts_data->known_ids & ~modified_ids;
+	for(i = 0; released_ids && i < MAX_TOUCH_POINTS; i++) {
+		if(released_ids & (1<<i)) {
+			LOG_DBG("Release id-%d, known = %x modified = %x\n", i, ts_data->known_ids, modified_ids);
+			input_mt_slot(ts_data->input_dev, i);
+			input_mt_report_slot_state(ts_data->input_dev, MT_TOOL_FINGER, false);
+			modified_ids &= ~(1 << i);
+		}
+	}
+	ts_data->known_ids = modified_ids;
+	input_mt_report_pointer_emulation(ts_data->input_dev, true);
+	input_sync(ts_data->input_dev);
+}
+
+static void raspits_ft5426_work(struct work_struct *work)
+{
+	struct raspits_ft5426_data *ts_data
+			= container_of(work, struct raspits_ft5426_data, ft5426_work);
+	struct ts_event *event = &ts_data->event;
+	int ret = 0, count = 8, td_status;
+
+	while(count > 0) {
+		ret = fts_check_fw_ver(ts_data->client);
+		if (ret == 0)
+			break;
+		LOG_INFO("checking touch ic, countdown: %d\n", count);
+		msleep(1000);
+		count--;
+	}
+	if (!count) {
+		LOG_ERR("checking touch ic timeout, %d\n", ret);
+		return;
+	}
+
+	//polling 60fps
+	while(1) {
+		td_status = fts_read_td_status(ts_data);
+		if (td_status < VALID_TD_STATUS_VAL+1 && (td_status > 0 || ts_data->known_ids != 0)) {
+			memset(event, -1, sizeof(struct ts_event));
+			event->touch_point = td_status;
+			ret = fts_read_touchdata(ts_data);
+			if (ret == 0)
+				fts_report_value(ts_data);
+		}
+		msleep_interruptible(17);
+	}
+}
+
+static int raspits_ft5426_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct raspits_ft5426_data *ts_data;
+	struct input_dev *input_dev;
+	int ret = 0;//, timeout = 10;
+
+	LOG_INFO("address = 0x%x\n", client->addr);
+
+	ts_data = kzalloc(sizeof(struct raspits_ft5426_data), GFP_KERNEL);
+	if (ts_data == NULL) {
+		LOG_ERR("no memory for device\n");
+		return -ENOMEM;
+	}
+
+	ts_data->client = client;
+	i2c_set_clientdata(client, ts_data);
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		LOG_ERR("failed to allocate input device\n");
+		goto input_allocate_failed;
+	}
+	input_dev->name = "fts_ts";
+	input_dev->id.bustype = BUS_I2C;
+	input_dev->dev.parent = &ts_data->client->dev;
+
+	ts_data->input_dev = input_dev;
+	input_set_drvdata(input_dev, ts_data);
+
+	__set_bit(EV_SYN, input_dev->evbit);
+	__set_bit(EV_KEY, input_dev->evbit);
+	__set_bit(EV_ABS, input_dev->evbit);
+	__set_bit(BTN_TOUCH, input_dev->keybit);
+
+	input_mt_init_slots(input_dev, MAX_TOUCH_POINTS, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0,
+			     SCREEN_WIDTH, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0,
+			     SCREEN_HEIGHT, 0, 0);
+
+	ret = input_register_device(input_dev);
+	if (ret) {
+		LOG_ERR("Input device registration failed\n");
+		goto input_register_failed;
+	}
+
+	INIT_WORK(&ts_data->ft5426_work, raspits_ft5426_work);
+	schedule_work(&ts_data->ft5426_work);
+
+	return 0;
+
+input_register_failed:
+	input_free_device(input_dev);
+input_allocate_failed:
+	kfree(ts_data);
+	return ret;
+}
+
+static int raspits_ft5426_remove(struct i2c_client *client)
+{
+	struct raspits_ft5426_data *ts_data = i2c_get_clientdata(client);
+
+	cancel_work_sync(&ts_data->ft5426_work);
+	if (ts_data->input_dev) {
+		input_unregister_device(ts_data->input_dev);
+		input_free_device(ts_data->input_dev);
+	}
+	kfree(ts_data);
+	return 0;
+}
+
+static const struct i2c_device_id raspits_ft5426_id[] = {
+	{ "raspits_ft5426", 0 },
+	{ },
+};
+
+static struct i2c_driver raspits_ft5426_driver = {
+	.driver = {
+		.name = "raspits_ft5426",
+	},
+	.probe = raspits_ft5426_probe,
+	.remove = raspits_ft5426_remove,
+	.id_table = raspits_ft5426_id,
+};
+module_i2c_driver(raspits_ft5426_driver);
+
+MODULE_DESCRIPTION("Raspberry Pi 7 inch Touchscreen FT5426 Touch driver");
+MODULE_LICENSE("GPL v2");
+
Index: kernel-rockchip/drivers/input/touchscreen/raspits_ft5426.h
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/input/touchscreen/raspits_ft5426.h
@@ -0,0 +1,64 @@
+#ifndef _RASPITS_FT5426_H_
+#define _RASPITS_FT5426_H_
+
+#define LOG_DBG(fmt,arg...) pr_debug("raspits-ft5426: %s: "fmt, __func__, ##arg);
+#define LOG_INFO(fmt,arg...) pr_info("raspits-ft5426: %s: "fmt, __func__, ##arg);
+#define LOG_ERR(fmt,arg...) pr_err("raspits-ft5426: %s: "fmt, __func__, ##arg);
+
+#define XY_REVERSE 1
+
+#define SCREEN_WIDTH	800
+#define SCREEN_HEIGHT	480
+
+#define FT_ONE_TCH_LEN	6
+
+#define FT_REG_FW_VER			0xA6
+#define FT_REG_FW_MIN_VER		0xB2
+#define FT_REG_FW_SUB_MIN_VER	0xB3
+
+#define VALID_TD_STATUS_VAL		10
+#define MAX_TOUCH_POINTS		1
+
+#define FT_PRESS			0x7F
+#define FT_MAX_ID			0x0F
+
+#define FT_TOUCH_X_H	0
+#define FT_TOUCH_X_L	1
+#define FT_TOUCH_Y_H	2
+#define FT_TOUCH_Y_L	3
+#define FT_TOUCH_EVENT	0
+#define FT_TOUCH_ID		2
+
+#define FT_TOUCH_X_H_REG	3
+#define FT_TOUCH_X_L_REG	4
+#define FT_TOUCH_Y_H_REG	5
+#define FT_TOUCH_Y_L_REG	6
+#define FT_TD_STATUS_REG	2
+#define FT_TOUCH_EVENT_REG	3
+#define FT_TOUCH_ID_REG		5
+
+#define FT_TOUCH_DOWN		0
+#define FT_TOUCH_CONTACT	2
+
+struct ts_event {
+	u16 au16_x[MAX_TOUCH_POINTS]; /*x coordinate */
+	u16 au16_y[MAX_TOUCH_POINTS]; /*y coordinate */
+	u8 au8_touch_event[MAX_TOUCH_POINTS]; /*touch event: 0:down; 1:up; 2:contact */
+	u8 au8_finger_id[MAX_TOUCH_POINTS]; /*touch ID */
+	u16 pressure;
+	u8 touch_point;
+	u8 point_num;
+};
+
+struct raspits_ft5426_data {
+	struct device *dev;
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct ts_event event;
+	struct work_struct ft5426_work;
+
+	int known_ids;
+};
+
+#endif
+
Index: kernel-rockchip/drivers/misc/Kconfig
===================================================================
--- kernel-rockchip.orig/drivers/misc/Kconfig
+++ kernel-rockchip/drivers/misc/Kconfig
@@ -498,6 +498,12 @@ config HISI_HIKEY_USB
 	  switching between the dual-role USB-C port and the USB-A host ports
 	  using only one USB controller.
 
+config KHADAS_MCU
+  tristate "Khadas MCU control driver"
+  default y
+  help
+    This driver allow to control MCU.
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
Index: kernel-rockchip/drivers/misc/Makefile
===================================================================
--- kernel-rockchip.orig/drivers/misc/Makefile
+++ kernel-rockchip/drivers/misc/Makefile
@@ -62,3 +62,4 @@ obj-$(CONFIG_UACCE)		+= uacce/
 obj-$(CONFIG_XILINX_SDFEC)	+= xilinx_sdfec.o
 obj-$(CONFIG_HISI_HIKEY_USB)	+= hisi_hikey_usb.o
 obj-$(CONFIG_UID_SYS_STATS)	+= uid_sys_stats.o
+obj-$(CONFIG_KHADAS_MCU) += khadas-mcu.o
Index: kernel-rockchip/drivers/misc/khadas-mcu.c
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/misc/khadas-mcu.c
@@ -0,0 +1,698 @@
+/*
+ * Khadas Edge2 MCU control driver
+ *
+ * Written by: Nick <nick@khadas.com>
+ *
+ * Copyright (C) 2022 Wesion Technologies Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/string.h>
+#include <linux/list.h>
+#include <linux/sysfs.h>
+#include <linux/ctype.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+
+/* Device registers */
+#define MCU_PWR_OFF_CMD_REG       0x80
+#define MCU_SHUTDOWN_NORMAL_REG   0x2c
+
+/*Fan device*/
+#define MCU_CMD_FAN_STATUS_CTRL_REGv2   0x8A
+
+#define MCU_FAN_TRIG_TEMP_LEVEL0        60  // 50 degree if not set
+#define MCU_FAN_TRIG_TEMP_LEVEL1        80  // 60 degree if not set
+#define MCU_FAN_TRIG_TEMP_LEVEL2        100 // 70 degree if not set
+#define MCU_FAN_TRIG_MAXTEMP            105
+#define MCU_FAN_LOOP_SECS               (30 * HZ)   // 30 seconds
+#define MCU_FAN_TEST_LOOP_SECS          (5 * HZ)  // 5 seconds
+#define MCU_FAN_LOOP_NODELAY_SECS       0
+#define MCU_FAN_SPEED_OFF               0
+#define MCU_FAN_SPEED_LOW               1
+#define MCU_FAN_SPEED_MID               2
+#define MCU_FAN_SPEED_HIGH              3
+#define MCU_FAN_SPEED_LOW_V2            0x32
+#define MCU_FAN_SPEED_MID_V2            0x48
+#define MCU_FAN_SPEED_HIGH_V2           0x64
+
+enum khadas_board {
+	KHADAS_BOARD_NONE = 0,
+	KHADAS_BOARD_EDGE2
+};
+
+enum khadas_board_hwver {
+	KHADAS_BOARD_HWVER_NONE = 0,
+	KHADAS_BOARD_HWVER_V11
+};
+
+enum mcu_fan_mode {
+	MCU_FAN_MODE_MANUAL = 0,
+	MCU_FAN_MODE_AUTO
+};
+
+enum mcu_fan_level {
+	MCU_FAN_LEVEL_0 = 0,
+	MCU_FAN_LEVEL_1,
+	MCU_FAN_LEVEL_2,
+	MCU_FAN_LEVEL_3
+};
+
+enum mcu_fan_status {
+	MCU_FAN_STATUS_DISABLE = 0,
+	MCU_FAN_STATUS_ENABLE,
+};
+
+struct mcu_fan_data {
+    struct platform_device *pdev;
+    struct class *fan_class;
+    struct delayed_work work;
+    struct delayed_work fan_test_work;
+    enum mcu_fan_status enable;
+    enum mcu_fan_mode mode;
+    enum mcu_fan_level level;
+    int trig_temp_level0;
+    int trig_temp_level1;
+    int trig_temp_level2;
+};
+
+struct mcu_data {
+	struct i2c_client *client;
+	struct class *mcu_class;
+	enum khadas_board board;
+	enum khadas_board_hwver hwver;
+	struct mcu_fan_data fan_data;
+};
+
+struct mcu_data *g_mcu_data;
+
+static int i2c_master_reg8_send(const struct i2c_client *client,
+		const char reg, const char *buf, int count)
+{
+	struct i2c_adapter *adap = client->adapter;
+	struct i2c_msg msg;
+	int ret;
+	char *tx_buf = kzalloc(count + 1, GFP_KERNEL);
+	if (!tx_buf)
+		return -ENOMEM;
+	tx_buf[0] = reg;
+	memcpy(tx_buf+1, buf, count);
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = count + 1;
+	msg.buf = (char *)tx_buf;
+
+	ret = i2c_transfer(adap, &msg, 1);
+	kfree(tx_buf);
+	return (ret == 1) ? count : ret;
+}
+
+#if 0
+static int i2c_master_reg8_recv(const struct i2c_client *client,
+		const char reg, char *buf, int count)
+{
+	struct i2c_adapter *adap = client->adapter;
+	struct i2c_msg msgs[2];
+	int ret;
+	char reg_buf = reg;
+
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].len = 1;
+	msgs[0].buf = &reg_buf;
+
+	msgs[1].addr = client->addr;
+	msgs[1].flags = client->flags | I2C_M_RD;
+	msgs[1].len = count;
+	msgs[1].buf = (char *)buf;
+
+	ret = i2c_transfer(adap, msgs, 2);
+
+	return (ret == 2) ? count : ret;
+}
+
+static int mcu_i2c_read_regs(struct i2c_client *client,
+		u8 reg, u8 buf[], unsigned len)
+{
+	int ret;
+	ret = i2c_master_reg8_recv(client, reg, buf, len);
+	return ret;
+}
+#endif
+
+static int mcu_i2c_write_regs(struct i2c_client *client,
+		u8 reg, u8 const buf[], __u16 len)
+{
+	int ret;
+
+	ret = i2c_master_reg8_send(client, reg, buf, (int)len);
+
+	return ret;
+}
+
+static int is_mcu_fan_control_supported(void)
+{
+	// MCU FAN control is supported for:
+	// 1. Khadas EDGE2
+	if (g_mcu_data->board == KHADAS_BOARD_EDGE2) {
+		if (g_mcu_data->hwver >= KHADAS_BOARD_HWVER_V11)
+			return 1;
+		else
+			return 0;
+	} else {
+			return 0;
+	}
+
+}
+static void mcu_fan_level_set(struct mcu_fan_data *fan_data, int level)
+{
+    if (is_mcu_fan_control_supported()) {
+        int ret;
+        u8 data = 0;
+
+        g_mcu_data->fan_data.level = level;
+
+		if (g_mcu_data->board == KHADAS_BOARD_EDGE2) {
+            if (level == 0)
+                data = MCU_FAN_SPEED_OFF;
+            else if (level == 1)
+                data = MCU_FAN_SPEED_LOW_V2;
+            else if (level == 2)
+                data = MCU_FAN_SPEED_MID_V2;
+            else if (level == 3)
+                data = MCU_FAN_SPEED_HIGH_V2;
+            ret = mcu_i2c_write_regs(g_mcu_data->client,
+                    MCU_CMD_FAN_STATUS_CTRL_REGv2,
+                    &data, 1);
+            if (ret < 0) {
+                pr_debug("write fan control err\n");
+                return;
+            }
+	      }
+    }
+}
+
+extern int rk_get_temperature(void);
+
+static void fan_work_func(struct work_struct *_work)
+{
+    if (is_mcu_fan_control_supported()) {
+        int temp = -EINVAL;
+        struct mcu_fan_data *fan_data = &g_mcu_data->fan_data;
+
+		if (g_mcu_data->board == KHADAS_BOARD_EDGE2) {
+            temp = rk_get_temperature();
+		} else {
+           temp = fan_data->trig_temp_level0;
+		}
+
+		if (temp != -EINVAL) {
+            if (temp < fan_data->trig_temp_level0)
+                mcu_fan_level_set(fan_data, 0);
+            else if (temp < fan_data->trig_temp_level1)
+                mcu_fan_level_set(fan_data, 1);
+            else if (temp < fan_data->trig_temp_level2)
+                mcu_fan_level_set(fan_data, 2);
+            else
+                mcu_fan_level_set(fan_data, 3);
+        }
+
+        schedule_delayed_work(&fan_data->work, MCU_FAN_LOOP_SECS);
+    }
+}
+
+static void khadas_fan_set(struct mcu_fan_data  *fan_data)
+{
+	if (is_mcu_fan_control_supported()) {
+        cancel_delayed_work(&fan_data->work);
+        if (fan_data->enable == MCU_FAN_STATUS_DISABLE) {
+            mcu_fan_level_set(fan_data, 0);
+            return;
+        }
+        switch (fan_data->mode) {
+        case MCU_FAN_MODE_MANUAL:
+            switch (fan_data->level) {
+				case MCU_FAN_LEVEL_0:
+					mcu_fan_level_set(fan_data, 0);
+					break;
+				case MCU_FAN_LEVEL_1:
+					mcu_fan_level_set(fan_data, 1);
+					break;
+				case MCU_FAN_LEVEL_2:
+					mcu_fan_level_set(fan_data, 2);
+					break;
+				case MCU_FAN_LEVEL_3:
+					mcu_fan_level_set(fan_data, 3);
+					break;
+				default:
+					break;
+            }
+            break;
+		case MCU_FAN_MODE_AUTO:
+            // FIXME: achieve with a better way
+			schedule_delayed_work(&fan_data->work,
+                    MCU_FAN_LOOP_NODELAY_SECS);
+			break;
+		default:
+			break;
+        }
+    }
+}
+
+static ssize_t show_fan_enable(struct class *cls,
+             struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "Fan enable: %d\n", g_mcu_data->fan_data.enable);
+}
+
+static ssize_t store_fan_enable(struct class *cls, struct class_attribute *attr,
+               const char *buf, size_t count)
+{
+    int enable;
+
+    if (kstrtoint(buf, 0, &enable))
+        return -EINVAL;
+
+    // 0: manual, 1: auto
+    if (enable >= 0 && enable < 2) {
+        g_mcu_data->fan_data.enable = enable;
+        khadas_fan_set(&g_mcu_data->fan_data);
+    }
+
+	return count;
+}
+
+
+static ssize_t show_fan_mode(struct class *cls,
+             struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "Fan mode: %d\n", g_mcu_data->fan_data.mode);
+}
+
+static ssize_t store_fan_mode(struct class *cls, struct class_attribute *attr,
+               const char *buf, size_t count)
+{
+    int mode;
+
+    if (kstrtoint(buf, 0, &mode))
+        return -EINVAL;
+
+    // 0: manual, 1: auto
+    if (mode >= 0 && mode < 2) {
+        g_mcu_data->fan_data.mode = mode;
+        khadas_fan_set(&g_mcu_data->fan_data);
+    }
+
+    return count;
+}
+
+static ssize_t show_fan_level(struct class *cls,
+             struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "Fan level: %d\n", g_mcu_data->fan_data.level);
+}
+
+static ssize_t store_fan_level(struct class *cls, struct class_attribute *attr,
+               const char *buf, size_t count)
+{
+    int level;
+
+    if (kstrtoint(buf, 0, &level))
+        return -EINVAL;
+
+    if (level >= 0 && level < 4) {
+        g_mcu_data->fan_data.level = level;
+        khadas_fan_set(&g_mcu_data->fan_data);
+    }
+
+    return count;
+}
+
+static ssize_t show_fan_temp(struct class *cls,
+             struct class_attribute *attr, char *buf)
+{
+    struct mcu_fan_data *fan_data = &g_mcu_data->fan_data;
+    int temp = -EINVAL;
+
+    if (g_mcu_data->board == KHADAS_BOARD_EDGE2)
+        temp = rk_get_temperature();
+    else
+        temp = fan_data->trig_temp_level0;
+
+    return sprintf(buf,
+            "cpu_temp:%d\nFan trigger temperature: level0:%d level1:%d level2:%d\n",
+            temp, g_mcu_data->fan_data.trig_temp_level0,
+            g_mcu_data->fan_data.trig_temp_level1,
+            g_mcu_data->fan_data.trig_temp_level2);
+}
+
+void fan_level_set(struct mcu_data *ug_mcu_data)
+{
+    struct mcu_fan_data *fan_data = &g_mcu_data->fan_data;
+    int temp = -EINVAL;
+
+    if (ug_mcu_data->board == KHADAS_BOARD_EDGE2)
+        temp = rk_get_temperature();
+    else
+        temp = fan_data->trig_temp_level0;
+
+    if (temp != -EINVAL) {
+        if (temp < ug_mcu_data->fan_data.trig_temp_level0)
+            mcu_fan_level_set(fan_data, 0);
+        else if (temp < ug_mcu_data->fan_data.trig_temp_level1)
+            mcu_fan_level_set(fan_data, 1);
+        else if (temp < ug_mcu_data->fan_data.trig_temp_level2)
+            mcu_fan_level_set(fan_data, 2);
+        else
+            mcu_fan_level_set(fan_data, 3);
+    }
+}
+
+static ssize_t show_fan_trigger_low(struct class *cls,
+        struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf,
+            "Fan trigger low speed temperature:%d\n",
+            g_mcu_data->fan_data.trig_temp_level0);
+}
+
+static ssize_t store_fan_trigger_low(struct class *cls,
+        struct class_attribute *attr,
+        const char *buf, size_t count)
+{
+    int trigger;
+
+    if (kstrtoint(buf, 0, &trigger))
+        return -EINVAL;
+
+    if (trigger >= g_mcu_data->fan_data.trig_temp_level1) {
+        pr_err("Invalid parameter\n");
+        return -EINVAL;
+    }
+
+    g_mcu_data->fan_data.trig_temp_level0 = trigger;
+
+    fan_level_set(g_mcu_data);
+
+    return count;
+}
+
+static ssize_t show_fan_trigger_mid(struct class *cls,
+        struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf,
+            "Fan trigger mid speed temperature:%d\n",
+            g_mcu_data->fan_data.trig_temp_level1);
+}
+
+static ssize_t store_fan_trigger_mid(struct class *cls,
+        struct class_attribute *attr,
+        const char *buf, size_t count)
+{
+    int trigger;
+
+    if (kstrtoint(buf, 0, &trigger))
+        return -EINVAL;
+
+    if (trigger >= g_mcu_data->fan_data.trig_temp_level2 ||
+            trigger <= g_mcu_data->fan_data.trig_temp_level0){
+        pr_err("Invalid parameter\n");
+        return -EINVAL;
+    }
+
+    g_mcu_data->fan_data.trig_temp_level1 = trigger;
+
+    fan_level_set(g_mcu_data);
+
+    return count;
+}
+
+static ssize_t show_fan_trigger_high(struct class *cls,
+        struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf,
+            "Fan trigger high speed temperature:%d\n",
+            g_mcu_data->fan_data.trig_temp_level2);
+}
+
+static ssize_t store_fan_trigger_high(struct class *cls,
+        struct class_attribute *attr,
+        const char *buf, size_t count)
+{
+    int trigger;
+
+    if (kstrtoint(buf, 0, &trigger))
+        return -EINVAL;
+
+    if (trigger <= g_mcu_data->fan_data.trig_temp_level1) {
+        pr_err("Invalid parameter\n");
+        return -EINVAL;
+    }
+
+    g_mcu_data->fan_data.trig_temp_level2 = trigger;
+
+    fan_level_set(g_mcu_data);
+
+    return count;
+}
+
+static ssize_t store_mcu_poweroff(struct class *cls,struct class_attribute *attr,
+				const char *buf, size_t count)
+{
+	int ret;
+	int val;
+	char reg;
+
+	if (kstrtoint(buf, 0, &val))
+		return -EINVAL;
+
+	if (val != 1)
+		return -EINVAL;
+
+	reg = (char)val;
+
+	ret = mcu_i2c_write_regs(g_mcu_data->client,MCU_PWR_OFF_CMD_REG,
+							&reg, 1);
+	if (ret < 0) {
+		pr_debug("write poweroff cmd error\n");
+		return ret;
+	}
+
+	return count;
+}
+
+static ssize_t store_mcu_rst(struct class *cls, struct class_attribute *attr,
+				const char *buf, size_t count)
+{
+	char reg;
+	int ret;
+	int rst;
+
+	if (kstrtoint(buf, 0, &rst))
+		return -EINVAL;
+
+	reg = rst;
+	ret = mcu_i2c_write_regs(g_mcu_data->client,MCU_SHUTDOWN_NORMAL_REG,
+							&reg, 1);
+	if (ret < 0) {
+		pr_debug("write poweroff cmd error\n");
+		return ret;
+	}
+
+	return count;
+}
+
+static struct class_attribute fan_class_attrs[] = {
+    __ATTR(enable, 0644, show_fan_enable, store_fan_enable),
+    __ATTR(mode, 0644, show_fan_mode, store_fan_mode),
+    __ATTR(level, 0644, show_fan_level, store_fan_level),
+    __ATTR(trigger_temp_low, 0644,
+            show_fan_trigger_low, store_fan_trigger_low),
+    __ATTR(trigger_temp_mid, 0644,
+            show_fan_trigger_mid, store_fan_trigger_mid),
+    __ATTR(trigger_temp_high, 0644,
+            show_fan_trigger_high, store_fan_trigger_high),
+    __ATTR(temp, 0644, show_fan_temp, NULL),
+};
+
+static struct class_attribute mcu_class_attrs[] = {
+	__ATTR(poweroff, 0644, NULL, store_mcu_poweroff),
+	__ATTR(rst, 0644, NULL, store_mcu_rst),
+};
+
+static void create_mcu_attrs(void) {
+	int i;
+
+	g_mcu_data->mcu_class = class_create(THIS_MODULE, "mcu");
+	if (IS_ERR(g_mcu_data->mcu_class)) {
+		pr_err("create mcu_class debug class fail\n");
+
+		return;
+	}
+	for (i = 0; i < ARRAY_SIZE(mcu_class_attrs); i++) {
+		if (class_create_file(g_mcu_data->mcu_class, &mcu_class_attrs[i]))
+			pr_err("create mcu attribute %s fail\n",
+							mcu_class_attrs[i].attr.name);
+	}
+
+	if (is_mcu_fan_control_supported()) {
+		g_mcu_data->fan_data.fan_class = class_create(THIS_MODULE, "fan");
+			if (IS_ERR(g_mcu_data->fan_data.fan_class)) {
+				pr_err("create fan_class debug class fail\n");
+				return;
+			}
+			for (i = 0; i < ARRAY_SIZE(fan_class_attrs); i++) {
+				if (class_create_file(g_mcu_data->fan_data.fan_class,
+                        &fan_class_attrs[i]))
+					pr_err("create fan attribute %s fail\n", fan_class_attrs[i].attr.name);
+        }
+	}
+}
+
+static int mcu_parse_dt(struct device *dev)
+{
+	int ret = 0;
+	const char *hwver = NULL;
+
+	if (NULL == dev) return -EINVAL;
+
+	ret = of_property_read_string(dev->of_node, "hwver", &hwver);
+	if (ret < 0) {
+			return 0;
+	} else {
+			if (strstr(hwver, "EDGE2"))
+					g_mcu_data->board = KHADAS_BOARD_EDGE2;
+			else
+					g_mcu_data->board = KHADAS_BOARD_NONE;
+
+			if (g_mcu_data->board == KHADAS_BOARD_EDGE2) {
+					if (strcmp(hwver, "EDGE2.V11") == 0)
+							g_mcu_data->hwver = KHADAS_BOARD_HWVER_V11;
+			}
+	}
+
+		ret = of_property_read_u32(dev->of_node,
+            "fan,trig_temp_level0",
+            &g_mcu_data->fan_data.trig_temp_level0);
+    if (ret < 0)
+        g_mcu_data->fan_data.trig_temp_level0 =
+            MCU_FAN_TRIG_TEMP_LEVEL0;
+    ret = of_property_read_u32(dev->of_node,
+            "fan,trig_temp_level1",
+            &g_mcu_data->fan_data.trig_temp_level1);
+    if (ret < 0)
+        g_mcu_data->fan_data.trig_temp_level1 =
+            MCU_FAN_TRIG_TEMP_LEVEL1;
+    ret = of_property_read_u32(dev->of_node,
+            "fan,trig_temp_level2",&g_mcu_data->fan_data.trig_temp_level2);
+    if (ret < 0){
+        g_mcu_data->fan_data.trig_temp_level2 =MCU_FAN_TRIG_TEMP_LEVEL2;
+	}
+
+	return ret;
+}
+
+static int mcu_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	printk("%s\n", __func__);
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	g_mcu_data = kzalloc(sizeof(struct mcu_data), GFP_KERNEL);
+
+	if (g_mcu_data == NULL)
+		return -ENOMEM;
+
+	mcu_parse_dt(&client->dev);
+
+	g_mcu_data->client = client;
+
+	g_mcu_data->fan_data.mode = MCU_FAN_MODE_AUTO;
+	g_mcu_data->fan_data.level = MCU_FAN_LEVEL_0;
+	g_mcu_data->fan_data.enable = MCU_FAN_STATUS_ENABLE;
+
+	INIT_DELAYED_WORK(&g_mcu_data->fan_data.work, fan_work_func);
+	mcu_fan_level_set(&g_mcu_data->fan_data, 0);
+	schedule_delayed_work(&g_mcu_data->fan_data.work, MCU_FAN_LOOP_SECS);
+	create_mcu_attrs();
+
+	return 0;
+}
+
+static int mcu_remove(struct i2c_client *client)
+{
+	kfree(g_mcu_data);
+	return 0;
+}
+
+static void khadas_fan_shutdown(struct i2c_client *client)
+{
+    g_mcu_data->fan_data.enable = MCU_FAN_STATUS_DISABLE;
+    khadas_fan_set(&g_mcu_data->fan_data);
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int khadas_fan_suspend(struct device *dev)
+{
+    cancel_delayed_work(&g_mcu_data->fan_data.work);
+    mcu_fan_level_set(&g_mcu_data->fan_data, 0);
+
+    return 0;
+}
+
+static int khadas_fan_resume(struct device *dev)
+{
+    khadas_fan_set(&g_mcu_data->fan_data);
+
+    return 0;
+}
+
+static const struct dev_pm_ops fan_dev_pm_ops = {
+    SET_SYSTEM_SLEEP_PM_OPS(khadas_fan_suspend, khadas_fan_resume)
+};
+
+#define FAN_PM_OPS (&(fan_dev_pm_ops))
+
+#endif
+
+static const struct i2c_device_id mcu_id[] = {
+	{ "khadas-mcu", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, mcu_id);
+
+
+static struct of_device_id mcu_dt_ids[] = {
+	{ .compatible = "khadas-mcu" },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, mcu_dt_ids);
+
+struct i2c_driver mcu_driver = {
+	.driver  = {
+		.name   = "khadas-mcu",
+		.owner  = THIS_MODULE,
+		.of_match_table = of_match_ptr(mcu_dt_ids),
+#ifdef CONFIG_PM_SLEEP
+		.pm = FAN_PM_OPS,
+#endif
+	},
+	.probe		= mcu_probe,
+	.remove 	= mcu_remove,
+	.shutdown = khadas_fan_shutdown,
+	.id_table	= mcu_id,
+};
+module_i2c_driver(mcu_driver);
+
+MODULE_AUTHOR("Nick <nick@khadas.com>");
+MODULE_DESCRIPTION("Khadas Edge2 MCU control driver");
+MODULE_LICENSE("GPL");
Index: kernel-rockchip/drivers/watchdog/Kconfig
===================================================================
--- kernel-rockchip.orig/drivers/watchdog/Kconfig
+++ kernel-rockchip/drivers/watchdog/Kconfig
@@ -2165,4 +2165,14 @@ config USBPCWATCHDOG
 
 	  Most people will say N.
 
+config KHADAS_WATCHDOG
+  tristate "KHADAS watchdog support"
+  default y
+  help
+   Say Y here to include watchdog support embedded into KHADAS.
+   If the watchdog timer expires, TPS3851 will shut down all its power
+   supplies.
+   To compile this driver as a module, choose M here: the
+   module will be called KHADAS_wdt.
+
 endif # WATCHDOG
Index: kernel-rockchip/drivers/watchdog/Makefile
===================================================================
--- kernel-rockchip.orig/drivers/watchdog/Makefile
+++ kernel-rockchip/drivers/watchdog/Makefile
@@ -227,3 +227,4 @@ obj-$(CONFIG_MENZ069_WATCHDOG) += menz69
 obj-$(CONFIG_RAVE_SP_WATCHDOG) += rave-sp-wdt.o
 obj-$(CONFIG_STPMIC1_WATCHDOG) += stpmic1_wdt.o
 obj-$(CONFIG_SL28CPLD_WATCHDOG) += sl28cpld_wdt.o
+obj-$(CONFIG_KHADAS_WATCHDOG) += khadas_wdt.o
Index: kernel-rockchip/drivers/watchdog/khadas_wdt.c
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/watchdog/khadas_wdt.c
@@ -0,0 +1,157 @@
+//#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/fs.h>
+#include <linux/timer.h>
+#include <linux/jiffies.h>
+
+static struct timer_list mytimer;
+static unsigned int hw_margin = 3;
+static int khadas_input_pin;
+static unsigned int khadas_enble = 1;
+
+static void time_pre(struct timer_list *timer)
+{
+	static unsigned int flag=0;
+    flag = !flag;
+	gpio_direction_output(khadas_input_pin, flag);
+
+    //printk("%s\n", __func__);
+    mytimer.expires = jiffies + hw_margin * HZ/1000;  // 500ms 
+	if(khadas_enble)
+		mod_timer(&mytimer, mytimer.expires);
+}
+
+/*
+static void wdt_exit(void)
+{
+    if(timer_pending(&mytimer))
+    {
+        del_timer(&mytimer);
+    }
+    printk("exit Success \n");
+}*/
+
+static ssize_t show_enble(struct class *cls,
+				struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", khadas_enble);
+}
+
+static ssize_t store_enble(struct class *cls, struct class_attribute *attr,
+		        const char *buf, size_t count)
+{
+	int enable;
+
+	if (kstrtoint(buf, 0, &enable)){
+		printk("khadas_enble error\n");
+		return -EINVAL;
+	}
+	printk("khadas_enble=%d\n",enable);
+	khadas_enble = enable;
+	if(khadas_enble){
+		mytimer.expires = jiffies + hw_margin * HZ/1000;  // 500ms 
+		mod_timer(&mytimer, mytimer.expires);
+	}
+	return count;
+}
+
+static ssize_t store_pin_out(struct class *cls, struct class_attribute *attr,
+		        const char *buf, size_t count)
+{
+	int enable;
+
+	if (kstrtoint(buf, 0, &enable)){
+		printk("khadas_pin_out error\n");
+		return -EINVAL;
+	}
+	printk("khadas_pin_out=%d\n",enable);
+	gpio_direction_output(khadas_input_pin, enable);
+	return count;
+}
+
+static struct class_attribute khadas_attrs[] = {
+	__ATTR(enble, 0644, show_enble, store_enble),
+	__ATTR(pin_out, 0644, NULL, store_pin_out),
+};
+
+static void create_khadas_attrs(void)
+{
+	int i;
+	struct class *khadas_class;
+	printk("%s\n",__func__);
+	khadas_class = class_create(THIS_MODULE, "khadas");
+	if (IS_ERR(khadas_class)) {
+		pr_err("create khadas_class debug class fail\n");
+		return;
+	}
+	for (i = 0; i < ARRAY_SIZE(khadas_attrs); i++) {
+		if (class_create_file(khadas_class, &khadas_attrs[i]))
+			pr_err("create khadas attribute %s fail\n", khadas_attrs[i].attr.name);
+	}
+}
+
+static int wdt_probe(struct platform_device *pdev)
+{
+	const char *value;
+	int ret;
+	printk("hw_wdt enter probe\n");
+
+	ret = of_property_read_u32(pdev->dev.of_node,"hw_margin_ms", &hw_margin);
+	if (ret)
+		return ret;
+
+	ret = of_property_read_string(pdev->dev.of_node,
+					  "hw-gpios", &value);
+	if (ret) {
+		printk("no hw-gpios");
+		return -1;
+	} else {
+		khadas_input_pin = of_get_named_gpio_flags
+						(pdev->dev.of_node,
+						"hw-gpios",
+						0, NULL);
+		printk("hlm hw-gpios: %d.\n", khadas_input_pin);
+		ret = gpio_request(khadas_input_pin, "khadas");
+	}
+
+    timer_setup(&mytimer, time_pre, 0);
+    mytimer.expires = jiffies + hw_margin * HZ/1000; //// 5ms 
+    add_timer(&mytimer);
+	create_khadas_attrs();
+	return 0;
+}
+
+static const struct of_device_id hw_khadas_wdt_dt_ids[] = {
+	{ .compatible = "linux,wdt-khadas", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, hw_khadas_wdt_dt_ids);
+
+static struct platform_driver khadas_wdt_driver = {
+	.driver	= {
+		.name		= "hw_khadas_wdt",
+		.of_match_table	= hw_khadas_wdt_dt_ids,
+	},
+	.probe	= wdt_probe,
+};
+
+static int __init wdt_drv_init(void)
+{
+	return platform_driver_register(&khadas_wdt_driver);
+}
+arch_initcall(wdt_drv_init);
+
+MODULE_LICENSE("GPL");
Index: kernel-rockchip/drivers/net/ethernet/realtek/r8125/Makefile
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/net/ethernet/realtek/r8125/Makefile
@@ -0,0 +1,121 @@
+# SPDX-License-Identifier: GPL-2.0-only
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2021 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+
+################################################################################
+#  This product is covered by one or more of the following patents:
+#  US6,570,884, US6,115,776, and US6,327,625.
+################################################################################
+
+CONFIG_SOC_LAN = n
+ENABLE_REALWOW_SUPPORT = n
+ENABLE_DASH_SUPPORT = n
+ENABLE_DASH_PRINTER_SUPPORT = n
+CONFIG_DOWN_SPEED_100 = n
+CONFIG_ASPM = y
+ENABLE_S5WOL = y
+ENABLE_S5_KEEP_CURR_MAC = n
+ENABLE_EEE = n
+ENABLE_S0_MAGIC_PACKET = n
+ENABLE_TX_NO_CLOSE = y
+ENABLE_MULTIPLE_TX_QUEUE = y
+ENABLE_PTP_SUPPORT = n
+ENABLE_PTP_MASTER_MODE = n
+ENABLE_RSS_SUPPORT = y
+ENABLE_LIB_SUPPORT = n
+ENABLE_USE_FIRMWARE_FILE = n
+DISABLE_PM_SUPPORT = n
+DISABLE_MULTI_MSIX_VECTOR = n
+
+obj-$(CONFIG_R8125) := r8125.o
+r8125-objs := r8125_n.o rtl_eeprom.o rtltool.o
+
+ifeq ($(CONFIG_SOC_LAN), y)
+	EXTRA_CFLAGS += -DCONFIG_SOC_LAN
+endif
+ifeq ($(ENABLE_REALWOW_SUPPORT), y)
+	r8125-objs += r8125_realwow.o
+	EXTRA_CFLAGS += -DENABLE_REALWOW_SUPPORT
+endif
+ifeq ($(ENABLE_DASH_SUPPORT), y)
+	r8125-objs += r8125_dash.o
+	EXTRA_CFLAGS += -DENABLE_DASH_SUPPORT
+endif
+ifeq ($(ENABLE_DASH_PRINTER_SUPPORT), y)
+	r8125-objs += r8125_dash.o
+	EXTRA_CFLAGS += -DENABLE_DASH_SUPPORT -DENABLE_DASH_PRINTER_SUPPORT
+endif
+EXTRA_CFLAGS += -DCONFIG_R8125_NAPI
+EXTRA_CFLAGS += -DCONFIG_R8125_VLAN
+ifeq ($(CONFIG_DOWN_SPEED_100), y)
+	EXTRA_CFLAGS += -DCONFIG_DOWN_SPEED_100
+endif
+ifeq ($(CONFIG_ASPM), y)
+	EXTRA_CFLAGS += -DCONFIG_ASPM
+endif
+ifeq ($(ENABLE_S5WOL), y)
+	EXTRA_CFLAGS += -DENABLE_S5WOL
+endif
+ifeq ($(ENABLE_S5_KEEP_CURR_MAC), y)
+	EXTRA_CFLAGS += -DENABLE_S5_KEEP_CURR_MAC
+endif
+ifeq ($(ENABLE_EEE), y)
+	EXTRA_CFLAGS += -DENABLE_EEE
+endif
+ifeq ($(ENABLE_S0_MAGIC_PACKET), y)
+	EXTRA_CFLAGS += -DENABLE_S0_MAGIC_PACKET
+endif
+ifeq ($(ENABLE_TX_NO_CLOSE), y)
+	EXTRA_CFLAGS += -DENABLE_TX_NO_CLOSE
+endif
+ifeq ($(ENABLE_MULTIPLE_TX_QUEUE), y)
+	EXTRA_CFLAGS += -DENABLE_MULTIPLE_TX_QUEUE
+endif
+ifeq ($(ENABLE_PTP_SUPPORT), y)
+	r8125-objs += r8125_ptp.o
+	EXTRA_CFLAGS += -DENABLE_PTP_SUPPORT
+endif
+ifeq ($(ENABLE_PTP_MASTER_MODE), y)
+	EXTRA_CFLAGS += -DENABLE_PTP_MASTER_MODE
+endif
+ifeq ($(ENABLE_RSS_SUPPORT), y)
+	r8125-objs += r8125_rss.o
+	EXTRA_CFLAGS += -DENABLE_RSS_SUPPORT
+endif
+ifeq ($(ENABLE_LIB_SUPPORT), y)
+	r8125-objs += r8125_lib.o
+	EXTRA_CFLAGS += -DENABLE_LIB_SUPPORT
+endif
+ifeq ($(ENABLE_USE_FIRMWARE_FILE), y)
+	r8125-objs += r8125_firmware.o
+	EXTRA_CFLAGS += -DENABLE_USE_FIRMWARE_FILE
+endif
+ifeq ($(DISABLE_PM_SUPPORT), y)
+	EXTRA_CFLAGS += -DDISABLE_PM_SUPPORT
+endif
+ifeq ($(DISABLE_MULTI_MSIX_VECTOR), y)
+	EXTRA_CFLAGS += -DDISABLE_MULTI_MSIX_VECTOR
+endif
Index: kernel-rockchip/drivers/net/ethernet/realtek/r8125/r8125.h
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/net/ethernet/realtek/r8125/r8125.h
@@ -0,0 +1,2536 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2022 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef __R8125_H
+#define __R8125_H
+
+//#include <linux/pci.h>
+#include <linux/ethtool.h>
+#include <linux/interrupt.h>
+#include <linux/version.h>
+#include "r8125_dash.h"
+#include "r8125_realwow.h"
+#include "r8125_ptp.h"
+#include "r8125_rss.h"
+#ifdef ENABLE_LIB_SUPPORT
+#include "r8125_lib.h"
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,32)
+typedef int netdev_tx_t;
+#endif
+
+/*
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)&& !defined(ENABLE_LIB_SUPPORT)
+#define RTL_USE_NEW_INTR_API
+#endif
+*/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+#define skb_transport_offset(skb) (skb->h.raw - skb->data)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)
+#define device_set_wakeup_enable(dev, val)	do {} while (0)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,14,0)
+static inline void ether_addr_copy(u8 *dst, const u8 *src)
+{
+        u16 *a = (u16 *)dst;
+        const u16 *b = (const u16 *)src;
+
+        a[0] = b[0];
+        a[1] = b[1];
+        a[2] = b[2];
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,15,0)
+#define IS_ERR_OR_NULL(ptr)			(!ptr)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,13,0)
+#define reinit_completion(x)			((x)->done = 0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,39)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+#define pm_runtime_mark_last_busy(x)
+#define pm_runtime_put_autosuspend(x)		pm_runtime_put(x)
+#define pm_runtime_put_sync_autosuspend(x)	pm_runtime_put_sync(x)
+
+static inline bool pm_runtime_suspended(struct device *dev)
+{
+        return dev->power.runtime_status == RPM_SUSPENDED
+               && !dev->power.disable_depth;
+}
+
+static inline bool pm_runtime_active(struct device *dev)
+{
+        return dev->power.runtime_status == RPM_ACTIVE
+               || dev->power.disable_depth;
+}
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
+#define queue_delayed_work(long_wq, work, delay)	schedule_delayed_work(work, delay)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34)
+#define netif_printk(priv, type, level, netdev, fmt, args...)	\
+	do {								\
+		if (netif_msg_##type(priv))				\
+			printk(level "%s: " fmt,(netdev)->name , ##args); \
+	} while (0)
+
+#define netif_emerg(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_EMERG, netdev, fmt, ##args)
+#define netif_alert(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_ALERT, netdev, fmt, ##args)
+#define netif_crit(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_CRIT, netdev, fmt, ##args)
+#define netif_err(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_ERR, netdev, fmt, ##args)
+#define netif_warn(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_WARNING, netdev, fmt, ##args)
+#define netif_notice(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_NOTICE, netdev, fmt, ##args)
+#define netif_info(priv, type, netdev, fmt, args...)		\
+		netif_printk(priv, type, KERN_INFO, (netdev), fmt, ##args)
+#endif
+#endif
+#endif
+#endif
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+#define setup_timer(_timer, _function, _data) \
+do { \
+	(_timer)->function = _function; \
+	(_timer)->data = _data; \
+	init_timer(_timer); \
+} while (0)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0)
+#if defined(skb_vlan_tag_present) && !defined(vlan_tx_tag_present)
+#define vlan_tx_tag_present skb_vlan_tag_present
+#endif
+#if defined(skb_vlan_tag_get) && !defined(vlan_tx_tag_get)
+#define vlan_tx_tag_get skb_vlan_tag_get
+#endif
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0)
+
+#define RTL_ALLOC_SKB_INTR(napi, length) dev_alloc_skb(length)
+#ifdef CONFIG_R8125_NAPI
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
+#undef RTL_ALLOC_SKB_INTR
+#define RTL_ALLOC_SKB_INTR(napi, length) napi_alloc_skb(napi, length)
+#endif
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)
+#define eth_random_addr(addr) random_ether_addr(addr)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,6,0)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0)
+#define netdev_features_t  u32
+#endif
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,5,0)
+#define NETIF_F_ALL_CSUM        NETIF_F_CSUM_MASK
+#else
+#ifndef NETIF_F_ALL_CSUM
+#define NETIF_F_ALL_CSUM        NETIF_F_CSUM_MASK
+#endif
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,37)
+#define ENABLE_R8125_PROCFS
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+#define NETIF_F_HW_VLAN_RX	NETIF_F_HW_VLAN_CTAG_RX
+#define NETIF_F_HW_VLAN_TX	NETIF_F_HW_VLAN_CTAG_TX
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0)
+#define __devinit
+#define __devexit
+#define __devexit_p(func)   func
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+#define CHECKSUM_PARTIAL CHECKSUM_HW
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#define irqreturn_t void
+#define IRQ_HANDLED    1
+#define IRQ_NONE   0
+#define IRQ_RETVAL(x)
+#endif
+
+#ifndef NETIF_F_RXALL
+#define NETIF_F_RXALL  0
+#endif
+
+#ifndef NETIF_F_RXFCS
+#define NETIF_F_RXFCS  0
+#endif
+
+#ifndef HAVE_FREE_NETDEV
+#define free_netdev(x)  kfree(x)
+#endif
+
+#ifndef SET_NETDEV_DEV
+#define SET_NETDEV_DEV(net, pdev)
+#endif
+
+#ifndef SET_MODULE_OWNER
+#define SET_MODULE_OWNER(dev)
+#endif
+
+#ifndef SA_SHIRQ
+#define SA_SHIRQ IRQF_SHARED
+#endif
+
+#ifndef NETIF_F_GSO
+#define gso_size    tso_size
+#define gso_segs    tso_segs
+#endif
+
+#ifndef PCI_VENDOR_ID_DLINK
+#define PCI_VENDOR_ID_DLINK 0x1186
+#endif
+
+#ifndef dma_mapping_error
+#define dma_mapping_error(a,b) 0
+#endif
+
+#ifndef netif_err
+#define netif_err(a,b,c,d)
+#endif
+
+#ifndef AUTONEG_DISABLE
+#define AUTONEG_DISABLE   0x00
+#endif
+
+#ifndef AUTONEG_ENABLE
+#define AUTONEG_ENABLE    0x01
+#endif
+
+#ifndef BMCR_SPEED1000
+#define BMCR_SPEED1000  0x0040
+#endif
+
+#ifndef BMCR_SPEED100
+#define BMCR_SPEED100   0x2000
+#endif
+
+#ifndef BMCR_SPEED10
+#define BMCR_SPEED10    0x0000
+#endif
+
+#ifndef SPEED_UNKNOWN
+#define SPEED_UNKNOWN   -1
+#endif
+
+#ifndef DUPLEX_UNKNOWN
+#define DUPLEX_UNKNOWN  0xff
+#endif
+
+#ifndef SUPPORTED_Pause
+#define SUPPORTED_Pause  (1 << 13)
+#endif
+
+#ifndef SUPPORTED_Asym_Pause
+#define SUPPORTED_Asym_Pause  (1 << 14)
+#endif
+
+#ifndef  MDIO_EEE_100TX
+#define  MDIO_EEE_100TX  0x0002
+#endif
+
+#ifndef  MDIO_EEE_1000T
+#define  MDIO_EEE_1000T  0x0004
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+#ifdef CONFIG_NET_POLL_CONTROLLER
+#define RTL_NET_POLL_CONTROLLER dev->poll_controller=rtl8125_netpoll
+#else
+#define RTL_NET_POLL_CONTROLLER
+#endif
+
+#ifdef CONFIG_R8125_VLAN
+#define RTL_SET_VLAN dev->vlan_rx_register=rtl8125_vlan_rx_register
+#else
+#define RTL_SET_VLAN
+#endif
+
+#define RTL_NET_DEVICE_OPS(ops) dev->open=rtl8125_open; \
+                    dev->hard_start_xmit=rtl8125_start_xmit; \
+                    dev->get_stats=rtl8125_get_stats; \
+                    dev->stop=rtl8125_close; \
+                    dev->tx_timeout=rtl8125_tx_timeout; \
+                    dev->set_multicast_list=rtl8125_set_rx_mode; \
+                    dev->change_mtu=rtl8125_change_mtu; \
+                    dev->set_mac_address=rtl8125_set_mac_address; \
+                    dev->do_ioctl=rtl8125_do_ioctl; \
+                    RTL_NET_POLL_CONTROLLER; \
+                    RTL_SET_VLAN;
+#else
+#define RTL_NET_DEVICE_OPS(ops) dev->netdev_ops=&ops
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#ifndef TRUE
+#define TRUE  1
+#endif
+
+#ifndef false
+#define false 0
+#endif
+
+#ifndef true
+#define true  1
+#endif
+
+//Hardware will continue interrupt 10 times after interrupt finished.
+#define RTK_KEEP_INTERRUPT_COUNT (10)
+
+//the low 32 bit address of receive buffer must be 8-byte alignment.
+#ifndef NET_IP_ALIGN
+#define NET_IP_ALIGN        2
+#endif
+#define RTK_RX_ALIGN        8
+
+#ifdef CONFIG_R8125_NAPI
+#define NAPI_SUFFIX "-NAPI"
+#else
+#define NAPI_SUFFIX ""
+#endif
+#if defined(ENABLE_DASH_PRINTER_SUPPORT)
+#define DASH_SUFFIX "-PRINTER"
+#elif defined(ENABLE_DASH_SUPPORT)
+#define DASH_SUFFIX "-DASH"
+#else
+#define DASH_SUFFIX ""
+#endif
+
+#if defined(ENABLE_REALWOW_SUPPORT)
+#define REALWOW_SUFFIX "-REALWOW"
+#else
+#define REALWOW_SUFFIX ""
+#endif
+
+#if defined(ENABLE_PTP_SUPPORT)
+#define PTP_SUFFIX "-PTP"
+#else
+#define PTP_SUFFIX ""
+#endif
+
+#if defined(ENABLE_RSS_SUPPORT)
+#define RSS_SUFFIX "-RSS"
+#else
+#define RSS_SUFFIX ""
+#endif
+
+#define RTL8125_VERSION "9.009.00" NAPI_SUFFIX DASH_SUFFIX REALWOW_SUFFIX PTP_SUFFIX RSS_SUFFIX
+#define MODULENAME "r8125"
+#define PFX MODULENAME ": "
+
+#define GPL_CLAIM "\
+r8125  Copyright (C) 2022 Realtek NIC software team <nicfae@realtek.com> \n \
+This program comes with ABSOLUTELY NO WARRANTY; for details, please see <http://www.gnu.org/licenses/>. \n \
+This is free software, and you are welcome to redistribute it under certain conditions; see <http://www.gnu.org/licenses/>. \n"
+
+#ifdef RTL8125_DEBUG
+#define assert(expr) \
+        if(!(expr)) {                   \
+            printk( "Assertion failed! %s,%s,%s,line=%d\n", \
+            #expr,__FILE__,__FUNCTION__,__LINE__);      \
+        }
+#define dprintk(fmt, args...)   do { printk(PFX fmt, ## args); } while (0)
+#else
+#define assert(expr) do {} while (0)
+#define dprintk(fmt, args...)   do {} while (0)
+#endif /* RTL8125_DEBUG */
+
+#define R8125_MSG_DEFAULT \
+    (NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_IFUP | NETIF_MSG_IFDOWN)
+
+#ifdef CONFIG_R8125_NAPI
+#define rtl8125_rx_hwaccel_skb      vlan_hwaccel_receive_skb
+#define rtl8125_rx_quota(count, quota)  min(count, quota)
+#else
+#define rtl8125_rx_hwaccel_skb      vlan_hwaccel_rx
+#define rtl8125_rx_quota(count, quota)  count
+#endif
+
+/* MAC address length */
+#ifndef MAC_ADDR_LEN
+#define MAC_ADDR_LEN    6
+#endif
+
+#ifndef MAC_PROTOCOL_LEN
+#define MAC_PROTOCOL_LEN    2
+#endif
+
+#ifndef ETH_FCS_LEN
+#define ETH_FCS_LEN	  4
+#endif
+
+#ifndef NETIF_F_TSO6
+#define NETIF_F_TSO6  0
+#endif
+
+#define Reserved2_data  7
+#define RX_DMA_BURST    7   /* Maximum PCI burst, '7' is unlimited */
+#define TX_DMA_BURST_unlimited  7
+#define TX_DMA_BURST_1024   6
+#define TX_DMA_BURST_512    5
+#define TX_DMA_BURST_256    4
+#define TX_DMA_BURST_128    3
+#define TX_DMA_BURST_64     2
+#define TX_DMA_BURST_32     1
+#define TX_DMA_BURST_16     0
+#define Reserved1_data  0x3F
+#define RxPacketMaxSize 0x3FE8  /* 16K - 1 - ETH_HLEN - VLAN - CRC... */
+#define Jumbo_Frame_1k  ETH_DATA_LEN
+#define Jumbo_Frame_2k  (2*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_3k  (3*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_4k  (4*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_5k  (5*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_6k  (6*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_7k  (7*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_8k  (8*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define Jumbo_Frame_9k  (9*1024 - ETH_HLEN - VLAN_HLEN - ETH_FCS_LEN)
+#define InterFrameGap   0x03    /* 3 means InterFrameGap = the shortest one */
+#define RxEarly_off_V1 (0x07 << 11)
+#define RxEarly_off_V2 (1 << 11)
+#define Rx_Single_fetch_V2 (1 << 14)
+
+#define R8125_REGS_SIZE     (256)
+#define R8125_MAC_REGS_SIZE     (256)
+#define R8125_PHY_REGS_SIZE     (16*2)
+#define R8125_EPHY_REGS_SIZE  	(31*2)
+#define R8125_ERI_REGS_SIZE  	(0x100)
+#define R8125_REGS_DUMP_SIZE     (0x400)
+#define R8125_PCI_REGS_SIZE  	(0x100)
+#define R8125_NAPI_WEIGHT   64
+
+#define R8125_MAX_MSIX_VEC_8125B   32
+#define R8125_MIN_MSIX_VEC_8125B   17
+#define R8125_MAX_MSIX_VEC   32
+#define R8125_MAX_RX_QUEUES_VEC_V3 (16)
+
+#define RTL8125_TX_TIMEOUT  (6 * HZ)
+#define RTL8125_LINK_TIMEOUT    (1 * HZ)
+#define RTL8125_ESD_TIMEOUT (2 * HZ)
+
+#define MAX_NUM_TX_DESC 1024    /* Maximum number of Tx descriptor registers */
+#define MAX_NUM_RX_DESC 1024    /* Maximum number of Rx descriptor registers */
+
+#define MIN_NUM_TX_DESC 256    /* Minimum number of Tx descriptor registers */
+#define MIN_NUM_RX_DESC 256    /* Minimum number of Rx descriptor registers */
+
+#define NUM_TX_DESC MAX_NUM_TX_DESC    /* Number of Tx descriptor registers */
+#define NUM_RX_DESC MAX_NUM_RX_DESC    /* Number of Rx descriptor registers */
+
+#define RX_BUF_SIZE 0x05F3  /* 0x05F3 = 1522bye + 1 */
+
+#define R8125_MAX_TX_QUEUES (2)
+#define R8125_MAX_RX_QUEUES (4)
+#define R8125_MAX_QUEUES R8125_MAX_RX_QUEUES
+
+#define OCP_STD_PHY_BASE	0xa400
+
+#ifdef ENABLE_LIB_SUPPORT
+#define R8125_MULTI_RX_Q(tp) 0
+#else
+#define R8125_MULTI_RX_Q(tp) (tp->num_rx_rings > 1)
+#endif
+
+#define NODE_ADDRESS_SIZE 6
+
+#define SHORT_PACKET_PADDING_BUF_SIZE 256
+
+#define RTK_MAGIC_DEBUG_VALUE 0x0badbeef
+
+/* write/read MMIO register */
+#define RTL_W8(tp, reg, val8)	writeb((val8), tp->mmio_addr + (reg))
+#define RTL_W16(tp, reg, val16)	writew((val16), tp->mmio_addr + (reg))
+#define RTL_W32(tp, reg, val32)	writel((val32), tp->mmio_addr + (reg))
+#define RTL_R8(tp, reg)		readb(tp->mmio_addr + (reg))
+#define RTL_R16(tp, reg)		readw(tp->mmio_addr + (reg))
+#define RTL_R32(tp, reg)		((unsigned long) readl(tp->mmio_addr + (reg)))
+
+#ifndef DMA_64BIT_MASK
+#define DMA_64BIT_MASK  0xffffffffffffffffULL
+#endif
+
+#ifndef DMA_32BIT_MASK
+#define DMA_32BIT_MASK  0x00000000ffffffffULL
+#endif
+
+#ifndef NETDEV_TX_OK
+#define NETDEV_TX_OK 0      /* driver took care of packet */
+#endif
+
+#ifndef NETDEV_TX_BUSY
+#define NETDEV_TX_BUSY 1    /* driver tx path was busy*/
+#endif
+
+#ifndef NETDEV_TX_LOCKED
+#define NETDEV_TX_LOCKED -1t /* driver tx lock was already taken */
+#endif
+
+#ifndef ADVERTISED_Pause
+#define ADVERTISED_Pause    (1 << 13)
+#endif
+
+#ifndef ADVERTISED_Asym_Pause
+#define ADVERTISED_Asym_Pause   (1 << 14)
+#endif
+
+#ifndef ADVERTISE_PAUSE_CAP
+#define ADVERTISE_PAUSE_CAP 0x400
+#endif
+
+#ifndef ADVERTISE_PAUSE_ASYM
+#define ADVERTISE_PAUSE_ASYM    0x800
+#endif
+
+#ifndef MII_CTRL1000
+#define MII_CTRL1000        0x09
+#endif
+
+#ifndef ADVERTISE_1000FULL
+#define ADVERTISE_1000FULL  0x200
+#endif
+
+#ifndef ADVERTISE_1000HALF
+#define ADVERTISE_1000HALF  0x100
+#endif
+
+#ifndef ADVERTISED_2500baseX_Full
+#define ADVERTISED_2500baseX_Full  0x8000
+#endif
+
+#define RTK_ADVERTISE_2500FULL  0x80
+#define RTK_LPA_ADVERTISE_2500FULL  0x20
+#define RTK_LPA_ADVERTISE_5000FULL  0x40
+#define RTK_LPA_ADVERTISE_10000FULL  0x800
+
+#define RTK_EEE_ADVERTISE_2500FULL  0x01
+#define RTK_LPA_EEE_ADVERTISE_2500FULL  0x01
+
+/* Tx NO CLOSE */
+#define MAX_TX_NO_CLOSE_DESC_PTR_V2 0x10000
+#define TX_NO_CLOSE_SW_PTR_MASK_V2 0x1FFFF
+
+#ifndef ETH_MIN_MTU
+#define ETH_MIN_MTU  68
+#endif
+
+#define D0_SPEED_UP_SPEED_DISABLE    0
+#define D0_SPEED_UP_SPEED_1000       1
+#define D0_SPEED_UP_SPEED_2500       2
+
+#define RTL8125_MAC_MCU_PAGE_SIZE 256 //256 words
+
+#ifndef WRITE_ONCE
+#define WRITE_ONCE(var, val) (*((volatile typeof(val) *)(&(var))) = (val))
+#endif
+#ifndef READ_ONCE
+#define READ_ONCE(var) (*((volatile typeof(var) *)(&(var))))
+#endif
+
+/*****************************************************************************/
+
+//#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,3)
+#if (( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,27) ) || \
+     (( LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0) ) && \
+      ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,3) )))
+/* copied from linux kernel 2.6.20 include/linux/netdev.h */
+#define NETDEV_ALIGN        32
+#define NETDEV_ALIGN_CONST  (NETDEV_ALIGN - 1)
+
+static inline void *netdev_priv(struct net_device *dev)
+{
+        return (char *)dev + ((sizeof(struct net_device)
+                               + NETDEV_ALIGN_CONST)
+                              & ~NETDEV_ALIGN_CONST);
+}
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,3)
+
+/*****************************************************************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+#define RTLDEV  tp
+#else
+#define RTLDEV  dev
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+/*****************************************************************************/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+typedef struct net_device *napi_ptr;
+typedef int *napi_budget;
+
+#define napi dev
+#define RTL_NAPI_CONFIG(ndev, priv, function, weig) ndev->poll=function;    \
+                                ndev->weight=weig;
+#define RTL_NAPI_QUOTA(budget, ndev)            min(*budget, ndev->quota)
+#define RTL_GET_PRIV(stuct_ptr, priv_struct)        netdev_priv(stuct_ptr)
+#define RTL_GET_NETDEV(priv_ptr)
+#define RTL_RX_QUOTA(budget)          *budget
+#define RTL_NAPI_QUOTA_UPDATE(ndev, work_done, budget)  *budget -= work_done;   \
+                                ndev->quota -= work_done;
+#define RTL_NETIF_RX_COMPLETE(dev, napi, work_done)        netif_rx_complete(dev)
+#define RTL_NETIF_RX_SCHEDULE_PREP(dev, napi)       netif_rx_schedule_prep(dev)
+#define __RTL_NETIF_RX_SCHEDULE(dev, napi)      __netif_rx_schedule(dev)
+#define RTL_NAPI_RETURN_VALUE               work_done >= work_to_do
+#define RTL_NAPI_ENABLE(dev, napi)          netif_poll_enable(dev)
+#define RTL_NAPI_DISABLE(dev, napi)         netif_poll_disable(dev)
+#define DMA_BIT_MASK(n) (((n) == 64) ? ~0ULL : ((1ULL<<(n))-1))
+#else
+typedef struct napi_struct *napi_ptr;
+typedef int napi_budget;
+
+#define RTL_NAPI_CONFIG(ndev, priv, function, weight)   netif_napi_add(ndev, &priv->napi, function, weight)
+#define RTL_NAPI_QUOTA(budget, ndev)            min(budget, budget)
+#define RTL_GET_PRIV(stuct_ptr, priv_struct)        container_of(stuct_ptr, priv_struct, stuct_ptr)
+#define RTL_GET_NETDEV(priv_ptr)            struct net_device *dev = priv_ptr->dev;
+#define RTL_RX_QUOTA(budget)          budget
+#define RTL_NAPI_QUOTA_UPDATE(ndev, work_done, budget)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+#define RTL_NETIF_RX_COMPLETE(dev, napi, work_done)        netif_rx_complete(dev, napi)
+#define RTL_NETIF_RX_SCHEDULE_PREP(dev, napi)       netif_rx_schedule_prep(dev, napi)
+#define __RTL_NETIF_RX_SCHEDULE(dev, napi)      __netif_rx_schedule(dev, napi)
+#endif
+#if LINUX_VERSION_CODE == KERNEL_VERSION(2,6,29)
+#define RTL_NETIF_RX_COMPLETE(dev, napi, work_done)        netif_rx_complete(napi)
+#define RTL_NETIF_RX_SCHEDULE_PREP(dev, napi)       netif_rx_schedule_prep(napi)
+#define __RTL_NETIF_RX_SCHEDULE(dev, napi)      __netif_rx_schedule(napi)
+#endif
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,19,0)
+#define RTL_NETIF_RX_COMPLETE(dev, napi, work_done)        napi_complete_done(napi, work_done)
+#else
+#define RTL_NETIF_RX_COMPLETE(dev, napi, work_done)        napi_complete(napi)
+#endif
+#define RTL_NETIF_RX_SCHEDULE_PREP(dev, napi)       napi_schedule_prep(napi)
+#define __RTL_NETIF_RX_SCHEDULE(dev, napi)      __napi_schedule(napi)
+#endif
+#define RTL_NAPI_RETURN_VALUE work_done
+#define RTL_NAPI_ENABLE(dev, napi)          napi_enable(napi)
+#define RTL_NAPI_DISABLE(dev, napi)         napi_disable(napi)
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+#define RTL_NAPI_DEL(priv)
+#else
+#define RTL_NAPI_DEL(priv)   netif_napi_del(&priv->napi)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27)
+
+/*****************************************************************************/
+#ifdef CONFIG_R8125_NAPI
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0)
+#define RTL_NAPI_CONSUME_SKB_ANY(skb, budget)          napi_consume_skb(skb, budget)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
+#define RTL_NAPI_CONSUME_SKB_ANY(skb, budget)          dev_consume_skb_any(skb);
+#else
+#define RTL_NAPI_CONSUME_SKB_ANY(skb, budget)          dev_kfree_skb_any(skb);
+#endif  //LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,0)
+#else   //CONFIG_R8125_NAPI
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
+#define RTL_NAPI_CONSUME_SKB_ANY(skb, budget)          dev_consume_skb_any(skb);
+#else
+#define RTL_NAPI_CONSUME_SKB_ANY(skb, budget)          dev_kfree_skb_any(skb);
+#endif
+#endif  //CONFIG_R8125_NAPI
+
+/*****************************************************************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+#ifdef __CHECKER__
+#define __iomem __attribute__((noderef, address_space(2)))
+extern void __chk_io_ptr(void __iomem *);
+#define __bitwise __attribute__((bitwise))
+#else
+#define __iomem
+#define __chk_io_ptr(x) (void)0
+#define __bitwise
+#endif
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+
+/*****************************************************************************/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
+#ifdef __CHECKER__
+#define __force __attribute__((force))
+#else
+#define __force
+#endif
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,8)
+
+#ifndef module_param
+#define module_param(v,t,p) MODULE_PARM(v, "i");
+#endif
+
+#ifndef PCI_DEVICE
+#define PCI_DEVICE(vend,dev) \
+    .vendor = (vend), .device = (dev), \
+    .subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID
+#endif
+
+/*****************************************************************************/
+/* 2.5.28 => 2.4.23 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,5,28) )
+
+static inline void _kc_synchronize_irq(void)
+{
+        synchronize_irq();
+}
+#undef synchronize_irq
+#define synchronize_irq(X) _kc_synchronize_irq()
+
+#include <linux/tqueue.h>
+#define work_struct tq_struct
+#undef INIT_WORK
+#define INIT_WORK(a,b,c) INIT_TQUEUE(a,(void (*)(void *))b,c)
+#undef container_of
+#define container_of list_entry
+#define schedule_work schedule_task
+#define flush_scheduled_work flush_scheduled_tasks
+#endif /* 2.5.28 => 2.4.17 */
+
+/*****************************************************************************/
+/* 2.6.4 => 2.6.0 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,4) )
+#define MODULE_VERSION(_version) MODULE_INFO(version, _version)
+#endif /* 2.6.4 => 2.6.0 */
+/*****************************************************************************/
+/* 2.6.0 => 2.5.28 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) )
+#define MODULE_INFO(version, _version)
+#ifndef CONFIG_E1000_DISABLE_PACKET_SPLIT
+#define CONFIG_E1000_DISABLE_PACKET_SPLIT 1
+#endif
+
+#define pci_set_consistent_dma_mask(dev,mask) 1
+
+#undef dev_put
+#define dev_put(dev) __dev_put(dev)
+
+#ifndef skb_fill_page_desc
+#define skb_fill_page_desc _kc_skb_fill_page_desc
+extern void _kc_skb_fill_page_desc(struct sk_buff *skb, int i, struct page *page, int off, int size);
+#endif
+
+#ifndef pci_dma_mapping_error
+#define pci_dma_mapping_error _kc_pci_dma_mapping_error
+static inline int _kc_pci_dma_mapping_error(dma_addr_t dma_addr)
+{
+        return dma_addr == 0;
+}
+#endif
+
+#undef ALIGN
+#define ALIGN(x,a) (((x)+(a)-1)&~((a)-1))
+
+#endif /* 2.6.0 => 2.5.28 */
+
+/*****************************************************************************/
+/* 2.4.22 => 2.4.17 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,22) )
+#define pci_name(x) ((x)->slot_name)
+#endif /* 2.4.22 => 2.4.17 */
+
+/*****************************************************************************/
+/* 2.6.5 => 2.6.0 */
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,6,5) )
+#define pci_dma_sync_single_for_cpu pci_dma_sync_single
+#define pci_dma_sync_single_for_device  pci_dma_sync_single_for_cpu
+#endif /* 2.6.5 => 2.6.0 */
+
+/*****************************************************************************/
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+/*
+ * initialize a work-struct's func and data pointers:
+ */
+#define PREPARE_WORK(_work, _func, _data)           \
+    do {                            \
+        (_work)->func = _func;              \
+        (_work)->data = _data;              \
+    } while (0)
+
+#endif
+/*****************************************************************************/
+/* 2.6.4 => 2.6.0 */
+#if ((LINUX_VERSION_CODE < KERNEL_VERSION(2,4,25) && \
+     LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)) || \
+    (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0) && \
+      LINUX_VERSION_CODE < KERNEL_VERSION(2,6,4)))
+#define ETHTOOL_OPS_COMPAT
+#endif /* 2.6.4 => 2.6.0 */
+
+/*****************************************************************************/
+/* Installations with ethtool version without eeprom, adapter id, or statistics
+ * support */
+
+#ifndef ETH_GSTRING_LEN
+#define ETH_GSTRING_LEN 32
+#endif
+
+#ifndef ETHTOOL_GSTATS
+#define ETHTOOL_GSTATS 0x1d
+#undef ethtool_drvinfo
+#define ethtool_drvinfo k_ethtool_drvinfo
+struct k_ethtool_drvinfo {
+        u32 cmd;
+        char driver[32];
+        char version[32];
+        char fw_version[32];
+        char bus_info[32];
+        char reserved1[32];
+        char reserved2[16];
+        u32 n_stats;
+        u32 testinfo_len;
+        u32 eedump_len;
+        u32 regdump_len;
+};
+
+struct ethtool_stats {
+        u32 cmd;
+        u32 n_stats;
+        u64 data[0];
+};
+#endif /* ETHTOOL_GSTATS */
+
+#ifndef ETHTOOL_PHYS_ID
+#define ETHTOOL_PHYS_ID 0x1c
+#endif /* ETHTOOL_PHYS_ID */
+
+#ifndef ETHTOOL_GSTRINGS
+#define ETHTOOL_GSTRINGS 0x1b
+enum ethtool_stringset {
+        ETH_SS_TEST             = 0,
+        ETH_SS_STATS,
+};
+struct ethtool_gstrings {
+        u32 cmd;            /* ETHTOOL_GSTRINGS */
+        u32 string_set;     /* string set id e.c. ETH_SS_TEST, etc*/
+        u32 len;            /* number of strings in the string set */
+        u8 data[0];
+};
+#endif /* ETHTOOL_GSTRINGS */
+
+#ifndef ETHTOOL_TEST
+#define ETHTOOL_TEST 0x1a
+enum ethtool_test_flags {
+        ETH_TEST_FL_OFFLINE = (1 << 0),
+        ETH_TEST_FL_FAILED  = (1 << 1),
+};
+struct ethtool_test {
+        u32 cmd;
+        u32 flags;
+        u32 reserved;
+        u32 len;
+        u64 data[0];
+};
+#endif /* ETHTOOL_TEST */
+
+#ifndef ETHTOOL_GEEPROM
+#define ETHTOOL_GEEPROM 0xb
+#undef ETHTOOL_GREGS
+struct ethtool_eeprom {
+        u32 cmd;
+        u32 magic;
+        u32 offset;
+        u32 len;
+        u8 data[0];
+};
+
+struct ethtool_value {
+        u32 cmd;
+        u32 data;
+};
+#endif /* ETHTOOL_GEEPROM */
+
+#ifndef ETHTOOL_GLINK
+#define ETHTOOL_GLINK 0xa
+#endif /* ETHTOOL_GLINK */
+
+#ifndef ETHTOOL_GREGS
+#define ETHTOOL_GREGS       0x00000004 /* Get NIC registers */
+#define ethtool_regs _kc_ethtool_regs
+/* for passing big chunks of data */
+struct _kc_ethtool_regs {
+        u32 cmd;
+        u32 version; /* driver-specific, indicates different chips/revs */
+        u32 len; /* bytes */
+        u8 data[0];
+};
+#endif /* ETHTOOL_GREGS */
+
+#ifndef ETHTOOL_GMSGLVL
+#define ETHTOOL_GMSGLVL     0x00000007 /* Get driver message level */
+#endif
+#ifndef ETHTOOL_SMSGLVL
+#define ETHTOOL_SMSGLVL     0x00000008 /* Set driver msg level, priv. */
+#endif
+#ifndef ETHTOOL_NWAY_RST
+#define ETHTOOL_NWAY_RST    0x00000009 /* Restart autonegotiation, priv */
+#endif
+#ifndef ETHTOOL_GLINK
+#define ETHTOOL_GLINK       0x0000000a /* Get link status */
+#endif
+#ifndef ETHTOOL_GEEPROM
+#define ETHTOOL_GEEPROM     0x0000000b /* Get EEPROM data */
+#endif
+#ifndef ETHTOOL_SEEPROM
+#define ETHTOOL_SEEPROM     0x0000000c /* Set EEPROM data */
+#endif
+#ifndef ETHTOOL_GCOALESCE
+#define ETHTOOL_GCOALESCE   0x0000000e /* Get coalesce config */
+/* for configuring coalescing parameters of chip */
+#define ethtool_coalesce _kc_ethtool_coalesce
+struct _kc_ethtool_coalesce {
+        u32 cmd;    /* ETHTOOL_{G,S}COALESCE */
+
+        /* How many usecs to delay an RX interrupt after
+         * a packet arrives.  If 0, only rx_max_coalesced_frames
+         * is used.
+         */
+        u32 rx_coalesce_usecs;
+
+        /* How many packets to delay an RX interrupt after
+         * a packet arrives.  If 0, only rx_coalesce_usecs is
+         * used.  It is illegal to set both usecs and max frames
+         * to zero as this would cause RX interrupts to never be
+         * generated.
+         */
+        u32 rx_max_coalesced_frames;
+
+        /* Same as above two parameters, except that these values
+         * apply while an IRQ is being serviced by the host.  Not
+         * all cards support this feature and the values are ignored
+         * in that case.
+         */
+        u32 rx_coalesce_usecs_irq;
+        u32 rx_max_coalesced_frames_irq;
+
+        /* How many usecs to delay a TX interrupt after
+         * a packet is sent.  If 0, only tx_max_coalesced_frames
+         * is used.
+         */
+        u32 tx_coalesce_usecs;
+
+        /* How many packets to delay a TX interrupt after
+         * a packet is sent.  If 0, only tx_coalesce_usecs is
+         * used.  It is illegal to set both usecs and max frames
+         * to zero as this would cause TX interrupts to never be
+         * generated.
+         */
+        u32 tx_max_coalesced_frames;
+
+        /* Same as above two parameters, except that these values
+         * apply while an IRQ is being serviced by the host.  Not
+         * all cards support this feature and the values are ignored
+         * in that case.
+         */
+        u32 tx_coalesce_usecs_irq;
+        u32 tx_max_coalesced_frames_irq;
+
+        /* How many usecs to delay in-memory statistics
+         * block updates.  Some drivers do not have an in-memory
+         * statistic block, and in such cases this value is ignored.
+         * This value must not be zero.
+         */
+        u32 stats_block_coalesce_usecs;
+
+        /* Adaptive RX/TX coalescing is an algorithm implemented by
+         * some drivers to improve latency under low packet rates and
+         * improve throughput under high packet rates.  Some drivers
+         * only implement one of RX or TX adaptive coalescing.  Anything
+         * not implemented by the driver causes these values to be
+         * silently ignored.
+         */
+        u32 use_adaptive_rx_coalesce;
+        u32 use_adaptive_tx_coalesce;
+
+        /* When the packet rate (measured in packets per second)
+         * is below pkt_rate_low, the {rx,tx}_*_low parameters are
+         * used.
+         */
+        u32 pkt_rate_low;
+        u32 rx_coalesce_usecs_low;
+        u32 rx_max_coalesced_frames_low;
+        u32 tx_coalesce_usecs_low;
+        u32 tx_max_coalesced_frames_low;
+
+        /* When the packet rate is below pkt_rate_high but above
+         * pkt_rate_low (both measured in packets per second) the
+         * normal {rx,tx}_* coalescing parameters are used.
+         */
+
+        /* When the packet rate is (measured in packets per second)
+         * is above pkt_rate_high, the {rx,tx}_*_high parameters are
+         * used.
+         */
+        u32 pkt_rate_high;
+        u32 rx_coalesce_usecs_high;
+        u32 rx_max_coalesced_frames_high;
+        u32 tx_coalesce_usecs_high;
+        u32 tx_max_coalesced_frames_high;
+
+        /* How often to do adaptive coalescing packet rate sampling,
+         * measured in seconds.  Must not be zero.
+         */
+        u32 rate_sample_interval;
+};
+#endif /* ETHTOOL_GCOALESCE */
+
+#ifndef ETHTOOL_SCOALESCE
+#define ETHTOOL_SCOALESCE   0x0000000f /* Set coalesce config. */
+#endif
+#ifndef ETHTOOL_GRINGPARAM
+#define ETHTOOL_GRINGPARAM  0x00000010 /* Get ring parameters */
+/* for configuring RX/TX ring parameters */
+#define ethtool_ringparam _kc_ethtool_ringparam
+struct _kc_ethtool_ringparam {
+        u32 cmd;    /* ETHTOOL_{G,S}RINGPARAM */
+
+        /* Read only attributes.  These indicate the maximum number
+         * of pending RX/TX ring entries the driver will allow the
+         * user to set.
+         */
+        u32 rx_max_pending;
+        u32 rx_mini_max_pending;
+        u32 rx_jumbo_max_pending;
+        u32 tx_max_pending;
+
+        /* Values changeable by the user.  The valid values are
+         * in the range 1 to the "*_max_pending" counterpart above.
+         */
+        u32 rx_pending;
+        u32 rx_mini_pending;
+        u32 rx_jumbo_pending;
+        u32 tx_pending;
+};
+#endif /* ETHTOOL_GRINGPARAM */
+
+#ifndef ETHTOOL_SRINGPARAM
+#define ETHTOOL_SRINGPARAM  0x00000011 /* Set ring parameters, priv. */
+#endif
+#ifndef ETHTOOL_GPAUSEPARAM
+#define ETHTOOL_GPAUSEPARAM 0x00000012 /* Get pause parameters */
+/* for configuring link flow control parameters */
+#define ethtool_pauseparam _kc_ethtool_pauseparam
+struct _kc_ethtool_pauseparam {
+        u32 cmd;    /* ETHTOOL_{G,S}PAUSEPARAM */
+
+        /* If the link is being auto-negotiated (via ethtool_cmd.autoneg
+         * being true) the user may set 'autonet' here non-zero to have the
+         * pause parameters be auto-negotiated too.  In such a case, the
+         * {rx,tx}_pause values below determine what capabilities are
+         * advertised.
+         *
+         * If 'autoneg' is zero or the link is not being auto-negotiated,
+         * then {rx,tx}_pause force the driver to use/not-use pause
+         * flow control.
+         */
+        u32 autoneg;
+        u32 rx_pause;
+        u32 tx_pause;
+};
+#endif /* ETHTOOL_GPAUSEPARAM */
+
+#ifndef ETHTOOL_SPAUSEPARAM
+#define ETHTOOL_SPAUSEPARAM 0x00000013 /* Set pause parameters. */
+#endif
+#ifndef ETHTOOL_GRXCSUM
+#define ETHTOOL_GRXCSUM     0x00000014 /* Get RX hw csum enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_SRXCSUM
+#define ETHTOOL_SRXCSUM     0x00000015 /* Set RX hw csum enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_GTXCSUM
+#define ETHTOOL_GTXCSUM     0x00000016 /* Get TX hw csum enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_STXCSUM
+#define ETHTOOL_STXCSUM     0x00000017 /* Set TX hw csum enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_GSG
+#define ETHTOOL_GSG     0x00000018 /* Get scatter-gather enable
+* (ethtool_value) */
+#endif
+#ifndef ETHTOOL_SSG
+#define ETHTOOL_SSG     0x00000019 /* Set scatter-gather enable
+* (ethtool_value). */
+#endif
+#ifndef ETHTOOL_TEST
+#define ETHTOOL_TEST        0x0000001a /* execute NIC self-test, priv. */
+#endif
+#ifndef ETHTOOL_GSTRINGS
+#define ETHTOOL_GSTRINGS    0x0000001b /* get specified string set */
+#endif
+#ifndef ETHTOOL_PHYS_ID
+#define ETHTOOL_PHYS_ID     0x0000001c /* identify the NIC */
+#endif
+#ifndef ETHTOOL_GSTATS
+#define ETHTOOL_GSTATS      0x0000001d /* get NIC-specific statistics */
+#endif
+#ifndef ETHTOOL_GTSO
+#define ETHTOOL_GTSO        0x0000001e /* Get TSO enable (ethtool_value) */
+#endif
+#ifndef ETHTOOL_STSO
+#define ETHTOOL_STSO        0x0000001f /* Set TSO enable (ethtool_value) */
+#endif
+
+#ifndef ETHTOOL_BUSINFO_LEN
+#define ETHTOOL_BUSINFO_LEN 32
+#endif
+
+/*****************************************************************************/
+
+enum RTL8125_registers {
+        MAC0            = 0x00,     /* Ethernet hardware address. */
+        MAC4            = 0x04,
+        MAR0            = 0x08,     /* Multicast filter. */
+        CounterAddrLow      = 0x10,
+        CounterAddrHigh     = 0x14,
+        CustomLED       = 0x18,
+        TxDescStartAddrLow  = 0x20,
+        TxDescStartAddrHigh = 0x24,
+        TxHDescStartAddrLow = 0x28,
+        TxHDescStartAddrHigh    = 0x2c,
+        FLASH           = 0x30,
+        INT_CFG0_8125   = 0x34,
+        ERSR            = 0x36,
+        ChipCmd         = 0x37,
+        TxPoll          = 0x38,
+        IntrMask        = 0x3C,
+        IntrStatus      = 0x3E,
+        TxConfig        = 0x40,
+        RxConfig        = 0x44,
+        TCTR            = 0x48,
+        Cfg9346         = 0x50,
+        Config0         = 0x51,
+        Config1         = 0x52,
+        Config2         = 0x53,
+        Config3         = 0x54,
+        Config4         = 0x55,
+        Config5         = 0x56,
+        TDFNR           = 0x57,
+        TimeInt0        = 0x58,
+        TimeInt1        = 0x5C,
+        PHYAR           = 0x60,
+        CSIDR           = 0x64,
+        CSIAR           = 0x68,
+        PHYstatus       = 0x6C,
+        MACDBG          = 0x6D,
+        GPIO            = 0x6E,
+        PMCH            = 0x6F,
+        ERIDR           = 0x70,
+        ERIAR           = 0x74,
+        INT_CFG1_8125   = 0x7A,
+        EPHY_RXER_NUM   = 0x7C,
+        EPHYAR          = 0x80,
+        TimeInt2        = 0x8C,
+        OCPDR           = 0xB0,
+        MACOCP          = 0xB0,
+        OCPAR           = 0xB4,
+        SecMAC0         = 0xB4,
+        SecMAC4         = 0xB8,
+        PHYOCP          = 0xB8,
+        DBG_reg         = 0xD1,
+        TwiCmdReg       = 0xD2,
+        MCUCmd_reg      = 0xD3,
+        RxMaxSize       = 0xDA,
+        EFUSEAR         = 0xDC,
+        CPlusCmd        = 0xE0,
+        IntrMitigate    = 0xE2,
+        RxDescAddrLow   = 0xE4,
+        RxDescAddrHigh  = 0xE8,
+        MTPS            = 0xEC,
+        FuncEvent       = 0xF0,
+        PPSW            = 0xF2,
+        FuncEventMask   = 0xF4,
+        TimeInt3        = 0xF4,
+        FuncPresetState = 0xF8,
+        CMAC_IBCR0      = 0xF8,
+        CMAC_IBCR2      = 0xF9,
+        CMAC_IBIMR0     = 0xFA,
+        CMAC_IBISR0     = 0xFB,
+        FuncForceEvent  = 0xFC,
+        //8125
+        IMR0_8125          = 0x38,
+        ISR0_8125          = 0x3C,
+        TPPOLL_8125        = 0x90,
+        IMR1_8125          = 0x800,
+        ISR1_8125          = 0x802,
+        IMR2_8125          = 0x804,
+        ISR2_8125          = 0x806,
+        IMR3_8125          = 0x808,
+        ISR3_8125          = 0x80A,
+        BACKUP_ADDR0_8125  = 0x19E0,
+        BACKUP_ADDR1_8125  = 0X19E4,
+        TCTR0_8125         = 0x0048,
+        TCTR1_8125         = 0x004C,
+        TCTR2_8125         = 0x0088,
+        TCTR3_8125         = 0x001C,
+        TIMER_INT0_8125    = 0x0058,
+        TIMER_INT1_8125    = 0x005C,
+        TIMER_INT2_8125    = 0x008C,
+        TIMER_INT3_8125    = 0x00F4,
+        INT_MITI_V2_0_RX   = 0x0A00,
+        INT_MITI_V2_0_TX   = 0x0A02,
+        INT_MITI_V2_1_RX   = 0x0A08,
+        INT_MITI_V2_1_TX   = 0x0A0A,
+        IMR_V2_CLEAR_REG_8125 = 0x0D00,
+        ISR_V2_8125           = 0x0D04,
+        IMR_V2_SET_REG_8125   = 0x0D0C,
+        TDU_STA_8125       = 0x0D08,
+        RDU_STA_8125       = 0x0D0A,
+        TX_NEW_CTRL        = 0x203E,
+        TNPDS_Q1_LOW_8125  = 0x2100,
+        PLA_TXQ0_IDLE_CREDIT = 0x2500,
+        PLA_TXQ1_IDLE_CREDIT = 0x2504,
+        SW_TAIL_PTR0_8125  = 0x2800,
+        HW_CLO_PTR0_8125   = 0x2802,
+        RDSAR_Q1_LOW_8125  = 0x4000,
+        RSS_CTRL_8125      = 0x4500,
+        Q_NUM_CTRL_8125    = 0x4800,
+        RSS_KEY_8125       = 0x4600,
+        RSS_INDIRECTION_TBL_8125_V2 = 0x4700,
+        EEE_TXIDLE_TIMER_8125   = 0x6048,
+        PTP_CTRL_8125      = 0x6800,
+        PTP_STATUS_8125    = 0x6802,
+        PTP_ISR_8125       = 0x6804,
+        PTP_IMR_8125       = 0x6805,
+        PTP_TIME_CORRECT_CMD_8125    = 0x6806,
+        PTP_SOFT_CONFIG_Time_NS_8125 = 0x6808,
+        PTP_SOFT_CONFIG_Time_S_8125  = 0x680C,
+        PTP_LOCAL_Time_SUB_NS_8125   = 0x6814,
+        PTP_LOCAL_Time_NS_8125       = 0x6818,
+        PTP_LOCAL_Time_S_8125        = 0x681C,
+        PTP_Time_SHIFTER_S_8125      = 0x6856,
+        PPS_RISE_TIME_NS_8125        = 0x68A0,
+        PPS_RISE_TIME_S_8125         = 0x68A4,
+};
+
+enum RTL8125_register_content {
+        /* InterruptStatusBits */
+        SYSErr      = 0x8000,
+        PCSTimeout  = 0x4000,
+        SWInt       = 0x0100,
+        TxDescUnavail   = 0x0080,
+        RxFIFOOver  = 0x0040,
+        LinkChg     = 0x0020,
+        RxDescUnavail   = 0x0010,
+        TxErr       = 0x0008,
+        TxOK        = 0x0004,
+        RxErr       = 0x0002,
+        RxOK        = 0x0001,
+        RxDU1       = 0x0002,
+        RxOK1       = 0x0001,
+
+        /* RxStatusDesc */
+        RxRWT = (1 << 22),
+        RxRES = (1 << 21),
+        RxRUNT = (1 << 20),
+        RxCRC = (1 << 19),
+
+        RxRWT_V3 = (1 << 18),
+        RxRES_V3 = (1 << 20),
+        RxRUNT_V3 = (1 << 19),
+        RxCRC_V3 = (1 << 17),
+
+        /* ChipCmdBits */
+        StopReq  = 0x80,
+        CmdReset = 0x10,
+        CmdRxEnb = 0x08,
+        CmdTxEnb = 0x04,
+        RxBufEmpty = 0x01,
+
+        /* Cfg9346Bits */
+        Cfg9346_Lock = 0x00,
+        Cfg9346_Unlock = 0xC0,
+        Cfg9346_EEDO = (1 << 0),
+        Cfg9346_EEDI = (1 << 1),
+        Cfg9346_EESK = (1 << 2),
+        Cfg9346_EECS = (1 << 3),
+        Cfg9346_EEM0 = (1 << 6),
+        Cfg9346_EEM1 = (1 << 7),
+
+        /* rx_mode_bits */
+        AcceptErr = 0x20,
+        AcceptRunt = 0x10,
+        AcceptBroadcast = 0x08,
+        AcceptMulticast = 0x04,
+        AcceptMyPhys = 0x02,
+        AcceptAllPhys = 0x01,
+
+        /* Transmit Priority Polling*/
+        HPQ = 0x80,
+        NPQ = 0x40,
+        FSWInt = 0x01,
+
+        /* RxConfigBits */
+        Reserved2_shift = 13,
+        RxCfgDMAShift = 8,
+        EnableRxDescV3 = (1 << 24),
+        EnableOuterVlan = (1 << 23),
+        EnableInnerVlan = (1 << 22),
+        RxCfg_128_int_en = (1 << 15),
+        RxCfg_fet_multi_en = (1 << 14),
+        RxCfg_half_refetch = (1 << 13),
+        RxCfg_pause_slot_en = (1 << 11),
+        RxCfg_9356SEL = (1 << 6),
+
+        /* TxConfigBits */
+        TxInterFrameGapShift = 24,
+        TxDMAShift = 8, /* DMA burst value (0-7) is shift this many bits */
+        TxMACLoopBack = (1 << 17),  /* MAC loopback */
+
+        /* Config1 register */
+        LEDS1       = (1 << 7),
+        LEDS0       = (1 << 6),
+        Speed_down  = (1 << 4),
+        MEMMAP      = (1 << 3),
+        IOMAP       = (1 << 2),
+        VPD         = (1 << 1),
+        PMEnable    = (1 << 0), /* Power Management Enable */
+
+        /* Config2 register */
+        PMSTS_En    = (1 << 5),
+
+        /* Config3 register */
+        Isolate_en  = (1 << 12), /* Isolate enable */
+        MagicPacket = (1 << 5), /* Wake up when receives a Magic Packet */
+        LinkUp      = (1 << 4), /* This bit is reserved in RTL8125B.*/
+        /* Wake up when the cable connection is re-established */
+        ECRCEN      = (1 << 3), /* This bit is reserved in RTL8125B*/
+        Jumbo_En0   = (1 << 2), /* This bit is reserved in RTL8125B*/
+        RDY_TO_L23  = (1 << 1), /* This bit is reserved in RTL8125B*/
+        Beacon_en   = (1 << 0), /* This bit is reserved in RTL8125B*/
+
+        /* Config4 register */
+        Jumbo_En1   = (1 << 1), /* This bit is reserved in RTL8125B*/
+
+        /* Config5 register */
+        BWF     = (1 << 6), /* Accept Broadcast wakeup frame */
+        MWF     = (1 << 5), /* Accept Multicast wakeup frame */
+        UWF     = (1 << 4), /* Accept Unicast wakeup frame */
+        LanWake     = (1 << 1), /* LanWake enable/disable */
+        PMEStatus   = (1 << 0), /* PME status can be reset by PCI RST# */
+
+        /* CPlusCmd */
+        EnableBist  = (1 << 15),
+        Macdbgo_oe  = (1 << 14),
+        Normal_mode = (1 << 13),
+        Force_halfdup   = (1 << 12),
+        Force_rxflow_en = (1 << 11),
+        Force_txflow_en = (1 << 10),
+        Cxpl_dbg_sel    = (1 << 9),//This bit is reserved in RTL8125B
+        ASF     = (1 << 8),//This bit is reserved in RTL8125C
+        PktCntrDisable  = (1 << 7),
+        RxVlan      = (1 << 6),
+        RxChkSum    = (1 << 5),
+        Macdbgo_sel = 0x001C,
+        INTT_0      = 0x0000,
+        INTT_1      = 0x0001,
+        INTT_2      = 0x0002,
+        INTT_3      = 0x0003,
+
+        /* rtl8125_PHYstatus */
+        PowerSaveStatus = 0x80,
+        _2500bpsF = 0x400,
+        TxFlowCtrl = 0x40,
+        RxFlowCtrl = 0x20,
+        _1000bpsF = 0x10,
+        _100bps = 0x08,
+        _10bps = 0x04,
+        LinkStatus = 0x02,
+        FullDup = 0x01,
+
+        /* DBG_reg */
+        Fix_Nak_1 = (1 << 4),
+        Fix_Nak_2 = (1 << 3),
+        DBGPIN_E2 = (1 << 0),
+
+        /* ResetCounterCommand */
+        CounterReset = 0x1,
+        /* DumpCounterCommand */
+        CounterDump = 0x8,
+
+        /* PHY access */
+        PHYAR_Flag = 0x80000000,
+        PHYAR_Write = 0x80000000,
+        PHYAR_Read = 0x00000000,
+        PHYAR_Reg_Mask = 0x1f,
+        PHYAR_Reg_shift = 16,
+        PHYAR_Data_Mask = 0xffff,
+
+        /* EPHY access */
+        EPHYAR_Flag = 0x80000000,
+        EPHYAR_Write = 0x80000000,
+        EPHYAR_Read = 0x00000000,
+        EPHYAR_Reg_Mask = 0x3f,
+        EPHYAR_Reg_Mask_v2 = 0x7f,
+        EPHYAR_Reg_shift = 16,
+        EPHYAR_Data_Mask = 0xffff,
+
+        /* CSI access */
+        CSIAR_Flag = 0x80000000,
+        CSIAR_Write = 0x80000000,
+        CSIAR_Read = 0x00000000,
+        CSIAR_ByteEn = 0x0f,
+        CSIAR_ByteEn_shift = 12,
+        CSIAR_Addr_Mask = 0x0fff,
+
+        /* ERI access */
+        ERIAR_Flag = 0x80000000,
+        ERIAR_Write = 0x80000000,
+        ERIAR_Read = 0x00000000,
+        ERIAR_Addr_Align = 4, /* ERI access register address must be 4 byte alignment */
+        ERIAR_ExGMAC = 0,
+        ERIAR_MSIX = 1,
+        ERIAR_ASF = 2,
+        ERIAR_OOB = 2,
+        ERIAR_Type_shift = 16,
+        ERIAR_ByteEn = 0x0f,
+        ERIAR_ByteEn_shift = 12,
+
+        /* OCP GPHY access */
+        OCPDR_Write = 0x80000000,
+        OCPDR_Read = 0x00000000,
+        OCPDR_Reg_Mask = 0xFF,
+        OCPDR_Data_Mask = 0xFFFF,
+        OCPDR_GPHY_Reg_shift = 16,
+        OCPAR_Flag = 0x80000000,
+        OCPAR_GPHY_Write = 0x8000F060,
+        OCPAR_GPHY_Read = 0x0000F060,
+        OCPR_Write = 0x80000000,
+        OCPR_Read = 0x00000000,
+        OCPR_Addr_Reg_shift = 16,
+        OCPR_Flag = 0x80000000,
+        OCP_STD_PHY_BASE_PAGE = 0x0A40,
+
+        /* MCU Command */
+        Now_is_oob = (1 << 7),
+        Txfifo_empty = (1 << 5),
+        Rxfifo_empty = (1 << 4),
+
+        /* E-FUSE access */
+        EFUSE_WRITE = 0x80000000,
+        EFUSE_WRITE_OK  = 0x00000000,
+        EFUSE_READ  = 0x00000000,
+        EFUSE_READ_OK   = 0x80000000,
+        EFUSE_WRITE_V3 = 0x40000000,
+        EFUSE_WRITE_OK_V3  = 0x00000000,
+        EFUSE_READ_V3  = 0x80000000,
+        EFUSE_READ_OK_V3   = 0x00000000,
+        EFUSE_Reg_Mask  = 0x03FF,
+        EFUSE_Reg_Shift = 8,
+        EFUSE_Check_Cnt = 300,
+        EFUSE_READ_FAIL = 0xFF,
+        EFUSE_Data_Mask = 0x000000FF,
+
+        /* GPIO */
+        GPIO_en = (1 << 0),
+
+        /* PTP */
+        PTP_ISR_TOK = (1 << 1),
+        PTP_ISR_TER = (1 << 2),
+        PTP_EXEC_CMD = (1 << 7),
+        PTP_ADJUST_TIME_NS_NEGATIVE = (1 << 30),
+        PTP_ADJUST_TIME_S_NEGATIVE = (1ULL << 48),
+
+        /* New Interrupt Bits */
+        INT_CFG0_ENABLE_8125 = (1 << 0),
+        INT_CFG0_TIMEOUT0_BYPASS_8125 = (1 << 1),
+        INT_CFG0_MITIGATION_BYPASS_8125 = (1 << 2),
+        ISRIMR_V2_ROK_Q0     = (1 << 0),
+        ISRIMR_TOK_Q0        = (1 << 16),
+        ISRIMR_TOK_Q1        = (1 << 18),
+        ISRIMR_V2_LINKCHG    = (1 << 21),
+
+        /* Magic Number */
+        RTL8125_MAGIC_NUMBER = 0x0badbadbadbadbadull,
+};
+
+enum _DescStatusBit {
+        DescOwn     = (1 << 31), /* Descriptor is owned by NIC */
+        RingEnd     = (1 << 30), /* End of descriptor ring */
+        FirstFrag   = (1 << 29), /* First segment of a packet */
+        LastFrag    = (1 << 28), /* Final segment of a packet */
+
+        DescOwn_V3     = (DescOwn), /* Descriptor is owned by NIC */
+        RingEnd_V3     = (RingEnd), /* End of descriptor ring */
+        FirstFrag_V3   = (1 << 25), /* First segment of a packet */
+        LastFrag_V3    = (1 << 24), /* Final segment of a packet */
+
+        /* Tx private */
+        /*------ offset 0 of tx descriptor ------*/
+        LargeSend   = (1 << 27), /* TCP Large Send Offload (TSO) */
+        GiantSendv4 = (1 << 26), /* TCP Giant Send Offload V4 (GSOv4) */
+        GiantSendv6 = (1 << 25), /* TCP Giant Send Offload V6 (GSOv6) */
+        LargeSend_DP = (1 << 16), /* TCP Large Send Offload (TSO) */
+        MSSShift    = 16,        /* MSS value position */
+        MSSMask     = 0x7FFU,    /* MSS value 11 bits */
+        TxIPCS      = (1 << 18), /* Calculate IP checksum */
+        TxUDPCS     = (1 << 17), /* Calculate UDP/IP checksum */
+        TxTCPCS     = (1 << 16), /* Calculate TCP/IP checksum */
+        TxVlanTag   = (1 << 17), /* Add VLAN tag */
+
+        /*@@@@@@ offset 4 of tx descriptor => bits for RTL8125 only     begin @@@@@@*/
+        TxUDPCS_C   = (1 << 31), /* Calculate UDP/IP checksum */
+        TxTCPCS_C   = (1 << 30), /* Calculate TCP/IP checksum */
+        TxIPCS_C    = (1 << 29), /* Calculate IP checksum */
+        TxIPV6F_C   = (1 << 28), /* Indicate it is an IPv6 packet */
+        /*@@@@@@ offset 4 of tx descriptor => bits for RTL8125 only     end @@@@@@*/
+
+
+        /* Rx private */
+        /*------ offset 0 of rx descriptor ------*/
+        PID1        = (1 << 18), /* Protocol ID bit 1/2 */
+        PID0        = (1 << 17), /* Protocol ID bit 2/2 */
+
+#define RxProtoUDP  (PID1)
+#define RxProtoTCP  (PID0)
+#define RxProtoIP   (PID1 | PID0)
+#define RxProtoMask RxProtoIP
+
+        RxIPF       = (1 << 16), /* IP checksum failed */
+        RxUDPF      = (1 << 15), /* UDP/IP checksum failed */
+        RxTCPF      = (1 << 14), /* TCP/IP checksum failed */
+        RxVlanTag   = (1 << 16), /* VLAN tag available */
+
+        /*@@@@@@ offset 0 of rx descriptor => bits for RTL8125 only     begin @@@@@@*/
+        RxUDPT      = (1 << 18),
+        RxTCPT      = (1 << 17),
+        /*@@@@@@ offset 0 of rx descriptor => bits for RTL8125 only     end @@@@@@*/
+
+        /*@@@@@@ offset 4 of rx descriptor => bits for RTL8125 only     begin @@@@@@*/
+        RxV6F       = (1 << 31),
+        RxV4F       = (1 << 30),
+        /*@@@@@@ offset 4 of rx descriptor => bits for RTL8125 only     end @@@@@@*/
+
+
+        PID1_v3        = (1 << 29), /* Protocol ID bit 1/2 */
+        PID0_v3        = (1 << 28), /* Protocol ID bit 2/2 */
+
+#define RxProtoUDP_v3  (PID1_v3)
+#define RxProtoTCP_v3  (PID0_v3)
+#define RxProtoIP_v3   (PID1_v3 | PID0_v3)
+#define RxProtoMask_v3 RxProtoIP_v3
+
+        RxIPF_v3       = (1 << 26), /* IP checksum failed */
+        RxUDPF_v3      = (1 << 25), /* UDP/IP checksum failed */
+        RxTCPF_v3      = (1 << 24), /* TCP/IP checksum failed */
+        RxSCTPF_v3     = (1 << 23), /* TCP/IP checksum failed */
+        RxVlanTag_v3   = (RxVlanTag), /* VLAN tag available */
+
+        /*@@@@@@ offset 0 of rx descriptor => bits for RTL8125 only     begin @@@@@@*/
+        RxUDPT_v3      = (1 << 29),
+        RxTCPT_v3      = (1 << 28),
+        RxSCTP_v3      = (1 << 27),
+        /*@@@@@@ offset 0 of rx descriptor => bits for RTL8125 only     end @@@@@@*/
+
+        /*@@@@@@ offset 4 of rx descriptor => bits for RTL8125 only     begin @@@@@@*/
+        RxV6F_v3       = (RxV6F),
+        RxV4F_v3       = (RxV4F),
+        /*@@@@@@ offset 4 of rx descriptor => bits for RTL8125 only     end @@@@@@*/
+};
+
+enum features {
+//  RTL_FEATURE_WOL = (1 << 0),
+        RTL_FEATURE_MSI = (1 << 1),
+        RTL_FEATURE_MSIX = (1 << 2),
+};
+
+enum wol_capability {
+        WOL_DISABLED = 0,
+        WOL_ENABLED = 1
+};
+
+enum bits {
+        BIT_0 = (1 << 0),
+        BIT_1 = (1 << 1),
+        BIT_2 = (1 << 2),
+        BIT_3 = (1 << 3),
+        BIT_4 = (1 << 4),
+        BIT_5 = (1 << 5),
+        BIT_6 = (1 << 6),
+        BIT_7 = (1 << 7),
+        BIT_8 = (1 << 8),
+        BIT_9 = (1 << 9),
+        BIT_10 = (1 << 10),
+        BIT_11 = (1 << 11),
+        BIT_12 = (1 << 12),
+        BIT_13 = (1 << 13),
+        BIT_14 = (1 << 14),
+        BIT_15 = (1 << 15),
+        BIT_16 = (1 << 16),
+        BIT_17 = (1 << 17),
+        BIT_18 = (1 << 18),
+        BIT_19 = (1 << 19),
+        BIT_20 = (1 << 20),
+        BIT_21 = (1 << 21),
+        BIT_22 = (1 << 22),
+        BIT_23 = (1 << 23),
+        BIT_24 = (1 << 24),
+        BIT_25 = (1 << 25),
+        BIT_26 = (1 << 26),
+        BIT_27 = (1 << 27),
+        BIT_28 = (1 << 28),
+        BIT_29 = (1 << 29),
+        BIT_30 = (1 << 30),
+        BIT_31 = (1 << 31)
+};
+
+enum effuse {
+        EFUSE_NOT_SUPPORT = 0,
+        EFUSE_SUPPORT_V1,
+        EFUSE_SUPPORT_V2,
+        EFUSE_SUPPORT_V3,
+        EFUSE_SUPPORT_V4,
+};
+#define RsvdMask    0x3fffc000
+#define RsvdMaskV3  0x3fff8000
+
+struct TxDesc {
+        u32 opts1;
+        u32 opts2;
+        u64 addr;
+        u32 reserved0;
+        u32 reserved1;
+        u32 reserved2;
+        u32 reserved3;
+};
+
+struct RxDesc {
+        u32 opts1;
+        u32 opts2;
+        u64 addr;
+};
+
+struct RxDescV3 {
+        union {
+                struct {
+                        u32 rsv1;
+                        u32 rsv2;
+                } RxDescDDWord1;
+        };
+
+        union {
+                struct {
+                        u32 RSSResult;
+                        u16 HeaderBufferLen;
+                        u16 HeaderInfo;
+                } RxDescNormalDDWord2;
+
+                struct {
+                        u32 rsv5;
+                        u32 rsv6;
+                } RxDescDDWord2;
+        };
+
+        union {
+                u64   addr;
+
+                struct {
+                        u32 TimeStampLow;
+                        u32 TimeStampHigh;
+                } RxDescTimeStamp;
+
+                struct {
+                        u32 rsv8;
+                        u32 rsv9;
+                } RxDescDDWord3;
+        };
+
+        union {
+                struct {
+                        u32 opts2;
+                        u32 opts1;
+                } RxDescNormalDDWord4;
+
+                struct {
+                        u16 TimeStampHHigh;
+                        u16 rsv11;
+                        u32 opts1;
+                } RxDescPTPDDWord4;
+        };
+};
+
+enum rxdesc_type {
+        RXDESC_TYPE_NORMAL=0,
+        RXDESC_TYPE_NEXT,
+        RXDESC_TYPE_PTP,
+        RXDESC_TYPE_MAX
+};
+
+//Rx Desc Type
+enum rx_desc_ring_type {
+        RX_DESC_RING_TYPE_UNKNOWN=0,
+        RX_DESC_RING_TYPE_1,
+        RX_DESC_RING_TYPE_2,
+        RX_DESC_RING_TYPE_3,
+        RX_DESC_RING_TYPE_MAX
+};
+
+enum rx_desc_len {
+        RX_DESC_LEN_TYPE_1 = (sizeof(struct RxDesc)),
+        RX_DESC_LEN_TYPE_3 = (sizeof(struct RxDescV3))
+};
+
+struct ring_info {
+        struct sk_buff  *skb;
+        u32     len;
+        u8      __pad[sizeof(void *) - sizeof(u32)];
+};
+
+struct pci_resource {
+        u8  cmd;
+        u8  cls;
+        u16 io_base_h;
+        u16 io_base_l;
+        u16 mem_base_h;
+        u16 mem_base_l;
+        u8  ilr;
+        u16 resv_0x1c_h;
+        u16 resv_0x1c_l;
+        u16 resv_0x20_h;
+        u16 resv_0x20_l;
+        u16 resv_0x24_h;
+        u16 resv_0x24_l;
+        u16 resv_0x2c_h;
+        u16 resv_0x2c_l;
+        u32 pci_sn_l;
+        u32 pci_sn_h;
+};
+
+enum r8125_flag {
+        R8125_FLAG_DOWN = 0,
+        R8125_FLAG_TASK_RESET_PENDING,
+        R8125_FLAG_TASK_ESD_CHECK_PENDING,
+        R8125_FLAG_TASK_LINKCHG_CHECK_PENDING,
+        R8125_FLAG_MAX
+};
+
+struct rtl8125_tx_ring {
+        void* priv;
+        u32 index;
+        u32 cur_tx; /* Index into the Tx descriptor buffer of next Rx pkt. */
+        u32 dirty_tx;
+        u32 num_tx_desc; /* Number of Tx descriptor registers */
+        struct TxDesc *TxDescArray; /* 256-aligned Tx descriptor ring */
+        dma_addr_t TxPhyAddr;
+        struct ring_info tx_skb[MAX_NUM_TX_DESC]; /* Tx data buffers */
+
+        u32 NextHwDesCloPtr;
+        u32 BeginHwDesCloPtr;
+
+        u16 hw_clo_ptr_reg;
+        u16 sw_tail_ptr_reg;
+
+        u16 tdsar_reg; /* Transmit Descriptor Start Address */
+};
+
+struct rtl8125_rx_ring {
+        void* priv;
+        u32 index;
+        u32 cur_rx; /* Index into the Rx descriptor buffer of next Rx pkt. */
+        u32 dirty_rx;
+        u32 num_rx_desc; /* Number of Rx descriptor registers */
+        struct RxDesc *RxDescArray; /* 256-aligned Rx descriptor ring */
+        u64 RxDescPhyAddr[MAX_NUM_RX_DESC]; /* Rx desc physical address*/
+        dma_addr_t RxPhyAddr;
+        struct sk_buff *Rx_skbuff[MAX_NUM_RX_DESC]; /* Rx data buffers */
+
+        u16 rdsar_reg; /* Receive Descriptor Start Address */
+};
+
+struct r8125_napi {
+#ifdef CONFIG_R8125_NAPI
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,24)
+        struct napi_struct napi;
+#endif
+#endif
+        void* priv;
+        int index;
+};
+
+struct r8125_irq {
+        irq_handler_t	handler;
+        unsigned int	vector;
+        u8		requested;
+        char		name[IFNAMSIZ + 10];
+};
+
+#pragma pack(1)
+struct rtl8125_regs {
+        //00
+        u8 mac_id[6];
+        u16 reg_06;
+        u8 mar[8];
+        //10
+        u64 dtccr;
+        u16 ledsel0;
+        u16 legreg;
+        u32 tctr3;
+        //20
+        u32 txq0_dsc_st_addr_0;
+        u32 txq0_dsc_st_addr_2;
+        u64 reg_28;
+        //30
+        u16 rit;
+        u16 ritc;
+        u16 reg_34;
+        u8 reg_36;
+        u8 command;
+        u32 imr0;
+        u32 isr0;
+        //40
+        u32 tcr;
+        u32 rcr;
+        u32 tctr0;
+        u32 tctr1;
+        //50
+        u8 cr93c46;
+        u8 config0;
+        u8 config1;
+        u8 config2;
+        u8 config3;
+        u8 config4;
+        u8 config5;
+        u8 tdfnr;
+        u32 timer_int0;
+        u32 timer_int1;
+        //60
+        u32 gphy_mdcmdio;
+        u32 csidr;
+        u32 csiar;
+        u16 phy_status;
+        u8 config6;
+        u8 pmch;
+        //70
+        u32 eridr;
+        u32 eriar;
+        u16 config7;
+        u16 reg_7a;
+        u32 ephy_rxerr_cnt;
+        //80
+        u32 ephy_mdcmdio;
+        u16 ledsel2;
+        u16 ledsel1;
+        u32 tctr2;
+        u32 timer_int2;
+        //90
+        u8 tppoll0;
+        u8 reg_91;
+        u16 reg_92;
+        u16 led_feature;
+        u16 ledsel3;
+        u16 eee_led_config;
+        u16 reg_9a;
+        u32 reg_9c;
+        //a0
+        u32 reg_a0;
+        u32 reg_a4;
+        u32 reg_a8;
+        u32 reg_ac;
+        //b0
+        u32 patch_dbg;
+        u32 reg_b4;
+        u32 gphy_ocp;
+        u32 reg_bc;
+        //c0
+        u32 reg_c0;
+        u32 reg_c4;
+        u32 reg_c8;
+        u16 otp_cmd;
+        u16 otp_pg_config;
+        //d0
+        u16 phy_pwr;
+        u8 twsi_ctrl;
+        u8 oob_ctrl;
+        u16 mac_dbgo;
+        u16 mac_dbg;
+        u16 reg_d8;
+        u16 rms;
+        u32 efuse_data;
+        //e0
+        u16 cplus_cmd;
+        u16 reg_e2;
+        u32 rxq0_dsc_st_addr_0;
+        u32 rxq0_dsc_st_addr_2;
+        u16 reg_ec;
+        u16 tx10midle_cnt;
+        //f0
+        u16 misc0;
+        u16 misc1;
+        u32 timer_int3;
+        u32 cmac_ib;
+        u16 reg_fc;
+        u16 sw_rst;
+};
+#pragma pack()
+
+struct rtl8125_regs_save {
+        union {
+                u8 mac_io[R8125_MAC_REGS_SIZE];
+
+                struct rtl8125_regs mac_reg;
+        };
+        u16 pcie_phy[R8125_EPHY_REGS_SIZE/2];
+        u16 eth_phy[R8125_PHY_REGS_SIZE/2];
+        u32 eri_reg[R8125_ERI_REGS_SIZE/4];
+        u32 pci_reg[R8125_PCI_REGS_SIZE/4];
+        u16 sw_tail_ptr_reg[R8125_MAX_TX_QUEUES];
+        u16 hw_clo_ptr_reg[R8125_MAX_TX_QUEUES];
+
+        //ktime_t begin_ktime;
+        //ktime_t end_ktime;
+        //u64 duration_ns;
+
+        u16 sw0_tail_ptr;
+        u16 next_hwq0_clo_ptr;
+        u16 sw1_tail_ptr;
+        u16 next_hwq1_clo_ptr;
+
+        u16 int_miti_rxq0;
+        u16 int_miti_txq0;
+        u16 int_miti_rxq1;
+        u16 int_miti_txq1;
+        u8 int_config;
+        u32 imr_new;
+        u32 isr_new;
+
+        u8 tdu_status;
+        u16 rdu_status;
+
+        u16 tc_mode;
+
+        u32 txq1_dsc_st_addr_0;
+        u32 txq1_dsc_st_addr_2;
+
+        u32 pla_tx_q0_idle_credit;
+        u32 pla_tx_q1_idle_credit;
+
+        u32 rxq1_dsc_st_addr_0;
+        u32 rxq1_dsc_st_addr_2;
+
+        u32 rss_ctrl;
+        u8 rss_key[RTL8125_RSS_KEY_SIZE];
+        u8 rss_i_table[RTL8125_MAX_INDIRECTION_TABLE_ENTRIES];
+        u16 rss_queue_num_sel_r;
+};
+
+struct rtl8125_counters {
+        /* legacy */
+        u64 tx_packets;
+        u64 rx_packets;
+        u64 tx_errors;
+        u32 rx_errors;
+        u16 rx_missed;
+        u16 align_errors;
+        u32 tx_one_collision;
+        u32 tx_multi_collision;
+        u64 rx_unicast;
+        u64 rx_broadcast;
+        u32 rx_multicast;
+        u16 tx_aborted;
+        u16 tx_underrun;
+
+        /* extended */
+        u64 tx_octets;
+        u64 rx_octets;
+        u64 rx_multicast64;
+        u64 tx_unicast64;
+        u64 tx_broadcast64;
+        u64 tx_multicast64;
+        u32 tx_pause_on;
+        u32 tx_pause_off;
+        u32 tx_pause_all;
+        u32 tx_deferred;
+        u32 tx_late_collision;
+        u32 tx_all_collision;
+        u32 tx_aborted32;
+        u32 align_errors32;
+        u32 rx_frame_too_long;
+        u32 rx_runt;
+        u32 rx_pause_on;
+        u32 rx_pause_off;
+        u32 rx_pause_all;
+        u32 rx_unknown_opcode;
+        u32 rx_mac_error;
+        u32 tx_underrun32;
+        u32 rx_mac_missed;
+        u32 rx_tcam_dropped;
+        u32 tdu;
+        u32 rdu;
+};
+
+/* Flow Control Settings */
+enum rtl8125_fc_mode {
+        rtl8125_fc_none = 0,
+        rtl8125_fc_rx_pause,
+        rtl8125_fc_tx_pause,
+        rtl8125_fc_full,
+        rtl8125_fc_default
+};
+
+struct rtl8125_private {
+        void __iomem *mmio_addr;    /* memory map physical address */
+        struct pci_dev *pci_dev;    /* Index of PCI device */
+        struct net_device *dev;
+        struct r8125_napi r8125napi[R8125_MAX_MSIX_VEC];
+        struct r8125_irq irq_tbl[R8125_MAX_MSIX_VEC];
+        unsigned int irq_nvecs;
+        unsigned int max_irq_nvecs;
+        unsigned int min_irq_nvecs;
+        //struct msix_entry msix_entries[R8125_MAX_MSIX_VEC];
+        struct net_device_stats stats;  /* statistics of net device */
+#ifdef ENABLE_PTP_SUPPORT
+        spinlock_t lock;        /* spin lock flag */
+#endif
+        u32 msg_enable;
+        u32 tx_tcp_csum_cmd;
+        u32 tx_udp_csum_cmd;
+        u32 tx_ip_csum_cmd;
+        u32 tx_ipv6_csum_cmd;
+        int max_jumbo_frame_size;
+        int chipset;
+        u32 mcfg;
+        //u32 cur_rx; /* Index into the Rx descriptor buffer of next Rx pkt. */
+        //u32 cur_tx; /* Index into the Tx descriptor buffer of next Rx pkt. */
+        //u32 dirty_rx;
+        //u32 dirty_tx;
+        //struct TxDesc *TxDescArray; /* 256-aligned Tx descriptor ring */
+        //struct RxDesc *RxDescArray; /* 256-aligned Rx descriptor ring */
+        //dma_addr_t TxPhyAddr;
+        //dma_addr_t RxPhyAddr;
+        //struct sk_buff *Rx_skbuff[MAX_NUM_RX_DESC]; /* Rx data buffers */
+        //struct ring_info tx_skb[MAX_NUM_TX_DESC];   /* Tx data buffers */
+        unsigned rx_buf_sz;
+        u16 HwSuppNumTxQueues;
+        u16 HwSuppNumRxQueues;
+        unsigned int num_tx_rings;
+        unsigned int num_rx_rings;
+        struct rtl8125_tx_ring tx_ring[R8125_MAX_TX_QUEUES];
+        struct rtl8125_rx_ring rx_ring[R8125_MAX_RX_QUEUES];
+#ifdef ENABLE_LIB_SUPPORT
+        struct atomic_notifier_head lib_nh;
+        struct rtl8125_ring lib_tx_ring[R8125_MAX_TX_QUEUES];
+        struct rtl8125_ring lib_rx_ring[R8125_MAX_RX_QUEUES];
+#endif
+        //struct timer_list esd_timer;
+        //struct timer_list link_timer;
+        struct pci_resource pci_cfg_space;
+        unsigned int esd_flag;
+        unsigned int pci_cfg_is_read;
+        unsigned int rtl8125_rx_config;
+        u16 cp_cmd;
+        u32 intr_mask;
+        u32 timer_intr_mask;
+        u16 isr_reg[R8125_MAX_QUEUES];
+        u16 imr_reg[R8125_MAX_QUEUES];
+        int phy_auto_nego_reg;
+        int phy_1000_ctrl_reg;
+        int phy_2500_ctrl_reg;
+        u8 org_mac_addr[NODE_ADDRESS_SIZE];
+        struct rtl8125_counters *tally_vaddr;
+        dma_addr_t tally_paddr;
+
+#ifdef CONFIG_R8125_VLAN
+        struct vlan_group *vlgrp;
+#endif
+        u8  wol_enabled;
+        u32 wol_opts;
+        u8  efuse_ver;
+        u8  eeprom_type;
+        u8  autoneg;
+        u8  duplex;
+        u32 speed;
+        u32 advertising;
+        enum rtl8125_fc_mode fcpause;
+        u16 eeprom_len;
+        u16 cur_page;
+        u32 bios_setting;
+
+        int (*set_speed)(struct net_device *, u8 autoneg, u32 speed, u8 duplex, u32 adv);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+        void (*get_settings)(struct net_device *, struct ethtool_cmd *);
+#else
+        void (*get_settings)(struct net_device *, struct ethtool_link_ksettings *);
+#endif
+        void (*phy_reset_enable)(struct net_device *);
+        unsigned int (*phy_reset_pending)(struct net_device *);
+        unsigned int (*link_ok)(struct net_device *);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+        struct work_struct reset_task;
+        struct work_struct esd_task;
+        struct work_struct linkchg_task;
+#else
+        struct delayed_work reset_task;
+        struct delayed_work esd_task;
+        struct delayed_work linkchg_task;
+#endif
+        DECLARE_BITMAP(task_flags, R8125_FLAG_MAX);
+        unsigned features;
+
+        u8 org_pci_offset_99;
+        u8 org_pci_offset_180;
+        u8 issue_offset_99_event;
+
+        u8 org_pci_offset_80;
+        u8 org_pci_offset_81;
+        u8 use_timer_interrrupt;
+
+        u32 keep_intr_cnt;
+
+        u8  HwIcVerUnknown;
+        u8  NotWrRamCodeToMicroP;
+        u8  NotWrMcuPatchCode;
+        u8  HwHasWrRamCodeToMicroP;
+
+        u16 sw_ram_code_ver;
+        u16 hw_ram_code_ver;
+
+        u8 RequireRduNonStopPatch;
+
+        u8 rtk_enable_diag;
+
+        u8 ShortPacketSwChecksum;
+
+        u8 UseSwPaddingShortPkt;
+
+        void *ShortPacketEmptyBuffer;
+        dma_addr_t ShortPacketEmptyBufferPhy;
+
+        u8 RequireAdcBiasPatch;
+        u16 AdcBiasPatchIoffset;
+
+        u8 RequireAdjustUpsTxLinkPulseTiming;
+        u16 SwrCnt1msIni;
+
+        u8 HwSuppNowIsOobVer;
+
+        u8 RequiredSecLanDonglePatch;
+
+        u8 RequirePhyMdiSwapPatch;
+
+        u8 RequireLSOPatch;
+
+        u32 HwFiberModeVer;
+        u32 HwFiberStat;
+        u8 HwSwitchMdiToFiber;
+
+        u16 NicCustLedValue;
+
+        u8 HwSuppMagicPktVer;
+
+        u8 HwSuppLinkChgWakeUpVer;
+
+        u8 HwSuppCheckPhyDisableModeVer;
+
+        u8 random_mac;
+
+        u16 phy_reg_aner;
+        u16 phy_reg_anlpar;
+        u16 phy_reg_gbsr;
+        u16 phy_reg_status_2500;
+
+        u32 HwPcieSNOffset;
+
+        u8 HwSuppTxNoCloseVer;
+        u8 EnableTxNoClose;
+
+        u8 HwSuppIsrVer;
+        u8 HwCurrIsrVer;
+
+        u8 HwSuppIntMitiVer;
+
+        u8 HwSuppExtendTallyCounterVer;
+
+        u8 check_keep_link_speed;
+        u8 resume_not_chg_speed;
+
+        u8 HwSuppD0SpeedUpVer;
+        u8 D0SpeedUpSpeed;
+
+        u8 ring_lib_enabled;
+
+        const char *fw_name;
+        struct rtl8125_fw *rtl_fw;
+        u32 ocp_base;
+
+        //Dash+++++++++++++++++
+        u8 HwSuppDashVer;
+        u8 DASH;
+        u8 dash_printer_enabled;
+        u8 HwPkgDet;
+        void __iomem *mapped_cmac_ioaddr; /* mapped cmac memory map physical address */
+        void __iomem *cmac_ioaddr; /* cmac memory map physical address */
+
+#ifdef ENABLE_DASH_SUPPORT
+        u16 AfterRecvFromFwBufLen;
+        u8 AfterRecvFromFwBuf[RECV_FROM_FW_BUF_SIZE];
+        u16 AfterSendToFwBufLen;
+        u8 AfterSendToFwBuf[SEND_TO_FW_BUF_SIZE];
+        u16 SendToFwBufferLen;
+        u32 SizeOfSendToFwBuffer;
+        u32 SizeOfSendToFwBufferMemAlloc;
+        u32 NumOfSendToFwBuffer;
+
+        u8 OobReq;
+        u8 OobAck;
+        u32 OobReqComplete;
+        u32 OobAckComplete;
+
+        u8 RcvFwReqSysOkEvt;
+        u8 RcvFwDashOkEvt;
+        u8 SendFwHostOkEvt;
+
+        u8 DashFwDisableRx;
+
+        void *UnalignedSendToFwBufferVa;
+        void *SendToFwBuffer;
+        u64 SendToFwBufferPhy;
+        u8 SendingToFw;
+        dma_addr_t UnalignedSendToFwBufferPa;
+        PTX_DASH_SEND_FW_DESC TxDashSendFwDesc;
+        u64 TxDashSendFwDescPhy;
+        u8 *UnalignedTxDashSendFwDescVa;
+        u32 SizeOfTxDashSendFwDescMemAlloc;
+        u32 SizeOfTxDashSendFwDesc;
+        u32 NumTxDashSendFwDesc;
+        u32 CurrNumTxDashSendFwDesc;
+        u32 LastSendNumTxDashSendFwDesc;
+        dma_addr_t UnalignedTxDashSendFwDescPa;
+
+        u32 NumRecvFromFwBuffer;
+        u32 SizeOfRecvFromFwBuffer;
+        u32 SizeOfRecvFromFwBufferMemAlloc;
+        void *RecvFromFwBuffer;
+        u64 RecvFromFwBufferPhy;
+
+        void *UnalignedRecvFromFwBufferVa;
+        dma_addr_t UnalignedRecvFromFwBufferPa;
+        PRX_DASH_FROM_FW_DESC RxDashRecvFwDesc;
+        u64 RxDashRecvFwDescPhy;
+        u8 *UnalignedRxDashRecvFwDescVa;
+        u32 SizeOfRxDashRecvFwDescMemAlloc;
+        u32 SizeOfRxDashRecvFwDesc;
+        u32 NumRxDashRecvFwDesc;
+        u32 CurrNumRxDashRecvFwDesc;
+        dma_addr_t UnalignedRxDashRecvFwDescPa;
+        u8 DashReqRegValue;
+        u16 HostReqValue;
+
+        u32 CmacResetIsrCounter;
+        u8 CmacResetIntr;
+        u8 CmacResetting;
+        u8 CmacOobIssueCmacReset;
+        u32 CmacResetbyFwCnt;
+
+#if defined(ENABLE_DASH_PRINTER_SUPPORT)
+        struct completion fw_ack;
+        struct completion fw_req;
+        struct completion fw_host_ok;
+#endif
+        //Dash-----------------
+#endif //ENABLE_DASH_SUPPORT
+
+        //Realwow++++++++++++++
+        u8 HwSuppKCPOffloadVer;
+
+        u8 EnableDhcpTimeoutWake;
+        u8 EnableTeredoOffload;
+        u8 EnableKCPOffload;
+#ifdef ENABLE_REALWOW_SUPPORT
+        u32 DhcpTimeout;
+        MP_KCP_INFO MpKCPInfo;
+        //Realwow--------------
+#endif //ENABLE_REALWOW_SUPPORT
+
+        struct ethtool_eee eee;
+
+#ifdef ENABLE_R8125_PROCFS
+        //Procfs support
+        struct proc_dir_entry *proc_dir;
+#endif
+        u8 InitRxDescType;
+        u16 RxDescLength; //V1 16 Byte V2 32 Bytes
+
+        u8 HwSuppPtpVer;
+        u8 EnablePtp;
+        u8 ptp_master_mode;
+        s64 ptp_adjust;
+#ifdef ENABLE_PTP_SUPPORT
+        u32 tx_hwtstamp_timeouts;
+        u32 tx_hwtstamp_skipped;
+        struct work_struct ptp_tx_work;
+        struct sk_buff *ptp_tx_skb;
+        struct hwtstamp_config hwtstamp_config;
+        unsigned long ptp_tx_start;
+        struct ptp_clock_info ptp_clock_info;
+        struct ptp_clock *ptp_clock;
+#endif
+
+        u8 HwSuppRssVer;
+        u8 EnableRss;
+        u16 HwSuppIndirTblEntries;
+#ifdef ENABLE_RSS_SUPPORT
+        u32 rss_flags;
+        /* Receive Side Scaling settings */
+        u8 rss_key[RTL8125_RSS_KEY_SIZE];
+        u8 rss_indir_tbl[RTL8125_MAX_INDIRECTION_TABLE_ENTRIES];
+        u32 rss_options;
+#endif
+
+        u8 HwSuppMacMcuVer;
+        u16 MacMcuPageSize;
+};
+
+#ifdef ENABLE_LIB_SUPPORT
+static inline unsigned int
+rtl8125_num_lib_tx_rings(struct rtl8125_private *tp)
+{
+        int count, i;
+
+        for (count = 0, i = tp->num_tx_rings; i < tp->HwSuppNumTxQueues; i++)
+                if(tp->lib_tx_ring[i].enabled)
+                        count++;
+
+        return count;
+}
+
+static inline unsigned int
+rtl8125_num_lib_rx_rings(struct rtl8125_private *tp)
+{
+        int count, i;
+
+        for (count = 0, i = tp->num_rx_rings; i < tp->HwSuppNumRxQueues; i++)
+                if(tp->lib_rx_ring[i].enabled)
+                        count++;
+
+        return count;
+}
+
+#else
+static inline unsigned int
+rtl8125_num_lib_tx_rings(struct rtl8125_private *tp)
+{
+        return 0;
+}
+
+static inline unsigned int
+rtl8125_num_lib_rx_rings(struct rtl8125_private *tp)
+{
+        return 0;
+}
+#endif
+
+static inline unsigned int
+rtl8125_tot_tx_rings(struct rtl8125_private *tp)
+{
+        return tp->num_tx_rings + rtl8125_num_lib_tx_rings(tp);
+}
+
+static inline unsigned int
+rtl8125_tot_rx_rings(struct rtl8125_private *tp)
+{
+        return tp->num_rx_rings + rtl8125_num_lib_rx_rings(tp);
+}
+
+enum eetype {
+        EEPROM_TYPE_NONE=0,
+        EEPROM_TYPE_93C46,
+        EEPROM_TYPE_93C56,
+        EEPROM_TWSI
+};
+
+enum mcfg {
+        CFG_METHOD_2=2,
+        CFG_METHOD_3,
+        CFG_METHOD_4,
+        CFG_METHOD_5,
+        CFG_METHOD_6,
+        CFG_METHOD_7,
+        CFG_METHOD_DEFAULT,
+        CFG_METHOD_MAX
+};
+
+#define LSO_32K 32000
+#define LSO_64K 64000
+
+#define NIC_MIN_PHYS_BUF_COUNT          (2)
+#define NIC_MAX_PHYS_BUF_COUNT_LSO_64K  (24)
+#define NIC_MAX_PHYS_BUF_COUNT_LSO2     (16*4)
+
+#define GTTCPHO_SHIFT                   18
+#define GTTCPHO_MAX                     0x70U
+#define GTPKTSIZE_MAX                   0x3ffffU
+#define TCPHO_SHIFT                     18
+#define TCPHO_MAX                       0x3ffU
+#define LSOPKTSIZE_MAX                  0xffffU
+#define MSS_MAX                         0x07ffu /* MSS value */
+
+#define OOB_CMD_RESET       0x00
+#define OOB_CMD_DRIVER_START    0x05
+#define OOB_CMD_DRIVER_STOP 0x06
+#define OOB_CMD_SET_IPMAC   0x41
+
+#define WAKEUP_MAGIC_PACKET_NOT_SUPPORT (0)
+#define WAKEUP_MAGIC_PACKET_V1 (1)
+#define WAKEUP_MAGIC_PACKET_V2 (2)
+#define WAKEUP_MAGIC_PACKET_V3 (3)
+
+//Ram Code Version
+#define NIC_RAMCODE_VERSION_CFG_METHOD_2 (0x0b11)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_3 (0x0b33)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_4 (0x0b17)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_5 (0x0b74)
+
+//hwoptimize
+#define HW_PATCH_SOC_LAN (BIT_0)
+#define HW_PATCH_SAMSUNG_LAN_DONGLE (BIT_2)
+
+static const u16 other_q_intr_mask = (RxOK1 | RxDU1);
+
+void rtl8125_mdio_write(struct rtl8125_private *tp, u16 RegAddr, u16 value);
+void rtl8125_mdio_prot_write(struct rtl8125_private *tp, u32 RegAddr, u32 value);
+void rtl8125_mdio_prot_direct_write_phy_ocp(struct rtl8125_private *tp, u32 RegAddr, u32 value);
+u32 rtl8125_mdio_read(struct rtl8125_private *tp, u16 RegAddr);
+u32 rtl8125_mdio_prot_read(struct rtl8125_private *tp, u32 RegAddr);
+u32 rtl8125_mdio_prot_direct_read_phy_ocp(struct rtl8125_private *tp, u32 RegAddr);
+void rtl8125_ephy_write(struct rtl8125_private *tp, int RegAddr, int value);
+void rtl8125_mac_ocp_write(struct rtl8125_private *tp, u16 reg_addr, u16 value);
+u32 rtl8125_mac_ocp_read(struct rtl8125_private *tp, u16 reg_addr);
+void rtl8125_clear_eth_phy_bit(struct rtl8125_private *tp, u8 addr, u16 mask);
+void rtl8125_set_eth_phy_bit(struct rtl8125_private *tp,  u8  addr, u16  mask);
+void rtl8125_ocp_write(struct rtl8125_private *tp, u16 addr, u8 len, u32 data);
+void rtl8125_oob_notify(struct rtl8125_private *tp, u8 cmd);
+void rtl8125_init_ring_indexes(struct rtl8125_private *tp);
+int rtl8125_eri_write(struct rtl8125_private *tp, int addr, int len, u32 value, int type);
+void rtl8125_oob_mutex_lock(struct rtl8125_private *tp);
+u32 rtl8125_ocp_read(struct rtl8125_private *tp, u16 addr, u8 len);
+u32 rtl8125_ocp_read_with_oob_base_address(struct rtl8125_private *tp, u16 addr, u8 len, u32 base_address);
+u32 rtl8125_ocp_write_with_oob_base_address(struct rtl8125_private *tp, u16 addr, u8 len, u32 value, u32 base_address);
+u32 rtl8125_eri_read(struct rtl8125_private *tp, int addr, int len, int type);
+u32 rtl8125_eri_read_with_oob_base_address(struct rtl8125_private *tp, int addr, int len, int type, u32 base_address);
+int rtl8125_eri_write(struct rtl8125_private *tp, int addr, int len, u32 value, int type);
+int rtl8125_eri_write_with_oob_base_address(struct rtl8125_private *tp, int addr, int len, u32 value, int type, u32 base_address);
+u16 rtl8125_ephy_read(struct rtl8125_private *tp, int RegAddr);
+void rtl8125_wait_txrx_fifo_empty(struct net_device *dev);
+void rtl8125_enable_now_is_oob(struct rtl8125_private *tp);
+void rtl8125_disable_now_is_oob(struct rtl8125_private *tp);
+void rtl8125_oob_mutex_unlock(struct rtl8125_private *tp);
+void rtl8125_dash2_disable_tx(struct rtl8125_private *tp);
+void rtl8125_dash2_enable_tx(struct rtl8125_private *tp);
+void rtl8125_dash2_disable_rx(struct rtl8125_private *tp);
+void rtl8125_dash2_enable_rx(struct rtl8125_private *tp);
+void rtl8125_hw_disable_mac_mcu_bps(struct net_device *dev);
+void rtl8125_mark_to_asic(struct rtl8125_private *tp, struct RxDesc *desc, u32 rx_buf_sz);
+
+static inline void
+rtl8125_make_unusable_by_asic(struct rtl8125_private *tp,
+                              struct RxDesc *desc)
+{
+        if (tp->InitRxDescType == RX_DESC_RING_TYPE_3) {
+                ((struct RxDescV3 *)desc)->addr = RTL8125_MAGIC_NUMBER;
+                ((struct RxDescV3 *)desc)->RxDescNormalDDWord4.opts1 &= ~cpu_to_le32(DescOwn | RsvdMaskV3);
+        } else {
+                desc->addr = RTL8125_MAGIC_NUMBER;
+                desc->opts1 &= ~cpu_to_le32(DescOwn | RsvdMask);
+        }
+}
+
+static inline struct RxDesc*
+rtl8125_get_rxdesc(struct rtl8125_private *tp, struct RxDesc *RxDescBase, u32 const cur_rx)
+{
+        return (struct RxDesc*)((u8*)RxDescBase + (cur_rx * tp->RxDescLength));
+}
+
+static inline void
+rtl8125_disable_hw_interrupt_v2(struct rtl8125_private *tp,
+                                u32 message_id)
+{
+        RTL_W32(tp, IMR_V2_CLEAR_REG_8125, BIT(message_id));
+}
+
+static inline void
+rtl8125_enable_hw_interrupt_v2(struct rtl8125_private *tp, u32 message_id)
+{
+        RTL_W32(tp, IMR_V2_SET_REG_8125, BIT(message_id));
+}
+
+int rtl8125_open(struct net_device *dev);
+int rtl8125_close(struct net_device *dev);
+void rtl8125_hw_config(struct net_device *dev);
+void rtl8125_hw_set_timer_int_8125(struct rtl8125_private *tp, u32 message_id, u8 timer_intmiti_val);
+void rtl8125_set_rx_q_num(struct rtl8125_private *tp, unsigned int num_rx_queues);
+void rtl8125_set_tx_q_num(struct rtl8125_private *tp, unsigned int num_tx_queues);
+void rtl8125_hw_start(struct net_device *dev);
+void rtl8125_hw_reset(struct net_device *dev);
+void rtl8125_tx_clear(struct rtl8125_private *tp);
+void rtl8125_rx_clear(struct rtl8125_private *tp);
+int rtl8125_init_ring(struct net_device *dev);
+void rtl8125_hw_set_rx_packet_filter(struct net_device *dev);
+void rtl8125_enable_hw_linkchg_interrupt(struct rtl8125_private *tp);
+int rtl8125_dump_tally_counter(struct rtl8125_private *tp, dma_addr_t paddr);
+
+#ifndef ENABLE_LIB_SUPPORT
+static inline void rtl8125_lib_reset_prepare(struct rtl8125_private *tp) { }
+static inline void rtl8125_lib_reset_complete(struct rtl8125_private *tp) { }
+#endif
+
+#define HW_SUPPORT_CHECK_PHY_DISABLE_MODE(_M)        ((_M)->HwSuppCheckPhyDisableModeVer > 0 )
+#define HW_HAS_WRITE_PHY_MCU_RAM_CODE(_M)        (((_M)->HwHasWrRamCodeToMicroP == TRUE) ? 1 : 0)
+#define HW_SUPPORT_D0_SPEED_UP(_M)        ((_M)->HwSuppD0SpeedUpVer > 0)
+#define HW_SUPPORT_MAC_MCU(_M)        ((_M)->HwSuppMacMcuVer > 0)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,34)
+#define netdev_mc_count(dev) ((dev)->mc_count)
+#define netdev_mc_empty(dev) (netdev_mc_count(dev) == 0)
+#define netdev_for_each_mc_addr(mclist, dev) \
+    for (mclist = dev->mc_list; mclist; mclist = mclist->next)
+#endif
+
+#endif /* __R8125_H */
Index: kernel-rockchip/drivers/net/ethernet/realtek/r8125/r8125_dash.h
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/net/ethernet/realtek/r8125/r8125_dash.h
@@ -0,0 +1,261 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2022 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_R8125_DASH_H
+#define _LINUX_R8125_DASH_H
+
+#include <linux/if.h>
+
+#define SIOCDEVPRIVATE_RTLDASH   SIOCDEVPRIVATE+2
+
+enum rtl_dash_cmd {
+        RTL_DASH_ARP_NS_OFFLOAD = 0,
+        RTL_DASH_SET_OOB_IPMAC,
+        RTL_DASH_NOTIFY_OOB,
+
+        RTL_DASH_SEND_BUFFER_DATA_TO_DASH_FW,
+        RTL_DASH_CHECK_SEND_BUFFER_TO_DASH_FW_COMPLETE,
+        RTL_DASH_GET_RCV_FROM_FW_BUFFER_DATA,
+        RTL_DASH_OOB_REQ,
+        RTL_DASH_OOB_ACK,
+        RTL_DASH_DETACH_OOB_REQ,
+        RTL_DASH_DETACH_OOB_ACK,
+
+        RTL_FW_SET_IPV4 = 0x10,
+        RTL_FW_GET_IPV4,
+        RTL_FW_SET_IPV6,
+        RTL_FW_GET_IPV6,
+        RTL_FW_SET_EXT_SNMP,
+        RTL_FW_GET_EXT_SNMP,
+        RTL_FW_SET_WAKEUP_PATTERN,
+        RTL_FW_GET_WAKEUP_PATTERN,
+        RTL_FW_DEL_WAKEUP_PATTERN,
+
+        RTLT_DASH_COMMAND_INVALID,
+};
+
+struct rtl_dash_ip_mac {
+        struct sockaddr ifru_addr;
+        struct sockaddr ifru_netmask;
+        struct sockaddr ifru_hwaddr;
+};
+
+struct rtl_dash_ioctl_struct {
+        __u32	cmd;
+        __u32	offset;
+        __u32	len;
+        union {
+                __u32	data;
+                void *data_buffer;
+        };
+};
+
+struct settings_ipv4 {
+        __u32	IPv4addr;
+        __u32	IPv4mask;
+        __u32	IPv4Gateway;
+};
+
+struct settings_ipv6 {
+        __u32	reserved;
+        __u32	prefixLen;
+        __u16	IPv6addr[8];
+        __u16	IPv6Gateway[8];
+};
+
+struct settings_ext_snmp {
+        __u16	index;
+        __u16	oid_get_len;
+        __u8	oid_for_get[24];
+        __u8	reserved0[26];
+        __u16	value_len;
+        __u8	value[256];
+        __u8	supported;
+        __u8	reserved1[27];
+};
+
+struct wakeup_pattern {
+        __u8	index;
+        __u8	valid;
+        __u8	start;
+        __u8	length;
+        __u8	name[36];
+        __u8	mask[16];
+        __u8	pattern[128];
+        __u32	reserved[2];
+};
+
+typedef struct _RX_DASH_FROM_FW_DESC {
+        u16 length;
+        u8 statusLowByte;
+        u8 statusHighByte;
+        u32 resv;
+        u64 BufferAddress;
+}
+RX_DASH_FROM_FW_DESC, *PRX_DASH_FROM_FW_DESC;
+
+typedef struct _TX_DASH_SEND_FW_DESC {
+        u16 length;
+        u8 statusLowByte;
+        u8 statusHighByte;
+        u32 resv;
+        u64 BufferAddress;
+}
+TX_DASH_SEND_FW_DESC, *PTX_DASH_SEND_FW_DESC;
+
+typedef struct _OSOOBHdr {
+        u32 len;
+        u8 type;
+        u8 flag;
+        u8 hostReqV;
+        u8 res;
+}
+OSOOBHdr, *POSOOBHdr;
+
+typedef struct _RX_DASH_BUFFER_TYPE_2 {
+        OSOOBHdr oobhdr;
+        u8 RxDataBuffer[0];
+}
+RX_DASH_BUFFER_TYPE_2, *PRX_DASH_BUFFER_TYPE_2;
+
+#define ALIGN_8                 (0x7)
+#define ALIGN_16                (0xf)
+#define ALIGN_32                (0x1f)
+#define ALIGN_64                (0x3f)
+#define ALIGN_256               (0xff)
+#define ALIGN_4096              (0xfff)
+
+#define OCP_REG_CONFIG0 (0x10)
+#define OCP_REG_CONFIG0_REV_F (0xB8)
+#define OCP_REG_DASH_POLL (0x30)
+#define OCP_REG_HOST_REQ (0x34)
+#define OCP_REG_DASH_REQ (0x35)
+#define OCP_REG_CR (0x36)
+#define OCP_REG_DMEMSTA (0x38)
+#define OCP_REG_GPHYAR (0x60)
+
+
+#define OCP_REG_CONFIG0_DASHEN           BIT_15
+#define OCP_REG_CONFIG0_OOBRESET         BIT_14
+#define OCP_REG_CONFIG0_APRDY            BIT_13
+#define OCP_REG_CONFIG0_FIRMWARERDY      BIT_12
+#define OCP_REG_CONFIG0_DRIVERRDY        BIT_11
+#define OCP_REG_CONFIG0_OOB_WDT          BIT_9
+#define OCP_REG_CONFIG0_DRV_WAIT_OOB     BIT_8
+#define OCP_REG_CONFIG0_TLSEN            BIT_7
+
+#define HW_DASH_SUPPORT_DASH(_M)        ((_M)->HwSuppDashVer > 0 )
+#define HW_DASH_SUPPORT_TYPE_1(_M)        ((_M)->HwSuppDashVer == 1 )
+#define HW_DASH_SUPPORT_TYPE_2(_M)        ((_M)->HwSuppDashVer == 2 )
+#define HW_DASH_SUPPORT_TYPE_3(_M)        ((_M)->HwSuppDashVer == 3 )
+
+#define RECV_FROM_FW_BUF_SIZE (1520)
+#define SEND_TO_FW_BUF_SIZE (1520)
+
+#define RX_DASH_FROM_FW_OWN BIT_15
+#define TX_DASH_SEND_FW_OWN BIT_15
+#define TX_DASH_SEND_FW_OWN_HIGHBYTE BIT_7
+
+#define TXS_CC3_0       (BIT_0|BIT_1|BIT_2|BIT_3)
+#define TXS_EXC         BIT_4
+#define TXS_LNKF        BIT_5
+#define TXS_OWC         BIT_6
+#define TXS_TES         BIT_7
+#define TXS_UNF         BIT_9
+#define TXS_LGSEN       BIT_11
+#define TXS_LS          BIT_12
+#define TXS_FS          BIT_13
+#define TXS_EOR         BIT_14
+#define TXS_OWN         BIT_15
+
+#define TPPool_HRDY     0x20
+
+#define HostReqReg (0xC0)
+#define SystemMasterDescStartAddrLow (0xF0)
+#define SystemMasterDescStartAddrHigh (0xF4)
+#define SystemSlaveDescStartAddrLow (0xF8)
+#define SystemSlaveDescStartAddrHigh (0xFC)
+
+//DASH Request Type
+#define WSMANREG 0x01
+#define OSPUSHDATA 0x02
+
+#define RXS_OWN      BIT_15
+#define RXS_EOR      BIT_14
+#define RXS_FS       BIT_13
+#define RXS_LS       BIT_12
+
+#define ISRIMR_DP_DASH_OK BIT_15
+#define ISRIMR_DP_HOST_OK BIT_13
+#define ISRIMR_DP_REQSYS_OK BIT_11
+
+#define ISRIMR_DASH_INTR_EN BIT_12
+#define ISRIMR_DASH_INTR_CMAC_RESET BIT_15
+
+#define ISRIMR_DASH_TYPE2_ROK BIT_0
+#define ISRIMR_DASH_TYPE2_RDU BIT_1
+#define ISRIMR_DASH_TYPE2_TOK BIT_2
+#define ISRIMR_DASH_TYPE2_TDU BIT_3
+#define ISRIMR_DASH_TYPE2_TX_FIFO_FULL BIT_4
+#define ISRIMR_DASH_TYPE2_TX_DISABLE_IDLE BIT_5
+#define ISRIMR_DASH_TYPE2_RX_DISABLE_IDLE BIT_6
+
+#define CMAC_OOB_STOP 0x25
+#define CMAC_OOB_INIT 0x26
+#define CMAC_OOB_RESET 0x2a
+
+#define NO_BASE_ADDRESS 0x00000000
+#define RTL8168FP_OOBMAC_BASE 0xBAF70000
+#define RTL8168FP_CMAC_IOBASE 0xBAF20000
+#define RTL8168FP_KVM_BASE 0xBAF80400
+#define CMAC_SYNC_REG 0x20
+#define CMAC_RXDESC_OFFSET 0x90    //RX: 0x90 - 0x98
+#define CMAC_TXDESC_OFFSET 0x98    //TX: 0x98 - 0x9F
+
+/* cmac write/read MMIO register */
+#define RTL_CMAC_W8(tp, reg, val8)   writeb ((val8), tp->cmac_ioaddr + (reg))
+#define RTL_CMAC_W16(tp, reg, val16) writew ((val16), tp->cmac_ioaddr + (reg))
+#define RTL_CMAC_W32(tp, reg, val32) writel ((val32), tp->cmac_ioaddr + (reg))
+#define RTL_CMAC_R8(tp, reg)     readb (tp->cmac_ioaddr + (reg))
+#define RTL_CMAC_R16(tp, reg)        readw (tp->cmac_ioaddr + (reg))
+#define RTL_CMAC_R32(tp, reg)        ((unsigned long) readl (tp->cmac_ioaddr + (reg)))
+
+int rtl8125_dash_ioctl(struct net_device *dev, struct ifreq *ifr);
+void HandleDashInterrupt(struct net_device *dev);
+int AllocateDashShareMemory(struct net_device *dev);
+void FreeAllocatedDashShareMemory(struct net_device *dev);
+void DashHwInit(struct net_device *dev);
+
+
+#endif /* _LINUX_R8125_DASH_H */
Index: kernel-rockchip/drivers/net/ethernet/realtek/r8125/r8125_firmware.c
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/net/ethernet/realtek/r8125/r8125_firmware.c
@@ -0,0 +1,264 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+################################################################################
+#
+# r8168 is the Linux device driver released for Realtek Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2022 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#include <linux/version.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+
+#include "r8125_firmware.h"
+
+enum rtl_fw_opcode {
+        PHY_READ		= 0x0,
+        PHY_DATA_OR		= 0x1,
+        PHY_DATA_AND		= 0x2,
+        PHY_BJMPN		= 0x3,
+        PHY_MDIO_CHG		= 0x4,
+        PHY_CLEAR_READCOUNT	= 0x7,
+        PHY_WRITE		= 0x8,
+        PHY_READCOUNT_EQ_SKIP	= 0x9,
+        PHY_COMP_EQ_SKIPN	= 0xa,
+        PHY_COMP_NEQ_SKIPN	= 0xb,
+        PHY_WRITE_PREVIOUS	= 0xc,
+        PHY_SKIPN		= 0xd,
+        PHY_DELAY_MS		= 0xe,
+};
+
+struct fw_info {
+        u32	magic;
+        char	version[RTL8125_VER_SIZE];
+        __le32	fw_start;
+        __le32	fw_len;
+        u8	chksum;
+} __packed;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,16,0)
+#define sizeof_field(TYPE, MEMBER) sizeof((((TYPE *)0)->MEMBER))
+#endif
+#define FW_OPCODE_SIZE sizeof_field(struct rtl8125_fw_phy_action, code[0])
+
+static bool rtl8125_fw_format_ok(struct rtl8125_fw *rtl_fw)
+{
+        const struct firmware *fw = rtl_fw->fw;
+        struct fw_info *fw_info = (struct fw_info *)fw->data;
+        struct rtl8125_fw_phy_action *pa = &rtl_fw->phy_action;
+
+        if (fw->size < FW_OPCODE_SIZE)
+                return false;
+
+        if (!fw_info->magic) {
+                size_t i, size, start;
+                u8 checksum = 0;
+
+                if (fw->size < sizeof(*fw_info))
+                        return false;
+
+                for (i = 0; i < fw->size; i++)
+                        checksum += fw->data[i];
+                if (checksum != 0)
+                        return false;
+
+                start = le32_to_cpu(fw_info->fw_start);
+                if (start > fw->size)
+                        return false;
+
+                size = le32_to_cpu(fw_info->fw_len);
+                if (size > (fw->size - start) / FW_OPCODE_SIZE)
+                        return false;
+
+                strscpy(rtl_fw->version, fw_info->version, RTL8125_VER_SIZE);
+
+                pa->code = (__le32 *)(fw->data + start);
+                pa->size = size;
+        } else {
+                if (fw->size % FW_OPCODE_SIZE)
+                        return false;
+
+                strscpy(rtl_fw->version, rtl_fw->fw_name, RTL8125_VER_SIZE);
+
+                pa->code = (__le32 *)fw->data;
+                pa->size = fw->size / FW_OPCODE_SIZE;
+        }
+
+        return true;
+}
+
+static bool rtl8125_fw_data_ok(struct rtl8125_fw *rtl_fw)
+{
+        struct rtl8125_fw_phy_action *pa = &rtl_fw->phy_action;
+        size_t index;
+
+        for (index = 0; index < pa->size; index++) {
+                u32 action = le32_to_cpu(pa->code[index]);
+                u32 val = action & 0x0000ffff;
+                u32 regno = (action & 0x0fff0000) >> 16;
+
+                switch (action >> 28) {
+                case PHY_READ:
+                case PHY_DATA_OR:
+                case PHY_DATA_AND:
+                case PHY_CLEAR_READCOUNT:
+                case PHY_WRITE:
+                case PHY_WRITE_PREVIOUS:
+                case PHY_DELAY_MS:
+                        break;
+
+                case PHY_MDIO_CHG:
+                        if (val > 1)
+                                goto out;
+                        break;
+
+                case PHY_BJMPN:
+                        if (regno > index)
+                                goto out;
+                        break;
+                case PHY_READCOUNT_EQ_SKIP:
+                        if (index + 2 >= pa->size)
+                                goto out;
+                        break;
+                case PHY_COMP_EQ_SKIPN:
+                case PHY_COMP_NEQ_SKIPN:
+                case PHY_SKIPN:
+                        if (index + 1 + regno >= pa->size)
+                                goto out;
+                        break;
+
+                default:
+                        dev_err(rtl_fw->dev, "Invalid action 0x%08x\n", action);
+                        return false;
+                }
+        }
+
+        return true;
+out:
+        dev_err(rtl_fw->dev, "Out of range of firmware\n");
+        return false;
+}
+
+void rtl8125_fw_write_firmware(struct rtl8125_private *tp, struct rtl8125_fw *rtl_fw)
+{
+        struct rtl8125_fw_phy_action *pa = &rtl_fw->phy_action;
+        rtl8125_fw_write_t fw_write = rtl_fw->phy_write;
+        rtl8125_fw_read_t fw_read = rtl_fw->phy_read;
+        int predata = 0, count = 0;
+        size_t index;
+
+        for (index = 0; index < pa->size; index++) {
+                u32 action = le32_to_cpu(pa->code[index]);
+                u32 data = action & 0x0000ffff;
+                u32 regno = (action & 0x0fff0000) >> 16;
+                enum rtl_fw_opcode opcode = action >> 28;
+
+                if (!action)
+                        break;
+
+                switch (opcode) {
+                case PHY_READ:
+                        predata = fw_read(tp, regno);
+                        count++;
+                        break;
+                case PHY_DATA_OR:
+                        predata |= data;
+                        break;
+                case PHY_DATA_AND:
+                        predata &= data;
+                        break;
+                case PHY_BJMPN:
+                        index -= (regno + 1);
+                        break;
+                case PHY_MDIO_CHG:
+                        if (data) {
+                                fw_write = rtl_fw->mac_mcu_write;
+                                fw_read = rtl_fw->mac_mcu_read;
+                        } else {
+                                fw_write = rtl_fw->phy_write;
+                                fw_read = rtl_fw->phy_read;
+                        }
+
+                        break;
+                case PHY_CLEAR_READCOUNT:
+                        count = 0;
+                        break;
+                case PHY_WRITE:
+                        fw_write(tp, regno, data);
+                        break;
+                case PHY_READCOUNT_EQ_SKIP:
+                        if (count == data)
+                                index++;
+                        break;
+                case PHY_COMP_EQ_SKIPN:
+                        if (predata == data)
+                                index += regno;
+                        break;
+                case PHY_COMP_NEQ_SKIPN:
+                        if (predata != data)
+                                index += regno;
+                        break;
+                case PHY_WRITE_PREVIOUS:
+                        fw_write(tp, regno, predata);
+                        break;
+                case PHY_SKIPN:
+                        index += regno;
+                        break;
+                case PHY_DELAY_MS:
+                        mdelay(data);
+                        break;
+                }
+        }
+}
+
+void rtl8125_fw_release_firmware(struct rtl8125_fw *rtl_fw)
+{
+        release_firmware(rtl_fw->fw);
+}
+
+int rtl8125_fw_request_firmware(struct rtl8125_fw *rtl_fw)
+{
+        int rc;
+
+        rc = request_firmware(&rtl_fw->fw, rtl_fw->fw_name, rtl_fw->dev);
+        if (rc < 0)
+                goto out;
+
+        if (!rtl8125_fw_format_ok(rtl_fw) || !rtl8125_fw_data_ok(rtl_fw)) {
+                release_firmware(rtl_fw->fw);
+                rc = -EINVAL;
+                goto out;
+        }
+
+        return 0;
+out:
+        dev_err(rtl_fw->dev, "Unable to load firmware %s (%d)\n",
+                rtl_fw->fw_name, rc);
+        return rc;
+}
Index: kernel-rockchip/drivers/net/ethernet/realtek/r8125/r8125_firmware.h
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/net/ethernet/realtek/r8125/r8125_firmware.h
@@ -0,0 +1,68 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2022 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_rtl8125_FIRMWARE_H
+#define _LINUX_rtl8125_FIRMWARE_H
+
+#include <linux/device.h>
+#include <linux/firmware.h>
+
+struct rtl8125_private;
+typedef void (*rtl8125_fw_write_t)(struct rtl8125_private *tp, u16 reg, u16 val);
+typedef u32 (*rtl8125_fw_read_t)(struct rtl8125_private *tp, u16 reg);
+
+#define RTL8125_VER_SIZE		32
+
+struct rtl8125_fw {
+        rtl8125_fw_write_t phy_write;
+        rtl8125_fw_read_t phy_read;
+        rtl8125_fw_write_t mac_mcu_write;
+        rtl8125_fw_read_t mac_mcu_read;
+        const struct firmware *fw;
+        const char *fw_name;
+        struct device *dev;
+
+        char version[RTL8125_VER_SIZE];
+
+        struct rtl8125_fw_phy_action {
+                __le32 *code;
+                size_t size;
+        } phy_action;
+};
+
+int rtl8125_fw_request_firmware(struct rtl8125_fw *rtl_fw);
+void rtl8125_fw_release_firmware(struct rtl8125_fw *rtl_fw);
+void rtl8125_fw_write_firmware(struct rtl8125_private *tp, struct rtl8125_fw *rtl_fw);
+
+#endif /* _LINUX_rtl8125_FIRMWARE_H */
Index: kernel-rockchip/drivers/net/ethernet/realtek/r8125/r8125_n.c
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/net/ethernet/realtek/r8125/r8125_n.c
@@ -0,0 +1,15801 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2022 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+/*
+ * This driver is modified from r8169.c in Linux kernel 2.6.18
+ */
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/delay.h>
+#include <linux/mii.h>
+#include <linux/if_vlan.h>
+#include <linux/crc32.h>
+#include <linux/interrupt.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+#include <linux/ipv6.h>
+#include <net/ip6_checksum.h>
+#endif
+#include <linux/tcp.h>
+#include <linux/init.h>
+#include <linux/rtnetlink.h>
+#include <linux/completion.h>
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0)
+#include <linux/pci-aspm.h>
+#endif
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,37)
+#include <linux/prefetch.h>
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#define dev_printk(A,B,fmt,args...) printk(A fmt,##args)
+#else
+#include <linux/dma-mapping.h>
+#include <linux/moduleparam.h>
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)
+#include <linux/mdio.h>
+#endif
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include "r8125.h"
+#include "rtl_eeprom.h"
+#include "rtltool.h"
+#include "r8125_firmware.h"
+
+#ifdef ENABLE_R8125_PROCFS
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#endif
+
+#define FIRMWARE_8125A_3	"rtl_nic/rtl8125a-3.fw"
+#define FIRMWARE_8125B_2	"rtl_nic/rtl8125b-2.fw"
+
+/* Maximum number of multicast addresses to filter (vs. Rx-all-multicast).
+   The RTL chips use a 64 element hash table based on the Ethernet CRC. */
+static const int multicast_filter_limit = 32;
+
+static const struct {
+        const char *name;
+        const char *fw_name;
+} rtl_chip_fw_infos[] = {
+        /* PCI-E devices. */
+        [CFG_METHOD_2] = {"RTL8125A"				},
+        [CFG_METHOD_3] = {"RTL8125A",		FIRMWARE_8125A_3},
+        [CFG_METHOD_4] = {"RTL8125B",                       },
+        [CFG_METHOD_5] = {"RTL8125B",		FIRMWARE_8125B_2},
+        [CFG_METHOD_6] = {"RTL8168KB",		FIRMWARE_8125A_3},
+        [CFG_METHOD_7] = {"RTL8168KB",		FIRMWARE_8125B_2},
+        [CFG_METHOD_DEFAULT] = {"Unknown",                  },
+};
+
+#define _R(NAME,MAC,RCR,MASK,JumFrameSz) \
+    { .name = NAME, .mcfg = MAC, .RCR_Cfg = RCR, .RxConfigMask = MASK, .jumbo_frame_sz = JumFrameSz }
+
+static const struct {
+        const char *name;
+        u8 mcfg;
+        u32 RCR_Cfg;
+        u32 RxConfigMask;   /* Clears the bits supported by this chip */
+        u32 jumbo_frame_sz;
+} rtl_chip_info[] = {
+        _R("RTL8125A",
+        CFG_METHOD_2,
+        BIT_30 | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("RTL8125A",
+        CFG_METHOD_3,
+        BIT_30 | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("RTL8125B",
+        CFG_METHOD_4,
+        BIT_30 | RxCfg_pause_slot_en | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("RTL8125B",
+        CFG_METHOD_5,
+        BIT_30 | RxCfg_pause_slot_en | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("RTL8168KB",
+        CFG_METHOD_6,
+        BIT_30 | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("RTL8168KB",
+        CFG_METHOD_7,
+        BIT_30 | RxCfg_pause_slot_en | EnableInnerVlan | EnableOuterVlan | (RX_DMA_BURST << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_9k),
+
+        _R("Unknown",
+        CFG_METHOD_DEFAULT,
+        (RX_DMA_BURST << RxCfgDMAShift),
+        0xff7e5880,
+        Jumbo_Frame_1k)
+};
+#undef _R
+
+
+#ifndef PCI_VENDOR_ID_DLINK
+#define PCI_VENDOR_ID_DLINK 0x1186
+#endif
+
+static struct pci_device_id rtl8125_pci_tbl[] = {
+        { PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x8125), },
+        { PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x8162), },
+        { PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x3000), },
+        {0,},
+};
+
+MODULE_DEVICE_TABLE(pci, rtl8125_pci_tbl);
+
+static int rx_copybreak = 0;
+static int use_dac = 1;
+static int timer_count = 0x2600;
+static int timer_count_v2 = (0x2600 / 0x100);
+
+static struct {
+        u32 msg_enable;
+} debug = { -1 };
+
+static unsigned int speed_mode = SPEED_2500;
+static unsigned int duplex_mode = DUPLEX_FULL;
+static unsigned int autoneg_mode = AUTONEG_ENABLE;
+static unsigned int advertising_mode =  ADVERTISED_10baseT_Half |
+                                        ADVERTISED_10baseT_Full |
+                                        ADVERTISED_100baseT_Half |
+                                        ADVERTISED_100baseT_Full |
+                                        ADVERTISED_1000baseT_Half |
+                                        ADVERTISED_1000baseT_Full |
+                                        ADVERTISED_2500baseX_Full;
+#ifdef CONFIG_ASPM
+static int aspm = 1;
+#else
+static int aspm = 0;
+#endif
+#ifdef ENABLE_S5WOL
+static int s5wol = 1;
+#else
+static int s5wol = 0;
+#endif
+#ifdef ENABLE_S5_KEEP_CURR_MAC
+static int s5_keep_curr_mac = 1;
+#else
+static int s5_keep_curr_mac = 0;
+#endif
+#ifdef ENABLE_EEE
+static int eee_enable = 1;
+#else
+static int eee_enable = 0;
+#endif
+#ifdef CONFIG_SOC_LAN
+static ulong hwoptimize = HW_PATCH_SOC_LAN;
+#else
+static ulong hwoptimize = 0;
+#endif
+#ifdef ENABLE_S0_MAGIC_PACKET
+static int s0_magic_packet = 1;
+#else
+static int s0_magic_packet = 0;
+#endif
+#ifdef ENABLE_TX_NO_CLOSE
+static int tx_no_close_enable = 1;
+#else
+static int tx_no_close_enable = 0;
+#endif
+#ifdef ENABLE_PTP_MASTER_MODE
+static int enable_ptp_master_mode = 1;
+#else
+static int enable_ptp_master_mode = 0;
+#endif
+#ifdef DISABLE_PM_SUPPORT
+static int disable_pm_support = 1;
+#else
+static int disable_pm_support = 0;
+#endif
+
+MODULE_AUTHOR("Realtek and the Linux r8125 crew <netdev@vger.kernel.org>");
+MODULE_DESCRIPTION("Realtek RTL8125 2.5Gigabit Ethernet driver");
+
+module_param(speed_mode, uint, 0);
+MODULE_PARM_DESC(speed_mode, "force phy operation. Deprecated by ethtool (8).");
+
+module_param(duplex_mode, uint, 0);
+MODULE_PARM_DESC(duplex_mode, "force phy operation. Deprecated by ethtool (8).");
+
+module_param(autoneg_mode, uint, 0);
+MODULE_PARM_DESC(autoneg_mode, "force phy operation. Deprecated by ethtool (8).");
+
+module_param(advertising_mode, uint, 0);
+MODULE_PARM_DESC(advertising_mode, "force phy operation. Deprecated by ethtool (8).");
+
+module_param(aspm, int, 0);
+MODULE_PARM_DESC(aspm, "Enable ASPM.");
+
+module_param(s5wol, int, 0);
+MODULE_PARM_DESC(s5wol, "Enable Shutdown Wake On Lan.");
+
+module_param(s5_keep_curr_mac, int, 0);
+MODULE_PARM_DESC(s5_keep_curr_mac, "Enable Shutdown Keep Current MAC Address.");
+
+module_param(rx_copybreak, int, 0);
+MODULE_PARM_DESC(rx_copybreak, "Copy breakpoint for copy-only-tiny-frames");
+
+module_param(use_dac, int, 0);
+MODULE_PARM_DESC(use_dac, "Enable PCI DAC. Unsafe on 32 bit PCI slot.");
+
+module_param(timer_count, int, 0);
+MODULE_PARM_DESC(timer_count, "Timer Interrupt Interval.");
+
+module_param(eee_enable, int, 0);
+MODULE_PARM_DESC(eee_enable, "Enable Energy Efficient Ethernet.");
+
+module_param(hwoptimize, ulong, 0);
+MODULE_PARM_DESC(hwoptimize, "Enable HW optimization function.");
+
+module_param(s0_magic_packet, int, 0);
+MODULE_PARM_DESC(s0_magic_packet, "Enable S0 Magic Packet.");
+
+module_param(tx_no_close_enable, int, 0);
+MODULE_PARM_DESC(tx_no_close_enable, "Enable TX No Close.");
+
+module_param(enable_ptp_master_mode, int, 0);
+MODULE_PARM_DESC(enable_ptp_master_mode, "Enable PTP Master Mode.");
+
+module_param(disable_pm_support, int, 0);
+MODULE_PARM_DESC(disable_pm_support, "Disable PM support.");
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+module_param_named(debug, debug.msg_enable, int, 0);
+MODULE_PARM_DESC(debug, "Debug verbosity level (0=none, ..., 16=all)");
+#endif//LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+
+MODULE_LICENSE("GPL");
+#ifdef ENABLE_USE_FIRMWARE_FILE
+MODULE_FIRMWARE(FIRMWARE_8125A_3);
+MODULE_FIRMWARE(FIRMWARE_8125B_2);
+#endif
+
+MODULE_VERSION(RTL8125_VERSION);
+
+/*
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+static void rtl8125_esd_timer(unsigned long __opaque);
+#else
+static void rtl8125_esd_timer(struct timer_list *t);
+#endif
+*/
+/*
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+static void rtl8125_link_timer(unsigned long __opaque);
+#else
+static void rtl8125_link_timer(struct timer_list *t);
+#endif
+*/
+
+static netdev_tx_t rtl8125_start_xmit(struct sk_buff *skb, struct net_device *dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static irqreturn_t rtl8125_interrupt(int irq, void *dev_instance, struct pt_regs *regs);
+#else
+static irqreturn_t rtl8125_interrupt(int irq, void *dev_instance);
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static irqreturn_t rtl8125_interrupt_msix(int irq, void *dev_instance, struct pt_regs *regs);
+#else
+static irqreturn_t rtl8125_interrupt_msix(int irq, void *dev_instance);
+#endif
+static void rtl8125_set_rx_mode(struct net_device *dev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0)
+static void rtl8125_tx_timeout(struct net_device *dev, unsigned int txqueue);
+#else
+static void rtl8125_tx_timeout(struct net_device *dev);
+#endif
+static struct net_device_stats *rtl8125_get_stats(struct net_device *dev);
+static int rtl8125_rx_interrupt(struct net_device *, struct rtl8125_private *, struct rtl8125_rx_ring *, napi_budget);
+static int rtl8125_tx_interrupt(struct rtl8125_tx_ring *ring, int budget);
+static int rtl8125_tx_interrupt_with_vector(struct rtl8125_private *tp, const int message_id, int budget);
+static void rtl8125_wait_for_quiescence(struct net_device *dev);
+static int rtl8125_change_mtu(struct net_device *dev, int new_mtu);
+static void rtl8125_down(struct net_device *dev);
+
+static int rtl8125_set_mac_address(struct net_device *dev, void *p);
+static void rtl8125_rar_set(struct rtl8125_private *tp, const u8 *addr);
+static void rtl8125_desc_addr_fill(struct rtl8125_private *);
+static void rtl8125_tx_desc_init(struct rtl8125_private *tp);
+static void rtl8125_rx_desc_init(struct rtl8125_private *tp);
+
+static u32 mdio_direct_read_phy_ocp(struct rtl8125_private *tp, u16 RegAddr);
+static u16 rtl8125_get_hw_phy_mcu_code_ver(struct rtl8125_private *tp);
+static void rtl8125_phy_power_up(struct net_device *dev);
+static void rtl8125_phy_power_down(struct net_device *dev);
+static int rtl8125_set_speed(struct net_device *dev, u8 autoneg, u32 speed, u8 duplex, u32 adv);
+static bool rtl8125_set_phy_mcu_patch_request(struct rtl8125_private *tp);
+static bool rtl8125_clear_phy_mcu_patch_request(struct rtl8125_private *tp);
+
+#ifdef CONFIG_R8125_NAPI
+static int rtl8125_poll(napi_ptr napi, napi_budget budget);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+static void rtl8125_reset_task(void *_data);
+static void rtl8125_esd_task(void *_data);
+static void rtl8125_linkchg_task(void *_data);
+#else
+static void rtl8125_reset_task(struct work_struct *work);
+static void rtl8125_esd_task(struct work_struct *work);
+static void rtl8125_linkchg_task(struct work_struct *work);
+#endif
+static void rtl8125_schedule_reset_work(struct rtl8125_private *tp);
+static void rtl8125_schedule_esd_work(struct rtl8125_private *tp);
+static void rtl8125_schedule_linkchg_work(struct rtl8125_private *tp);
+static void rtl8125_init_all_schedule_work(struct rtl8125_private *tp);
+static void rtl8125_cancel_all_schedule_work(struct rtl8125_private *tp);
+
+static inline struct device *tp_to_dev(struct rtl8125_private *tp)
+{
+        return &tp->pci_dev->dev;
+}
+
+#if ((LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0) && \
+     LINUX_VERSION_CODE >= KERNEL_VERSION(4,6,00)))
+void ethtool_convert_legacy_u32_to_link_mode(unsigned long *dst,
+                u32 legacy_u32)
+{
+        bitmap_zero(dst, __ETHTOOL_LINK_MODE_MASK_NBITS);
+        dst[0] = legacy_u32;
+}
+
+bool ethtool_convert_link_mode_to_legacy_u32(u32 *legacy_u32,
+                const unsigned long *src)
+{
+        bool retval = true;
+
+        /* TODO: following test will soon always be true */
+        if (__ETHTOOL_LINK_MODE_MASK_NBITS > 32) {
+                __ETHTOOL_DECLARE_LINK_MODE_MASK(ext);
+
+                bitmap_zero(ext, __ETHTOOL_LINK_MODE_MASK_NBITS);
+                bitmap_fill(ext, 32);
+                bitmap_complement(ext, ext, __ETHTOOL_LINK_MODE_MASK_NBITS);
+                if (bitmap_intersects(ext, src,
+                                      __ETHTOOL_LINK_MODE_MASK_NBITS)) {
+                        /* src mask goes beyond bit 31 */
+                        retval = false;
+                }
+        }
+        *legacy_u32 = src[0];
+        return retval;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+
+#ifndef LPA_1000FULL
+#define LPA_1000FULL            0x0800
+#endif
+
+#ifndef LPA_1000HALF
+#define LPA_1000HALF            0x0400
+#endif
+
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)
+static inline void eth_hw_addr_random(struct net_device *dev)
+{
+        random_ether_addr(dev->dev_addr);
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#undef ethtool_ops
+#define ethtool_ops _kc_ethtool_ops
+
+struct _kc_ethtool_ops {
+        int  (*get_settings)(struct net_device *, struct ethtool_cmd *);
+        int  (*set_settings)(struct net_device *, struct ethtool_cmd *);
+        void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *);
+        int  (*get_regs_len)(struct net_device *);
+        void (*get_regs)(struct net_device *, struct ethtool_regs *, void *);
+        void (*get_wol)(struct net_device *, struct ethtool_wolinfo *);
+        int  (*set_wol)(struct net_device *, struct ethtool_wolinfo *);
+        u32  (*get_msglevel)(struct net_device *);
+        void (*set_msglevel)(struct net_device *, u32);
+        int  (*nway_reset)(struct net_device *);
+        u32  (*get_link)(struct net_device *);
+        int  (*get_eeprom_len)(struct net_device *);
+        int  (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
+        int  (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
+        int  (*get_coalesce)(struct net_device *, struct ethtool_coalesce *);
+        int  (*set_coalesce)(struct net_device *, struct ethtool_coalesce *);
+        void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *);
+        int  (*set_ringparam)(struct net_device *, struct ethtool_ringparam *);
+        void (*get_pauseparam)(struct net_device *,
+                               struct ethtool_pauseparam*);
+        int  (*set_pauseparam)(struct net_device *,
+                               struct ethtool_pauseparam*);
+        u32  (*get_rx_csum)(struct net_device *);
+        int  (*set_rx_csum)(struct net_device *, u32);
+        u32  (*get_tx_csum)(struct net_device *);
+        int  (*set_tx_csum)(struct net_device *, u32);
+        u32  (*get_sg)(struct net_device *);
+        int  (*set_sg)(struct net_device *, u32);
+        u32  (*get_tso)(struct net_device *);
+        int  (*set_tso)(struct net_device *, u32);
+        int  (*self_test_count)(struct net_device *);
+        void (*self_test)(struct net_device *, struct ethtool_test *, u64 *);
+        void (*get_strings)(struct net_device *, u32 stringset, u8 *);
+        int  (*phys_id)(struct net_device *, u32);
+        int  (*get_stats_count)(struct net_device *);
+        void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *,
+                                  u64 *);
+} *ethtool_ops = NULL;
+
+#undef SET_ETHTOOL_OPS
+#define SET_ETHTOOL_OPS(netdev, ops) (ethtool_ops = (ops))
+
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,16,0)
+#ifndef SET_ETHTOOL_OPS
+#define SET_ETHTOOL_OPS(netdev,ops) \
+         ( (netdev)->ethtool_ops = (ops) )
+#endif //SET_ETHTOOL_OPS
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(3,16,0)
+
+//#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,5)
+#ifndef netif_msg_init
+#define netif_msg_init _kc_netif_msg_init
+/* copied from linux kernel 2.6.20 include/linux/netdevice.h */
+static inline u32 netif_msg_init(int debug_value, int default_msg_enable_bits)
+{
+        /* use default */
+        if (debug_value < 0 || debug_value >= (sizeof(u32) * 8))
+                return default_msg_enable_bits;
+        if (debug_value == 0)   /* no output */
+                return 0;
+        /* set low N bits */
+        return (1 << debug_value) - 1;
+}
+
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,5)
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22)
+static inline void eth_copy_and_sum (struct sk_buff *dest,
+                                     const unsigned char *src,
+                                     int len, int base)
+{
+        memcpy (dest->data, src, len);
+}
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7)
+/* copied from linux kernel 2.6.20 /include/linux/time.h */
+/* Parameters used to convert the timespec values: */
+#define MSEC_PER_SEC    1000L
+
+/* copied from linux kernel 2.6.20 /include/linux/jiffies.h */
+/*
+ * Change timeval to jiffies, trying to avoid the
+ * most obvious overflows..
+ *
+ * And some not so obvious.
+ *
+ * Note that we don't want to return MAX_LONG, because
+ * for various timeout reasons we often end up having
+ * to wait "jiffies+1" in order to guarantee that we wait
+ * at _least_ "jiffies" - so "jiffies+1" had better still
+ * be positive.
+ */
+#define MAX_JIFFY_OFFSET ((~0UL >> 1)-1)
+
+/*
+ * Convert jiffies to milliseconds and back.
+ *
+ * Avoid unnecessary multiplications/divisions in the
+ * two most common HZ cases:
+ */
+static inline unsigned int _kc_jiffies_to_msecs(const unsigned long j)
+{
+#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)
+        return (MSEC_PER_SEC / HZ) * j;
+#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)
+        return (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);
+#else
+        return (j * MSEC_PER_SEC) / HZ;
+#endif
+}
+
+static inline unsigned long _kc_msecs_to_jiffies(const unsigned int m)
+{
+        if (m > _kc_jiffies_to_msecs(MAX_JIFFY_OFFSET))
+                return MAX_JIFFY_OFFSET;
+#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)
+        return (m + (MSEC_PER_SEC / HZ) - 1) / (MSEC_PER_SEC / HZ);
+#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)
+        return m * (HZ / MSEC_PER_SEC);
+#else
+        return (m * HZ + MSEC_PER_SEC - 1) / MSEC_PER_SEC;
+#endif
+}
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7)
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+
+/* copied from linux kernel 2.6.12.6 /include/linux/pm.h */
+typedef int __bitwise pci_power_t;
+
+/* copied from linux kernel 2.6.12.6 /include/linux/pci.h */
+typedef u32 __bitwise pm_message_t;
+
+#define PCI_D0  ((pci_power_t __force) 0)
+#define PCI_D1  ((pci_power_t __force) 1)
+#define PCI_D2  ((pci_power_t __force) 2)
+#define PCI_D3hot   ((pci_power_t __force) 3)
+#define PCI_D3cold  ((pci_power_t __force) 4)
+#define PCI_POWER_ERROR ((pci_power_t __force) -1)
+
+/* copied from linux kernel 2.6.12.6 /drivers/pci/pci.c */
+/**
+ * pci_choose_state - Choose the power state of a PCI device
+ * @dev: PCI device to be suspended
+ * @state: target sleep state for the whole system. This is the value
+ *  that is passed to suspend() function.
+ *
+ * Returns PCI power state suitable for given device and given system
+ * message.
+ */
+
+pci_power_t pci_choose_state(struct pci_dev *dev, pm_message_t state)
+{
+        if (!pci_find_capability(dev, PCI_CAP_ID_PM))
+                return PCI_D0;
+
+        switch (state) {
+        case 0:
+                return PCI_D0;
+        case 3:
+                return PCI_D3hot;
+        default:
+                printk("They asked me for state %d\n", state);
+//      BUG();
+        }
+        return PCI_D0;
+}
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+/**
+ * msleep_interruptible - sleep waiting for waitqueue interruptions
+ * @msecs: Time in milliseconds to sleep for
+ */
+#define msleep_interruptible _kc_msleep_interruptible
+unsigned long _kc_msleep_interruptible(unsigned int msecs)
+{
+        unsigned long timeout = _kc_msecs_to_jiffies(msecs);
+
+        while (timeout && !signal_pending(current)) {
+                set_current_state(TASK_INTERRUPTIBLE);
+                timeout = schedule_timeout(timeout);
+        }
+        return _kc_jiffies_to_msecs(timeout);
+}
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7)
+/* copied from linux kernel 2.6.20 include/linux/sched.h */
+#ifndef __sched
+#define __sched     __attribute__((__section__(".sched.text")))
+#endif
+
+/* copied from linux kernel 2.6.20 kernel/timer.c */
+signed long __sched schedule_timeout_uninterruptible(signed long timeout)
+{
+        __set_current_state(TASK_UNINTERRUPTIBLE);
+        return schedule_timeout(timeout);
+}
+
+/* copied from linux kernel 2.6.20 include/linux/mii.h */
+#undef if_mii
+#define if_mii _kc_if_mii
+static inline struct mii_ioctl_data *if_mii(struct ifreq *rq)
+{
+        return (struct mii_ioctl_data *) &rq->ifr_ifru;
+}
+#endif  //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7)
+
+static u32 rtl8125_read_thermal_sensor(struct rtl8125_private *tp)
+{
+        u16 ts_digout;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                ts_digout = mdio_direct_read_phy_ocp(tp, 0xBD84);
+                ts_digout &= 0x3ff;
+                break;
+        default:
+                ts_digout = 0xffff;
+                break;
+        }
+
+        return ts_digout;
+}
+
+int rtl8125_dump_tally_counter(struct rtl8125_private *tp, dma_addr_t paddr)
+{
+        u32 cmd;
+        u32 WaitCnt;
+        int retval = -1;
+
+        RTL_W32(tp, CounterAddrHigh, (u64)paddr >> 32);
+        cmd = (u64)paddr & DMA_BIT_MASK(32);
+        RTL_W32(tp, CounterAddrLow, cmd);
+        RTL_W32(tp, CounterAddrLow, cmd | CounterDump);
+
+        WaitCnt = 0;
+        while (RTL_R32(tp, CounterAddrLow) & CounterDump) {
+                udelay(10);
+
+                WaitCnt++;
+                if (WaitCnt > 20)
+                        break;
+        }
+
+        if (WaitCnt <= 20)
+                retval = 0;
+
+        return retval;
+}
+
+#ifdef ENABLE_R8125_PROCFS
+/****************************************************************************
+*   -----------------------------PROCFS STUFF-------------------------
+*****************************************************************************
+*/
+
+static struct proc_dir_entry *rtl8125_proc;
+static int proc_init_num = 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+static int proc_get_driver_variable(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        seq_puts(m, "\nDump Driver Variable\n");
+
+        rtnl_lock();
+
+        seq_puts(m, "Variable\tValue\n----------\t-----\n");
+        seq_printf(m, "MODULENAME\t%s\n", MODULENAME);
+        seq_printf(m, "driver version\t%s\n", RTL8125_VERSION);
+        seq_printf(m, "mcfg\t%d\n", tp->mcfg);
+        seq_printf(m, "chipset\t%d\n", tp->chipset);
+        seq_printf(m, "chipset_name\t%s\n", rtl_chip_info[tp->chipset].name);
+        seq_printf(m, "mtu\t%d\n", dev->mtu);
+        seq_printf(m, "NUM_RX_DESC\t0x%x\n", tp->rx_ring[0].num_rx_desc);
+        seq_printf(m, "cur_rx0\t0x%x\n", tp->rx_ring[0].cur_rx);
+        seq_printf(m, "dirty_rx0\t0x%x\n", tp->rx_ring[0].dirty_rx);
+        seq_printf(m, "cur_rx1\t0x%x\n", tp->rx_ring[1].cur_rx);
+        seq_printf(m, "dirty_rx1\t0x%x\n", tp->rx_ring[1].dirty_rx);
+        seq_printf(m, "cur_rx2\t0x%x\n", tp->rx_ring[2].cur_rx);
+        seq_printf(m, "dirty_rx2\t0x%x\n", tp->rx_ring[2].dirty_rx);
+        seq_printf(m, "cur_rx3\t0x%x\n", tp->rx_ring[3].cur_rx);
+        seq_printf(m, "dirty_rx3\t0x%x\n", tp->rx_ring[3].dirty_rx);
+        seq_printf(m, "NUM_TX_DESC\t0x%x\n", tp->tx_ring[0].num_tx_desc);
+        seq_printf(m, "cur_tx0\t0x%x\n", tp->tx_ring[0].cur_tx);
+        seq_printf(m, "dirty_tx0\t0x%x\n", tp->tx_ring[0].dirty_tx);
+        seq_printf(m, "cur_tx1\t0x%x\n", tp->tx_ring[1].cur_tx);
+        seq_printf(m, "dirty_tx1\t0x%x\n", tp->tx_ring[1].dirty_tx);
+        seq_printf(m, "rx_buf_sz\t0x%x\n", tp->rx_buf_sz);
+        seq_printf(m, "esd_flag\t0x%x\n", tp->esd_flag);
+        seq_printf(m, "pci_cfg_is_read\t0x%x\n", tp->pci_cfg_is_read);
+        seq_printf(m, "rtl8125_rx_config\t0x%x\n", tp->rtl8125_rx_config);
+        seq_printf(m, "cp_cmd\t0x%x\n", tp->cp_cmd);
+        seq_printf(m, "intr_mask\t0x%x\n", tp->intr_mask);
+        seq_printf(m, "timer_intr_mask\t0x%x\n", tp->timer_intr_mask);
+        seq_printf(m, "wol_enabled\t0x%x\n", tp->wol_enabled);
+        seq_printf(m, "wol_opts\t0x%x\n", tp->wol_opts);
+        seq_printf(m, "efuse_ver\t0x%x\n", tp->efuse_ver);
+        seq_printf(m, "eeprom_type\t0x%x\n", tp->eeprom_type);
+        seq_printf(m, "autoneg\t0x%x\n", tp->autoneg);
+        seq_printf(m, "duplex\t0x%x\n", tp->duplex);
+        seq_printf(m, "speed\t%d\n", tp->speed);
+        seq_printf(m, "advertising\t0x%x\n", tp->advertising);
+        seq_printf(m, "eeprom_len\t0x%x\n", tp->eeprom_len);
+        seq_printf(m, "cur_page\t0x%x\n", tp->cur_page);
+        seq_printf(m, "bios_setting\t0x%x\n", tp->bios_setting);
+        seq_printf(m, "features\t0x%x\n", tp->features);
+        seq_printf(m, "org_pci_offset_99\t0x%x\n", tp->org_pci_offset_99);
+        seq_printf(m, "org_pci_offset_180\t0x%x\n", tp->org_pci_offset_180);
+        seq_printf(m, "issue_offset_99_event\t0x%x\n", tp->issue_offset_99_event);
+        seq_printf(m, "org_pci_offset_80\t0x%x\n", tp->org_pci_offset_80);
+        seq_printf(m, "org_pci_offset_81\t0x%x\n", tp->org_pci_offset_81);
+        seq_printf(m, "use_timer_interrrupt\t0x%x\n", tp->use_timer_interrrupt);
+        seq_printf(m, "HwIcVerUnknown\t0x%x\n", tp->HwIcVerUnknown);
+        seq_printf(m, "NotWrRamCodeToMicroP\t0x%x\n", tp->NotWrRamCodeToMicroP);
+        seq_printf(m, "NotWrMcuPatchCode\t0x%x\n", tp->NotWrMcuPatchCode);
+        seq_printf(m, "HwHasWrRamCodeToMicroP\t0x%x\n", tp->HwHasWrRamCodeToMicroP);
+        seq_printf(m, "sw_ram_code_ver\t0x%x\n", tp->sw_ram_code_ver);
+        seq_printf(m, "hw_ram_code_ver\t0x%x\n", tp->hw_ram_code_ver);
+        seq_printf(m, "rtk_enable_diag\t0x%x\n", tp->rtk_enable_diag);
+        seq_printf(m, "ShortPacketSwChecksum\t0x%x\n", tp->ShortPacketSwChecksum);
+        seq_printf(m, "UseSwPaddingShortPkt\t0x%x\n", tp->UseSwPaddingShortPkt);
+        seq_printf(m, "RequireRduNonStopPatch\t0x%x\n", tp->RequireRduNonStopPatch);
+        seq_printf(m, "RequireAdcBiasPatch\t0x%x\n", tp->RequireAdcBiasPatch);
+        seq_printf(m, "AdcBiasPatchIoffset\t0x%x\n", tp->AdcBiasPatchIoffset);
+        seq_printf(m, "RequireAdjustUpsTxLinkPulseTiming\t0x%x\n", tp->RequireAdjustUpsTxLinkPulseTiming);
+        seq_printf(m, "SwrCnt1msIni\t0x%x\n", tp->SwrCnt1msIni);
+        seq_printf(m, "HwSuppNowIsOobVer\t0x%x\n", tp->HwSuppNowIsOobVer);
+        seq_printf(m, "HwFiberModeVer\t0x%x\n", tp->HwFiberModeVer);
+        seq_printf(m, "HwFiberStat\t0x%x\n", tp->HwFiberStat);
+        seq_printf(m, "HwSwitchMdiToFiber\t0x%x\n", tp->HwSwitchMdiToFiber);
+        seq_printf(m, "NicCustLedValue\t0x%x\n", tp->NicCustLedValue);
+        seq_printf(m, "RequiredSecLanDonglePatch\t0x%x\n", tp->RequiredSecLanDonglePatch);
+        seq_printf(m, "HwSuppDashVer\t0x%x\n", tp->HwSuppDashVer);
+        seq_printf(m, "DASH\t0x%x\n", tp->DASH);
+        seq_printf(m, "dash_printer_enabled\t0x%x\n", tp->dash_printer_enabled);
+        seq_printf(m, "HwSuppKCPOffloadVer\t0x%x\n", tp->HwSuppKCPOffloadVer);
+        seq_printf(m, "speed_mode\t0x%x\n", speed_mode);
+        seq_printf(m, "duplex_mode\t0x%x\n", duplex_mode);
+        seq_printf(m, "autoneg_mode\t0x%x\n", autoneg_mode);
+        seq_printf(m, "advertising_mode\t0x%x\n", advertising_mode);
+        seq_printf(m, "aspm\t0x%x\n", aspm);
+        seq_printf(m, "s5wol\t0x%x\n", s5wol);
+        seq_printf(m, "s5_keep_curr_mac\t0x%x\n", s5_keep_curr_mac);
+        seq_printf(m, "eee_enable\t0x%x\n", tp->eee.eee_enabled);
+        seq_printf(m, "hwoptimize\t0x%lx\n", hwoptimize);
+        seq_printf(m, "proc_init_num\t0x%x\n", proc_init_num);
+        seq_printf(m, "s0_magic_packet\t0x%x\n", s0_magic_packet);
+        seq_printf(m, "HwSuppMagicPktVer\t0x%x\n", tp->HwSuppMagicPktVer);
+        seq_printf(m, "HwSuppLinkChgWakeUpVer\t0x%x\n", tp->HwSuppLinkChgWakeUpVer);
+        seq_printf(m, "HwSuppD0SpeedUpVer\t0x%x\n", tp->HwSuppD0SpeedUpVer);
+        seq_printf(m, "D0SpeedUpSpeed\t0x%x\n", tp->D0SpeedUpSpeed);
+        seq_printf(m, "HwSuppCheckPhyDisableModeVer\t0x%x\n", tp->HwSuppCheckPhyDisableModeVer);
+        seq_printf(m, "HwPkgDet\t0x%x\n", tp->HwPkgDet);
+        seq_printf(m, "HwSuppTxNoCloseVer\t0x%x\n", tp->HwSuppTxNoCloseVer);
+        seq_printf(m, "EnableTxNoClose\t0x%x\n", tp->EnableTxNoClose);
+        seq_printf(m, "NextHwDesCloPtr0\t0x%x\n", tp->tx_ring[0].NextHwDesCloPtr);
+        seq_printf(m, "BeginHwDesCloPtr0\t0x%x\n", tp->tx_ring[0].BeginHwDesCloPtr);
+        seq_printf(m, "NextHwDesCloPtr1\t0x%x\n", tp->tx_ring[1].NextHwDesCloPtr);
+        seq_printf(m, "BeginHwDesCloPtr1\t0x%x\n", tp->tx_ring[1].BeginHwDesCloPtr);
+        seq_printf(m, "InitRxDescType\t0x%x\n", tp->InitRxDescType);
+        seq_printf(m, "RxDescLength\t0x%x\n", tp->RxDescLength);
+        seq_printf(m, "num_rx_rings\t0x%x\n", tp->num_rx_rings);
+        seq_printf(m, "num_tx_rings\t0x%x\n", tp->num_tx_rings);
+        seq_printf(m, "tot_rx_rings\t0x%x\n", rtl8125_tot_rx_rings(tp));
+        seq_printf(m, "tot_tx_rings\t0x%x\n", rtl8125_tot_tx_rings(tp));
+        seq_printf(m, "EnableRss\t0x%x\n", tp->EnableRss);
+        seq_printf(m, "EnablePtp\t0x%x\n", tp->EnablePtp);
+        seq_printf(m, "ptp_master_mode\t0x%x\n", tp->ptp_master_mode);
+        seq_printf(m, "min_irq_nvecs\t0x%x\n", tp->min_irq_nvecs);
+        seq_printf(m, "irq_nvecs\t0x%x\n", tp->irq_nvecs);
+        seq_printf(m, "ring_lib_enabled\t0x%x\n", tp->ring_lib_enabled);
+        seq_printf(m, "HwSuppIsrVer\t0x%x\n", tp->HwSuppIsrVer);
+        seq_printf(m, "HwCurrIsrVer\t0x%x\n", tp->HwCurrIsrVer);
+#ifdef ENABLE_PTP_SUPPORT
+        seq_printf(m, "tx_hwtstamp_timeouts\t0x%x\n", tp->tx_hwtstamp_timeouts);
+        seq_printf(m, "tx_hwtstamp_skipped\t0x%x\n", tp->tx_hwtstamp_skipped);
+#endif
+        seq_printf(m, "random_mac\t0x%x\n", tp->random_mac);
+        seq_printf(m, "org_mac_addr\t%pM\n", tp->org_mac_addr);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13)
+        seq_printf(m, "perm_addr\t%pM\n", dev->perm_addr);
+#endif
+        seq_printf(m, "dev_addr\t%pM\n", dev->dev_addr);
+
+        rtnl_unlock();
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_get_tally_counter(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct rtl8125_counters *counters;
+        dma_addr_t paddr;
+
+        seq_puts(m, "\nDump Tally Counter\n");
+
+        rtnl_lock();
+
+        counters = tp->tally_vaddr;
+        paddr = tp->tally_paddr;
+        if (!counters) {
+                seq_puts(m, "\nDump Tally Counter Fail\n");
+                goto out_unlock;
+        }
+
+        rtl8125_dump_tally_counter(tp, paddr);
+
+        seq_puts(m, "Statistics\tValue\n----------\t-----\n");
+        seq_printf(m, "tx_packets\t%lld\n", le64_to_cpu(counters->tx_packets));
+        seq_printf(m, "rx_packets\t%lld\n", le64_to_cpu(counters->rx_packets));
+        seq_printf(m, "tx_errors\t%lld\n", le64_to_cpu(counters->tx_errors));
+        seq_printf(m, "rx_errors\t%d\n", le32_to_cpu(counters->rx_errors));
+        seq_printf(m, "rx_missed\t%d\n", le16_to_cpu(counters->rx_missed));
+        seq_printf(m, "align_errors\t%d\n", le16_to_cpu(counters->align_errors));
+        seq_printf(m, "tx_one_collision\t%d\n", le32_to_cpu(counters->tx_one_collision));
+        seq_printf(m, "tx_multi_collision\t%d\n", le32_to_cpu(counters->tx_multi_collision));
+        seq_printf(m, "rx_unicast\t%lld\n", le64_to_cpu(counters->rx_unicast));
+        seq_printf(m, "rx_broadcast\t%lld\n", le64_to_cpu(counters->rx_broadcast));
+        seq_printf(m, "rx_multicast\t%d\n", le32_to_cpu(counters->rx_multicast));
+        seq_printf(m, "tx_aborted\t%d\n", le16_to_cpu(counters->tx_aborted));
+        seq_printf(m, "tx_underrun\t%d\n", le16_to_cpu(counters->tx_underrun));
+
+        seq_printf(m, "tx_octets\t%lld\n", le64_to_cpu(counters->tx_octets));
+        seq_printf(m, "rx_octets\t%lld\n", le64_to_cpu(counters->rx_octets));
+        seq_printf(m, "rx_multicast64\t%lld\n", le64_to_cpu(counters->rx_multicast64));
+        seq_printf(m, "tx_unicast64\t%lld\n", le64_to_cpu(counters->tx_unicast64));
+        seq_printf(m, "tx_broadcast64\t%lld\n", le64_to_cpu(counters->tx_broadcast64));
+        seq_printf(m, "tx_multicast64\t%lld\n", le64_to_cpu(counters->tx_multicast64));
+        seq_printf(m, "tx_pause_on\t%d\n", le32_to_cpu(counters->tx_pause_on));
+        seq_printf(m, "tx_pause_off\t%d\n", le32_to_cpu(counters->tx_pause_off));
+        seq_printf(m, "tx_pause_all\t%d\n", le32_to_cpu(counters->tx_pause_all));
+        seq_printf(m, "tx_deferred\t%d\n", le32_to_cpu(counters->tx_deferred));
+        seq_printf(m, "tx_late_collision\t%d\n", le32_to_cpu(counters->tx_late_collision));
+        seq_printf(m, "tx_all_collision\t%d\n", le32_to_cpu(counters->tx_all_collision));
+        seq_printf(m, "tx_aborted32\t%d\n", le32_to_cpu(counters->tx_aborted32));
+        seq_printf(m, "align_errors32\t%d\n", le32_to_cpu(counters->align_errors32));
+        seq_printf(m, "rx_frame_too_long\t%d\n", le32_to_cpu(counters->rx_frame_too_long));
+        seq_printf(m, "rx_runt\t%d\n", le32_to_cpu(counters->rx_runt));
+        seq_printf(m, "rx_pause_on\t%d\n", le32_to_cpu(counters->rx_pause_on));
+        seq_printf(m, "rx_pause_off\t%d\n", le32_to_cpu(counters->rx_pause_off));
+        seq_printf(m, "rx_pause_all\t%d\n", le32_to_cpu(counters->rx_pause_all));
+        seq_printf(m, "rx_unknown_opcode\t%d\n", le32_to_cpu(counters->rx_unknown_opcode));
+        seq_printf(m, "rx_mac_error\t%d\n", le32_to_cpu(counters->rx_mac_error));
+        seq_printf(m, "tx_underrun32\t%d\n", le32_to_cpu(counters->tx_underrun32));
+        seq_printf(m, "rx_mac_missed\t%d\n", le32_to_cpu(counters->rx_mac_missed));
+        seq_printf(m, "rx_tcam_dropped\t%d\n", le32_to_cpu(counters->rx_tcam_dropped));
+        seq_printf(m, "tdu\t%d\n", le32_to_cpu(counters->tdu));
+        seq_printf(m, "rdu\t%d\n", le32_to_cpu(counters->rdu));
+
+        seq_putc(m, '\n');
+
+out_unlock:
+        rtnl_unlock();
+
+        return 0;
+}
+
+static int proc_get_registers(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        int i, n, max = R8125_MAC_REGS_SIZE;
+        u8 byte_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        void __iomem *ioaddr = tp->mmio_addr;
+
+        seq_puts(m, "\nDump MAC Registers\n");
+        seq_puts(m, "Offset\tValue\n------\t-----\n");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                seq_printf(m, "\n0x%02x:\t", n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        seq_printf(m, "%02x ", byte_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_get_pcie_phy(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        int i, n, max = R8125_EPHY_REGS_SIZE/2;
+        u16 word_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        seq_puts(m, "\nDump PCIE PHY\n");
+        seq_puts(m, "\nOffset\tValue\n------\t-----\n ");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                seq_printf(m, "\n0x%02x:\t", n);
+
+                for (i = 0; i < 8 && n < max; i++, n++) {
+                        word_rd = rtl8125_ephy_read(tp, n);
+                        seq_printf(m, "%04x ", word_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_get_eth_phy(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        int i, n, max = R8125_PHY_REGS_SIZE/2;
+        u16 word_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        seq_puts(m, "\nDump Ethernet PHY\n");
+        seq_puts(m, "\nOffset\tValue\n------\t-----\n ");
+
+        rtnl_lock();
+
+        seq_puts(m, "\n####################page 0##################\n ");
+        rtl8125_mdio_write(tp, 0x1f, 0x0000);
+        for (n = 0; n < max;) {
+                seq_printf(m, "\n0x%02x:\t", n);
+
+                for (i = 0; i < 8 && n < max; i++, n++) {
+                        word_rd = rtl8125_mdio_read(tp, n);
+                        seq_printf(m, "%04x ", word_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_get_extended_registers(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        int i, n, max = R8125_ERI_REGS_SIZE;
+        u32 dword_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        seq_puts(m, "\nDump Extended Registers\n");
+        seq_puts(m, "\nOffset\tValue\n------\t-----\n ");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                seq_printf(m, "\n0x%02x:\t", n);
+
+                for (i = 0; i < 4 && n < max; i++, n+=4) {
+                        dword_rd = rtl8125_eri_read(tp, n, 4, ERIAR_ExGMAC);
+                        seq_printf(m, "%08x ", dword_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_get_pci_registers(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        int i, n, max = R8125_PCI_REGS_SIZE;
+        u32 dword_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        seq_puts(m, "\nDump PCI Registers\n");
+        seq_puts(m, "\nOffset\tValue\n------\t-----\n ");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                seq_printf(m, "\n0x%03x:\t", n);
+
+                for (i = 0; i < 4 && n < max; i++, n+=4) {
+                        pci_read_config_dword(tp->pci_dev, n, &dword_rd);
+                        seq_printf(m, "%08x ", dword_rd);
+                }
+        }
+
+        n = 0x110;
+        pci_read_config_dword(tp->pci_dev, n, &dword_rd);
+        seq_printf(m, "\n0x%03x:\t%08x ", n, dword_rd);
+        n = 0x70c;
+        pci_read_config_dword(tp->pci_dev, n, &dword_rd);
+        seq_printf(m, "\n0x%03x:\t%08x ", n, dword_rd);
+
+        rtnl_unlock();
+
+        seq_putc(m, '\n');
+        return 0;
+}
+
+static int proc_get_temperature(struct seq_file *m, void *v)
+{
+        struct net_device *dev = m->private;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u16 ts_digout, tj, fah;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                seq_puts(m, "\nChip Temperature\n");
+                break;
+        default:
+                seq_puts(m, "\nThis Chip Does Not Support Dump Temperature\n");
+                break;
+        }
+
+        rtnl_lock();
+        ts_digout = rtl8125_read_thermal_sensor(tp);
+        rtnl_unlock();
+
+        tj = ts_digout / 2;
+        if (ts_digout <= 512) {
+                tj = ts_digout / 2;
+                seq_printf(m, "Cel:%d\n", tj);
+                fah = tj * (9/5) + 32;
+                seq_printf(m, "Fah:%d\n", fah);
+        } else {
+                tj = (512 - ((ts_digout / 2) - 512)) / 2;
+                seq_printf(m, "Cel:-%d\n", tj);
+                fah = tj * (9/5) + 32;
+                seq_printf(m, "Fah:-%d\n", fah);
+        }
+
+        seq_putc(m, '\n');
+        return 0;
+}
+#else
+
+static int proc_get_driver_variable(char *page, char **start,
+                                    off_t offset, int count,
+                                    int *eof, void *data)
+{
+        struct net_device *dev = data;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump Driver Driver\n");
+
+        rtnl_lock();
+
+        len += snprintf(page + len, count - len,
+                        "Variable\tValue\n----------\t-----\n");
+
+        len += snprintf(page + len, count - len,
+                        "MODULENAME\t%s\n"
+                        "driver version\t%s\n"
+                        "mcfg\t%d\n"
+                        "chipset\t%d\n"
+                        "chipset_name\t%s\n"
+                        "mtu\t%d\n"
+                        "NUM_RX_DESC\t0x%x\n"
+                        "cur_rx0\t0x%x\n"
+                        "dirty_rx0\t0x%x\n"
+                        "cur_rx1\t0x%x\n"
+                        "dirty_rx1\t0x%x\n"
+                        "cur_rx2\t0x%x\n"
+                        "dirty_rx2\t0x%x\n"
+                        "cur_rx3\t0x%x\n"
+                        "dirty_rx3\t0x%x\n"
+                        "NUM_TX_DESC\t0x%x\n"
+                        "cur_tx0\t0x%x\n"
+                        "dirty_tx0\t0x%x\n"
+                        "cur_tx1\t0x%x\n"
+                        "dirty_tx1\t0x%x\n"
+                        "rx_buf_sz\t0x%x\n"
+                        "esd_flag\t0x%x\n"
+                        "pci_cfg_is_read\t0x%x\n"
+                        "rtl8125_rx_config\t0x%x\n"
+                        "cp_cmd\t0x%x\n"
+                        "intr_mask\t0x%x\n"
+                        "timer_intr_mask\t0x%x\n"
+                        "wol_enabled\t0x%x\n"
+                        "wol_opts\t0x%x\n"
+                        "efuse_ver\t0x%x\n"
+                        "eeprom_type\t0x%x\n"
+                        "autoneg\t0x%x\n"
+                        "duplex\t0x%x\n"
+                        "speed\t%d\n"
+                        "advertising\t0x%x\n"
+                        "eeprom_len\t0x%x\n"
+                        "cur_page\t0x%x\n"
+                        "bios_setting\t0x%x\n"
+                        "features\t0x%x\n"
+                        "org_pci_offset_99\t0x%x\n"
+                        "org_pci_offset_180\t0x%x\n"
+                        "issue_offset_99_event\t0x%x\n"
+                        "org_pci_offset_80\t0x%x\n"
+                        "org_pci_offset_81\t0x%x\n"
+                        "use_timer_interrrupt\t0x%x\n"
+                        "HwIcVerUnknown\t0x%x\n"
+                        "NotWrRamCodeToMicroP\t0x%x\n"
+                        "NotWrMcuPatchCode\t0x%x\n"
+                        "HwHasWrRamCodeToMicroP\t0x%x\n"
+                        "sw_ram_code_ver\t0x%x\n"
+                        "hw_ram_code_ver\t0x%x\n"
+                        "rtk_enable_diag\t0x%x\n"
+                        "ShortPacketSwChecksum\t0x%x\n"
+                        "UseSwPaddingShortPkt\t0x%x\n"
+                        "RequireRduNonStopPatch\t0x%x\n"
+                        "RequireAdcBiasPatch\t0x%x\n"
+                        "AdcBiasPatchIoffset\t0x%x\n"
+                        "RequireAdjustUpsTxLinkPulseTiming\t0x%x\n"
+                        "SwrCnt1msIni\t0x%x\n"
+                        "HwSuppNowIsOobVer\t0x%x\n"
+                        "HwFiberModeVer\t0x%x\n"
+                        "HwFiberStat\t0x%x\n"
+                        "HwSwitchMdiToFiber\t0x%x\n"
+                        "NicCustLedValue\t0x%x\n"
+                        "RequiredSecLanDonglePatch\t0x%x\n"
+                        "HwSuppDashVer\t0x%x\n"
+                        "DASH\t0x%x\n"
+                        "dash_printer_enabled\t0x%x\n"
+                        "HwSuppKCPOffloadVer\t0x%x\n"
+                        "speed_mode\t0x%x\n"
+                        "duplex_mode\t0x%x\n"
+                        "autoneg_mode\t0x%x\n"
+                        "advertising_mode\t0x%x\n"
+                        "aspm\t0x%x\n"
+                        "s5wol\t0x%x\n"
+                        "s5_keep_curr_mac\t0x%x\n"
+                        "eee_enable\t0x%x\n"
+                        "hwoptimize\t0x%lx\n"
+                        "proc_init_num\t0x%x\n"
+                        "s0_magic_packet\t0x%x\n"
+                        "HwSuppMagicPktVer\t0x%x\n"
+                        "HwSuppLinkChgWakeUpVer\t0x%x\n"
+                        "HwSuppD0SpeedUpVer\t0x%x\n"
+                        "D0SpeedUpSpeed\t0x%x\n"
+                        "HwSuppCheckPhyDisableModeVer\t0x%x\n"
+                        "HwPkgDet\t0x%x\n"
+                        "HwSuppTxNoCloseVer\t0x%x\n"
+                        "EnableTxNoClose\t0x%x\n"
+                        "NextHwDesCloPtr0\t0x%x\n"
+                        "BeginHwDesCloPtr0\t0x%x\n"
+                        "NextHwDesCloPtr1\t0x%x\n"
+                        "BeginHwDesCloPtr1\t0x%x\n"
+                        "InitRxDescType\t0x%x\n"
+                        "RxDescLength\t0x%x\n"
+                        "num_rx_rings\t0x%x\n"
+                        "num_tx_rings\t0x%x\n"
+                        "tot_rx_rings\t0x%x\n"
+                        "tot_tx_rings\t0x%x\n"
+                        "EnableRss\t0x%x\n"
+                        "EnablePtp\t0x%x\n"
+                        "ptp_master_mode\t0x%x\n"
+                        "min_irq_nvecs\t0x%x\n"
+                        "irq_nvecs\t0x%x\n"
+                        "ring_lib_enabled\t0x%x\n"
+                        "HwSuppIsrVer\t0x%x\n"
+                        "HwCurrIsrVer\t0x%x\n"
+#ifdef ENABLE_PTP_SUPPORT
+                        "tx_hwtstamp_timeouts\t0x%x\n"
+                        "tx_hwtstamp_skipped\t0x%x\n"
+#endif
+                        "random_mac\t0x%x\n"
+                        "org_mac_addr\t%pM\n"
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13)
+                        "perm_addr\t%pM\n"
+#endif
+                        "dev_addr\t%pM\n",
+                        MODULENAME,
+                        RTL8125_VERSION,
+                        tp->mcfg,
+                        tp->chipset,
+                        rtl_chip_info[tp->chipset].name,
+                        dev->mtu,
+                        tp->rx_ring[0].num_rx_desc,
+                        tp->rx_ring[0].cur_rx,
+                        tp->rx_ring[0].dirty_rx,
+                        tp->rx_ring[1].cur_rx,
+                        tp->rx_ring[1].dirty_rx,
+                        tp->rx_ring[2].cur_rx,
+                        tp->rx_ring[2].dirty_rx,
+                        tp->rx_ring[3].cur_rx,
+                        tp->rx_ring[3].dirty_rx,
+                        tp->tx_ring[0].num_tx_desc,
+                        tp->tx_ring[0].cur_tx,
+                        tp->tx_ring[0].dirty_tx,
+                        tp->tx_ring[1].cur_tx,
+                        tp->tx_ring[1].dirty_tx,
+                        tp->rx_buf_sz,
+                        tp->esd_flag,
+                        tp->pci_cfg_is_read,
+                        tp->rtl8125_rx_config,
+                        tp->cp_cmd,
+                        tp->intr_mask,
+                        tp->timer_intr_mask,
+                        tp->wol_enabled,
+                        tp->wol_opts,
+                        tp->efuse_ver,
+                        tp->eeprom_type,
+                        tp->autoneg,
+                        tp->duplex,
+                        tp->speed,
+                        tp->advertising,
+                        tp->eeprom_len,
+                        tp->cur_page,
+                        tp->bios_setting,
+                        tp->features,
+                        tp->org_pci_offset_99,
+                        tp->org_pci_offset_180,
+                        tp->issue_offset_99_event,
+                        tp->org_pci_offset_80,
+                        tp->org_pci_offset_81,
+                        tp->use_timer_interrrupt,
+                        tp->HwIcVerUnknown,
+                        tp->NotWrRamCodeToMicroP,
+                        tp->NotWrMcuPatchCode,
+                        tp->HwHasWrRamCodeToMicroP,
+                        tp->sw_ram_code_ver,
+                        tp->hw_ram_code_ver,
+                        tp->rtk_enable_diag,
+                        tp->ShortPacketSwChecksum,
+                        tp->UseSwPaddingShortPkt,
+                        tp->RequireRduNonStopPatch,
+                        tp->RequireAdcBiasPatch,
+                        tp->AdcBiasPatchIoffset,
+                        tp->RequireAdjustUpsTxLinkPulseTiming,
+                        tp->SwrCnt1msIni,
+                        tp->HwSuppNowIsOobVer,
+                        tp->HwFiberModeVer,
+                        tp->HwFiberStat,
+                        tp->HwSwitchMdiToFiber,
+                        tp->NicCustLedValue,
+                        tp->RequiredSecLanDonglePatch,
+                        tp->HwSuppDashVer,
+                        tp->DASH,
+                        tp->dash_printer_enabled,
+                        tp->HwSuppKCPOffloadVer,
+                        speed_mode,
+                        duplex_mode,
+                        autoneg_mode,
+                        advertising_mode,
+                        aspm,
+                        s5wol,
+                        s5_keep_curr_mac,
+                        tp->eee.eee_enabled,
+                        hwoptimize,
+                        proc_init_num,
+                        s0_magic_packet,
+                        tp->HwSuppMagicPktVer,
+                        tp->HwSuppLinkChgWakeUpVer,
+                        tp->HwSuppD0SpeedUpVer,
+                        tp->D0SpeedUpSpeed,
+                        tp->HwSuppCheckPhyDisableModeVer,
+                        tp->HwPkgDet,
+                        tp->HwSuppTxNoCloseVer,
+                        tp->EnableTxNoClose,
+                        tp->tx_ring[0].NextHwDesCloPtr,
+                        tp->tx_ring[0].BeginHwDesCloPtr,
+                        tp->tx_ring[1].NextHwDesCloPtr,
+                        tp->tx_ring[1].BeginHwDesCloPtr,
+                        tp->InitRxDescType,
+                        tp->RxDescLength,
+                        tp->num_rx_rings,
+                        tp->num_tx_rings,
+                        tp->tot_rx_rings,
+                        tp->tot_tx_rings,
+                        tp->EnableRss,
+                        tp->EnablePtp,
+                        tp->ptp_master_mode,
+                        tp->min_irq_nvecs,
+                        tp->irq_nvecs,
+                        tp->ring_lib_enabled,
+                        tp->HwSuppIsrVer,
+                        tp->HwCurrIsrVer,
+#ifdef ENABLE_PTP_SUPPORT
+                        tp->tx_hwtstamp_timeouts,
+                        tp->tx_hwtstamp_skipped,
+#endif
+                        tp->random_mac,
+                        tp->org_mac_addr,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13)
+                        dev->perm_addr,
+#endif
+                        dev->dev_addr
+                       );
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_tally_counter(char *page, char **start,
+                                  off_t offset, int count,
+                                  int *eof, void *data)
+{
+        struct net_device *dev = data;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct rtl8125_counters *counters;
+        dma_addr_t paddr;
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump Tally Counter\n");
+
+        rtnl_lock();
+
+        counters = tp->tally_vaddr;
+        paddr = tp->tally_paddr;
+        if (!counters) {
+                len += snprintf(page + len, count - len,
+                                "\nDump Tally Counter Fail\n");
+                goto out_unlock;
+        }
+
+        rtl8125_dump_tally_counter(tp, paddr);
+
+        len += snprintf(page + len, count - len,
+                        "Statistics\tValue\n----------\t-----\n");
+
+        len += snprintf(page + len, count - len,
+                        "tx_packets\t%lld\n"
+                        "rx_packets\t%lld\n"
+                        "tx_errors\t%lld\n"
+                        "rx_errors\t%d\n"
+                        "rx_missed\t%d\n"
+                        "align_errors\t%d\n"
+                        "tx_one_collision\t%d\n"
+                        "tx_multi_collision\t%d\n"
+                        "rx_unicast\t%lld\n"
+                        "rx_broadcast\t%lld\n"
+                        "rx_multicast\t%d\n"
+                        "tx_aborted\t%d\n"
+                        "tx_underrun\t%d\n",
+
+                        "tx_octets\t%lld\n",
+                        "rx_octets\t%lld\n",
+                        "rx_multicast64\t%lld\n",
+                        "tx_unicast64\t%lld\n",
+                        "tx_broadcast64\t%lld\n",
+                        "tx_multicast64\t%lld\n",
+                        "tx_pause_on\t%d\n",
+                        "tx_pause_off\t%d\n",
+                        "tx_pause_all\t%d\n",
+                        "tx_deferred\t%d\n",
+                        "tx_late_collision\t%d\n",
+                        "tx_all_collision\t%d\n",
+                        "tx_aborted32\t%d\n",
+                        "align_errors32\t%d\n",
+                        "rx_frame_too_long\t%d\n",
+                        "rx_runt\t%d\n",
+                        "rx_pause_on\t%d\n",
+                        "rx_pause_off\t%d\n",
+                        "rx_pause_all\t%d\n",
+                        "rx_unknown_opcode\t%d\n",
+                        "rx_mac_error\t%d\n",
+                        "tx_underrun32\t%d\n",
+                        "rx_mac_missed\t%d\n",
+                        "rx_tcam_dropped\t%d\n",
+                        "tdu\t%d\n",
+                        "rdu\t%d\n",
+                        le64_to_cpu(counters->tx_packets),
+                        le64_to_cpu(counters->rx_packets),
+                        le64_to_cpu(counters->tx_errors),
+                        le32_to_cpu(counters->rx_errors),
+                        le16_to_cpu(counters->rx_missed),
+                        le16_to_cpu(counters->align_errors),
+                        le32_to_cpu(counters->tx_one_collision),
+                        le32_to_cpu(counters->tx_multi_collision),
+                        le64_to_cpu(counters->rx_unicast),
+                        le64_to_cpu(counters->rx_broadcast),
+                        le32_to_cpu(counters->rx_multicast),
+                        le16_to_cpu(counters->tx_aborted),
+                        le16_to_cpu(counters->tx_underrun),
+
+                        le64_to_cpu(counters->tx_octets),
+                        le64_to_cpu(counters->rx_octets),
+                        le64_to_cpu(counters->rx_multicast64),
+                        le64_to_cpu(counters->tx_unicast64),
+                        le64_to_cpu(counters->tx_broadcast64),
+                        le64_to_cpu(counters->tx_multicast64),
+                        le32_to_cpu(counters->tx_pause_on),
+                        le32_to_cpu(counters->tx_pause_off),
+                        le32_to_cpu(counters->tx_pause_all),
+                        le32_to_cpu(counters->tx_deferred),
+                        le32_to_cpu(counters->tx_late_collision),
+                        le32_to_cpu(counters->tx_all_collision),
+                        le32_to_cpu(counters->tx_aborted32),
+                        le32_to_cpu(counters->align_errors32),
+                        le32_to_cpu(counters->rx_frame_too_long),
+                        le32_to_cpu(counters->rx_runt),
+                        le32_to_cpu(counters->rx_pause_on),
+                        le32_to_cpu(counters->rx_pause_off),
+                        le32_to_cpu(counters->rx_pause_all),
+                        le32_to_cpu(counters->rx_unknown_opcode),
+                        le32_to_cpu(counters->rx_mac_error),
+                        le32_to_cpu(counters->tx_underrun32),
+                        le32_to_cpu(counters->rx_mac_missed),
+                        le32_to_cpu(counters->rx_tcam_dropped),
+                        le32_to_cpu(counters->tdu),
+                        le32_to_cpu(counters->rdu),
+                       );
+
+        len += snprintf(page + len, count - len, "\n");
+out_unlock:
+        rtnl_unlock();
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_registers(char *page, char **start,
+                              off_t offset, int count,
+                              int *eof, void *data)
+{
+        struct net_device *dev = data;
+        int i, n, max = R8125_MAC_REGS_SIZE;
+        u8 byte_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        void __iomem *ioaddr = tp->mmio_addr;
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump MAC Registers\n"
+                        "Offset\tValue\n------\t-----\n");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%02x:\t",
+                                n);
+
+                for (i = 0; i < 16 && n < max; i++, n++) {
+                        byte_rd = readb(ioaddr + n);
+                        len += snprintf(page + len, count - len,
+                                        "%02x ",
+                                        byte_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_pcie_phy(char *page, char **start,
+                             off_t offset, int count,
+                             int *eof, void *data)
+{
+        struct net_device *dev = data;
+        int i, n, max = R8125_EPHY_REGS_SIZE/2;
+        u16 word_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump PCIE PHY\n"
+                        "Offset\tValue\n------\t-----\n");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%02x:\t",
+                                n);
+
+                for (i = 0; i < 8 && n < max; i++, n++) {
+                        word_rd = rtl8125_ephy_read(tp, n);
+                        len += snprintf(page + len, count - len,
+                                        "%04x ",
+                                        word_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_eth_phy(char *page, char **start,
+                            off_t offset, int count,
+                            int *eof, void *data)
+{
+        struct net_device *dev = data;
+        int i, n, max = R8125_PHY_REGS_SIZE/2;
+        u16 word_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump Ethernet PHY\n"
+                        "Offset\tValue\n------\t-----\n");
+
+        rtnl_lock();
+
+        len += snprintf(page + len, count - len,
+                        "\n####################page 0##################\n");
+        rtl8125_mdio_write(tp, 0x1f, 0x0000);
+        for (n = 0; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%02x:\t",
+                                n);
+
+                for (i = 0; i < 8 && n < max; i++, n++) {
+                        word_rd = rtl8125_mdio_read(tp, n);
+                        len += snprintf(page + len, count - len,
+                                        "%04x ",
+                                        word_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_extended_registers(char *page, char **start,
+                                       off_t offset, int count,
+                                       int *eof, void *data)
+{
+        struct net_device *dev = data;
+        int i, n, max = R8125_ERI_REGS_SIZE;
+        u32 dword_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump Extended Registers\n"
+                        "Offset\tValue\n------\t-----\n");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%02x:\t",
+                                n);
+
+                for (i = 0; i < 4 && n < max; i++, n+=4) {
+                        dword_rd = rtl8125_eri_read(tp, n, 4, ERIAR_ExGMAC);
+                        len += snprintf(page + len, count - len,
+                                        "%08x ",
+                                        dword_rd);
+                }
+        }
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_pci_registers(char *page, char **start,
+                                  off_t offset, int count,
+                                  int *eof, void *data)
+{
+        struct net_device *dev = data;
+        int i, n, max = R8125_PCI_REGS_SIZE;
+        u32 dword_rd;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int len = 0;
+
+        len += snprintf(page + len, count - len,
+                        "\nDump PCI Registers\n"
+                        "Offset\tValue\n------\t-----\n");
+
+        rtnl_lock();
+
+        for (n = 0; n < max;) {
+                len += snprintf(page + len, count - len,
+                                "\n0x%03x:\t",
+                                n);
+
+                for (i = 0; i < 4 && n < max; i++, n+=4) {
+                        pci_read_config_dword(tp->pci_dev, n, &dword_rd);
+                        len += snprintf(page + len, count - len,
+                                        "%08x ",
+                                        dword_rd);
+                }
+        }
+
+        n = 0x110;
+        pci_read_config_dword(tp->pci_dev, n, &dword_rd);
+        len += snprintf(page + len, count - len,
+                        "\n0x%03x:\t%08x ",
+                        n,
+                        dword_rd);
+        n = 0x70c;
+        pci_read_config_dword(tp->pci_dev, n, &dword_rd);
+        len += snprintf(page + len, count - len,
+                        "\n0x%03x:\t%08x ",
+                        n,
+                        dword_rd);
+
+        rtnl_unlock();
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+
+static int proc_get_temperature(char *page, char **start,
+                                off_t offset, int count,
+                                int *eof, void *data)
+{
+        struct net_device *dev = data;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u16 ts_digout, tj, fah;
+        int len = 0;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                len += snprintf(page + len, count - len,
+                                "\nChip Temperature\n");
+                break;
+        default:
+                len += snprintf(page + len, count - len,
+                                "\nThis Chip Does Not Support Dump Temperature\n");
+                break;
+        }
+
+        rtnl_lock();
+        ts_digout = rtl8125_read_thermal_sensor(tp);
+        rtnl_unlock();
+
+        tj = ts_digout / 2;
+        if (ts_digout <= 512) {
+                tj = ts_digout / 2;
+                len += snprintf(page + len, count - len,
+                                "Cel:%d\n",
+                                tj);
+                fah = tj * (9/5) + 32;
+                len += snprintf(page + len, count - len,
+                                "Fah:%d\n",
+                                fah);
+
+        } else {
+                tj = (512 - ((ts_digout / 2) - 512)) / 2;
+                len += snprintf(page + len, count - len,
+                                "Cel:-%d\n",
+                                tj);
+                fah = tj * (9/5) + 32;
+                len += snprintf(page + len, count - len,
+                                "Fah:-%d\n",
+                                fah);
+        }
+
+        len += snprintf(page + len, count - len, "\n");
+
+        *eof = 1;
+        return len;
+}
+#endif
+static void rtl8125_proc_module_init(void)
+{
+        //create /proc/net/r8125
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+        rtl8125_proc = proc_mkdir(MODULENAME, init_net.proc_net);
+#else
+        rtl8125_proc = proc_mkdir(MODULENAME, proc_net);
+#endif
+        if (!rtl8125_proc)
+                dprintk("cannot create %s proc entry \n", MODULENAME);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+/*
+ * seq_file wrappers for procfile show routines.
+ */
+static int rtl8125_proc_open(struct inode *inode, struct file *file)
+{
+        struct net_device *dev = proc_get_parent_data(inode);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+        int (*show)(struct seq_file *, void *) = pde_data(inode);
+#else
+        int (*show)(struct seq_file *, void *) = PDE_DATA(inode);
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+
+        return single_open(file, show, dev);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0)
+static const struct proc_ops rtl8125_proc_fops = {
+        .proc_open           = rtl8125_proc_open,
+        .proc_read           = seq_read,
+        .proc_lseek          = seq_lseek,
+        .proc_release        = single_release,
+};
+#else
+static const struct file_operations rtl8125_proc_fops = {
+        .open           = rtl8125_proc_open,
+        .read           = seq_read,
+        .llseek         = seq_lseek,
+        .release        = single_release,
+};
+#endif
+
+#endif
+
+/*
+ * Table of proc files we need to create.
+ */
+struct rtl8125_proc_file {
+        char name[12];
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+        int (*show)(struct seq_file *, void *);
+#else
+        int (*show)(char *, char **, off_t, int, int *, void *);
+#endif
+};
+
+static const struct rtl8125_proc_file rtl8125_proc_files[] = {
+        { "driver_var", &proc_get_driver_variable },
+        { "tally", &proc_get_tally_counter },
+        { "registers", &proc_get_registers },
+        { "pcie_phy", &proc_get_pcie_phy },
+        { "eth_phy", &proc_get_eth_phy },
+        { "ext_regs", &proc_get_extended_registers },
+        { "pci_regs", &proc_get_pci_registers },
+        { "temp", &proc_get_temperature },
+        { "", NULL }
+};
+
+static void rtl8125_proc_init(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        const struct rtl8125_proc_file *f;
+        struct proc_dir_entry *dir;
+
+        if (rtl8125_proc && !tp->proc_dir) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+                dir = proc_mkdir_data(dev->name, 0, rtl8125_proc, dev);
+                if (!dir) {
+                        printk("Unable to initialize /proc/net/%s/%s\n",
+                               MODULENAME, dev->name);
+                        return;
+                }
+
+                tp->proc_dir = dir;
+                proc_init_num++;
+
+                for (f = rtl8125_proc_files; f->name[0]; f++) {
+                        if (!proc_create_data(f->name, S_IFREG | S_IRUGO, dir,
+                                              &rtl8125_proc_fops, f->show)) {
+                                printk("Unable to initialize "
+                                       "/proc/net/%s/%s/%s\n",
+                                       MODULENAME, dev->name, f->name);
+                                return;
+                        }
+                }
+#else
+                dir = proc_mkdir(dev->name, rtl8125_proc);
+                if (!dir) {
+                        printk("Unable to initialize /proc/net/%s/%s\n",
+                               MODULENAME, dev->name);
+                        return;
+                }
+
+                tp->proc_dir = dir;
+                proc_init_num++;
+
+                for (f = rtl8125_proc_files; f->name[0]; f++) {
+                        if (!create_proc_read_entry(f->name, S_IFREG | S_IRUGO,
+                                                    dir, f->show, dev)) {
+                                printk("Unable to initialize "
+                                       "/proc/net/%s/%s/%s\n",
+                                       MODULENAME, dev->name, f->name);
+                                return;
+                        }
+                }
+#endif
+        }
+}
+
+static void rtl8125_proc_remove(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (tp->proc_dir) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+                remove_proc_subtree(dev->name, rtl8125_proc);
+                proc_init_num--;
+
+#else
+                const struct rtl8125_proc_file *f;
+                struct rtl8125_private *tp = netdev_priv(dev);
+
+                for (f = rtl8125_proc_files; f->name[0]; f++)
+                        remove_proc_entry(f->name, tp->proc_dir);
+
+                remove_proc_entry(dev->name, rtl8125_proc);
+                proc_init_num--;
+#endif
+                tp->proc_dir = NULL;
+        }
+}
+
+#endif //ENABLE_R8125_PROCFS
+
+static inline u16 map_phy_ocp_addr(u16 PageNum, u8 RegNum)
+{
+        u16 OcpPageNum = 0;
+        u8 OcpRegNum = 0;
+        u16 OcpPhyAddress = 0;
+
+        if ( PageNum == 0 ) {
+                OcpPageNum = OCP_STD_PHY_BASE_PAGE + ( RegNum / 8 );
+                OcpRegNum = 0x10 + ( RegNum % 8 );
+        } else {
+                OcpPageNum = PageNum;
+                OcpRegNum = RegNum;
+        }
+
+        OcpPageNum <<= 4;
+
+        if ( OcpRegNum < 16 ) {
+                OcpPhyAddress = 0;
+        } else {
+                OcpRegNum -= 16;
+                OcpRegNum <<= 1;
+
+                OcpPhyAddress = OcpPageNum + OcpRegNum;
+        }
+
+
+        return OcpPhyAddress;
+}
+
+static void mdio_real_direct_write_phy_ocp(struct rtl8125_private *tp,
+                u16 RegAddr,
+                u16 value)
+{
+        u32 data32;
+        int i;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+        WARN_ON_ONCE(RegAddr % 2);
+#endif
+        data32 = RegAddr/2;
+        data32 <<= OCPR_Addr_Reg_shift;
+        data32 |= OCPR_Write | value;
+
+        RTL_W32(tp, PHYOCP, data32);
+        for (i = 0; i < 100; i++) {
+                udelay(1);
+
+                if (!(RTL_R32(tp, PHYOCP) & OCPR_Flag))
+                        break;
+        }
+}
+
+static void mdio_direct_write_phy_ocp(struct rtl8125_private *tp,
+                                      u16 RegAddr,
+                                      u16 value)
+{
+        if (tp->rtk_enable_diag) return;
+
+        mdio_real_direct_write_phy_ocp(tp, RegAddr, value);
+}
+
+/*
+static void rtl8125_mdio_write_phy_ocp(struct rtl8125_private *tp,
+                                       u16 PageNum,
+                                       u32 RegAddr,
+                                       u32 value)
+{
+        u16 ocp_addr;
+
+        ocp_addr = map_phy_ocp_addr(PageNum, RegAddr);
+
+        mdio_direct_write_phy_ocp(tp, ocp_addr, value);
+}
+*/
+
+static void rtl8125_mdio_real_write_phy_ocp(struct rtl8125_private *tp,
+                u16 PageNum,
+                u32 RegAddr,
+                u32 value)
+{
+        u16 ocp_addr;
+
+        ocp_addr = map_phy_ocp_addr(PageNum, RegAddr);
+
+        mdio_real_direct_write_phy_ocp(tp, ocp_addr, value);
+}
+
+static void mdio_real_write(struct rtl8125_private *tp,
+                            u16 RegAddr,
+                            u16 value)
+{
+        if (RegAddr == 0x1F) {
+                tp->cur_page = value;
+                return;
+        }
+        rtl8125_mdio_real_write_phy_ocp(tp, tp->cur_page, RegAddr, value);
+}
+
+void rtl8125_mdio_write(struct rtl8125_private *tp,
+                        u16 RegAddr,
+                        u16 value)
+{
+        if (tp->rtk_enable_diag) return;
+
+        mdio_real_write(tp, RegAddr, value);
+}
+
+void rtl8125_mdio_prot_write(struct rtl8125_private *tp,
+                             u32 RegAddr,
+                             u32 value)
+{
+        mdio_real_write(tp, RegAddr, value);
+}
+
+void rtl8125_mdio_prot_direct_write_phy_ocp(struct rtl8125_private *tp,
+                u32 RegAddr,
+                u32 value)
+{
+        mdio_real_direct_write_phy_ocp(tp, RegAddr, value);
+}
+
+static u32 mdio_real_direct_read_phy_ocp(struct rtl8125_private *tp,
+                u16 RegAddr)
+{
+        u32 data32;
+        int i, value = 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+        WARN_ON_ONCE(RegAddr % 2);
+#endif
+        data32 = RegAddr/2;
+        data32 <<= OCPR_Addr_Reg_shift;
+
+        RTL_W32(tp, PHYOCP, data32);
+        for (i = 0; i < 100; i++) {
+                udelay(1);
+
+                if (RTL_R32(tp, PHYOCP) & OCPR_Flag)
+                        break;
+        }
+        value = RTL_R32(tp, PHYOCP) & OCPDR_Data_Mask;
+
+        return value;
+}
+
+static u32 mdio_direct_read_phy_ocp(struct rtl8125_private *tp,
+                                    u16 RegAddr)
+{
+        if (tp->rtk_enable_diag) return 0xffffffff;
+
+        return mdio_real_direct_read_phy_ocp(tp, RegAddr);
+}
+
+/*
+static u32 rtl8125_mdio_read_phy_ocp(struct rtl8125_private *tp,
+                                     u16 PageNum,
+                                     u32 RegAddr)
+{
+        u16 ocp_addr;
+
+        ocp_addr = map_phy_ocp_addr(PageNum, RegAddr);
+
+        return mdio_direct_read_phy_ocp(tp, ocp_addr);
+}
+*/
+
+static u32 rtl8125_mdio_real_read_phy_ocp(struct rtl8125_private *tp,
+                u16 PageNum,
+                u32 RegAddr)
+{
+        u16 ocp_addr;
+
+        ocp_addr = map_phy_ocp_addr(PageNum, RegAddr);
+
+        return mdio_real_direct_read_phy_ocp(tp, ocp_addr);
+}
+
+static u32 mdio_real_read(struct rtl8125_private *tp,
+                          u16 RegAddr)
+{
+        return rtl8125_mdio_real_read_phy_ocp(tp, tp->cur_page, RegAddr);
+}
+
+u32 rtl8125_mdio_read(struct rtl8125_private *tp,
+                      u16 RegAddr)
+{
+        if (tp->rtk_enable_diag) return 0xffffffff;
+
+        return mdio_real_read(tp, RegAddr);
+}
+
+u32 rtl8125_mdio_prot_read(struct rtl8125_private *tp,
+                           u32 RegAddr)
+{
+        return mdio_real_read(tp, RegAddr);
+}
+
+u32 rtl8125_mdio_prot_direct_read_phy_ocp(struct rtl8125_private *tp,
+                u32 RegAddr)
+{
+        return mdio_real_direct_read_phy_ocp(tp, RegAddr);
+}
+
+static void ClearAndSetEthPhyBit(struct rtl8125_private *tp, u8  addr, u16 clearmask, u16 setmask)
+{
+        u16 PhyRegValue;
+
+        PhyRegValue = rtl8125_mdio_read(tp, addr);
+        PhyRegValue &= ~clearmask;
+        PhyRegValue |= setmask;
+        rtl8125_mdio_write(tp, addr, PhyRegValue);
+}
+
+void rtl8125_clear_eth_phy_bit(struct rtl8125_private *tp, u8 addr, u16 mask)
+{
+        ClearAndSetEthPhyBit(tp,
+                             addr,
+                             mask,
+                             0
+                            );
+}
+
+void rtl8125_set_eth_phy_bit(struct rtl8125_private *tp,  u8  addr, u16  mask)
+{
+        ClearAndSetEthPhyBit(tp,
+                             addr,
+                             0,
+                             mask
+                            );
+}
+
+static void ClearAndSetEthPhyOcpBit(struct rtl8125_private *tp, u16 addr, u16 clearmask, u16 setmask)
+{
+        u16 PhyRegValue;
+
+        PhyRegValue = mdio_direct_read_phy_ocp(tp, addr);
+        PhyRegValue &= ~clearmask;
+        PhyRegValue |= setmask;
+        mdio_direct_write_phy_ocp(tp, addr, PhyRegValue);
+}
+
+void ClearEthPhyOcpBit(struct rtl8125_private *tp, u16 addr, u16 mask)
+{
+        ClearAndSetEthPhyOcpBit(tp,
+                                addr,
+                                mask,
+                                0
+                               );
+}
+
+void SetEthPhyOcpBit(struct rtl8125_private *tp,  u16 addr, u16 mask)
+{
+        ClearAndSetEthPhyOcpBit(tp,
+                                addr,
+                                0,
+                                mask
+                               );
+}
+
+void rtl8125_mac_ocp_write(struct rtl8125_private *tp, u16 reg_addr, u16 value)
+{
+        u32 data32;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+        WARN_ON_ONCE(reg_addr % 2);
+#endif
+
+        data32 = reg_addr/2;
+        data32 <<= OCPR_Addr_Reg_shift;
+        data32 += value;
+        data32 |= OCPR_Write;
+
+        RTL_W32(tp, MACOCP, data32);
+}
+
+u32 rtl8125_mac_ocp_read(struct rtl8125_private *tp, u16 reg_addr)
+{
+        u32 data32;
+        u16 data16 = 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+        WARN_ON_ONCE(reg_addr % 2);
+#endif
+
+        data32 = reg_addr/2;
+        data32 <<= OCPR_Addr_Reg_shift;
+
+        RTL_W32(tp, MACOCP, data32);
+        data16 = (u16)RTL_R32(tp, MACOCP);
+
+        return data16;
+}
+
+#ifdef ENABLE_USE_FIRMWARE_FILE
+static void mac_mcu_write(struct rtl8125_private *tp, u16 reg, u16 value)
+{
+        if (reg == 0x1f) {
+                tp->ocp_base = value << 4;
+                return;
+        }
+
+        rtl8125_mac_ocp_write(tp, tp->ocp_base + reg, value);
+}
+
+static u32 mac_mcu_read(struct rtl8125_private *tp, u16 reg)
+{
+        return rtl8125_mac_ocp_read(tp, tp->ocp_base + reg);
+}
+#endif
+
+static void
+ClearAndSetMcuAccessRegBit(
+        struct rtl8125_private *tp,
+        u16   addr,
+        u16   clearmask,
+        u16   setmask
+)
+{
+        u16 PhyRegValue;
+
+        PhyRegValue = rtl8125_mac_ocp_read(tp, addr);
+        PhyRegValue &= ~clearmask;
+        PhyRegValue |= setmask;
+        rtl8125_mac_ocp_write(tp, addr, PhyRegValue);
+}
+
+static void
+ClearMcuAccessRegBit(
+        struct rtl8125_private *tp,
+        u16   addr,
+        u16   mask
+)
+{
+        ClearAndSetMcuAccessRegBit(tp,
+                                   addr,
+                                   mask,
+                                   0
+                                  );
+}
+
+static void
+SetMcuAccessRegBit(
+        struct rtl8125_private *tp,
+        u16   addr,
+        u16   mask
+)
+{
+        ClearAndSetMcuAccessRegBit(tp,
+                                   addr,
+                                   0,
+                                   mask
+                                  );
+}
+
+u32 rtl8125_ocp_read_with_oob_base_address(struct rtl8125_private *tp, u16 addr, u8 len, const u32 base_address)
+{
+        return rtl8125_eri_read_with_oob_base_address(tp, addr, len, ERIAR_OOB, base_address);
+}
+
+u32 rtl8125_ocp_read(struct rtl8125_private *tp, u16 addr, u8 len)
+{
+        u32 value = 0;
+
+        if (HW_DASH_SUPPORT_TYPE_2(tp))
+                value = rtl8125_ocp_read_with_oob_base_address(tp, addr, len, NO_BASE_ADDRESS);
+        else if (HW_DASH_SUPPORT_TYPE_3(tp))
+                value = rtl8125_ocp_read_with_oob_base_address(tp, addr, len, RTL8168FP_OOBMAC_BASE);
+
+        return value;
+}
+
+u32 rtl8125_ocp_write_with_oob_base_address(struct rtl8125_private *tp, u16 addr, u8 len, u32 value, const u32 base_address)
+{
+        return rtl8125_eri_write_with_oob_base_address(tp, addr, len, value, ERIAR_OOB, base_address);
+}
+
+void rtl8125_ocp_write(struct rtl8125_private *tp, u16 addr, u8 len, u32 value)
+{
+        if (HW_DASH_SUPPORT_TYPE_2(tp))
+                rtl8125_ocp_write_with_oob_base_address(tp, addr, len, value, NO_BASE_ADDRESS);
+        else if (HW_DASH_SUPPORT_TYPE_3(tp))
+                rtl8125_ocp_write_with_oob_base_address(tp, addr, len, value, RTL8168FP_OOBMAC_BASE);
+}
+
+void rtl8125_oob_mutex_lock(struct rtl8125_private *tp)
+{
+        u8 reg_16, reg_a0;
+        u32 wait_cnt_0, wait_Cnt_1;
+        u16 ocp_reg_mutex_ib;
+        u16 ocp_reg_mutex_oob;
+        u16 ocp_reg_mutex_prio;
+
+        if (!tp->DASH) return;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+        default:
+                ocp_reg_mutex_oob = 0x110;
+                ocp_reg_mutex_ib = 0x114;
+                ocp_reg_mutex_prio = 0x11C;
+                break;
+        }
+
+        rtl8125_ocp_write(tp, ocp_reg_mutex_ib, 1, BIT_0);
+        reg_16 = rtl8125_ocp_read(tp, ocp_reg_mutex_oob, 1);
+        wait_cnt_0 = 0;
+        while(reg_16) {
+                reg_a0 = rtl8125_ocp_read(tp, ocp_reg_mutex_prio, 1);
+                if (reg_a0) {
+                        rtl8125_ocp_write(tp, ocp_reg_mutex_ib, 1, 0x00);
+                        reg_a0 = rtl8125_ocp_read(tp, ocp_reg_mutex_prio, 1);
+                        wait_Cnt_1 = 0;
+                        while(reg_a0) {
+                                reg_a0 = rtl8125_ocp_read(tp, ocp_reg_mutex_prio, 1);
+
+                                wait_Cnt_1++;
+
+                                if (wait_Cnt_1 > 2000)
+                                        break;
+                        };
+                        rtl8125_ocp_write(tp, ocp_reg_mutex_ib, 1, BIT_0);
+
+                }
+                reg_16 = rtl8125_ocp_read(tp, ocp_reg_mutex_oob, 1);
+
+                wait_cnt_0++;
+
+                if (wait_cnt_0 > 2000)
+                        break;
+        };
+}
+
+void rtl8125_oob_mutex_unlock(struct rtl8125_private *tp)
+{
+        u16 ocp_reg_mutex_ib;
+        u16 ocp_reg_mutex_oob;
+        u16 ocp_reg_mutex_prio;
+
+        if (!tp->DASH) return;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+        default:
+                ocp_reg_mutex_oob = 0x110;
+                ocp_reg_mutex_ib = 0x114;
+                ocp_reg_mutex_prio = 0x11C;
+                break;
+        }
+
+        rtl8125_ocp_write(tp, ocp_reg_mutex_prio, 1, BIT_0);
+        rtl8125_ocp_write(tp, ocp_reg_mutex_ib, 1, 0x00);
+}
+
+void rtl8125_oob_notify(struct rtl8125_private *tp, u8 cmd)
+{
+        rtl8125_eri_write(tp, 0xE8, 1, cmd, ERIAR_ExGMAC);
+
+        rtl8125_ocp_write(tp, 0x30, 1, 0x01);
+}
+
+static int rtl8125_check_dash(struct rtl8125_private *tp)
+{
+        if (HW_DASH_SUPPORT_TYPE_2(tp) || HW_DASH_SUPPORT_TYPE_3(tp)) {
+                if (rtl8125_ocp_read(tp, 0x128, 1) & BIT_0)
+                        return 1;
+        }
+
+        return 0;
+}
+
+void rtl8125_dash2_disable_tx(struct rtl8125_private *tp)
+{
+        if (!tp->DASH) return;
+
+        if (HW_DASH_SUPPORT_TYPE_2(tp) || HW_DASH_SUPPORT_TYPE_3(tp)) {
+                u16 WaitCnt;
+                u8 TmpUchar;
+
+                //Disable oob Tx
+                RTL_CMAC_W8(tp, CMAC_IBCR2, RTL_CMAC_R8(tp, CMAC_IBCR2) & ~( BIT_0 ));
+                WaitCnt = 0;
+
+                //wait oob tx disable
+                do {
+                        TmpUchar = RTL_CMAC_R8(tp, CMAC_IBISR0);
+
+                        if ( TmpUchar & ISRIMR_DASH_TYPE2_TX_DISABLE_IDLE ) {
+                                break;
+                        }
+
+                        udelay( 50 );
+                        WaitCnt++;
+                } while(WaitCnt < 2000);
+
+                //Clear ISRIMR_DASH_TYPE2_TX_DISABLE_IDLE
+                RTL_CMAC_W8(tp, CMAC_IBISR0, RTL_CMAC_R8(tp, CMAC_IBISR0) | ISRIMR_DASH_TYPE2_TX_DISABLE_IDLE);
+        }
+}
+
+void rtl8125_dash2_enable_tx(struct rtl8125_private *tp)
+{
+        if (!tp->DASH) return;
+
+        if (HW_DASH_SUPPORT_TYPE_2(tp) || HW_DASH_SUPPORT_TYPE_3(tp)) {
+                RTL_CMAC_W8(tp, CMAC_IBCR2, RTL_CMAC_R8(tp, CMAC_IBCR2) | BIT_0);
+        }
+}
+
+void rtl8125_dash2_disable_rx(struct rtl8125_private *tp)
+{
+        if (!tp->DASH) return;
+
+        if (HW_DASH_SUPPORT_TYPE_2(tp) || HW_DASH_SUPPORT_TYPE_3(tp)) {
+                RTL_CMAC_W8(tp, CMAC_IBCR0, RTL_CMAC_R8(tp, CMAC_IBCR0) & ~( BIT_0 ));
+        }
+}
+
+void rtl8125_dash2_enable_rx(struct rtl8125_private *tp)
+{
+        if (!tp->DASH) return;
+
+        if (HW_DASH_SUPPORT_TYPE_2(tp) || HW_DASH_SUPPORT_TYPE_3(tp)) {
+                RTL_CMAC_W8(tp, CMAC_IBCR0, RTL_CMAC_R8(tp, CMAC_IBCR0) | BIT_0);
+        }
+}
+
+static void rtl8125_dash2_disable_txrx(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (HW_DASH_SUPPORT_TYPE_2(tp) || HW_DASH_SUPPORT_TYPE_3(tp)) {
+                rtl8125_dash2_disable_tx( tp );
+                rtl8125_dash2_disable_rx( tp );
+        }
+}
+
+static void rtl8125_driver_start(struct rtl8125_private *tp)
+{
+        if (!tp->DASH)
+                return;
+
+        if (HW_DASH_SUPPORT_TYPE_2(tp) || HW_DASH_SUPPORT_TYPE_3(tp)) {
+                int timeout;
+                u32 tmp_value;
+
+                rtl8125_ocp_write(tp, 0x180, 1, OOB_CMD_DRIVER_START);
+                tmp_value = rtl8125_ocp_read(tp, 0x30, 1);
+                tmp_value |= BIT_0;
+                rtl8125_ocp_write(tp, 0x30, 1, tmp_value);
+
+                for (timeout = 0; timeout < 10; timeout++) {
+                        mdelay(10);
+                        if (rtl8125_ocp_read(tp, 0x124, 1) & BIT_0)
+                                break;
+                }
+        }
+}
+
+static void rtl8125_driver_stop(struct rtl8125_private *tp)
+{
+        if (!tp->DASH)
+                return;
+
+        if (HW_DASH_SUPPORT_TYPE_2(tp) || HW_DASH_SUPPORT_TYPE_3(tp)) {
+                struct net_device *dev = tp->dev;
+                int timeout;
+                u32 tmp_value;
+
+                rtl8125_dash2_disable_txrx(dev);
+
+                rtl8125_ocp_write(tp, 0x180, 1, OOB_CMD_DRIVER_STOP);
+                tmp_value = rtl8125_ocp_read(tp, 0x30, 1);
+                tmp_value |= BIT_0;
+                rtl8125_ocp_write(tp, 0x30, 1, tmp_value);
+
+                for (timeout = 0; timeout < 10; timeout++) {
+                        mdelay(10);
+                        if (!(rtl8125_ocp_read(tp, 0x124, 1) & BIT_0))
+                                break;
+                }
+        }
+}
+
+void rtl8125_ephy_write(struct rtl8125_private *tp, int RegAddr, int value)
+{
+        int i;
+
+        RTL_W32(tp, EPHYAR,
+                EPHYAR_Write |
+                (RegAddr & EPHYAR_Reg_Mask_v2) << EPHYAR_Reg_shift |
+                (value & EPHYAR_Data_Mask));
+
+        for (i = 0; i < 10; i++) {
+                udelay(100);
+
+                /* Check if the RTL8125 has completed EPHY write */
+                if (!(RTL_R32(tp, EPHYAR) & EPHYAR_Flag))
+                        break;
+        }
+
+        udelay(20);
+}
+
+u16 rtl8125_ephy_read(struct rtl8125_private *tp, int RegAddr)
+{
+        int i;
+        u16 value = 0xffff;
+
+        RTL_W32(tp, EPHYAR,
+                EPHYAR_Read | (RegAddr & EPHYAR_Reg_Mask_v2) << EPHYAR_Reg_shift);
+
+        for (i = 0; i < 10; i++) {
+                udelay(100);
+
+                /* Check if the RTL8125 has completed EPHY read */
+                if (RTL_R32(tp, EPHYAR) & EPHYAR_Flag) {
+                        value = (u16) (RTL_R32(tp, EPHYAR) & EPHYAR_Data_Mask);
+                        break;
+                }
+        }
+
+        udelay(20);
+
+        return value;
+}
+
+static void ClearAndSetPCIePhyBit(struct rtl8125_private *tp, u8 addr, u16 clearmask, u16 setmask)
+{
+        u16 EphyValue;
+
+        EphyValue = rtl8125_ephy_read(tp, addr);
+        EphyValue &= ~clearmask;
+        EphyValue |= setmask;
+        rtl8125_ephy_write(tp, addr, EphyValue);
+}
+
+static void ClearPCIePhyBit(struct rtl8125_private *tp, u8 addr, u16 mask)
+{
+        ClearAndSetPCIePhyBit( tp,
+                               addr,
+                               mask,
+                               0
+                             );
+}
+
+static void SetPCIePhyBit( struct rtl8125_private *tp, u8 addr, u16 mask)
+{
+        ClearAndSetPCIePhyBit( tp,
+                               addr,
+                               0,
+                               mask
+                             );
+}
+
+static u32
+rtl8125_csi_other_fun_read(struct rtl8125_private *tp,
+                           u8 multi_fun_sel_bit,
+                           u32 addr)
+{
+        u32 cmd;
+        int i;
+        u32 value = 0;
+
+        cmd = CSIAR_Read | CSIAR_ByteEn << CSIAR_ByteEn_shift | (addr & CSIAR_Addr_Mask);
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT)
+                multi_fun_sel_bit = 0;
+
+        if (multi_fun_sel_bit > 7)
+                return 0xffffffff;
+
+        cmd |= multi_fun_sel_bit << 16;
+
+        RTL_W32(tp, CSIAR, cmd);
+
+        for (i = 0; i < 10; i++) {
+                udelay(100);
+
+                /* Check if the RTL8125 has completed CSI read */
+                if (RTL_R32(tp, CSIAR) & CSIAR_Flag) {
+                        value = (u32)RTL_R32(tp, CSIDR);
+                        break;
+                }
+        }
+
+        udelay(20);
+
+        return value;
+}
+
+static void
+rtl8125_csi_other_fun_write(struct rtl8125_private *tp,
+                            u8 multi_fun_sel_bit,
+                            u32 addr,
+                            u32 value)
+{
+        u32 cmd;
+        int i;
+
+        RTL_W32(tp, CSIDR, value);
+        cmd = CSIAR_Write | CSIAR_ByteEn << CSIAR_ByteEn_shift | (addr & CSIAR_Addr_Mask);
+        if (tp->mcfg == CFG_METHOD_DEFAULT)
+                multi_fun_sel_bit = 0;
+
+        if ( multi_fun_sel_bit > 7 )
+                return;
+
+        cmd |= multi_fun_sel_bit << 16;
+
+        RTL_W32(tp, CSIAR, cmd);
+
+        for (i = 0; i < 10; i++) {
+                udelay(100);
+
+                /* Check if the RTL8125 has completed CSI write */
+                if (!(RTL_R32(tp, CSIAR) & CSIAR_Flag))
+                        break;
+        }
+
+        udelay(20);
+}
+
+static u32
+rtl8125_csi_read(struct rtl8125_private *tp,
+                 u32 addr)
+{
+        u8 multi_fun_sel_bit;
+
+        multi_fun_sel_bit = 0;
+
+        return rtl8125_csi_other_fun_read(tp, multi_fun_sel_bit, addr);
+}
+
+static void
+rtl8125_csi_write(struct rtl8125_private *tp,
+                  u32 addr,
+                  u32 value)
+{
+        u8 multi_fun_sel_bit;
+
+        multi_fun_sel_bit = 0;
+
+        rtl8125_csi_other_fun_write(tp, multi_fun_sel_bit, addr, value);
+}
+
+static u8
+rtl8125_csi_fun0_read_byte(struct rtl8125_private *tp,
+                           u32 addr)
+{
+        u8 RetVal = 0;
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT) {
+                struct pci_dev *pdev = tp->pci_dev;
+
+                pci_read_config_byte(pdev, addr, &RetVal);
+        } else {
+                u32 TmpUlong;
+                u16 RegAlignAddr;
+                u8 ShiftByte;
+
+                RegAlignAddr = addr & ~(0x3);
+                ShiftByte = addr & (0x3);
+                TmpUlong = rtl8125_csi_other_fun_read(tp, 0, addr);
+                TmpUlong >>= (8*ShiftByte);
+                RetVal = (u8)TmpUlong;
+        }
+
+        udelay(20);
+
+        return RetVal;
+}
+
+static void
+rtl8125_csi_fun0_write_byte(struct rtl8125_private *tp,
+                            u32 addr,
+                            u8 value)
+{
+        if (tp->mcfg == CFG_METHOD_DEFAULT) {
+                struct pci_dev *pdev = tp->pci_dev;
+
+                pci_write_config_byte(pdev, addr, value);
+        } else {
+                u32 TmpUlong;
+                u16 RegAlignAddr;
+                u8 ShiftByte;
+
+                RegAlignAddr = addr & ~(0x3);
+                ShiftByte = addr & (0x3);
+                TmpUlong = rtl8125_csi_other_fun_read(tp, 0, RegAlignAddr);
+                TmpUlong &= ~(0xFF << (8*ShiftByte));
+                TmpUlong |= (value << (8*ShiftByte));
+                rtl8125_csi_other_fun_write( tp, 0, RegAlignAddr, TmpUlong );
+        }
+
+        udelay(20);
+}
+
+u32 rtl8125_eri_read_with_oob_base_address(struct rtl8125_private *tp, int addr, int len, int type, const u32 base_address)
+{
+        int i, val_shift, shift = 0;
+        u32 value1 = 0, value2 = 0, mask;
+        u32 eri_cmd;
+        const u32 transformed_base_address = ((base_address & 0x00FFF000) << 6) | (base_address & 0x000FFF);
+
+        if (len > 4 || len <= 0)
+                return -1;
+
+        while (len > 0) {
+                val_shift = addr % ERIAR_Addr_Align;
+                addr = addr & ~0x3;
+
+                eri_cmd = ERIAR_Read |
+                          transformed_base_address |
+                          type << ERIAR_Type_shift |
+                          ERIAR_ByteEn << ERIAR_ByteEn_shift |
+                          (addr & 0x0FFF);
+                if (addr & 0xF000) {
+                        u32 tmp;
+
+                        tmp = addr & 0xF000;
+                        tmp >>= 12;
+                        eri_cmd |= (tmp << 20) & 0x00F00000;
+                }
+
+                RTL_W32(tp, ERIAR, eri_cmd);
+
+                for (i = 0; i < 10; i++) {
+                        udelay(100);
+
+                        /* Check if the RTL8125 has completed ERI read */
+                        if (RTL_R32(tp, ERIAR) & ERIAR_Flag)
+                                break;
+                }
+
+                if (len == 1)       mask = (0xFF << (val_shift * 8)) & 0xFFFFFFFF;
+                else if (len == 2)  mask = (0xFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+                else if (len == 3)  mask = (0xFFFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+                else            mask = (0xFFFFFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+
+                value1 = RTL_R32(tp, ERIDR) & mask;
+                value2 |= (value1 >> val_shift * 8) << shift * 8;
+
+                if (len <= 4 - val_shift) {
+                        len = 0;
+                } else {
+                        len -= (4 - val_shift);
+                        shift = 4 - val_shift;
+                        addr += 4;
+                }
+        }
+
+        udelay(20);
+
+        return value2;
+}
+
+u32 rtl8125_eri_read(struct rtl8125_private *tp, int addr, int len, int type)
+{
+        return rtl8125_eri_read_with_oob_base_address(tp, addr, len, type, 0);
+}
+
+int rtl8125_eri_write_with_oob_base_address(struct rtl8125_private *tp, int addr, int len, u32 value, int type, const u32 base_address)
+{
+        int i, val_shift, shift = 0;
+        u32 value1 = 0, mask;
+        u32 eri_cmd;
+        const u32 transformed_base_address = ((base_address & 0x00FFF000) << 6) | (base_address & 0x000FFF);
+
+        if (len > 4 || len <= 0)
+                return -1;
+
+        while (len > 0) {
+                val_shift = addr % ERIAR_Addr_Align;
+                addr = addr & ~0x3;
+
+                if (len == 1)       mask = (0xFF << (val_shift * 8)) & 0xFFFFFFFF;
+                else if (len == 2)  mask = (0xFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+                else if (len == 3)  mask = (0xFFFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+                else            mask = (0xFFFFFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+
+                value1 = rtl8125_eri_read_with_oob_base_address(tp, addr, 4, type, base_address) & ~mask;
+                value1 |= ((value << val_shift * 8) >> shift * 8);
+
+                RTL_W32(tp, ERIDR, value1);
+
+                eri_cmd = ERIAR_Write |
+                          transformed_base_address |
+                          type << ERIAR_Type_shift |
+                          ERIAR_ByteEn << ERIAR_ByteEn_shift |
+                          (addr & 0x0FFF);
+                if (addr & 0xF000) {
+                        u32 tmp;
+
+                        tmp = addr & 0xF000;
+                        tmp >>= 12;
+                        eri_cmd |= (tmp << 20) & 0x00F00000;
+                }
+
+                RTL_W32(tp, ERIAR, eri_cmd);
+
+                for (i = 0; i < 10; i++) {
+                        udelay(100);
+
+                        /* Check if the RTL8125 has completed ERI write */
+                        if (!(RTL_R32(tp, ERIAR) & ERIAR_Flag))
+                                break;
+                }
+
+                if (len <= 4 - val_shift) {
+                        len = 0;
+                } else {
+                        len -= (4 - val_shift);
+                        shift = 4 - val_shift;
+                        addr += 4;
+                }
+        }
+
+        udelay(20);
+
+        return 0;
+}
+
+int rtl8125_eri_write(struct rtl8125_private *tp, int addr, int len, u32 value, int type)
+{
+        return rtl8125_eri_write_with_oob_base_address(tp, addr, len, value, type, NO_BASE_ADDRESS);
+}
+
+static void
+rtl8125_enable_rxdvgate(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                RTL_W8(tp, 0xF2, RTL_R8(tp, 0xF2) | BIT_3);
+                mdelay(2);
+                break;
+        }
+}
+
+static void
+rtl8125_disable_rxdvgate(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                RTL_W8(tp, 0xF2, RTL_R8(tp, 0xF2) & ~BIT_3);
+                mdelay(2);
+                break;
+        }
+}
+
+static u8
+rtl8125_is_gpio_low(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u8 gpio_low = FALSE;
+
+        switch (tp->HwSuppCheckPhyDisableModeVer) {
+        case 3:
+                if (!(rtl8125_mac_ocp_read(tp, 0xDC04) & BIT_13))
+                        gpio_low = TRUE;
+                break;
+        }
+
+        if (gpio_low)
+                dprintk("gpio is low.\n");
+
+        return gpio_low;
+}
+
+static u8
+rtl8125_is_phy_disable_mode_enabled(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u8 phy_disable_mode_enabled = FALSE;
+
+        switch (tp->HwSuppCheckPhyDisableModeVer) {
+        case 3:
+                if (RTL_R8(tp, 0xF2) & BIT_5)
+                        phy_disable_mode_enabled = TRUE;
+                break;
+        }
+
+        if (phy_disable_mode_enabled)
+                dprintk("phy disable mode enabled.\n");
+
+        return phy_disable_mode_enabled;
+}
+
+static u8
+rtl8125_is_in_phy_disable_mode(struct net_device *dev)
+{
+        u8 in_phy_disable_mode = FALSE;
+
+        if (rtl8125_is_phy_disable_mode_enabled(dev) && rtl8125_is_gpio_low(dev))
+                in_phy_disable_mode = TRUE;
+
+        if (in_phy_disable_mode)
+                dprintk("Hardware is in phy disable mode.\n");
+
+        return in_phy_disable_mode;
+}
+
+static bool
+rtl8125_stop_all_request(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+
+        RTL_W8(tp, ChipCmd, RTL_R8(tp, ChipCmd) | StopReq);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                for (i = 0; i < 20; i++) {
+                        udelay(10);
+                        if (!(RTL_R8(tp, ChipCmd) & StopReq)) break;
+                }
+
+                if (i == 20)
+                        return 0;
+                break;
+        }
+
+        return 1;
+}
+
+void
+rtl8125_wait_txrx_fifo_empty(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                rtl8125_stop_all_request(dev);
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                for (i = 0; i < 3000; i++) {
+                        udelay(50);
+                        if ((RTL_R8(tp, MCUCmd_reg) & (Txfifo_empty | Rxfifo_empty)) == (Txfifo_empty | Rxfifo_empty))
+                                break;
+                }
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                for (i = 0; i < 3000; i++) {
+                        udelay(50);
+                        if ((RTL_R16(tp, IntrMitigate) & (BIT_0 | BIT_1 | BIT_8)) == (BIT_0 | BIT_1 | BIT_8))
+                                break;
+                }
+                break;
+        }
+}
+
+#ifdef ENABLE_DASH_SUPPORT
+
+static inline void
+rtl8125_enable_dash2_interrupt(struct rtl8125_private *tp)
+{
+        if (!tp->DASH) return;
+
+        if (HW_DASH_SUPPORT_TYPE_2(tp) || HW_DASH_SUPPORT_TYPE_3(tp)) {
+                RTL_CMAC_W8(tp, CMAC_IBIMR0, ( ISRIMR_DASH_TYPE2_ROK | ISRIMR_DASH_TYPE2_TOK | ISRIMR_DASH_TYPE2_TDU | ISRIMR_DASH_TYPE2_RDU | ISRIMR_DASH_TYPE2_RX_DISABLE_IDLE ));
+        }
+}
+
+static inline void
+rtl8125_disable_dash2_interrupt(struct rtl8125_private *tp)
+{
+        if (!tp->DASH) return;
+
+        if (HW_DASH_SUPPORT_TYPE_2(tp) || HW_DASH_SUPPORT_TYPE_3(tp)) {
+                RTL_CMAC_W8(tp, CMAC_IBIMR0, 0);
+        }
+}
+#endif
+
+void
+rtl8125_enable_hw_linkchg_interrupt(struct rtl8125_private *tp)
+{
+        switch (tp->HwCurrIsrVer) {
+        case 2:
+                RTL_W32(tp, IMR_V2_SET_REG_8125, ISRIMR_V2_LINKCHG);
+                break;
+        case 1:
+                RTL_W32(tp, tp->imr_reg[0], LinkChg | RTL_R32(tp, tp->imr_reg[0]));
+                break;
+        }
+
+#ifdef ENABLE_DASH_SUPPORT
+        if (tp->DASH)
+                rtl8125_enable_dash2_interrupt(tp);
+#endif
+}
+
+static inline void
+rtl8125_enable_hw_interrupt(struct rtl8125_private *tp)
+{
+        switch (tp->HwCurrIsrVer) {
+        case 2:
+                RTL_W32(tp, IMR_V2_SET_REG_8125, tp->intr_mask);
+                break;
+        case 1:
+                RTL_W32(tp, tp->imr_reg[0], tp->intr_mask);
+
+                if (R8125_MULTI_RX_Q(tp)) {
+                        int i;
+                        for (i=1; i<tp->num_rx_rings; i++)
+                                RTL_W16(tp, tp->imr_reg[i], other_q_intr_mask);
+                }
+                break;
+        }
+
+#ifdef ENABLE_DASH_SUPPORT
+        if (tp->DASH)
+                rtl8125_enable_dash2_interrupt(tp);
+#endif
+}
+
+static inline void rtl8125_clear_hw_isr_v2(struct rtl8125_private *tp,
+                u32 message_id)
+{
+        RTL_W32(tp, ISR_V2_8125, BIT(message_id));
+}
+
+static inline void
+rtl8125_disable_hw_interrupt(struct rtl8125_private *tp)
+{
+        if (tp->HwCurrIsrVer == 2) {
+                RTL_W32(tp, IMR_V2_CLEAR_REG_8125, 0xFFFFFFFF);
+        } else {
+                RTL_W32(tp, tp->imr_reg[0], 0x0000);
+
+                if (R8125_MULTI_RX_Q(tp)) {
+                        int i;
+                        for (i=1; i<tp->num_rx_rings; i++)
+                                RTL_W16(tp, tp->imr_reg[i], 0);
+                }
+
+#ifdef ENABLE_DASH_SUPPORT
+                if (tp->DASH)
+                        rtl8125_disable_dash2_interrupt(tp);
+#endif
+        }
+}
+
+static inline void
+rtl8125_switch_to_hw_interrupt(struct rtl8125_private *tp)
+{
+        RTL_W32(tp, TIMER_INT0_8125, 0x0000);
+
+        rtl8125_enable_hw_interrupt(tp);
+}
+
+static inline void
+rtl8125_switch_to_timer_interrupt(struct rtl8125_private *tp)
+{
+        if (tp->use_timer_interrrupt) {
+                RTL_W32(tp, TIMER_INT0_8125, timer_count);
+                RTL_W32(tp, TCTR0_8125, timer_count);
+                RTL_W32(tp, tp->imr_reg[0], tp->timer_intr_mask);
+
+#ifdef ENABLE_DASH_SUPPORT
+                if (tp->DASH)
+                        rtl8125_enable_dash2_interrupt(tp);
+#endif
+        } else {
+                rtl8125_switch_to_hw_interrupt(tp);
+        }
+}
+
+static void
+rtl8125_irq_mask_and_ack(struct rtl8125_private *tp)
+{
+        rtl8125_disable_hw_interrupt(tp);
+
+        if (tp->HwCurrIsrVer == 2) {
+                RTL_W32(tp, ISR_V2_8125, 0xFFFFFFFF);
+        } else {
+#ifdef ENABLE_DASH_SUPPORT
+                if (tp->DASH) {
+                        if (tp->dash_printer_enabled) {
+                                RTL_W32(tp, tp->isr_reg[0], RTL_R32(tp, tp->isr_reg[0]) &
+                                        ~(ISRIMR_DASH_INTR_EN | ISRIMR_DASH_INTR_CMAC_RESET));
+                        } else {
+                                if (HW_DASH_SUPPORT_TYPE_2(tp) || HW_DASH_SUPPORT_TYPE_3(tp)) {
+                                        RTL_CMAC_W8(tp, CMAC_IBISR0, RTL_CMAC_R8(tp, CMAC_IBISR0));
+                                }
+                        }
+                } else {
+                        RTL_W32(tp, tp->isr_reg[0], RTL_R32(tp, tp->isr_reg[0]));
+                }
+#else
+                RTL_W32(tp, tp->isr_reg[0], RTL_R32(tp, tp->isr_reg[0]));
+#endif
+                if (R8125_MULTI_RX_Q(tp)) {
+                        int i;
+                        for (i=1; i<tp->num_rx_rings; i++)
+                                RTL_W16(tp, tp->isr_reg[i], RTL_R16(tp, tp->isr_reg[i]));
+                }
+        }
+}
+
+static void
+rtl8125_nic_reset(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+
+        RTL_W32(tp, RxConfig, (RX_DMA_BURST << RxCfgDMAShift));
+
+        rtl8125_enable_rxdvgate(dev);
+
+        rtl8125_stop_all_request(dev);
+
+        rtl8125_wait_txrx_fifo_empty(dev);
+
+        mdelay(2);
+
+        /* Soft reset the chip. */
+        RTL_W8(tp, ChipCmd, CmdReset);
+
+        /* Check that the chip has finished the reset. */
+        for (i = 100; i > 0; i--) {
+                udelay(100);
+                if ((RTL_R8(tp, ChipCmd) & CmdReset) == 0)
+                        break;
+        }
+}
+
+static void
+rtl8125_hw_set_interrupt_type(struct rtl8125_private *tp, u8 isr_ver)
+{
+        u8 tmp;
+
+        switch (tp->HwSuppIsrVer) {
+        case 2:
+                tmp = RTL_R8(tp, INT_CFG0_8125);
+                tmp &= ~(INT_CFG0_ENABLE_8125);
+                if (isr_ver == 2)
+                        tmp |= INT_CFG0_ENABLE_8125;
+                RTL_W8(tp, INT_CFG0_8125, tmp);
+                break;
+        }
+}
+
+static void
+rtl8125_hw_clear_timer_int(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                RTL_W32(tp, TIMER_INT0_8125, 0x0000);
+                RTL_W32(tp, TIMER_INT1_8125, 0x0000);
+                RTL_W32(tp, TIMER_INT2_8125, 0x0000);
+                RTL_W32(tp, TIMER_INT3_8125, 0x0000);
+                break;
+        }
+}
+
+static void
+rtl8125_hw_clear_int_miti(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+
+        switch (tp->HwSuppIntMitiVer) {
+        case 3:
+                //IntMITI_0-IntMITI_31
+                for (i=0xA00; i<0xB00; i+=4)
+                        RTL_W32(tp, i, 0x0000);
+                break;
+        case 4:
+                //IntMITI_0-IntMITI_15
+                for (i = 0xA00; i < 0xA80; i += 4)
+                        RTL_W32(tp, i, 0x0000);
+
+                RTL_W8(tp, INT_CFG0_8125, RTL_R8(tp, INT_CFG0_8125) &
+                       ~(INT_CFG0_TIMEOUT0_BYPASS_8125 | INT_CFG0_MITIGATION_BYPASS_8125));
+
+                RTL_W16(tp, INT_CFG1_8125, 0x0000);
+                break;
+        }
+}
+
+void
+rtl8125_hw_set_timer_int_8125(struct rtl8125_private *tp,
+                              u32 message_id,
+                              u8 timer_intmiti_val)
+{
+        switch (tp->HwSuppIntMitiVer) {
+        case 4:
+#ifdef ENABLE_LIB_SUPPORT
+                if (message_id < R8125_MAX_RX_QUEUES_VEC_V3)
+                        timer_intmiti_val = 0;
+#else
+                if (tp->EnableRss && (message_id < R8125_MAX_RX_QUEUES_VEC_V3))
+                        timer_intmiti_val = 0;
+#endif //ENABLE_LIB_SUPPORT
+                if (message_id < R8125_MAX_RX_QUEUES_VEC_V3) //ROK
+                        RTL_W8(tp,INT_MITI_V2_0_RX + 8 * message_id, timer_intmiti_val);
+                else if (message_id == 16) //TOK
+                        RTL_W8(tp,INT_MITI_V2_0_TX, timer_intmiti_val);
+                else if (message_id == 18) //TOK
+                        RTL_W8(tp,INT_MITI_V2_1_TX, timer_intmiti_val);
+                break;
+        }
+}
+
+void
+rtl8125_hw_reset(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_lib_reset_prepare(tp);
+
+        /* Disable interrupts */
+        rtl8125_irq_mask_and_ack(tp);
+
+        rtl8125_hw_clear_timer_int(dev);
+
+        rtl8125_nic_reset(dev);
+}
+
+static unsigned int
+rtl8125_xmii_reset_pending(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        unsigned int retval;
+
+        rtl8125_mdio_write(tp, 0x1f, 0x0000);
+        retval = rtl8125_mdio_read(tp, MII_BMCR) & BMCR_RESET;
+
+        return retval;
+}
+
+static unsigned int
+rtl8125_xmii_link_ok(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        unsigned int retval;
+
+        retval = (RTL_R16(tp, PHYstatus) & LinkStatus) ? 1 : 0;
+
+        return retval;
+}
+
+static int
+rtl8125_wait_phy_reset_complete(struct rtl8125_private *tp)
+{
+        int i, val;
+
+        for (i = 0; i < 2500; i++) {
+                val = rtl8125_mdio_read(tp, MII_BMCR) & BMCR_RESET;
+                if (!val)
+                        return 0;
+
+                mdelay(1);
+        }
+
+        return -1;
+}
+
+static void
+rtl8125_xmii_reset_enable(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (rtl8125_is_in_phy_disable_mode(dev)) {
+                return;
+        }
+
+        rtl8125_mdio_write(tp, 0x1f, 0x0000);
+        rtl8125_mdio_write(tp, MII_ADVERTISE, rtl8125_mdio_read(tp, MII_ADVERTISE) &
+                           ~(ADVERTISE_10HALF | ADVERTISE_10FULL |
+                             ADVERTISE_100HALF | ADVERTISE_100FULL));
+        rtl8125_mdio_write(tp, MII_CTRL1000, rtl8125_mdio_read(tp, MII_CTRL1000) &
+                           ~(ADVERTISE_1000HALF | ADVERTISE_1000FULL));
+        mdio_direct_write_phy_ocp(tp, 0xA5D4, mdio_direct_read_phy_ocp(tp, 0xA5D4) & ~(RTK_ADVERTISE_2500FULL));
+        rtl8125_mdio_write(tp, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
+
+        if (rtl8125_wait_phy_reset_complete(tp) == 0) return;
+
+        if (netif_msg_link(tp))
+                printk(KERN_ERR "%s: PHY reset failed.\n", dev->name);
+}
+
+void
+rtl8125_init_ring_indexes(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i = 0; i < tp->HwSuppNumTxQueues; i++) {
+                struct rtl8125_tx_ring *ring = &tp->tx_ring[i];
+                ring->dirty_tx = ring->cur_tx = 0;
+                ring->NextHwDesCloPtr = 0;
+                ring->BeginHwDesCloPtr = 0;
+                ring->index = i;
+                ring->priv = tp;
+        }
+
+        for (i = 0; i < tp->HwSuppNumRxQueues; i++) {
+                struct rtl8125_rx_ring *ring = &tp->rx_ring[i];
+                ring->dirty_rx = ring->cur_rx = 0;
+                ring->index = i;
+                ring->priv = tp;
+        }
+
+#ifdef ENABLE_LIB_SUPPORT
+        for (i = 0; i < tp->HwSuppNumTxQueues; i++) {
+                struct rtl8125_ring *ring = &tp->lib_tx_ring[i];
+                ring->direction = RTL8125_CH_DIR_TX;
+                ring->queue_num = i;
+                ring->private = tp;
+        }
+
+        for (i = 0; i < tp->HwSuppNumRxQueues; i++) {
+                struct rtl8125_ring *ring = &tp->lib_rx_ring[i];
+                ring->direction = RTL8125_CH_DIR_RX;
+                ring->queue_num = i;
+                ring->private = tp;
+        }
+#endif
+}
+
+static void
+rtl8125_issue_offset_99_event(struct rtl8125_private *tp)
+{
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                rtl8125_mac_ocp_write(tp, 0xE09A,  rtl8125_mac_ocp_read(tp, 0xE09A) | BIT_0);
+                break;
+        }
+}
+
+#ifdef ENABLE_DASH_SUPPORT
+static void
+NICChkTypeEnableDashInterrupt(struct rtl8125_private *tp)
+{
+        if (tp->DASH) {
+                //
+                // even disconnected, enable 3 dash interrupt mask bits for in-band/out-band communication
+                //
+                if (HW_DASH_SUPPORT_TYPE_2(tp) || HW_DASH_SUPPORT_TYPE_3(tp)) {
+                        rtl8125_enable_dash2_interrupt(tp);
+                        RTL_W16(tp, IntrMask, (ISRIMR_DASH_INTR_EN | ISRIMR_DASH_INTR_CMAC_RESET));
+                }
+        }
+}
+#endif
+
+static int rtl8125_enable_eee_plus(struct rtl8125_private *tp)
+{
+        int ret;
+
+        ret = 0;
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                rtl8125_mac_ocp_write(tp, 0xE080, rtl8125_mac_ocp_read(tp, 0xE080)|BIT_1);
+                break;
+
+        default:
+//      dev_printk(KERN_DEBUG, tp_to_dev(tp), "Not Support EEEPlus\n");
+                ret = -EOPNOTSUPP;
+                break;
+        }
+
+        return ret;
+}
+
+static int rtl8125_disable_eee_plus(struct rtl8125_private *tp)
+{
+        int ret;
+
+        ret = 0;
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                rtl8125_mac_ocp_write(tp, 0xE080, rtl8125_mac_ocp_read(tp, 0xE080)&~BIT_1);
+                break;
+
+        default:
+//      dev_printk(KERN_DEBUG, tp_to_dev(tp), "Not Support EEEPlus\n");
+                ret = -EOPNOTSUPP;
+                break;
+        }
+
+        return ret;
+}
+
+static void
+rtl8125_link_on_patch(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_hw_config(dev);
+
+        if ((tp->mcfg == CFG_METHOD_2) &&
+            netif_running(dev)) {
+                if (RTL_R16(tp, PHYstatus)&FullDup)
+                        RTL_W32(tp, TxConfig, (RTL_R32(tp, TxConfig) | (BIT_24 | BIT_25)) & ~BIT_19);
+                else
+                        RTL_W32(tp, TxConfig, (RTL_R32(tp, TxConfig) | BIT_25) & ~(BIT_19 | BIT_24));
+        }
+
+        if ((tp->mcfg == CFG_METHOD_2 ||
+             tp->mcfg == CFG_METHOD_3 ||
+             tp->mcfg == CFG_METHOD_4 ||
+             tp->mcfg == CFG_METHOD_5 ||
+             tp->mcfg == CFG_METHOD_6 ||
+             tp->mcfg == CFG_METHOD_7) &&
+            (RTL_R8(tp, PHYstatus) & _10bps))
+                rtl8125_enable_eee_plus(tp);
+
+        rtl8125_hw_start(dev);
+
+        netif_carrier_on(dev);
+
+        netif_tx_wake_all_queues(dev);
+
+        tp->phy_reg_aner = rtl8125_mdio_read(tp, MII_EXPANSION);
+        tp->phy_reg_anlpar = rtl8125_mdio_read(tp, MII_LPA);
+        tp->phy_reg_gbsr = rtl8125_mdio_read(tp, MII_STAT1000);
+        tp->phy_reg_status_2500 = mdio_direct_read_phy_ocp(tp, 0xA5D6);
+}
+
+static void
+rtl8125_link_down_patch(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        tp->phy_reg_aner = 0;
+        tp->phy_reg_anlpar = 0;
+        tp->phy_reg_gbsr = 0;
+        tp->phy_reg_status_2500 = 0;
+
+        if (tp->mcfg == CFG_METHOD_2 ||
+            tp->mcfg == CFG_METHOD_3 ||
+            tp->mcfg == CFG_METHOD_4 ||
+            tp->mcfg == CFG_METHOD_5 ||
+            tp->mcfg == CFG_METHOD_6 ||
+            tp->mcfg == CFG_METHOD_7)
+                rtl8125_disable_eee_plus(tp);
+
+        netif_tx_stop_all_queues(dev);
+
+        netif_carrier_off(dev);
+
+        rtl8125_hw_reset(dev);
+
+        rtl8125_tx_clear(tp);
+
+        rtl8125_rx_clear(tp);
+
+        rtl8125_init_ring(dev);
+
+        rtl8125_enable_hw_linkchg_interrupt(tp);
+
+        //rtl8125_set_speed(dev, tp->autoneg, tp->speed, tp->duplex, tp->advertising);
+
+#ifdef ENABLE_DASH_SUPPORT
+        if (tp->DASH) {
+                NICChkTypeEnableDashInterrupt(tp);
+        }
+#endif
+}
+
+static void
+_rtl8125_check_link_status(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (tp->link_ok(dev)) {
+                rtl8125_link_on_patch(dev);
+
+                if (netif_msg_ifup(tp))
+                        printk(KERN_INFO PFX "%s: link up\n", dev->name);
+        } else {
+                if (netif_msg_ifdown(tp))
+                        printk(KERN_INFO PFX "%s: link down\n", dev->name);
+
+                rtl8125_link_down_patch(dev);
+        }
+}
+
+static void
+rtl8125_check_link_status(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        _rtl8125_check_link_status(dev);
+
+        tp->resume_not_chg_speed = 0;
+}
+
+static void
+rtl8125_link_option_giga(u8 *aut,
+                         u32 *spd,
+                         u8 *dup,
+                         u32 *adv)
+{
+        if ((*spd != SPEED_1000) &&
+            (*spd != SPEED_100) &&
+            (*spd != SPEED_10))
+                *spd = SPEED_1000;
+
+        if ((*dup != DUPLEX_FULL) && (*dup != DUPLEX_HALF))
+                *dup = DUPLEX_FULL;
+
+        if ((*aut != AUTONEG_ENABLE) && (*aut != AUTONEG_DISABLE))
+                *aut = AUTONEG_ENABLE;
+
+        *adv &= (ADVERTISED_10baseT_Half |
+                 ADVERTISED_10baseT_Full |
+                 ADVERTISED_100baseT_Half |
+                 ADVERTISED_100baseT_Full |
+                 ADVERTISED_1000baseT_Half |
+                 ADVERTISED_1000baseT_Full);
+        if (*adv == 0)
+                *adv = (ADVERTISED_10baseT_Half |
+                        ADVERTISED_10baseT_Full |
+                        ADVERTISED_100baseT_Half |
+                        ADVERTISED_100baseT_Full |
+                        ADVERTISED_1000baseT_Half |
+                        ADVERTISED_1000baseT_Full);
+}
+
+static void
+rtl8125_link_option(u8 *aut,
+                    u32 *spd,
+                    u8 *dup,
+                    u32 *adv)
+{
+        if ((*spd != SPEED_2500) && (*spd != SPEED_1000) &&
+            (*spd != SPEED_100) && (*spd != SPEED_10))
+                *spd = SPEED_2500;
+
+        if ((*dup != DUPLEX_FULL) && (*dup != DUPLEX_HALF))
+                *dup = DUPLEX_FULL;
+
+        if ((*aut != AUTONEG_ENABLE) && (*aut != AUTONEG_DISABLE))
+                *aut = AUTONEG_ENABLE;
+
+        *adv &= (ADVERTISED_10baseT_Half |
+                 ADVERTISED_10baseT_Full |
+                 ADVERTISED_100baseT_Half |
+                 ADVERTISED_100baseT_Full |
+                 ADVERTISED_1000baseT_Half |
+                 ADVERTISED_1000baseT_Full |
+                 ADVERTISED_2500baseX_Full);
+        if (*adv == 0)
+                *adv = (ADVERTISED_10baseT_Half |
+                        ADVERTISED_10baseT_Full |
+                        ADVERTISED_100baseT_Half |
+                        ADVERTISED_100baseT_Full |
+                        ADVERTISED_1000baseT_Half |
+                        ADVERTISED_1000baseT_Full |
+                        ADVERTISED_2500baseX_Full);
+}
+
+/*
+static void
+rtl8125_enable_ocp_phy_power_saving(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u16 val;
+
+         if (tp->mcfg == CFG_METHOD_2 ||
+             tp->mcfg == CFG_METHOD_3 ||
+             tp->mcfg == CFG_METHOD_4 ||
+			 tp->mcfg == CFG_METHOD_5 ||
+			 tp->mcfg == CFG_METHOD_6 ||
+			 tp->mcfg == CFG_METHOD_7) {
+                val = mdio_direct_read_phy_ocp(tp, 0xC416);
+                if (val != 0x0050) {
+                        rtl8125_set_phy_mcu_patch_request(tp);
+                        mdio_direct_write_phy_ocp(tp, 0xC416, 0x0000);
+                        mdio_direct_write_phy_ocp(tp, 0xC416, 0x0050);
+                        rtl8125_clear_phy_mcu_patch_request(tp);
+                }
+        }
+}
+*/
+
+static void
+rtl8125_disable_ocp_phy_power_saving(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u16 val;
+
+        if (tp->mcfg == CFG_METHOD_2 ||
+            tp->mcfg == CFG_METHOD_3 ||
+            tp->mcfg == CFG_METHOD_4 ||
+            tp->mcfg == CFG_METHOD_5 ||
+            tp->mcfg == CFG_METHOD_6 ||
+            tp->mcfg == CFG_METHOD_7) {
+                val = mdio_direct_read_phy_ocp(tp, 0xC416);
+                if (val != 0x0500) {
+                        rtl8125_set_phy_mcu_patch_request(tp);
+                        mdio_direct_write_phy_ocp(tp, 0xC416, 0x0000);
+                        mdio_direct_write_phy_ocp(tp, 0xC416, 0x0500);
+                        rtl8125_clear_phy_mcu_patch_request(tp);
+                }
+        }
+}
+
+static void
+rtl8125_wait_ll_share_fifo_ready(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+
+        for (i = 0; i < 10; i++) {
+                udelay(100);
+                if (RTL_R16(tp, 0xD2) & BIT_9)
+                        break;
+        }
+}
+
+static void
+rtl8125_disable_pci_offset_99(struct rtl8125_private *tp)
+{
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                rtl8125_mac_ocp_write(tp, 0xE032,  rtl8125_mac_ocp_read(tp, 0xE032) & ~(BIT_0 | BIT_1));
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                rtl8125_csi_fun0_write_byte(tp, 0x99, 0x00);
+                break;
+        }
+}
+
+static void
+rtl8125_enable_pci_offset_99(struct rtl8125_private *tp)
+{
+        u32 csi_tmp;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                rtl8125_csi_fun0_write_byte(tp, 0x99, tp->org_pci_offset_99);
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                csi_tmp = rtl8125_mac_ocp_read(tp, 0xE032);
+                csi_tmp &= ~(BIT_0 | BIT_1);
+                if (tp->org_pci_offset_99 & (BIT_5 | BIT_6))
+                        csi_tmp |= BIT_1;
+                if (tp->org_pci_offset_99 & BIT_2)
+                        csi_tmp |= BIT_0;
+                rtl8125_mac_ocp_write(tp, 0xE032, csi_tmp);
+                break;
+        }
+}
+
+static void
+rtl8125_init_pci_offset_99(struct rtl8125_private *tp)
+{
+        u32 csi_tmp;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                rtl8125_mac_ocp_write(tp, 0xCDD0, 0x9003);
+                csi_tmp = rtl8125_mac_ocp_read(tp, 0xE034);
+                csi_tmp |= (BIT_15 | BIT_14);
+                rtl8125_mac_ocp_write(tp, 0xE034, csi_tmp);
+                rtl8125_mac_ocp_write(tp, 0xCDD2, 0x889C);
+                rtl8125_mac_ocp_write(tp, 0xCDD8, 0x9003);
+                rtl8125_mac_ocp_write(tp, 0xCDD4, 0x8C30);
+                rtl8125_mac_ocp_write(tp, 0xCDDA, 0x9003);
+                rtl8125_mac_ocp_write(tp, 0xCDD6, 0x9003);
+                rtl8125_mac_ocp_write(tp, 0xCDDC, 0x9003);
+                rtl8125_mac_ocp_write(tp, 0xCDE8, 0x883E);
+                rtl8125_mac_ocp_write(tp, 0xCDEA, 0x9003);
+                rtl8125_mac_ocp_write(tp, 0xCDEC, 0x889C);
+                rtl8125_mac_ocp_write(tp, 0xCDEE, 0x9003);
+                rtl8125_mac_ocp_write(tp, 0xCDF0, 0x8C09);
+                rtl8125_mac_ocp_write(tp, 0xCDF2, 0x9003);
+                csi_tmp = rtl8125_mac_ocp_read(tp, 0xE032);
+                csi_tmp |= (BIT_14);
+                rtl8125_mac_ocp_write(tp, 0xE032, csi_tmp);
+                csi_tmp = rtl8125_mac_ocp_read(tp, 0xE0A2);
+                csi_tmp |= (BIT_0);
+                rtl8125_mac_ocp_write(tp, 0xE0A2, csi_tmp);
+                break;
+        }
+
+        rtl8125_enable_pci_offset_99(tp);
+}
+
+static void
+rtl8125_disable_pci_offset_180(struct rtl8125_private *tp)
+{
+        u32 csi_tmp;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                csi_tmp = rtl8125_mac_ocp_read(tp, 0xE092);
+                csi_tmp &= 0xFF00;
+                rtl8125_mac_ocp_write(tp, 0xE092, csi_tmp);
+                break;
+        }
+}
+
+static void
+rtl8125_enable_pci_offset_180(struct rtl8125_private *tp)
+{
+        u32 csi_tmp;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                csi_tmp = rtl8125_mac_ocp_read(tp, 0xE094);
+                csi_tmp &= 0x00FF;
+                rtl8125_mac_ocp_write(tp, 0xE094, csi_tmp);
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                csi_tmp = rtl8125_mac_ocp_read(tp, 0xE092);
+                csi_tmp &= 0xFF00;
+                csi_tmp |= BIT_2;
+                rtl8125_mac_ocp_write(tp, 0xE092, csi_tmp);
+                break;
+        }
+}
+
+static void
+rtl8125_init_pci_offset_180(struct rtl8125_private *tp)
+{
+        if (tp->org_pci_offset_180 & (BIT_0|BIT_1))
+                rtl8125_enable_pci_offset_180(tp);
+        else
+                rtl8125_disable_pci_offset_180(tp);
+}
+
+static void
+rtl8125_set_pci_99_180_exit_driver_para(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                if (tp->org_pci_offset_99 & BIT_2)
+                        rtl8125_issue_offset_99_event(tp);
+                rtl8125_disable_pci_offset_99(tp);
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                rtl8125_disable_pci_offset_180(tp);
+                break;
+        }
+}
+
+static void
+rtl8125_enable_cfg9346_write(struct rtl8125_private *tp)
+{
+        RTL_W8(tp, Cfg9346, RTL_R8(tp, Cfg9346) | Cfg9346_Unlock);
+}
+
+static void
+rtl8125_disable_cfg9346_write(struct rtl8125_private *tp)
+{
+        RTL_W8(tp, Cfg9346, RTL_R8(tp, Cfg9346) & ~Cfg9346_Unlock);
+}
+
+static void
+rtl8125_enable_exit_l1_mask(struct rtl8125_private *tp)
+{
+        //(1)ERI(0xD4)(OCP 0xC0AC).bit[7:12]=6'b111111, L1 Mask
+        SetMcuAccessRegBit(tp, 0xC0AC, (BIT_7 | BIT_8 | BIT_9 | BIT_10 | BIT_11 | BIT_12));
+}
+
+static void
+rtl8125_disable_exit_l1_mask(struct rtl8125_private *tp)
+{
+        //(1)ERI(0xD4)(OCP 0xC0AC).bit[7:12]=6'b000000, L1 Mask
+        ClearMcuAccessRegBit(tp, 0xC0AC, (BIT_7 | BIT_8 | BIT_9 | BIT_10 | BIT_11 | BIT_12));
+}
+
+static void
+rtl8125_enable_extend_tally_couter(struct rtl8125_private *tp)
+{
+        switch (tp->HwSuppExtendTallyCounterVer) {
+        case 1:
+                SetMcuAccessRegBit(tp, 0xEA84, (BIT_1 | BIT_0));
+                break;
+        }
+}
+
+static void
+rtl8125_disable_extend_tally_couter(struct rtl8125_private *tp)
+{
+        switch (tp->HwSuppExtendTallyCounterVer) {
+        case 1:
+                ClearMcuAccessRegBit(tp, 0xEA84, (BIT_1 | BIT_0));
+                break;
+        }
+}
+
+static void
+rtl8125_hw_d3_para(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        RTL_W16(tp, RxMaxSize, RX_BUF_SIZE);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                RTL_W8(tp, 0xF1, RTL_R8(tp, 0xF1) & ~BIT_7);
+                rtl8125_enable_cfg9346_write(tp);
+                RTL_W8(tp, Config2, RTL_R8(tp, Config2) & ~BIT_7);
+                RTL_W8(tp, Config5, RTL_R8(tp, Config5) & ~BIT_0);
+                rtl8125_disable_cfg9346_write(tp);
+                break;
+        }
+
+        rtl8125_disable_exit_l1_mask(tp);
+
+#ifdef ENABLE_REALWOW_SUPPORT
+        rtl8125_set_realwow_d3_para(dev);
+#endif
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                rtl8125_mac_ocp_write(tp, 0xEA18, 0x0064);
+                break;
+        }
+
+        rtl8125_set_pci_99_180_exit_driver_para(dev);
+
+        /*disable ocp phy power saving*/
+        if (tp->mcfg == CFG_METHOD_2 ||
+            tp->mcfg == CFG_METHOD_3 ||
+            tp->mcfg == CFG_METHOD_4 ||
+            tp->mcfg == CFG_METHOD_5 ||
+            tp->mcfg == CFG_METHOD_6 ||
+            tp->mcfg == CFG_METHOD_7)
+                rtl8125_disable_ocp_phy_power_saving(dev);
+
+        rtl8125_disable_rxdvgate(dev);
+
+        rtl8125_disable_extend_tally_couter(tp);
+}
+
+static void
+rtl8125_enable_magic_packet(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->HwSuppMagicPktVer) {
+        case WAKEUP_MAGIC_PACKET_V3:
+                rtl8125_mac_ocp_write(tp, 0xC0B6, rtl8125_mac_ocp_read(tp, 0xC0B6) | BIT_0);
+                break;
+        }
+}
+static void
+rtl8125_disable_magic_packet(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->HwSuppMagicPktVer) {
+        case WAKEUP_MAGIC_PACKET_V3:
+                rtl8125_mac_ocp_write(tp, 0xC0B6, rtl8125_mac_ocp_read(tp, 0xC0B6) & ~BIT_0);
+                break;
+        }
+}
+
+static void
+rtl8125_enable_linkchg_wakeup(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->HwSuppLinkChgWakeUpVer) {
+        case 3:
+                RTL_W8(tp, Config3, RTL_R8(tp, Config3) | LinkUp);
+                ClearAndSetMcuAccessRegBit(tp, 0xE0C6,  (BIT_5 | BIT_3 | BIT_2),  (BIT_4 | BIT_1 | BIT_0));
+                break;
+        }
+}
+
+static void
+rtl8125_disable_linkchg_wakeup(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->HwSuppLinkChgWakeUpVer) {
+        case 3:
+                RTL_W8(tp, Config3, RTL_R8(tp, Config3) & ~LinkUp);
+                ClearMcuAccessRegBit(tp, 0xE0C6,  (BIT_5 | BIT_4 | BIT_3 | BIT_2 | BIT_1 | BIT_0));
+                break;
+        }
+}
+
+#define WAKE_ANY (WAKE_PHY | WAKE_MAGIC | WAKE_UCAST | WAKE_BCAST | WAKE_MCAST)
+
+static u32
+rtl8125_get_hw_wol(struct rtl8125_private *tp)
+{
+        u8 options;
+        u32 csi_tmp;
+        u32 wol_opts = 0;
+
+        if (disable_pm_support)
+                goto out;
+
+        options = RTL_R8(tp, Config1);
+        if (!(options & PMEnable))
+                goto out;
+
+        options = RTL_R8(tp, Config3);
+        if (options & LinkUp)
+                wol_opts |= WAKE_PHY;
+
+        switch (tp->HwSuppMagicPktVer) {
+        case WAKEUP_MAGIC_PACKET_V3:
+                csi_tmp = rtl8125_mac_ocp_read(tp, 0xC0B6);
+                if (csi_tmp & BIT_0)
+                        wol_opts |= WAKE_MAGIC;
+                break;
+        }
+
+        options = RTL_R8(tp, Config5);
+        if (options & UWF)
+                wol_opts |= WAKE_UCAST;
+        if (options & BWF)
+                wol_opts |= WAKE_BCAST;
+        if (options & MWF)
+                wol_opts |= WAKE_MCAST;
+
+out:
+        return wol_opts;
+}
+
+static void
+rtl8125_enable_d0_speedup(struct rtl8125_private *tp)
+{
+        if (FALSE == HW_SUPPORT_D0_SPEED_UP(tp)) return;
+        if (tp->D0SpeedUpSpeed == D0_SPEED_UP_SPEED_DISABLE) return;
+
+        if (tp->HwSuppD0SpeedUpVer == 1) {
+                u16 mac_ocp_data;
+
+                RTL_W8(tp, 0xD0, RTL_R8(tp, 0xD0) | BIT_3);
+
+                //speed up speed
+                mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xE10A);
+                mac_ocp_data &= ~(BIT_10 | BIT_9 | BIT_8 | BIT_7);
+                if (tp->D0SpeedUpSpeed == D0_SPEED_UP_SPEED_2500) {
+                        mac_ocp_data |= BIT_7;
+                }
+                rtl8125_mac_ocp_write(tp, 0xE10A, mac_ocp_data);
+
+                //speed up flowcontrol
+                mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xE860);
+                mac_ocp_data |= (BIT_15 | BIT_14);
+                rtl8125_mac_ocp_write(tp, 0xE860, mac_ocp_data);
+        }
+}
+
+static void
+rtl8125_disable_d0_speedup(struct rtl8125_private *tp)
+{
+        if (FALSE == HW_SUPPORT_D0_SPEED_UP(tp)) return;
+
+        if (tp->HwSuppD0SpeedUpVer == 1)
+                RTL_W8(tp, 0xD0, RTL_R8(tp, 0xD0) & ~BIT_7);
+}
+
+static void
+rtl8125_set_hw_wol(struct net_device *dev, u32 wolopts)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i,tmp;
+        static struct {
+                u32 opt;
+                u16 reg;
+                u8  mask;
+        } cfg[] = {
+                { WAKE_PHY,   Config3, LinkUp },
+                { WAKE_UCAST, Config5, UWF },
+                { WAKE_BCAST, Config5, BWF },
+                { WAKE_MCAST, Config5, MWF },
+                { WAKE_ANY,   Config5, LanWake },
+                { WAKE_MAGIC, Config3, MagicPacket },
+        };
+
+        switch (tp->HwSuppMagicPktVer) {
+        case WAKEUP_MAGIC_PACKET_V3:
+        default:
+                tmp = ARRAY_SIZE(cfg) - 1;
+
+                if (wolopts & WAKE_MAGIC)
+                        rtl8125_enable_magic_packet(dev);
+                else
+                        rtl8125_disable_magic_packet(dev);
+                break;
+        }
+
+        rtl8125_enable_cfg9346_write(tp);
+
+        for (i = 0; i < tmp; i++) {
+                u8 options = RTL_R8(tp, cfg[i].reg) & ~cfg[i].mask;
+                if (wolopts & cfg[i].opt)
+                        options |= cfg[i].mask;
+                RTL_W8(tp, cfg[i].reg, options);
+        }
+
+        switch (tp->HwSuppLinkChgWakeUpVer) {
+        case 3:
+                if (wolopts & WAKE_PHY)
+                        rtl8125_enable_linkchg_wakeup(dev);
+                else
+                        rtl8125_disable_linkchg_wakeup(dev);
+                break;
+        }
+
+        rtl8125_disable_cfg9346_write(tp);
+}
+
+static void
+rtl8125_phy_restart_nway(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (rtl8125_is_in_phy_disable_mode(dev)) return;
+
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+        rtl8125_mdio_write(tp, MII_BMCR, BMCR_ANENABLE | BMCR_ANRESTART);
+}
+
+static void
+rtl8125_phy_setup_force_mode(struct net_device *dev, u32 speed, u8 duplex)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u16 bmcr_true_force = 0;
+
+        if (rtl8125_is_in_phy_disable_mode(dev)) return;
+
+        if ((speed == SPEED_10) && (duplex == DUPLEX_HALF)) {
+                bmcr_true_force = BMCR_SPEED10;
+        } else if ((speed == SPEED_10) && (duplex == DUPLEX_FULL)) {
+                bmcr_true_force = BMCR_SPEED10 | BMCR_FULLDPLX;
+        } else if ((speed == SPEED_100) && (duplex == DUPLEX_HALF)) {
+                bmcr_true_force = BMCR_SPEED100;
+        } else if ((speed == SPEED_100) && (duplex == DUPLEX_FULL)) {
+                bmcr_true_force = BMCR_SPEED100 | BMCR_FULLDPLX;
+        } else {
+                netif_err(tp, drv, dev, "Failed to set phy force mode!\n");
+                return;
+        }
+
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+        rtl8125_mdio_write(tp, MII_BMCR, bmcr_true_force);
+}
+
+static void
+rtl8125_set_pci_pme(struct rtl8125_private *tp, int set)
+{
+        struct pci_dev *pdev = tp->pci_dev;
+        u16 pmc;
+
+        if (!pdev->pm_cap)
+                return;
+
+        pci_read_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, &pmc);
+        pmc |= PCI_PM_CTRL_PME_STATUS;
+        if (set)
+                pmc |= PCI_PM_CTRL_PME_ENABLE;
+        else
+                pmc &= ~PCI_PM_CTRL_PME_ENABLE;
+        pci_write_config_word(pdev, pdev->pm_cap + PCI_PM_CTRL, pmc);
+}
+
+static void
+rtl8125_set_wol_link_speed(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int auto_nego;
+        int giga_ctrl;
+        int ctrl_2500;
+        u32 adv;
+        u16 anlpar;
+        u16 gbsr;
+        u16 status_2500;
+        u16 aner;
+
+        if (tp->autoneg != AUTONEG_ENABLE)
+                goto exit;
+
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+
+        auto_nego = rtl8125_mdio_read(tp, MII_ADVERTISE);
+        auto_nego &= ~(ADVERTISE_10HALF | ADVERTISE_10FULL
+                       | ADVERTISE_100HALF | ADVERTISE_100FULL);
+
+        giga_ctrl = rtl8125_mdio_read(tp, MII_CTRL1000);
+        giga_ctrl &= ~(ADVERTISE_1000HALF | ADVERTISE_1000FULL);
+
+        ctrl_2500 = mdio_direct_read_phy_ocp(tp, 0xA5D4);
+        ctrl_2500 &= ~(RTK_ADVERTISE_2500FULL);
+
+        aner = anlpar = gbsr = status_2500 = 0;
+        if (tp->link_ok(dev)) {
+                aner = rtl8125_mdio_read(tp, MII_EXPANSION);
+                anlpar = rtl8125_mdio_read(tp, MII_LPA);
+                gbsr = rtl8125_mdio_read(tp, MII_STAT1000);
+                status_2500 = mdio_direct_read_phy_ocp(tp, 0xA5D6);
+        } else {
+                if (netif_running(dev)) {
+                        aner = tp->phy_reg_aner;
+                        anlpar = tp->phy_reg_anlpar;
+                        gbsr = tp->phy_reg_gbsr;
+                        status_2500 = tp->phy_reg_status_2500;
+                }
+        }
+
+        if ((aner | anlpar | gbsr | status_2500) == 0) {
+                int auto_nego_tmp = 0;
+                adv = tp->advertising;
+                if ((adv & ADVERTISED_10baseT_Half) && (anlpar & LPA_10HALF))
+                        auto_nego_tmp |= ADVERTISE_10HALF;
+                if ((adv & ADVERTISED_10baseT_Full) && (anlpar & LPA_10FULL))
+                        auto_nego_tmp |= ADVERTISE_10FULL;
+                if ((adv & ADVERTISED_100baseT_Half) && (anlpar & LPA_100HALF))
+                        auto_nego_tmp |= ADVERTISE_100HALF;
+                if ((adv & ADVERTISED_100baseT_Full) && (anlpar & LPA_100FULL))
+                        auto_nego_tmp |= ADVERTISE_100FULL;
+
+                if (auto_nego_tmp == 0)	goto exit;
+
+                auto_nego |= auto_nego_tmp;
+                goto skip_check_lpa;
+        }
+        if (!(aner & EXPANSION_NWAY)) goto exit;
+
+        adv = tp->advertising;
+        if ((adv & ADVERTISED_10baseT_Half) && (anlpar & LPA_10HALF))
+                auto_nego |= ADVERTISE_10HALF;
+        else if ((adv & ADVERTISED_10baseT_Full) && (anlpar & LPA_10FULL))
+                auto_nego |= ADVERTISE_10FULL;
+        else if ((adv & ADVERTISED_100baseT_Half) && (anlpar & LPA_100HALF))
+                auto_nego |= ADVERTISE_100HALF;
+        else if ((adv & ADVERTISED_100baseT_Full) && (anlpar & LPA_100FULL))
+                auto_nego |= ADVERTISE_100FULL;
+        else if (adv & ADVERTISED_1000baseT_Half && (gbsr & LPA_1000HALF))
+                giga_ctrl |= ADVERTISE_1000HALF;
+        else if (adv & ADVERTISED_1000baseT_Full && (gbsr & LPA_1000FULL))
+                giga_ctrl |= ADVERTISE_1000FULL;
+        else if (adv & ADVERTISED_2500baseX_Full && (status_2500 & RTK_LPA_ADVERTISE_2500FULL))
+                ctrl_2500 |= RTK_ADVERTISE_2500FULL;
+        else
+                goto exit;
+
+skip_check_lpa:
+        if (tp->DASH)
+                auto_nego |= (ADVERTISE_100FULL | ADVERTISE_100HALF | ADVERTISE_10HALF | ADVERTISE_10FULL);
+
+#ifdef CONFIG_DOWN_SPEED_100
+        auto_nego |= (ADVERTISE_100FULL | ADVERTISE_100HALF | ADVERTISE_10HALF | ADVERTISE_10FULL);
+#endif
+
+        rtl8125_mdio_write(tp, MII_ADVERTISE, auto_nego);
+        rtl8125_mdio_write(tp, MII_CTRL1000, giga_ctrl);
+        mdio_direct_write_phy_ocp(tp, 0xA5D4, ctrl_2500);
+
+        rtl8125_phy_restart_nway(dev);
+
+exit:
+        return;
+}
+
+static bool
+rtl8125_keep_wol_link_speed(struct net_device *dev, u8 from_suspend)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if ((from_suspend && !tp->link_ok(dev)) ||
+            (!from_suspend && tp->resume_not_chg_speed))
+                return 1;
+
+        return 0;
+}
+static void
+rtl8125_powerdown_pll(struct net_device *dev, u8 from_suspend)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        tp->check_keep_link_speed = 0;
+        if (tp->wol_enabled == WOL_ENABLED || tp->DASH || tp->EnableKCPOffload) {
+                rtl8125_set_hw_wol(dev, tp->wol_opts);
+
+                if (tp->mcfg == CFG_METHOD_2 ||
+                    tp->mcfg == CFG_METHOD_3 ||
+                    tp->mcfg == CFG_METHOD_4 ||
+                    tp->mcfg == CFG_METHOD_5 ||
+                    tp->mcfg == CFG_METHOD_6 ||
+                    tp->mcfg == CFG_METHOD_7) {
+                        rtl8125_enable_cfg9346_write(tp);
+                        RTL_W8(tp, Config2, RTL_R8(tp, Config2) | PMSTS_En);
+                        rtl8125_disable_cfg9346_write(tp);
+                }
+
+                /* Enable the PME and clear the status */
+                rtl8125_set_pci_pme(tp, 1);
+
+                if (rtl8125_keep_wol_link_speed(dev, from_suspend)) {
+                        if (tp->wol_opts & WAKE_PHY)
+                                tp->check_keep_link_speed = 1;
+                } else {
+                        if (HW_SUPPORT_D0_SPEED_UP(tp)) {
+                                rtl8125_enable_d0_speedup(tp);
+                                tp->check_keep_link_speed = 1;
+                        }
+
+                        rtl8125_set_wol_link_speed(dev);
+                }
+
+                RTL_W32(tp, RxConfig, RTL_R32(tp, RxConfig) | AcceptBroadcast | AcceptMulticast | AcceptMyPhys);
+
+                return;
+        }
+
+        if (tp->DASH)
+                return;
+
+        rtl8125_phy_power_down(dev);
+
+        if (!tp->HwIcVerUnknown) {
+                switch (tp->mcfg) {
+                case CFG_METHOD_2:
+                case CFG_METHOD_3:
+                case CFG_METHOD_4:
+                case CFG_METHOD_5:
+                case CFG_METHOD_6:
+                case CFG_METHOD_7:
+                        RTL_W8(tp, PMCH, RTL_R8(tp, PMCH) & ~BIT_7);
+                        break;
+                }
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                RTL_W8(tp, 0xF2, RTL_R8(tp, 0xF2) & ~BIT_6);
+                break;
+        }
+}
+
+static void rtl8125_powerup_pll(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                RTL_W8(tp, PMCH, RTL_R8(tp, PMCH) | BIT_7 | BIT_6);
+                break;
+        }
+
+        if (tp->resume_not_chg_speed) return;
+
+        rtl8125_phy_power_up(dev);
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+static void
+rtl8125_get_wol(struct net_device *dev,
+                struct ethtool_wolinfo *wol)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u8 options;
+
+        wol->wolopts = 0;
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT || disable_pm_support) {
+                wol->supported = 0;
+                return;
+        } else {
+                wol->supported = WAKE_ANY;
+        }
+
+        options = RTL_R8(tp, Config1);
+        if (!(options & PMEnable))
+                return;
+
+        wol->wolopts = tp->wol_opts;
+}
+
+static int
+rtl8125_set_wol(struct net_device *dev,
+                struct ethtool_wolinfo *wol)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT || disable_pm_support)
+                return -EOPNOTSUPP;
+
+        tp->wol_opts = wol->wolopts;
+
+        tp->wol_enabled = (tp->wol_opts) ? WOL_ENABLED : WOL_DISABLED;
+
+        device_set_wakeup_enable(tp_to_dev(tp), wol->wolopts);
+
+        return 0;
+}
+
+static void
+rtl8125_get_drvinfo(struct net_device *dev,
+                    struct ethtool_drvinfo *info)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct rtl8125_fw *rtl_fw = tp->rtl_fw;
+
+        strcpy(info->driver, MODULENAME);
+        strcpy(info->version, RTL8125_VERSION);
+        strcpy(info->bus_info, pci_name(tp->pci_dev));
+        info->regdump_len = R8125_REGS_DUMP_SIZE;
+        info->eedump_len = tp->eeprom_len;
+        BUILD_BUG_ON(sizeof(info->fw_version) < sizeof(rtl_fw->version));
+        if (rtl_fw)
+                strlcpy(info->fw_version, rtl_fw->version,
+                        sizeof(info->fw_version));
+}
+
+static int
+rtl8125_get_regs_len(struct net_device *dev)
+{
+        return R8125_REGS_DUMP_SIZE;
+}
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+
+static void
+rtl8125_set_d0_speedup_speed(struct rtl8125_private *tp)
+{
+        if (FALSE == HW_SUPPORT_D0_SPEED_UP(tp)) return;
+
+        tp->D0SpeedUpSpeed = D0_SPEED_UP_SPEED_DISABLE;
+        if (tp->autoneg == AUTONEG_ENABLE) {
+                if (tp->speed == SPEED_2500)
+                        tp->D0SpeedUpSpeed = D0_SPEED_UP_SPEED_2500;
+                else if(tp->speed == SPEED_1000)
+                        tp->D0SpeedUpSpeed = D0_SPEED_UP_SPEED_1000;
+        }
+}
+
+static int
+rtl8125_set_speed_xmii(struct net_device *dev,
+                       u8 autoneg,
+                       u32 speed,
+                       u8 duplex,
+                       u32 adv)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int auto_nego = 0;
+        int giga_ctrl = 0;
+        int ctrl_2500 = 0;
+        int rc = -EINVAL;
+
+        //Disable Giga Lite
+        ClearEthPhyOcpBit(tp, 0xA428, BIT_9);
+        ClearEthPhyOcpBit(tp, 0xA5EA, BIT_0);
+
+        if (speed != SPEED_2500 &&
+            (speed != SPEED_1000) &&
+            (speed != SPEED_100) &&
+            (speed != SPEED_10)) {
+                speed = SPEED_2500;
+                duplex = DUPLEX_FULL;
+        }
+
+        giga_ctrl = rtl8125_mdio_read(tp, MII_CTRL1000);
+        giga_ctrl &= ~(ADVERTISE_1000HALF | ADVERTISE_1000FULL);
+        ctrl_2500 = mdio_direct_read_phy_ocp(tp, 0xA5D4);
+        ctrl_2500 &= ~(RTK_ADVERTISE_2500FULL);
+
+        if (autoneg == AUTONEG_ENABLE) {
+                /*n-way force*/
+                auto_nego = rtl8125_mdio_read(tp, MII_ADVERTISE);
+                auto_nego &= ~(ADVERTISE_10HALF | ADVERTISE_10FULL |
+                               ADVERTISE_100HALF | ADVERTISE_100FULL |
+                               ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
+
+                if (adv & ADVERTISED_10baseT_Half)
+                        auto_nego |= ADVERTISE_10HALF;
+                if (adv & ADVERTISED_10baseT_Full)
+                        auto_nego |= ADVERTISE_10FULL;
+                if (adv & ADVERTISED_100baseT_Half)
+                        auto_nego |= ADVERTISE_100HALF;
+                if (adv & ADVERTISED_100baseT_Full)
+                        auto_nego |= ADVERTISE_100FULL;
+                if (adv & ADVERTISED_1000baseT_Half)
+                        giga_ctrl |= ADVERTISE_1000HALF;
+                if (adv & ADVERTISED_1000baseT_Full)
+                        giga_ctrl |= ADVERTISE_1000FULL;
+                if (adv & ADVERTISED_2500baseX_Full)
+                        ctrl_2500 |= RTK_ADVERTISE_2500FULL;
+
+                //flow control
+                if (dev->mtu <= ETH_DATA_LEN && tp->fcpause == rtl8125_fc_full)
+                        auto_nego |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;
+
+                tp->phy_auto_nego_reg = auto_nego;
+                tp->phy_1000_ctrl_reg = giga_ctrl;
+
+                tp->phy_2500_ctrl_reg = ctrl_2500;
+
+                rtl8125_mdio_write(tp, 0x1f, 0x0000);
+                rtl8125_mdio_write(tp, MII_ADVERTISE, auto_nego);
+                rtl8125_mdio_write(tp, MII_CTRL1000, giga_ctrl);
+                mdio_direct_write_phy_ocp(tp, 0xA5D4, ctrl_2500);
+                rtl8125_phy_restart_nway(dev);
+                mdelay(20);
+        } else {
+                /*true force*/
+                if (speed == SPEED_10 || speed == SPEED_100)
+                        rtl8125_phy_setup_force_mode(dev, speed, duplex);
+                else
+                        goto out;
+        }
+
+        tp->autoneg = autoneg;
+        tp->speed = speed;
+        tp->duplex = duplex;
+        tp->advertising = adv;
+
+        rtl8125_set_d0_speedup_speed(tp);
+
+        rc = 0;
+out:
+        return rc;
+}
+
+static int
+rtl8125_set_speed(struct net_device *dev,
+                  u8 autoneg,
+                  u32 speed,
+                  u8 duplex,
+                  u32 adv)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int ret;
+
+        if (tp->resume_not_chg_speed) return 0;
+
+        ret = tp->set_speed(dev, autoneg, speed, duplex, adv);
+
+        return ret;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+static int
+rtl8125_set_settings(struct net_device *dev,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+                     struct ethtool_cmd *cmd
+#else
+                     const struct ethtool_link_ksettings *cmd
+#endif
+                    )
+{
+        int ret;
+        u8 autoneg;
+        u32 speed;
+        u8 duplex;
+        u32 supported, advertising;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+        autoneg = cmd->autoneg;
+        speed = cmd->speed;
+        duplex = cmd->duplex;
+        supported = cmd->supported;
+        advertising = cmd->advertising;
+#else
+        const struct ethtool_link_settings *base = &cmd->base;
+        autoneg = base->autoneg;
+        speed = base->speed;
+        duplex = base->duplex;
+        ethtool_convert_link_mode_to_legacy_u32(&supported,
+                                                cmd->link_modes.supported);
+        ethtool_convert_link_mode_to_legacy_u32(&advertising,
+                                                cmd->link_modes.advertising);
+        if (test_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+                     cmd->link_modes.supported))
+                supported |= ADVERTISED_2500baseX_Full;
+        if (test_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+                     cmd->link_modes.advertising))
+                advertising |= ADVERTISED_2500baseX_Full;
+#endif
+        if (advertising & ~supported)
+                return -EINVAL;
+
+        ret = rtl8125_set_speed(dev, autoneg, speed, duplex, advertising);
+
+        return ret;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+static u32
+rtl8125_get_tx_csum(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u32 ret;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+        ret = ((dev->features & NETIF_F_IP_CSUM) != 0);
+#else
+        ret = ((dev->features & (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM)) != 0);
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+
+        return ret;
+}
+
+static u32
+rtl8125_get_rx_csum(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u32 ret;
+
+        ret = tp->cp_cmd & RxChkSum;
+
+        return ret;
+}
+
+static int
+rtl8125_set_tx_csum(struct net_device *dev,
+                    u32 data)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT)
+                return -EOPNOTSUPP;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+        if (data)
+                dev->features |= NETIF_F_IP_CSUM;
+        else
+                dev->features &= ~NETIF_F_IP_CSUM;
+#else
+        if (data)
+                dev->features |= (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM);
+        else
+                dev->features &= ~(NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM);
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+
+        return 0;
+}
+
+static int
+rtl8125_set_rx_csum(struct net_device *dev,
+                    u32 data)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT)
+                return -EOPNOTSUPP;
+
+        if (data)
+                tp->cp_cmd |= RxChkSum;
+        else
+                tp->cp_cmd &= ~RxChkSum;
+
+        RTL_W16(tp, CPlusCmd, tp->cp_cmd);
+
+        return 0;
+}
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+
+static u32
+rtl8125_rx_desc_opts1(struct rtl8125_private *tp,
+                      struct RxDesc *desc)
+{
+        if (tp->InitRxDescType == RX_DESC_RING_TYPE_3)
+                return ((struct RxDescV3 *)desc)->RxDescNormalDDWord4.opts1;
+        else
+                return desc->opts1;
+}
+
+static u32
+rtl8125_rx_desc_opts2(struct rtl8125_private *tp,
+                      struct RxDesc *desc)
+{
+        if (tp->InitRxDescType == RX_DESC_RING_TYPE_3)
+                return ((struct RxDescV3 *)desc)->RxDescNormalDDWord4.opts2;
+        else
+                return desc->opts2;
+}
+
+#ifdef CONFIG_R8125_VLAN
+
+static void
+rtl8125_clear_rx_desc_opts2(struct rtl8125_private *tp,
+                            struct RxDesc *desc)
+{
+        if (tp->InitRxDescType == RX_DESC_RING_TYPE_3)
+                ((struct RxDescV3 *)desc)->RxDescNormalDDWord4.opts2 = 0;
+        else
+                desc->opts2 = 0;
+}
+
+static inline u32
+rtl8125_tx_vlan_tag(struct rtl8125_private *tp,
+                    struct sk_buff *skb)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+        return (tp->vlgrp && vlan_tx_tag_present(skb)) ?
+               TxVlanTag | swab16(vlan_tx_tag_get(skb)) : 0x00;
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0)
+        return (vlan_tx_tag_present(skb)) ?
+               TxVlanTag | swab16(vlan_tx_tag_get(skb)) : 0x00;
+#else
+        return (skb_vlan_tag_present(skb)) ?
+               TxVlanTag | swab16(skb_vlan_tag_get(skb)) : 0x00;
+#endif
+
+        return 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+
+static void
+rtl8125_vlan_rx_register(struct net_device *dev,
+                         struct vlan_group *grp)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        tp->vlgrp = grp;
+        if (tp->mcfg == CFG_METHOD_2 ||
+            tp->mcfg == CFG_METHOD_3 ||
+            tp->mcfg == CFG_METHOD_4 ||
+            tp->mcfg == CFG_METHOD_5 ||
+            tp->mcfg == CFG_METHOD_6 ||
+            tp->mcfg == CFG_METHOD_7) {
+                if (tp->vlgrp) {
+                        tp->rtl8125_rx_config |= (EnableInnerVlan | EnableOuterVlan);
+                        RTL_W32(tp, RxConfig, RTL_R32(tp, RxConfig) | (EnableInnerVlan | EnableOuterVlan))
+                } else {
+                        tp->rtl8125_rx_config &= ~(EnableInnerVlan | EnableOuterVlan);
+                        RTL_W32(tp, RxConfig, RTL_R32(tp, RxConfig) & ~(EnableInnerVlan | EnableOuterVlan))
+                }
+        }
+}
+
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+static void
+rtl8125_vlan_rx_kill_vid(struct net_device *dev,
+                         unsigned short vid)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+        if (tp->vlgrp)
+                tp->vlgrp->vlan_devices[vid] = NULL;
+#else
+        vlan_group_set_device(tp->vlgrp, vid, NULL);
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+}
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+
+static int
+rtl8125_rx_vlan_skb(struct rtl8125_private *tp,
+                    struct RxDesc *desc,
+                    struct sk_buff *skb)
+{
+        u32 opts2 = le32_to_cpu(rtl8125_rx_desc_opts2(tp, desc));
+        int ret = -1;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+        if (tp->vlgrp && (opts2 & RxVlanTag)) {
+                rtl8125_rx_hwaccel_skb(skb, tp->vlgrp,
+                                       swab16(opts2 & 0xffff));
+                ret = 0;
+        }
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+        if (opts2 & RxVlanTag)
+                __vlan_hwaccel_put_tag(skb, swab16(opts2 & 0xffff));
+#else
+        if (opts2 & RxVlanTag)
+                __vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q), swab16(opts2 & 0xffff));
+#endif
+
+        rtl8125_clear_rx_desc_opts2(tp, desc);
+        return ret;
+}
+
+#else /* !CONFIG_R8125_VLAN */
+
+static inline u32
+rtl8125_tx_vlan_tag(struct rtl8125_private *tp,
+                    struct sk_buff *skb)
+{
+        return 0;
+}
+
+static int
+rtl8125_rx_vlan_skb(struct rtl8125_private *tp,
+                    struct RxDesc *desc,
+                    struct sk_buff *skb)
+{
+        return -1;
+}
+
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0)
+
+static netdev_features_t rtl8125_fix_features(struct net_device *dev,
+                netdev_features_t features)
+{
+        if (dev->mtu > MSS_MAX)
+                features &= ~NETIF_F_ALL_TSO;
+        if (dev->mtu > ETH_DATA_LEN) {
+                features &= ~NETIF_F_ALL_TSO;
+                features &= ~NETIF_F_ALL_CSUM;
+        }
+#ifndef CONFIG_R8125_VLAN
+        features &= ~NETIF_F_ALL_CSUM;
+#endif
+
+        return features;
+}
+
+static int rtl8125_hw_set_features(struct net_device *dev,
+                                   netdev_features_t features)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u32 rx_config;
+
+        rx_config = RTL_R32(tp, RxConfig);
+        if (features & NETIF_F_RXALL) {
+                tp->rtl8125_rx_config |= (AcceptErr | AcceptRunt);
+                rx_config |= (AcceptErr | AcceptRunt);
+        } else {
+                tp->rtl8125_rx_config &= ~(AcceptErr | AcceptRunt);
+                rx_config &= ~(AcceptErr | AcceptRunt);
+        }
+
+        if (features & NETIF_F_HW_VLAN_RX) {
+                tp->rtl8125_rx_config |= (EnableInnerVlan | EnableOuterVlan);
+                rx_config |= (EnableInnerVlan | EnableOuterVlan);
+        } else {
+                tp->rtl8125_rx_config &= ~(EnableInnerVlan | EnableOuterVlan);
+                rx_config &= ~(EnableInnerVlan | EnableOuterVlan);
+        }
+
+        RTL_W32(tp, RxConfig, rx_config);
+
+        if (features & NETIF_F_RXCSUM)
+                tp->cp_cmd |= RxChkSum;
+        else
+                tp->cp_cmd &= ~RxChkSum;
+
+        RTL_W16(tp, CPlusCmd, tp->cp_cmd);
+        RTL_R16(tp, CPlusCmd);
+
+        return 0;
+}
+
+static int rtl8125_set_features(struct net_device *dev,
+                                netdev_features_t features)
+{
+        features &= NETIF_F_RXALL | NETIF_F_RXCSUM | NETIF_F_HW_VLAN_RX;
+
+        rtl8125_hw_set_features(dev, features);
+
+        return 0;
+}
+
+#endif
+
+static void rtl8125_gset_xmii(struct net_device *dev,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+                              struct ethtool_cmd *cmd
+#else
+                              struct ethtool_link_ksettings *cmd
+#endif
+                             )
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u16 aner = tp->phy_reg_aner;
+        u16 anlpar = tp->phy_reg_anlpar;
+        u16 gbsr = tp->phy_reg_gbsr;
+        u16 status_2500 = tp->phy_reg_status_2500;
+        u32 lpa_adv = 0;
+        u16 status;
+        u8 autoneg, duplex;
+        u32 speed = 0;
+        u16 bmcr;
+        u32 supported, advertising;
+        u8 report_lpa = 0;
+
+        supported = SUPPORTED_10baseT_Half |
+                    SUPPORTED_10baseT_Full |
+                    SUPPORTED_100baseT_Half |
+                    SUPPORTED_100baseT_Full |
+                    SUPPORTED_1000baseT_Full |
+                    SUPPORTED_2500baseX_Full |
+                    SUPPORTED_Autoneg |
+                    SUPPORTED_TP |
+                    SUPPORTED_Pause	|
+                    SUPPORTED_Asym_Pause;
+
+        if (tp->mcfg == CFG_METHOD_6 || tp->mcfg == CFG_METHOD_7)
+                supported &= ~SUPPORTED_2500baseX_Full;
+
+        advertising = ADVERTISED_TP;
+
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+        bmcr = rtl8125_mdio_read(tp, MII_BMCR);
+
+        if (bmcr & BMCR_ANENABLE) {
+                advertising |= ADVERTISED_Autoneg;
+                autoneg = AUTONEG_ENABLE;
+
+                if (tp->phy_auto_nego_reg & ADVERTISE_10HALF)
+                        advertising |= ADVERTISED_10baseT_Half;
+                if (tp->phy_auto_nego_reg & ADVERTISE_10FULL)
+                        advertising |= ADVERTISED_10baseT_Full;
+                if (tp->phy_auto_nego_reg & ADVERTISE_100HALF)
+                        advertising |= ADVERTISED_100baseT_Half;
+                if (tp->phy_auto_nego_reg & ADVERTISE_100FULL)
+                        advertising |= ADVERTISED_100baseT_Full;
+                if (tp->phy_1000_ctrl_reg & ADVERTISE_1000FULL)
+                        advertising |= ADVERTISED_1000baseT_Full;
+                if (tp->phy_2500_ctrl_reg & RTK_ADVERTISE_2500FULL)
+                        advertising |= ADVERTISED_2500baseX_Full;
+        } else {
+                autoneg = AUTONEG_DISABLE;
+        }
+
+        status = RTL_R16(tp, PHYstatus);
+        if (netif_running(dev) && (status & LinkStatus))
+                report_lpa = 1;
+
+        if (report_lpa) {
+                /*link on*/
+                if (status & _2500bpsF)
+                        speed = SPEED_2500;
+                else if (status & _1000bpsF)
+                        speed = SPEED_1000;
+                else if (status & _100bps)
+                        speed = SPEED_100;
+                else if (status & _10bps)
+                        speed = SPEED_10;
+
+                if (status & TxFlowCtrl)
+                        advertising |= ADVERTISED_Asym_Pause;
+
+                if (status & RxFlowCtrl)
+                        advertising |= ADVERTISED_Pause;
+
+                duplex = ((status & (_1000bpsF | _2500bpsF)) || (status & FullDup)) ?
+                         DUPLEX_FULL : DUPLEX_HALF;
+
+                /*link partner*/
+                if (aner & EXPANSION_NWAY)
+                        lpa_adv |= ADVERTISED_Autoneg;
+                if (anlpar & LPA_10HALF)
+                        lpa_adv |= ADVERTISED_10baseT_Half;
+                if (anlpar & LPA_10FULL)
+                        lpa_adv |= ADVERTISED_10baseT_Full;
+                if (anlpar & LPA_100HALF)
+                        lpa_adv |= ADVERTISED_100baseT_Half;
+                if (anlpar & LPA_100FULL)
+                        lpa_adv |= ADVERTISED_100baseT_Full;
+                if (anlpar & LPA_PAUSE_CAP)
+                        lpa_adv |= ADVERTISED_Pause;
+                if (anlpar & LPA_PAUSE_ASYM)
+                        lpa_adv |= ADVERTISED_Asym_Pause;
+                if (gbsr & LPA_1000HALF)
+                        lpa_adv |= ADVERTISED_1000baseT_Half;
+                if (gbsr & LPA_1000FULL)
+                        lpa_adv |= ADVERTISED_1000baseT_Full;
+                if (status_2500 & RTK_LPA_ADVERTISE_2500FULL)
+                        lpa_adv |= ADVERTISED_2500baseX_Full;
+        } else {
+                /*link down*/
+                speed = SPEED_UNKNOWN;
+                duplex = DUPLEX_UNKNOWN;
+                lpa_adv = 0;
+        }
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+        cmd->supported = supported;
+        cmd->advertising = advertising;
+        cmd->autoneg = autoneg;
+        cmd->speed = speed;
+        cmd->duplex = duplex;
+        cmd->port = PORT_TP;
+        cmd->lp_advertising = lpa_adv;
+#else
+        ethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,
+                                                supported);
+        ethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,
+                                                advertising);
+        ethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.lp_advertising,
+                                                lpa_adv);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0)
+        if (supported & SUPPORTED_2500baseX_Full) {
+                linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT,
+                                 cmd->link_modes.supported, 0);
+                linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+                                 cmd->link_modes.supported, 1);
+        }
+        if (advertising & ADVERTISED_2500baseX_Full) {
+                linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT,
+                                 cmd->link_modes.advertising, 0);
+                linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+                                 cmd->link_modes.advertising, 1);
+        }
+        if (report_lpa) {
+                if (lpa_adv & ADVERTISED_2500baseX_Full) {
+                        linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseX_Full_BIT,
+                                         cmd->link_modes.lp_advertising, 0);
+                        linkmode_mod_bit(ETHTOOL_LINK_MODE_2500baseT_Full_BIT,
+                                         cmd->link_modes.lp_advertising, 1);
+                }
+                if (status_2500 & RTK_LPA_ADVERTISE_5000FULL)
+                        linkmode_mod_bit(ETHTOOL_LINK_MODE_5000baseT_Full_BIT,
+                                         cmd->link_modes.lp_advertising, 1);
+                if (status_2500 & RTK_LPA_ADVERTISE_10000FULL)
+                        linkmode_mod_bit(ETHTOOL_LINK_MODE_10000baseT_Full_BIT,
+                                         cmd->link_modes.lp_advertising, 1);
+        }
+#endif
+        cmd->base.autoneg = autoneg;
+        cmd->base.speed = speed;
+        cmd->base.duplex = duplex;
+        cmd->base.port = PORT_TP;
+#endif
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+static int
+rtl8125_get_settings(struct net_device *dev,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+                     struct ethtool_cmd *cmd
+#else
+                     struct ethtool_link_ksettings *cmd
+#endif
+                    )
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        tp->get_settings(dev, cmd);
+
+        return 0;
+}
+
+static void rtl8125_get_regs(struct net_device *dev, struct ethtool_regs *regs,
+                             void *p)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        void __iomem *ioaddr = tp->mmio_addr;
+        unsigned int i;
+        u8 *data = p;
+
+        if (regs->len < R8125_REGS_DUMP_SIZE)
+                return /* -EINVAL */;
+
+        memset(p, 0, regs->len);
+
+        for (i = 0; i < R8125_MAC_REGS_SIZE; i++)
+                *data++ = readb(ioaddr + i);
+        data = (u8*)p + 256;
+
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+        for (i = 0; i < R8125_PHY_REGS_SIZE/2; i++) {
+                *(u16*)data = rtl8125_mdio_read(tp, i);
+                data += 2;
+        }
+        data = (u8*)p + 256 * 2;
+
+        for (i = 0; i < R8125_EPHY_REGS_SIZE/2; i++) {
+                *(u16*)data = rtl8125_ephy_read(tp, i);
+                data += 2;
+        }
+        data = (u8*)p + 256 * 3;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+        default:
+                for (i = 0; i < R8125_ERI_REGS_SIZE; i+=4) {
+                        *(u32*)data = rtl8125_eri_read(tp, i , 4, ERIAR_ExGMAC);
+                        data += 4;
+                }
+                break;
+        }
+}
+
+static void rtl8125_get_pauseparam(struct net_device *dev,
+                                   struct ethtool_pauseparam *pause)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        pause->autoneg = (tp->autoneg ? AUTONEG_ENABLE : AUTONEG_DISABLE);
+        if (tp->fcpause == rtl8125_fc_rx_pause)
+                pause->rx_pause = 1;
+        else if (tp->fcpause == rtl8125_fc_tx_pause)
+                pause->tx_pause = 1;
+        else if (tp->fcpause == rtl8125_fc_full) {
+                pause->rx_pause = 1;
+                pause->tx_pause = 1;
+        }
+}
+
+static int rtl8125_set_pauseparam(struct net_device *dev,
+                                  struct ethtool_pauseparam *pause)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        enum rtl8125_fc_mode newfc;
+
+        if (pause->tx_pause || pause->rx_pause)
+                newfc = rtl8125_fc_full;
+        else
+                newfc = rtl8125_fc_none;
+
+        if (tp->fcpause != newfc) {
+                tp->fcpause = newfc;
+
+                rtl8125_set_speed(dev, tp->autoneg, tp->speed, tp->duplex, tp->advertising);
+        }
+
+        return 0;
+
+}
+
+static u32
+rtl8125_get_msglevel(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        return tp->msg_enable;
+}
+
+static void
+rtl8125_set_msglevel(struct net_device *dev,
+                     u32 value)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        tp->msg_enable = value;
+}
+
+static const char rtl8125_gstrings[][ETH_GSTRING_LEN] = {
+        /* legacy */
+        "tx_packets",
+        "rx_packets",
+        "tx_errors",
+        "rx_errors",
+        "rx_missed",
+        "align_errors",
+        "tx_single_collisions",
+        "tx_multi_collisions",
+        "unicast",
+        "broadcast",
+        "multicast",
+        "tx_aborted",
+        "tx_underrun",
+
+        /* extended */
+        "tx_octets",
+        "rx_octets",
+        "rx_multicast64",
+        "tx_unicast64",
+        "tx_broadcast64",
+        "tx_multicast64",
+        "tx_pause_on",
+        "tx_pause_off",
+        "tx_pause_all",
+        "tx_deferred",
+        "tx_late_collision",
+        "tx_all_collision",
+        "tx_aborted32",
+        "align_errors32",
+        "rx_frame_too_long",
+        "rx_runt",
+        "rx_pause_on",
+        "rx_pause_off",
+        "rx_pause_all",
+        "rx_unknown_opcode",
+        "rx_mac_error",
+        "tx_underrun32",
+        "rx_mac_missed",
+        "rx_tcam_dropped",
+        "tdu",
+        "rdu",
+};
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+static int rtl8125_get_stats_count(struct net_device *dev)
+{
+        return ARRAY_SIZE(rtl8125_gstrings);
+}
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+#else
+static int rtl8125_get_sset_count(struct net_device *dev, int sset)
+{
+        switch (sset) {
+        case ETH_SS_STATS:
+                return ARRAY_SIZE(rtl8125_gstrings);
+        default:
+                return -EOPNOTSUPP;
+        }
+}
+#endif
+
+static void
+rtl8125_set_ring_size(struct rtl8125_private *tp, u32 rx, u32 tx)
+{
+        int i;
+
+        for (i = 0; i < tp->num_rx_rings; i++)
+                tp->rx_ring[i].num_rx_desc = rx;
+
+        for (i = 0; i < tp->num_tx_rings; i++)
+                tp->tx_ring[i].num_tx_desc = tx;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+static void rtl8125_get_ringparam(struct net_device *dev,
+                                  struct ethtool_ringparam *ring,
+                                  struct kernel_ethtool_ringparam *kernel_ring,
+                                  struct netlink_ext_ack *extack)
+#else
+static void rtl8125_get_ringparam(struct net_device *dev,
+                                  struct ethtool_ringparam *ring)
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        ring->rx_max_pending = MAX_NUM_TX_DESC;
+        ring->tx_max_pending = MAX_NUM_RX_DESC;;
+        ring->rx_pending = tp->rx_ring[0].num_rx_desc;
+        ring->tx_pending = tp->tx_ring[0].num_tx_desc;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+static int rtl8125_set_ringparam(struct net_device *dev,
+                                 struct ethtool_ringparam *ring,
+                                 struct kernel_ethtool_ringparam *kernel_ring,
+                                 struct netlink_ext_ack *extack)
+#else
+static int rtl8125_set_ringparam(struct net_device *dev,
+                                 struct ethtool_ringparam *ring)
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u32 new_rx_count, new_tx_count;
+        int rc = 0;
+
+        if ((ring->rx_mini_pending) || (ring->rx_jumbo_pending))
+                return -EINVAL;
+
+        new_tx_count = clamp_t(u32, ring->tx_pending,
+                               MIN_NUM_TX_DESC, MAX_NUM_TX_DESC);
+
+        new_rx_count = clamp_t(u32, ring->rx_pending,
+                               MIN_NUM_RX_DESC, MAX_NUM_RX_DESC);
+
+        if ((new_rx_count == tp->rx_ring[0].num_rx_desc) &&
+            (new_tx_count == tp->tx_ring[0].num_tx_desc)) {
+                /* nothing to do */
+                return 0;
+        }
+
+        if (netif_running(dev)) {
+                rtl8125_wait_for_quiescence(dev);
+                rtl8125_close(dev);
+        }
+
+        rtl8125_set_ring_size(tp, new_rx_count, new_tx_count);
+
+        if (netif_running(dev))
+                rc = rtl8125_open(dev);
+
+        return rc;
+}
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+static void
+rtl8125_get_ethtool_stats(struct net_device *dev,
+                          struct ethtool_stats *stats,
+                          u64 *data)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct rtl8125_counters *counters;
+        dma_addr_t paddr;
+
+        ASSERT_RTNL();
+
+        counters = tp->tally_vaddr;
+        paddr = tp->tally_paddr;
+        if (!counters)
+                return;
+
+        rtl8125_dump_tally_counter(tp, paddr);
+
+        data[0] = le64_to_cpu(counters->tx_packets);
+        data[1] = le64_to_cpu(counters->rx_packets);
+        data[2] = le64_to_cpu(counters->tx_errors);
+        data[3] = le32_to_cpu(counters->rx_errors);
+        data[4] = le16_to_cpu(counters->rx_missed);
+        data[5] = le16_to_cpu(counters->align_errors);
+        data[6] = le32_to_cpu(counters->tx_one_collision);
+        data[7] = le32_to_cpu(counters->tx_multi_collision);
+        data[8] = le64_to_cpu(counters->rx_unicast);
+        data[9] = le64_to_cpu(counters->rx_broadcast);
+        data[10] = le32_to_cpu(counters->rx_multicast);
+        data[11] = le16_to_cpu(counters->tx_aborted);
+        data[12] = le16_to_cpu(counters->tx_underrun);
+
+        data[13] = le64_to_cpu(counters->tx_octets);
+        data[14] = le64_to_cpu(counters->rx_octets);
+        data[15] = le64_to_cpu(counters->rx_multicast64);
+        data[16] = le64_to_cpu(counters->tx_unicast64);
+        data[17] = le64_to_cpu(counters->tx_broadcast64);
+        data[18] = le64_to_cpu(counters->tx_multicast64);
+        data[19] = le32_to_cpu(counters->tx_pause_on);
+        data[20] = le32_to_cpu(counters->tx_pause_off);
+        data[21] = le32_to_cpu(counters->tx_pause_all);
+        data[22] = le32_to_cpu(counters->tx_deferred);
+        data[23] = le32_to_cpu(counters->tx_late_collision);
+        data[24] = le32_to_cpu(counters->tx_all_collision);
+        data[25] = le32_to_cpu(counters->tx_aborted32);
+        data[26] = le32_to_cpu(counters->align_errors32);
+        data[27] = le32_to_cpu(counters->rx_frame_too_long);
+        data[28] = le32_to_cpu(counters->rx_runt);
+        data[29] = le32_to_cpu(counters->rx_pause_on);
+        data[30] = le32_to_cpu(counters->rx_pause_off);
+        data[31] = le32_to_cpu(counters->rx_pause_all);
+        data[32] = le32_to_cpu(counters->rx_unknown_opcode);
+        data[33] = le32_to_cpu(counters->rx_mac_error);
+        data[34] = le32_to_cpu(counters->tx_underrun32);
+        data[35] = le32_to_cpu(counters->rx_mac_missed);
+        data[36] = le32_to_cpu(counters->rx_tcam_dropped);
+        data[37] = le32_to_cpu(counters->tdu);
+        data[38] = le32_to_cpu(counters->rdu);
+}
+
+static void
+rtl8125_get_strings(struct net_device *dev,
+                    u32 stringset,
+                    u8 *data)
+{
+        switch (stringset) {
+        case ETH_SS_STATS:
+                memcpy(data, rtl8125_gstrings, sizeof(rtl8125_gstrings));
+                break;
+        }
+}
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+
+static int rtl_get_eeprom_len(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        return tp->eeprom_len;
+}
+
+static int rtl_get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom, u8 *buf)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i,j,ret;
+        int start_w, end_w;
+        int VPD_addr, VPD_data;
+        u32 *eeprom_buff;
+        u16 tmp;
+
+        if (tp->eeprom_type == EEPROM_TYPE_NONE) {
+                dev_printk(KERN_DEBUG, tp_to_dev(tp), "Detect none EEPROM\n");
+                return -EOPNOTSUPP;
+        } else if (eeprom->len == 0 || (eeprom->offset+eeprom->len) > tp->eeprom_len) {
+                dev_printk(KERN_DEBUG, tp_to_dev(tp), "Invalid parameter\n");
+                return -EINVAL;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+        default:
+                VPD_addr = 0xD2;
+                VPD_data = 0xD4;
+                break;
+        }
+
+        start_w = eeprom->offset >> 2;
+        end_w = (eeprom->offset + eeprom->len - 1) >> 2;
+
+        eeprom_buff = kmalloc(sizeof(u32)*(end_w - start_w + 1), GFP_KERNEL);
+        if (!eeprom_buff)
+                return -ENOMEM;
+
+        rtl8125_enable_cfg9346_write(tp);
+        ret = -EFAULT;
+        for (i=start_w; i<=end_w; i++) {
+                pci_write_config_word(tp->pci_dev, VPD_addr, (u16)i*4);
+                ret = -EFAULT;
+                for (j = 0; j < 10; j++) {
+                        udelay(400);
+                        pci_read_config_word(tp->pci_dev, VPD_addr, &tmp);
+                        if (tmp&0x8000) {
+                                ret = 0;
+                                break;
+                        }
+                }
+
+                if (ret)
+                        break;
+
+                pci_read_config_dword(tp->pci_dev, VPD_data, &eeprom_buff[i-start_w]);
+        }
+        rtl8125_disable_cfg9346_write(tp);
+
+        if (!ret)
+                memcpy(buf, (u8 *)eeprom_buff + (eeprom->offset & 3), eeprom->len);
+
+        kfree(eeprom_buff);
+
+        return ret;
+}
+
+#undef ethtool_op_get_link
+#define ethtool_op_get_link _kc_ethtool_op_get_link
+static u32 _kc_ethtool_op_get_link(struct net_device *dev)
+{
+        return netif_carrier_ok(dev) ? 1 : 0;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+#undef ethtool_op_get_sg
+#define ethtool_op_get_sg _kc_ethtool_op_get_sg
+static u32 _kc_ethtool_op_get_sg(struct net_device *dev)
+{
+#ifdef NETIF_F_SG
+        return (dev->features & NETIF_F_SG) != 0;
+#else
+        return 0;
+#endif
+}
+
+#undef ethtool_op_set_sg
+#define ethtool_op_set_sg _kc_ethtool_op_set_sg
+static int _kc_ethtool_op_set_sg(struct net_device *dev, u32 data)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT)
+                return -EOPNOTSUPP;
+
+#ifdef NETIF_F_SG
+        if (data)
+                dev->features |= NETIF_F_SG;
+        else
+                dev->features &= ~NETIF_F_SG;
+#endif
+
+        return 0;
+}
+#endif
+
+static int rtl8125_enable_eee(struct rtl8125_private *tp)
+{
+        struct ethtool_eee *eee = &tp->eee;
+        u16 eee_adv_t = ethtool_adv_to_mmd_eee_adv_t(eee->advertised);
+        int ret;
+
+        ret = 0;
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                RTL_W16(tp, EEE_TXIDLE_TIMER_8125, eee->tx_lpi_timer);
+
+                SetMcuAccessRegBit(tp, 0xE040, (BIT_1|BIT_0));
+                SetMcuAccessRegBit(tp, 0xEB62, (BIT_2|BIT_1));
+
+                SetEthPhyOcpBit(tp, 0xA432, BIT_4);
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xA5D0,
+                                        MDIO_EEE_100TX | MDIO_EEE_1000T,
+                                        eee_adv_t);
+                ClearEthPhyOcpBit(tp, 0xA6D4, BIT_0);
+
+                ClearEthPhyOcpBit(tp, 0xA6D8, BIT_4);
+                ClearEthPhyOcpBit(tp, 0xA428, BIT_7);
+                ClearEthPhyOcpBit(tp, 0xA4A2, BIT_9);
+                break;
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                RTL_W16(tp, EEE_TXIDLE_TIMER_8125, eee->tx_lpi_timer);
+
+                SetMcuAccessRegBit(tp, 0xE040, (BIT_1|BIT_0));
+
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xA5D0,
+                                        MDIO_EEE_100TX | MDIO_EEE_1000T,
+                                        eee_adv_t);
+                if (eee->advertised & SUPPORTED_2500baseX_Full)
+                        SetEthPhyOcpBit(tp, 0xA6D4, BIT_0);
+                else
+                        ClearEthPhyOcpBit(tp, 0xA6D4, BIT_0);
+
+                ClearEthPhyOcpBit(tp, 0xA6D8, BIT_4);
+                ClearEthPhyOcpBit(tp, 0xA428, BIT_7);
+                ClearEthPhyOcpBit(tp, 0xA4A2, BIT_9);
+                break;
+        default:
+//      dev_printk(KERN_DEBUG, tp_to_dev(tp), "Not Support EEE\n");
+                ret = -EOPNOTSUPP;
+                break;
+        }
+
+        /*Advanced EEE*/
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                rtl8125_set_phy_mcu_patch_request(tp);
+                ClearMcuAccessRegBit(tp, 0xE052, BIT_0);
+                ClearEthPhyOcpBit(tp, 0xA442, BIT_12 | BIT_13);
+                ClearEthPhyOcpBit(tp, 0xA430, BIT_15);
+                rtl8125_clear_phy_mcu_patch_request(tp);
+                break;
+        }
+
+        return ret;
+}
+
+static int rtl8125_disable_eee(struct rtl8125_private *tp)
+{
+        int ret;
+
+        ret = 0;
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                ClearMcuAccessRegBit(tp, 0xE040, (BIT_1|BIT_0));
+                ClearMcuAccessRegBit(tp, 0xEB62, (BIT_2|BIT_1));
+
+                ClearEthPhyOcpBit(tp, 0xA432, BIT_4);
+                ClearEthPhyOcpBit(tp, 0xA5D0, (BIT_2 | BIT_1));
+                ClearEthPhyOcpBit(tp, 0xA6D4, BIT_0);
+
+                ClearEthPhyOcpBit(tp, 0xA6D8, BIT_4);
+                ClearEthPhyOcpBit(tp, 0xA428, BIT_7);
+                ClearEthPhyOcpBit(tp, 0xA4A2, BIT_9);
+                break;
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                ClearMcuAccessRegBit(tp, 0xE040, (BIT_1|BIT_0));
+
+                ClearEthPhyOcpBit(tp, 0xA5D0, (BIT_2 | BIT_1));
+                ClearEthPhyOcpBit(tp, 0xA6D4, BIT_0);
+
+                ClearEthPhyOcpBit(tp, 0xA6D8, BIT_4);
+                ClearEthPhyOcpBit(tp, 0xA428, BIT_7);
+                ClearEthPhyOcpBit(tp, 0xA4A2, BIT_9);
+                break;
+        default:
+//      dev_printk(KERN_DEBUG, tp_to_dev(tp), "Not Support EEE\n");
+                ret = -EOPNOTSUPP;
+                break;
+        }
+
+        /*Advanced EEE*/
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                rtl8125_set_phy_mcu_patch_request(tp);
+                ClearMcuAccessRegBit(tp, 0xE052, BIT_0);
+                ClearEthPhyOcpBit(tp, 0xA442, BIT_12 | BIT_13);
+                ClearEthPhyOcpBit(tp, 0xA430, BIT_15);
+                rtl8125_clear_phy_mcu_patch_request(tp);
+                break;
+        }
+
+        return ret;
+}
+
+static int rtl_nway_reset(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int ret, bmcr;
+
+        if (unlikely(tp->rtk_enable_diag))
+                return -EBUSY;
+
+        /* if autoneg is off, it's an error */
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+        bmcr = rtl8125_mdio_read(tp, MII_BMCR);
+
+        if (bmcr & BMCR_ANENABLE) {
+                bmcr |= BMCR_ANRESTART;
+                rtl8125_mdio_write(tp, MII_BMCR, bmcr);
+                ret = 0;
+        } else {
+                ret = -EINVAL;
+        }
+
+        return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+static u32
+rtl8125_tx_lpi_timer_to_us(struct rtl8125_private *tp , u32 tx_lpi_timer)
+{
+        u32 to_us;
+        u16 status;
+
+        //2.5G : tx_lpi_timer * 3.2ns
+        //Giga: tx_lpi_timer * 8ns
+        //100M : tx_lpi_timer * 80ns
+        to_us = tx_lpi_timer * 80;
+        status = RTL_R16(tp, PHYstatus);
+        if (status & LinkStatus) {
+                /*link on*/
+                if (status & _2500bpsF)
+                        to_us = (tx_lpi_timer * 32) / 10;
+                else if (status & _1000bpsF)
+                        to_us = tx_lpi_timer * 8;
+        }
+
+        //ns to us
+        to_us /= 1000;
+
+        return to_us;
+}
+
+static int
+rtl_ethtool_get_eee(struct net_device *net, struct ethtool_eee *edata)
+{
+        struct rtl8125_private *tp = netdev_priv(net);
+        struct ethtool_eee *eee = &tp->eee;
+        u32 lp, adv, tx_lpi_timer, supported = 0;
+        u16 val;
+
+        if (unlikely(tp->rtk_enable_diag))
+                return -EBUSY;
+
+        /* Get Supported EEE */
+        //val = mdio_direct_read_phy_ocp(tp, 0xA5C4);
+        //supported = mmd_eee_cap_to_ethtool_sup_t(val);
+        supported = eee->supported;
+
+        /* Get advertisement EEE */
+        val = mdio_direct_read_phy_ocp(tp, 0xA5D0);
+        adv = mmd_eee_adv_to_ethtool_adv_t(val);
+        val = mdio_direct_read_phy_ocp(tp, 0xA6D4);
+        if (val & RTK_EEE_ADVERTISE_2500FULL)
+                adv |= ADVERTISED_2500baseX_Full;
+
+        /* Get LP advertisement EEE */
+        val = mdio_direct_read_phy_ocp(tp, 0xA5D2);
+        lp = mmd_eee_adv_to_ethtool_adv_t(val);
+        val = mdio_direct_read_phy_ocp(tp, 0xA6D0);
+        if (val & RTK_LPA_EEE_ADVERTISE_2500FULL)
+                lp |= ADVERTISED_2500baseX_Full;
+
+        /* Get EEE Tx LPI timer*/
+        tx_lpi_timer = RTL_R16(tp, EEE_TXIDLE_TIMER_8125);
+
+        val = rtl8125_mac_ocp_read(tp, 0xE040);
+        val &= BIT_1 | BIT_0;
+
+        edata->eee_enabled = !!val;
+        edata->eee_active = !!(supported & adv & lp);
+        edata->supported = supported;
+        edata->advertised = adv;
+        edata->lp_advertised = lp;
+        edata->tx_lpi_enabled = edata->eee_enabled;
+        edata->tx_lpi_timer = rtl8125_tx_lpi_timer_to_us(tp, tx_lpi_timer);
+
+        return 0;
+}
+
+static int
+rtl_ethtool_set_eee(struct net_device *net, struct ethtool_eee *edata)
+{
+        struct rtl8125_private *tp = netdev_priv(net);
+        struct ethtool_eee *eee = &tp->eee;
+        u32 advertising;
+        int rc = 0;
+
+        if (!HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp) ||
+            tp->DASH)
+                return -EOPNOTSUPP;
+
+        if (unlikely(tp->rtk_enable_diag)) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "Diag Enabled\n");
+                rc = -EBUSY;
+                goto out;
+        }
+
+        if (tp->autoneg != AUTONEG_ENABLE) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "EEE requires autoneg\n");
+                rc = -EINVAL;
+                goto out;
+        }
+
+        if (edata->tx_lpi_enabled) {
+                if (edata->tx_lpi_timer > tp->max_jumbo_frame_size ||
+                    edata->tx_lpi_timer < ETH_MIN_MTU) {
+                        dev_printk(KERN_WARNING, tp_to_dev(tp), "Valid LPI timer range is %d to %d. \n",
+                                   ETH_MIN_MTU, tp->max_jumbo_frame_size);
+                        rc = -EINVAL;
+                        goto out;
+                }
+        }
+
+        advertising = tp->advertising;
+        if (!edata->advertised) {
+                edata->advertised = advertising & eee->supported;
+        } else if (edata->advertised & ~advertising) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "EEE advertised %x must be a subset of autoneg advertised speeds %x\n",
+                           edata->advertised, advertising);
+                rc = -EINVAL;
+                goto out;
+        }
+
+        if (edata->advertised & ~eee->supported) {
+                dev_printk(KERN_WARNING, tp_to_dev(tp), "EEE advertised %x must be a subset of support %x\n",
+                           edata->advertised, eee->supported);
+                rc = -EINVAL;
+                goto out;
+        }
+
+        //tp->eee.eee_enabled = edata->eee_enabled;
+        //tp->eee_adv_t = ethtool_adv_to_mmd_eee_adv_t(edata->advertised);
+
+        dev_printk(KERN_WARNING, tp_to_dev(tp), "EEE tx_lpi_timer %x must be a subset of support %x\n",
+                   edata->tx_lpi_timer, eee->tx_lpi_timer);
+
+        eee->advertised = edata->advertised;
+        eee->tx_lpi_enabled = edata->tx_lpi_enabled;
+        eee->tx_lpi_timer = edata->tx_lpi_timer;
+        eee->eee_enabled = edata->eee_enabled;
+
+        if (eee->eee_enabled)
+                rtl8125_enable_eee(tp);
+        else
+                rtl8125_disable_eee(tp);
+
+        rtl_nway_reset(net);
+
+        return rc;
+
+out:
+
+        return rc;
+}
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+static const struct ethtool_ops rtl8125_ethtool_ops = {
+        .get_drvinfo        = rtl8125_get_drvinfo,
+        .get_regs_len       = rtl8125_get_regs_len,
+        .get_link       = ethtool_op_get_link,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        .get_ringparam      = rtl8125_get_ringparam,
+        .set_ringparam      = rtl8125_set_ringparam,
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+        .get_settings       = rtl8125_get_settings,
+        .set_settings       = rtl8125_set_settings,
+#else
+        .get_link_ksettings       = rtl8125_get_settings,
+        .set_link_ksettings       = rtl8125_set_settings,
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,6,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        .get_pauseparam     = rtl8125_get_pauseparam,
+        .set_pauseparam     = rtl8125_set_pauseparam,
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+        .get_msglevel       = rtl8125_get_msglevel,
+        .set_msglevel       = rtl8125_set_msglevel,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+        .get_rx_csum        = rtl8125_get_rx_csum,
+        .set_rx_csum        = rtl8125_set_rx_csum,
+        .get_tx_csum        = rtl8125_get_tx_csum,
+        .set_tx_csum        = rtl8125_set_tx_csum,
+        .get_sg         = ethtool_op_get_sg,
+        .set_sg         = ethtool_op_set_sg,
+#ifdef NETIF_F_TSO
+        .get_tso        = ethtool_op_get_tso,
+        .set_tso        = ethtool_op_set_tso,
+#endif //NETIF_F_TSO
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,3,0)
+        .get_regs       = rtl8125_get_regs,
+        .get_wol        = rtl8125_get_wol,
+        .set_wol        = rtl8125_set_wol,
+        .get_strings        = rtl8125_get_strings,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+        .get_stats_count    = rtl8125_get_stats_count,
+#else
+        .get_sset_count     = rtl8125_get_sset_count,
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+        .get_ethtool_stats  = rtl8125_get_ethtool_stats,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+#ifdef ETHTOOL_GPERMADDR
+        .get_perm_addr      = ethtool_op_get_perm_addr,
+#endif //ETHTOOL_GPERMADDR
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23)
+        .get_eeprom     = rtl_get_eeprom,
+        .get_eeprom_len     = rtl_get_eeprom_len,
+#ifdef ENABLE_RSS_SUPPORT
+        .get_rxnfc		= rtl8125_get_rxnfc,
+        .set_rxnfc		= rtl8125_set_rxnfc,
+        .get_rxfh_indir_size	= rtl8125_rss_indir_size,
+        .get_rxfh_key_size	= rtl8125_get_rxfh_key_size,
+        .get_rxfh		= rtl8125_get_rxfh,
+        .set_rxfh		= rtl8125_set_rxfh,
+#endif //ENABLE_RSS_SUPPORT
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+#ifdef ENABLE_PTP_SUPPORT
+        .get_ts_info        = rtl8125_get_ts_info,
+#else
+        .get_ts_info        = ethtool_op_get_ts_info,
+#endif //ENABLE_PTP_SUPPORT
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0)
+        .get_eee = rtl_ethtool_get_eee,
+        .set_eee = rtl_ethtool_set_eee,
+#endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(3,6,0) */
+        .nway_reset = rtl_nway_reset,
+
+};
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+
+#if 0
+
+static int rtl8125_enable_green_feature(struct rtl8125_private *tp)
+{
+        u16 gphy_val;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                mdio_direct_write_phy_ocp(tp, 0xA436, 0x8011);
+                SetEthPhyOcpBit(tp, 0xA438, BIT_15);
+                rtl8125_mdio_write(tp, 0x00, 0x9200);
+                break;
+        default:
+                dev_printk(KERN_DEBUG, tp_to_dev(tp), "Not Support Green Feature\n");
+                break;
+        }
+
+        return 0;
+}
+
+static int rtl8125_disable_green_feature(struct rtl8125_private *tp)
+{
+        u16 gphy_val;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                mdio_direct_write_phy_ocp(tp, 0xA436, 0x8011);
+                ClearEthPhyOcpBit(tp, 0xA438, BIT_15);
+                rtl8125_mdio_write(tp, 0x00, 0x9200);
+                break;
+        default:
+                dev_printk(KERN_DEBUG, tp_to_dev(tp), "Not Support Green Feature\n");
+                break;
+        }
+
+        return 0;
+}
+
+#endif
+
+static void rtl8125_get_mac_version(struct rtl8125_private *tp)
+{
+        u32 reg,val32;
+        u32 ICVerID;
+        struct pci_dev *pdev = tp->pci_dev;
+
+        val32 = RTL_R32(tp, TxConfig);
+        reg = val32 & 0x7c800000;
+        ICVerID = val32 & 0x00700000;
+
+        switch (reg) {
+        case 0x60800000:
+                if (ICVerID == 0x00000000) {
+                        tp->mcfg = CFG_METHOD_2;
+                } else if (ICVerID == 0x100000) {
+                        tp->mcfg = CFG_METHOD_3;
+                } else {
+                        tp->mcfg = CFG_METHOD_3;
+                        tp->HwIcVerUnknown = TRUE;
+                }
+
+                tp->efuse_ver = EFUSE_SUPPORT_V4;
+                break;
+        case 0x64000000:
+                if (ICVerID == 0x00000000) {
+                        tp->mcfg = CFG_METHOD_4;
+                } else if (ICVerID == 0x100000) {
+                        tp->mcfg = CFG_METHOD_5;
+                } else {
+                        tp->mcfg = CFG_METHOD_5;
+                        tp->HwIcVerUnknown = TRUE;
+                }
+
+                tp->efuse_ver = EFUSE_SUPPORT_V4;
+                break;
+        default:
+                printk("unknown chip version (%x)\n",reg);
+                tp->mcfg = CFG_METHOD_DEFAULT;
+                tp->HwIcVerUnknown = TRUE;
+                tp->efuse_ver = EFUSE_NOT_SUPPORT;
+                break;
+        }
+
+        if (pdev->subsystem_vendor == 0x8162) {
+                if (tp->mcfg == CFG_METHOD_3)
+                        tp->mcfg = CFG_METHOD_6;
+                else if (tp->mcfg == CFG_METHOD_5)
+                        tp->mcfg = CFG_METHOD_7;
+        }
+}
+
+static void
+rtl8125_print_mac_version(struct rtl8125_private *tp)
+{
+        int i;
+        for (i = ARRAY_SIZE(rtl_chip_info) - 1; i >= 0; i--) {
+                if (tp->mcfg == rtl_chip_info[i].mcfg) {
+                        dprintk("Realtek PCIe 2.5GbE Family Controller mcfg = %04d\n",
+                                rtl_chip_info[i].mcfg);
+                        return;
+                }
+        }
+
+        dprintk("mac_version == Unknown\n");
+}
+
+static void
+rtl8125_tally_counter_addr_fill(struct rtl8125_private *tp)
+{
+        if (!tp->tally_paddr)
+                return;
+
+        RTL_W32(tp, CounterAddrHigh, (u64)tp->tally_paddr >> 32);
+        RTL_W32(tp, CounterAddrLow, (u64)tp->tally_paddr & (DMA_BIT_MASK(32)));
+}
+
+static void
+rtl8125_tally_counter_clear(struct rtl8125_private *tp)
+{
+        if (!tp->tally_paddr)
+                return;
+
+        RTL_W32(tp, CounterAddrHigh, (u64)tp->tally_paddr >> 32);
+        RTL_W32(tp, CounterAddrLow, ((u64)tp->tally_paddr & (DMA_BIT_MASK(32))) | CounterReset);
+}
+
+static void
+rtl8125_clear_phy_ups_reg(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                ClearEthPhyOcpBit(tp, 0xA466, BIT_0);
+                break;
+        };
+        ClearEthPhyOcpBit(tp, 0xA468, BIT_3 | BIT_1);
+}
+
+static int
+rtl8125_is_ups_resume(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (tp->mcfg == CFG_METHOD_2 ||
+            tp->mcfg == CFG_METHOD_3 ||
+            tp->mcfg == CFG_METHOD_4 ||
+            tp->mcfg == CFG_METHOD_5 ||
+            tp->mcfg == CFG_METHOD_6 ||
+            tp->mcfg == CFG_METHOD_7)
+                return (rtl8125_mac_ocp_read(tp, 0xD42C) & BIT_8);
+
+        return 0;
+}
+
+static void
+rtl8125_clear_ups_resume_bit(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (tp->mcfg == CFG_METHOD_2 ||
+            tp->mcfg == CFG_METHOD_3 ||
+            tp->mcfg == CFG_METHOD_4 ||
+            tp->mcfg == CFG_METHOD_5 ||
+            tp->mcfg == CFG_METHOD_6 ||
+            tp->mcfg == CFG_METHOD_7)
+                rtl8125_mac_ocp_write(tp, 0xD408, rtl8125_mac_ocp_read(tp, 0xD408) & ~(BIT_8));
+}
+
+static void
+rtl8125_wait_phy_ups_resume(struct net_device *dev, u16 PhyState)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u16 TmpPhyState;
+        int i=0;
+
+        if (tp->mcfg == CFG_METHOD_2 ||
+            tp->mcfg == CFG_METHOD_3 ||
+            tp->mcfg == CFG_METHOD_4 ||
+            tp->mcfg == CFG_METHOD_5 ||
+            tp->mcfg == CFG_METHOD_6 ||
+            tp->mcfg == CFG_METHOD_7) {
+                do {
+                        TmpPhyState = mdio_direct_read_phy_ocp(tp, 0xA420);
+                        TmpPhyState &= 0x7;
+                        mdelay(1);
+                        i++;
+                } while ((i < 100) && (TmpPhyState != PhyState));
+        }
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
+        WARN_ON_ONCE(i == 100);
+#endif
+}
+
+void
+rtl8125_enable_now_is_oob(struct rtl8125_private *tp)
+{
+        if ( tp->HwSuppNowIsOobVer == 1 ) {
+                RTL_W8(tp, MCUCmd_reg, RTL_R8(tp, MCUCmd_reg) | Now_is_oob);
+        }
+}
+
+void
+rtl8125_disable_now_is_oob(struct rtl8125_private *tp)
+{
+        if ( tp->HwSuppNowIsOobVer == 1 ) {
+                RTL_W8(tp, MCUCmd_reg, RTL_R8(tp, MCUCmd_reg) & ~Now_is_oob);
+        }
+}
+
+static void
+rtl8125_exit_oob(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u16 data16;
+
+        RTL_W32(tp, RxConfig, RTL_R32(tp, RxConfig) & ~(AcceptErr | AcceptRunt | AcceptBroadcast | AcceptMulticast | AcceptMyPhys |  AcceptAllPhys));
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                rtl8125_dash2_disable_txrx(dev);
+                break;
+        }
+
+        if (tp->DASH) {
+                rtl8125_driver_stop(tp);
+                rtl8125_driver_start(tp);
+#ifdef ENABLE_DASH_SUPPORT
+                DashHwInit(dev);
+#endif
+        }
+
+#ifdef ENABLE_REALWOW_SUPPORT
+        rtl8125_realwow_hw_init(dev);
+#else
+        //Disable realwow  function
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                rtl8125_mac_ocp_write(tp, 0xC0BC, 0x00FF);
+                break;
+        }
+#endif //ENABLE_REALWOW_SUPPORT
+
+        rtl8125_nic_reset(dev);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                rtl8125_disable_now_is_oob(tp);
+
+                data16 = rtl8125_mac_ocp_read(tp, 0xE8DE) & ~BIT_14;
+                rtl8125_mac_ocp_write(tp, 0xE8DE, data16);
+                rtl8125_wait_ll_share_fifo_ready(dev);
+
+                rtl8125_mac_ocp_write(tp, 0xC0AA, 0x07D0);
+                rtl8125_mac_ocp_write(tp, 0xC0A6, 0x01B5);
+                rtl8125_mac_ocp_write(tp, 0xC01E, 0x5555);
+
+                rtl8125_wait_ll_share_fifo_ready(dev);
+                break;
+        }
+
+        //wait ups resume (phy state 2)
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                if (rtl8125_is_ups_resume(dev)) {
+                        rtl8125_wait_phy_ups_resume(dev, 2);
+                        rtl8125_clear_ups_resume_bit(dev);
+                        rtl8125_clear_phy_ups_reg(dev);
+                }
+                break;
+        };
+}
+
+void
+rtl8125_hw_disable_mac_mcu_bps(struct net_device *dev)
+{
+        u16 regAddr;
+
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                rtl8125_enable_cfg9346_write(tp);
+                RTL_W8(tp, Config5, RTL_R8(tp, Config5) & ~BIT_0);
+                RTL_W8(tp, Config2, RTL_R8(tp, Config2) & ~BIT_7);
+                rtl8125_disable_cfg9346_write(tp);
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                rtl8125_mac_ocp_write(tp, 0xFC48, 0x0000);
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                for (regAddr = 0xFC28; regAddr < 0xFC48; regAddr += 2) {
+                        rtl8125_mac_ocp_write(tp, regAddr, 0x0000);
+                }
+
+                mdelay(3);
+
+                rtl8125_mac_ocp_write(tp, 0xFC26, 0x0000);
+                break;
+        }
+}
+
+#ifndef ENABLE_USE_FIRMWARE_FILE
+static void
+rtl8125_switch_mac_mcu_ram_code_page(struct rtl8125_private *tp, u16 page)
+{
+        u16 tmpUshort;
+
+        page &= (BIT_1 | BIT_0);
+        tmpUshort = rtl8125_mac_ocp_read(tp, 0xE446);
+        tmpUshort &= ~(BIT_1 | BIT_0);
+        tmpUshort |= page;
+        rtl8125_mac_ocp_write(tp, 0xE446, tmpUshort);
+}
+
+static void
+_rtl8125_write_mac_mcu_ram_code(struct rtl8125_private *tp, const u16 *entry, u16 entry_cnt)
+{
+        u16 i;
+
+        for (i = 0; i < entry_cnt; i++) {
+                rtl8125_mac_ocp_write(tp, 0xF800 + i * 2, entry[i]);
+        }
+}
+
+static void
+_rtl8125_write_mac_mcu_ram_code_with_page(struct rtl8125_private *tp, const u16 *entry, u16 entry_cnt, u16 page_size)
+{
+        u16 i;
+        u16 offset;
+
+        if (page_size == 0) return;
+
+        for (i = 0; i < entry_cnt; i++) {
+                offset = i % page_size;
+                if (offset == 0) {
+                        u16 page = (i / page_size);
+                        rtl8125_switch_mac_mcu_ram_code_page(tp, page);
+                }
+                rtl8125_mac_ocp_write(tp, 0xF800 + offset * 2, entry[i]);
+        }
+}
+
+static void
+rtl8125_write_mac_mcu_ram_code(struct rtl8125_private *tp, const u16 *entry, u16 entry_cnt)
+{
+        if (FALSE == HW_SUPPORT_MAC_MCU(tp)) return;
+        if (entry == NULL || entry_cnt == 0) return;
+
+        if (tp->MacMcuPageSize > 0)
+                _rtl8125_write_mac_mcu_ram_code_with_page(tp, entry, entry_cnt, tp->MacMcuPageSize);
+        else
+                _rtl8125_write_mac_mcu_ram_code(tp, entry, entry_cnt);
+}
+
+static void
+rtl8125_set_mac_mcu_8125a_1(struct net_device *dev)
+{
+        rtl8125_hw_disable_mac_mcu_bps(dev);
+}
+
+static void
+rtl8125_set_mac_mcu_8125a_2(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        static const u16 mcu_patch_code_8125a_2[] =  {
+                0xE010, 0xE012, 0xE022, 0xE024, 0xE029, 0xE02B, 0xE094, 0xE09D, 0xE09F,
+                0xE0AA, 0xE0B5, 0xE0C6, 0xE0CC, 0xE0D1, 0xE0D6, 0xE0D8, 0xC602, 0xBE00,
+                0x0000, 0xC60F, 0x73C4, 0x49B3, 0xF106, 0x73C2, 0xC608, 0xB406, 0xC609,
+                0xFF80, 0xC605, 0xB406, 0xC605, 0xFF80, 0x0544, 0x0568, 0xE906, 0xCDE8,
+                0xC602, 0xBE00, 0x0000, 0x48C1, 0x48C2, 0x9C46, 0xC402, 0xBC00, 0x0A12,
+                0xC602, 0xBE00, 0x0EBA, 0x1501, 0xF02A, 0x1500, 0xF15D, 0xC661, 0x75C8,
+                0x49D5, 0xF00A, 0x49D6, 0xF008, 0x49D7, 0xF006, 0x49D8, 0xF004, 0x75D2,
+                0x49D9, 0xF150, 0xC553, 0x77A0, 0x75C8, 0x4855, 0x4856, 0x4857, 0x4858,
+                0x48DA, 0x48DB, 0x49FE, 0xF002, 0x485A, 0x49FF, 0xF002, 0x485B, 0x9DC8,
+                0x75D2, 0x4859, 0x9DD2, 0xC643, 0x75C0, 0x49D4, 0xF033, 0x49D0, 0xF137,
+                0xE030, 0xC63A, 0x75C8, 0x49D5, 0xF00E, 0x49D6, 0xF00C, 0x49D7, 0xF00A,
+                0x49D8, 0xF008, 0x75D2, 0x49D9, 0xF005, 0xC62E, 0x75C0, 0x49D7, 0xF125,
+                0xC528, 0x77A0, 0xC627, 0x75C8, 0x4855, 0x4856, 0x4857, 0x4858, 0x48DA,
+                0x48DB, 0x49FE, 0xF002, 0x485A, 0x49FF, 0xF002, 0x485B, 0x9DC8, 0x75D2,
+                0x4859, 0x9DD2, 0xC616, 0x75C0, 0x4857, 0x9DC0, 0xC613, 0x75C0, 0x49DA,
+                0xF003, 0x49D0, 0xF107, 0xC60B, 0xC50E, 0x48D9, 0x9DC0, 0x4859, 0x9DC0,
+                0xC608, 0xC702, 0xBF00, 0x3AE0, 0xE860, 0xB400, 0xB5D4, 0xE908, 0xE86C,
+                0x1200, 0xC409, 0x6780, 0x48F1, 0x8F80, 0xC404, 0xC602, 0xBE00, 0x10AA,
+                0xC010, 0xEA7C, 0xC602, 0xBE00, 0x0000, 0x740A, 0x4846, 0x4847, 0x9C0A,
+                0xC607, 0x74C0, 0x48C6, 0x9CC0, 0xC602, 0xBE00, 0x13FE, 0xE054, 0x72CA,
+                0x4826, 0x4827, 0x9ACA, 0xC607, 0x72C0, 0x48A6, 0x9AC0, 0xC602, 0xBE00,
+                0x07DC, 0xE054, 0xC60F, 0x74C4, 0x49CC, 0xF109, 0xC60C, 0x74CA, 0x48C7,
+                0x9CCA, 0xC609, 0x74C0, 0x4846, 0x9CC0, 0xC602, 0xBE00, 0x2480, 0xE092,
+                0xE0C0, 0xE054, 0x7420, 0x48C0, 0x9C20, 0x7444, 0xC602, 0xBE00, 0x12F8,
+                0x1BFF, 0x46EB, 0x1BFF, 0xC102, 0xB900, 0x0D5A, 0x1BFF, 0x46EB, 0x1BFF,
+                0xC102, 0xB900, 0x0E2A, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+                0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x6486,
+                0x0B15, 0x090E, 0x1139
+        };
+
+        rtl8125_hw_disable_mac_mcu_bps(dev);
+
+        rtl8125_write_mac_mcu_ram_code(tp, mcu_patch_code_8125a_2, ARRAY_SIZE(mcu_patch_code_8125a_2));
+
+        rtl8125_mac_ocp_write(tp, 0xFC26, 0x8000);
+
+        rtl8125_mac_ocp_write(tp, 0xFC2A, 0x0540);
+        rtl8125_mac_ocp_write(tp, 0xFC2E, 0x0A06);
+        rtl8125_mac_ocp_write(tp, 0xFC30, 0x0EB8);
+        rtl8125_mac_ocp_write(tp, 0xFC32, 0x3A5C);
+        rtl8125_mac_ocp_write(tp, 0xFC34, 0x10A8);
+        rtl8125_mac_ocp_write(tp, 0xFC40, 0x0D54);
+        rtl8125_mac_ocp_write(tp, 0xFC42, 0x0E24);
+
+        rtl8125_mac_ocp_write(tp, 0xFC48, 0x307A);
+}
+
+static void
+rtl8125_set_mac_mcu_8125b_1(struct net_device *dev)
+{
+        rtl8125_hw_disable_mac_mcu_bps(dev);
+}
+
+static void
+rtl8125_set_mac_mcu_8125b_2(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        static const u16 mcu_patch_code_8125b_2[] =  {
+                0xE010, 0xE01B, 0xE026, 0xE037, 0xE03D, 0xE057, 0xE05B, 0xE060, 0xE062,
+                0xE064, 0xE066, 0xE068, 0xE06A, 0xE06C, 0xE06E, 0xE070, 0x740A, 0x4846,
+                0x4847, 0x9C0A, 0xC607, 0x74C0, 0x48C6, 0x9CC0, 0xC602, 0xBE00, 0x13F0,
+                0xE054, 0x72CA, 0x4826, 0x4827, 0x9ACA, 0xC607, 0x72C0, 0x48A6, 0x9AC0,
+                0xC602, 0xBE00, 0x081C, 0xE054, 0xC60F, 0x74C4, 0x49CC, 0xF109, 0xC60C,
+                0x74CA, 0x48C7, 0x9CCA, 0xC609, 0x74C0, 0x4846, 0x9CC0, 0xC602, 0xBE00,
+                0x2494, 0xE092, 0xE0C0, 0xE054, 0x7420, 0x48C0, 0x9C20, 0x7444, 0xC602,
+                0xBE00, 0x12DC, 0x733A, 0x21B5, 0x25BC, 0x1304, 0xF111, 0x1B12, 0x1D2A,
+                0x3168, 0x3ADA, 0x31AB, 0x1A00, 0x9AC0, 0x1300, 0xF1FB, 0x7620, 0x236E,
+                0x276F, 0x1A3C, 0x22A1, 0x41B5, 0x9EE2, 0x76E4, 0x486F, 0x9EE4, 0xC602,
+                0xBE00, 0x4A26, 0x733A, 0x49BB, 0xC602, 0xBE00, 0x47A2, 0x48C1, 0x48C2,
+                0x9C46, 0xC402, 0xBC00, 0x0A52, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00,
+                0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00,
+                0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00,
+                0x0000, 0xC602, 0xBE00, 0x0000
+        };
+
+        rtl8125_hw_disable_mac_mcu_bps(dev);
+
+        rtl8125_write_mac_mcu_ram_code(tp, mcu_patch_code_8125b_2, ARRAY_SIZE(mcu_patch_code_8125b_2));
+
+        rtl8125_mac_ocp_write(tp, 0xFC26, 0x8000);
+
+        rtl8125_mac_ocp_write(tp, 0xFC28, 0x13E6);
+        rtl8125_mac_ocp_write(tp, 0xFC2A, 0x0812);
+        rtl8125_mac_ocp_write(tp, 0xFC2C, 0x248C);
+        rtl8125_mac_ocp_write(tp, 0xFC2E, 0x12DA);
+        rtl8125_mac_ocp_write(tp, 0xFC30, 0x4A20);
+        rtl8125_mac_ocp_write(tp, 0xFC32, 0x47A0);
+        //rtl8125_mac_ocp_write(tp, 0xFC34, 0x0A46);
+
+        rtl8125_mac_ocp_write(tp, 0xFC48, 0x003F);
+}
+
+static void
+rtl8125_hw_mac_mcu_config(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (tp->NotWrMcuPatchCode == TRUE) return;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+                rtl8125_set_mac_mcu_8125a_1(dev);
+                break;
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                rtl8125_set_mac_mcu_8125a_2(dev);
+                break;
+        case CFG_METHOD_4:
+                rtl8125_set_mac_mcu_8125b_1(dev);
+                break;
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                rtl8125_set_mac_mcu_8125b_2(dev);
+                break;
+        }
+}
+#endif
+
+#ifdef ENABLE_USE_FIRMWARE_FILE
+static void rtl8125_release_firmware(struct rtl8125_private *tp)
+{
+        if (tp->rtl_fw) {
+                rtl8125_fw_release_firmware(tp->rtl_fw);
+                kfree(tp->rtl_fw);
+                tp->rtl_fw = NULL;
+        }
+}
+
+void rtl8125_apply_firmware(struct rtl8125_private *tp)
+{
+        /* TODO: release firmware if rtl_fw_write_firmware signals failure. */
+        if (tp->rtl_fw) {
+                rtl8125_fw_write_firmware(tp, tp->rtl_fw);
+                /* At least one firmware doesn't reset tp->ocp_base. */
+                tp->ocp_base = OCP_STD_PHY_BASE;
+
+                /* PHY soft reset may still be in progress */
+                //phy_read_poll_timeout(tp->phydev, MII_BMCR, val,
+                //		      !(val & BMCR_RESET),
+                //		      50000, 600000, true);
+                rtl8125_wait_phy_reset_complete(tp);
+
+                tp->hw_ram_code_ver = rtl8125_get_hw_phy_mcu_code_ver(tp);
+                tp->sw_ram_code_ver = tp->hw_ram_code_ver;
+                tp->HwHasWrRamCodeToMicroP = TRUE;
+        }
+}
+#endif
+
+static void
+rtl8125_hw_init(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u32 csi_tmp;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                rtl8125_enable_cfg9346_write(tp);
+                RTL_W8(tp, Config5, RTL_R8(tp, Config5) & ~BIT_0);
+                RTL_W8(tp, Config2, RTL_R8(tp, Config2) & ~BIT_7);
+                rtl8125_disable_cfg9346_write(tp);
+                RTL_W8(tp, 0xF1, RTL_R8(tp, 0xF1) & ~BIT_7);
+                break;
+        }
+
+        //Disable UPS
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                rtl8125_mac_ocp_write(tp, 0xD40A, rtl8125_mac_ocp_read( tp, 0xD40A) & ~(BIT_4));
+                break;
+        }
+
+#ifndef ENABLE_USE_FIRMWARE_FILE
+        if (!tp->rtl_fw)
+                rtl8125_hw_mac_mcu_config(dev);
+#endif
+
+        /*disable ocp phy power saving*/
+        if (tp->mcfg == CFG_METHOD_2 ||
+            tp->mcfg == CFG_METHOD_3 ||
+            tp->mcfg == CFG_METHOD_4 ||
+            tp->mcfg == CFG_METHOD_5 ||
+            tp->mcfg == CFG_METHOD_6 ||
+            tp->mcfg == CFG_METHOD_7)
+                rtl8125_disable_ocp_phy_power_saving(dev);
+
+        //Set PCIE uncorrectable error status mask pcie 0x108
+        csi_tmp = rtl8125_csi_read(tp, 0x108);
+        csi_tmp |= BIT_20;
+        rtl8125_csi_write(tp, 0x108, csi_tmp);
+
+        rtl8125_enable_cfg9346_write(tp);
+        rtl8125_disable_linkchg_wakeup(dev);
+        rtl8125_disable_cfg9346_write(tp);
+        rtl8125_disable_magic_packet(dev);
+        rtl8125_disable_d0_speedup(tp);
+        rtl8125_set_pci_pme(tp, 0);
+        if (s0_magic_packet == 1)
+                rtl8125_enable_magic_packet(dev);
+
+#ifdef ENABLE_USE_FIRMWARE_FILE
+        if (tp->rtl_fw &&
+            !tp->resume_not_chg_speed &&
+            !(HW_DASH_SUPPORT_TYPE_3(tp) &&
+              tp->HwPkgDet == 0x06))
+                rtl8125_apply_firmware(tp);
+#endif
+}
+
+static void
+rtl8125_hw_ephy_config(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+                rtl8125_ephy_write(tp, 0x01, 0xA812);
+                rtl8125_ephy_write(tp, 0x09, 0x520C);
+                rtl8125_ephy_write(tp, 0x04, 0xD000);
+                rtl8125_ephy_write(tp, 0x0D, 0xF702);
+                rtl8125_ephy_write(tp, 0x0A, 0x8653);
+                rtl8125_ephy_write(tp, 0x06, 0x001E);
+                rtl8125_ephy_write(tp, 0x08, 0x3595);
+                rtl8125_ephy_write(tp, 0x20, 0x9455);
+                rtl8125_ephy_write(tp, 0x21, 0x99FF);
+                rtl8125_ephy_write(tp, 0x02, 0x6046);
+                rtl8125_ephy_write(tp, 0x29, 0xFE00);
+                rtl8125_ephy_write(tp, 0x23, 0xAB62);
+
+                rtl8125_ephy_write(tp, 0x41, 0xA80C);
+                rtl8125_ephy_write(tp, 0x49, 0x520C);
+                rtl8125_ephy_write(tp, 0x44, 0xD000);
+                rtl8125_ephy_write(tp, 0x4D, 0xF702);
+                rtl8125_ephy_write(tp, 0x4A, 0x8653);
+                rtl8125_ephy_write(tp, 0x46, 0x001E);
+                rtl8125_ephy_write(tp, 0x48, 0x3595);
+                rtl8125_ephy_write(tp, 0x60, 0x9455);
+                rtl8125_ephy_write(tp, 0x61, 0x99FF);
+                rtl8125_ephy_write(tp, 0x42, 0x6046);
+                rtl8125_ephy_write(tp, 0x69, 0xFE00);
+                rtl8125_ephy_write(tp, 0x63, 0xAB62);
+                break;
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                rtl8125_ephy_write(tp, 0x04, 0xD000);
+                rtl8125_ephy_write(tp, 0x0A, 0x8653);
+                rtl8125_ephy_write(tp, 0x23, 0xAB66);
+                rtl8125_ephy_write(tp, 0x20, 0x9455);
+                rtl8125_ephy_write(tp, 0x21, 0x99FF);
+                rtl8125_ephy_write(tp, 0x29, 0xFE04);
+
+                rtl8125_ephy_write(tp, 0x44, 0xD000);
+                rtl8125_ephy_write(tp, 0x4A, 0x8653);
+                rtl8125_ephy_write(tp, 0x63, 0xAB66);
+                rtl8125_ephy_write(tp, 0x60, 0x9455);
+                rtl8125_ephy_write(tp, 0x61, 0x99FF);
+                rtl8125_ephy_write(tp, 0x69, 0xFE04);
+
+                ClearAndSetPCIePhyBit(tp,
+                                      0x2A,
+                                      (BIT_14 | BIT_13 | BIT_12),
+                                      (BIT_13 | BIT_12)
+                                     );
+                ClearPCIePhyBit(tp, 0x19, BIT_6);
+                SetPCIePhyBit(tp, 0x1B, (BIT_11 | BIT_10 | BIT_9));
+                ClearPCIePhyBit(tp, 0x1B, (BIT_14 | BIT_13 | BIT_12));
+                rtl8125_ephy_write(tp, 0x02, 0x6042);
+                rtl8125_ephy_write(tp, 0x06, 0x0014);
+
+                ClearAndSetPCIePhyBit(tp,
+                                      0x6A,
+                                      (BIT_14 | BIT_13 | BIT_12),
+                                      (BIT_13 | BIT_12)
+                                     );
+                ClearPCIePhyBit(tp, 0x59, BIT_6);
+                SetPCIePhyBit(tp, 0x5B, (BIT_11 | BIT_10 | BIT_9));
+                ClearPCIePhyBit(tp, 0x5B, (BIT_14 | BIT_13 | BIT_12));
+                rtl8125_ephy_write(tp, 0x42, 0x6042);
+                rtl8125_ephy_write(tp, 0x46, 0x0014);
+                break;
+        case CFG_METHOD_4:
+                rtl8125_ephy_write(tp, 0x06, 0x001F);
+                rtl8125_ephy_write(tp, 0x0A, 0xB66B);
+                rtl8125_ephy_write(tp, 0x01, 0xA852);
+                rtl8125_ephy_write(tp, 0x24, 0x0008);
+                rtl8125_ephy_write(tp, 0x2F, 0x6052);
+                rtl8125_ephy_write(tp, 0x0D, 0xF716);
+                rtl8125_ephy_write(tp, 0x20, 0xD477);
+                rtl8125_ephy_write(tp, 0x21, 0x4477);
+                rtl8125_ephy_write(tp, 0x22, 0x0013);
+                rtl8125_ephy_write(tp, 0x23, 0xBB66);
+                rtl8125_ephy_write(tp, 0x0B, 0xA909);
+                rtl8125_ephy_write(tp, 0x29, 0xFF04);
+                rtl8125_ephy_write(tp, 0x1B, 0x1EA0);
+
+                rtl8125_ephy_write(tp, 0x46, 0x001F);
+                rtl8125_ephy_write(tp, 0x4A, 0xB66B);
+                rtl8125_ephy_write(tp, 0x41, 0xA84A);
+                rtl8125_ephy_write(tp, 0x64, 0x000C);
+                rtl8125_ephy_write(tp, 0x6F, 0x604A);
+                rtl8125_ephy_write(tp, 0x4D, 0xF716);
+                rtl8125_ephy_write(tp, 0x60, 0xD477);
+                rtl8125_ephy_write(tp, 0x61, 0x4477);
+                rtl8125_ephy_write(tp, 0x62, 0x0013);
+                rtl8125_ephy_write(tp, 0x63, 0xBB66);
+                rtl8125_ephy_write(tp, 0x4B, 0xA909);
+                rtl8125_ephy_write(tp, 0x69, 0xFF04);
+                rtl8125_ephy_write(tp, 0x5B, 0x1EA0);
+                break;
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                rtl8125_ephy_write(tp, 0x0B, 0xA908);
+                rtl8125_ephy_write(tp, 0x1E, 0x20EB);
+                rtl8125_ephy_write(tp, 0x22, 0x0023);
+                rtl8125_ephy_write(tp, 0x02, 0x60C2);
+                rtl8125_ephy_write(tp, 0x29, 0xFF00);
+
+                rtl8125_ephy_write(tp, 0x4B, 0xA908);
+                rtl8125_ephy_write(tp, 0x5E, 0x28EB);
+                rtl8125_ephy_write(tp, 0x62, 0x0023);
+                rtl8125_ephy_write(tp, 0x42, 0x60C2);
+                rtl8125_ephy_write(tp, 0x69, 0xFF00);
+                break;
+        }
+}
+
+static u16
+rtl8125_get_hw_phy_mcu_code_ver(struct rtl8125_private *tp)
+{
+        u16 hw_ram_code_ver = ~0;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                mdio_direct_write_phy_ocp(tp, 0xA436, 0x801E);
+                hw_ram_code_ver = mdio_direct_read_phy_ocp(tp, 0xA438);
+                break;
+        }
+
+        return hw_ram_code_ver;
+}
+
+static int
+rtl8125_check_hw_phy_mcu_code_ver(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int ram_code_ver_match = 0;
+
+        tp->hw_ram_code_ver = rtl8125_get_hw_phy_mcu_code_ver(tp);
+
+        if (tp->hw_ram_code_ver == tp->sw_ram_code_ver) {
+                ram_code_ver_match = 1;
+                tp->HwHasWrRamCodeToMicroP = TRUE;
+        }
+
+        return ram_code_ver_match;
+}
+
+bool
+rtl8125_set_phy_mcu_patch_request(struct rtl8125_private *tp)
+{
+        u16 gphy_val;
+        u16 WaitCount;
+        bool bSuccess = TRUE;
+
+        SetEthPhyOcpBit(tp, 0xB820, BIT_4);
+
+        WaitCount = 0;
+        do {
+                gphy_val = mdio_direct_read_phy_ocp(tp, 0xB800);
+                udelay(100);
+                WaitCount++;
+        } while (!(gphy_val & BIT_6) && (WaitCount < 1000));
+
+        if (!(gphy_val & BIT_6) && (WaitCount == 1000)) bSuccess = FALSE;
+
+        if (!bSuccess)
+                dprintk("rtl8125_set_phy_mcu_patch_request fail.\n");
+
+        return bSuccess;
+}
+
+bool
+rtl8125_clear_phy_mcu_patch_request(struct rtl8125_private *tp)
+{
+        u16 gphy_val;
+        u16 WaitCount;
+        bool bSuccess = TRUE;
+
+        ClearEthPhyOcpBit(tp, 0xB820, BIT_4);
+
+        WaitCount = 0;
+        do {
+                gphy_val = mdio_direct_read_phy_ocp(tp, 0xB800);
+                udelay(100);
+                WaitCount++;
+        } while ((gphy_val & BIT_6) && (WaitCount < 1000));
+
+        if ((gphy_val & BIT_6) && (WaitCount == 1000)) bSuccess = FALSE;
+
+        if (!bSuccess)
+                dprintk("rtl8125_clear_phy_mcu_patch_request fail.\n");
+
+        return bSuccess;
+}
+
+#ifndef ENABLE_USE_FIRMWARE_FILE
+static void
+rtl8125_write_hw_phy_mcu_code_ver(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                mdio_direct_write_phy_ocp(tp, 0xA436, 0x801E);
+                mdio_direct_write_phy_ocp(tp, 0xA438, tp->sw_ram_code_ver);
+                tp->hw_ram_code_ver = tp->sw_ram_code_ver;
+                break;
+        }
+}
+
+static void
+rtl8125_acquire_phy_mcu_patch_key_lock(struct rtl8125_private *tp)
+{
+        u16 PatchKey;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+                PatchKey = 0x8600;
+                break;
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                PatchKey = 0x8601;
+                break;
+        case CFG_METHOD_4:
+                PatchKey = 0x3700;
+                break;
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                PatchKey = 0x3701;
+                break;
+        default:
+                return;
+        }
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x8024);
+        mdio_direct_write_phy_ocp(tp, 0xA438, PatchKey);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xB82E);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0001);
+}
+
+static void
+rtl8125_release_phy_mcu_patch_key_lock(struct rtl8125_private *tp)
+{
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                mdio_direct_write_phy_ocp(tp, 0xA436, 0x0000);
+                mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+                ClearEthPhyOcpBit(tp, 0xB82E, BIT_0);
+                mdio_direct_write_phy_ocp(tp, 0xA436, 0x8024);
+                mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+                break;
+        default:
+                break;
+        }
+}
+
+static void
+rtl8125_set_phy_mcu_ram_code(struct net_device *dev, const u16 *ramcode, u16 codesize)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u16 i;
+        u16 addr;
+        u16 val;
+
+        if (ramcode == NULL || codesize % 2) {
+                goto out;
+        }
+
+        for (i = 0; i < codesize; i += 2) {
+                addr = ramcode[i];
+                val = ramcode[i + 1];
+                if (addr == 0xFFFF && val == 0xFFFF) {
+                        break;
+                }
+                mdio_direct_write_phy_ocp(tp, addr, val);
+        }
+
+out:
+        return;
+}
+
+static void
+rtl8125_enable_phy_disable_mode(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->HwSuppCheckPhyDisableModeVer) {
+        case 3:
+                RTL_W8(tp, 0xF2, RTL_R8(tp, 0xF2) | BIT_5);
+                break;
+        }
+
+        dprintk("enable phy disable mode.\n");
+}
+
+static void
+rtl8125_disable_phy_disable_mode(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->HwSuppCheckPhyDisableModeVer) {
+        case 3:
+                RTL_W8(tp, 0xF2, RTL_R8(tp, 0xF2) & ~BIT_5);
+                break;
+        }
+
+        mdelay(1);
+
+        dprintk("disable phy disable mode.\n");
+}
+
+static void
+rtl8125_set_hw_phy_before_init_phy_mcu(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u16 PhyRegValue;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+                mdio_direct_write_phy_ocp(tp, 0xBF86, 0x9000);
+
+                SetEthPhyOcpBit(tp, 0xC402, BIT_10);
+                ClearEthPhyOcpBit(tp, 0xC402, BIT_10);
+
+                PhyRegValue = mdio_direct_read_phy_ocp(tp, 0xBF86);
+                PhyRegValue &= (BIT_1 | BIT_0);
+                if (PhyRegValue != 0)
+                        dprintk("PHY watch dog not clear, value = 0x%x \n", PhyRegValue);
+
+                mdio_direct_write_phy_ocp(tp, 0xBD86, 0x1010);
+                mdio_direct_write_phy_ocp(tp, 0xBD88, 0x1010);
+
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xBD4E,
+                                        BIT_11 | BIT_10,
+                                        BIT_11);
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xBF46,
+                                        BIT_11 | BIT_10 | BIT_9 | BIT_8,
+                                        BIT_10 | BIT_9 | BIT_8);
+                break;
+        }
+}
+
+static void
+rtl8125_real_set_phy_mcu_8125a_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_acquire_phy_mcu_patch_key_lock(tp);
+
+
+        SetEthPhyOcpBit(tp, 0xB820, BIT_7);
+
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA016);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA012);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA014);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8013);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8021);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x802f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x803d);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8042);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8051);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8051);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa088);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a50);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8008);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd014);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd1a3);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x401a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd707);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x40c2);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x60a6);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5f8b);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a86);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a6c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8080);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd019);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd1a2);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x401a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd707);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x40c4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x60a6);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5f8b);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a86);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a84);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd503);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8970);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c07);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0901);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xce01);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xcf09);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd705);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xceff);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xaf0a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1213);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8401);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8580);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1253);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd064);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd181);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd704);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4018);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xc50f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd706);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x2c59);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x804d);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xc60f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf002);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xc605);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xae02);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x10fd);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA026);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA024);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA022);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x10f4);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA020);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1252);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA006);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1206);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA004);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a78);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA002);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a60);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a4f);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA008);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x3f00);
+
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA016);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0010);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA012);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA014);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8066);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x807c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8089);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x808e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x80a0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x80b2);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x80c2);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd501);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xce01);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x62db);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x655c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd73e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x60e9);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x614a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x61ab);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0501);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0503);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0505);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0509);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x653c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd73e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x60e9);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x614a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x61ab);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0503);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0502);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0506);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x050a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd73e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x60e9);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x614a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x61ab);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0505);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0506);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0504);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x050c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd73e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x60e9);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x614a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x61ab);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0509);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x050a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x050c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0508);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0304);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd501);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xce01);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd73e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x60e9);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x614a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x61ab);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0501);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0321);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0502);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0321);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0504);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0321);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0508);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0321);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0346);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd501);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xce01);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8208);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x609d);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa50f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x001a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0503);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x001a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x607d);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x00ab);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x00ab);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd501);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xce01);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x60fd);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa50f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xce00);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xaa0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x017b);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0503);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xce00);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a05);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x017b);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd501);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xce01);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x60fd);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa50f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xce00);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xaa0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x01e0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0503);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xce00);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a05);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x01e0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x60fd);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa50f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xce00);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xaa0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0231);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0503);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xce00);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a05);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0231);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA08E);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA08C);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0221);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA08A);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x01ce);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA088);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0169);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA086);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x00a6);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA084);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x000d);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA082);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0308);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA080);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x029f);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA090);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x007f);
+
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA016);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0020);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA012);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA014);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8017);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x801b);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8029);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8054);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x805a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8064);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x80a7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x9430);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x9480);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb408);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd120);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd057);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x064b);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xcb80);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x9906);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0567);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xcb94);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8190);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x82a0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x800a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8406);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8dff);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x07e4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa840);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0773);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xcb91);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4063);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd139);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf002);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd140);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd040);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb404);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d00);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x07dc);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa610);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa110);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa2a0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa404);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd704);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4045);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa180);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd704);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x405d);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa720);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0742);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x07ec);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5f74);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0742);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd702);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x7fb6);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8190);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x82a0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8404);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8610);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d01);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x07dc);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x064b);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x07c0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5fa7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0481);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x94bc);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x870c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa190);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa00a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa280);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa404);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8220);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x078e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xcb92);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa840);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4063);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd140);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf002);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd150);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd040);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd703);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x60a0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x6121);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x61a2);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x6223);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf02f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d10);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf00f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d20);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf00a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d30);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf005);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d40);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x07e4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa610);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa008);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd704);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4046);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa002);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd704);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x405d);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa720);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0742);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x07f7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5f74);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0742);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd702);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x7fb5);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x800a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d00);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x07e4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x3ad4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0537);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8610);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8840);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x064b);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8301);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x800a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8190);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x82a0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8404);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa70c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x9402);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x890c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8840);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x064b);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA10E);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0642);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA10C);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0686);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA10A);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0788);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA108);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x047b);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA106);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x065c);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA104);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0769);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA102);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0565);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA100);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x06f9);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA110);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x00ff);
+
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xb87c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8530);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xb87e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xaf85);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x3caf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8593);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xaf85);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x9caf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x85a5);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf86);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd702);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5afb);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xe083);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xfb0c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x020d);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x021b);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x10bf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x86d7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x86da);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xfbe0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x83fc);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c02);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d02);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1b10);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf86);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xda02);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf86);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xdd02);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5afb);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xe083);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xfd0c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x020d);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x021b);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x10bf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x86dd);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x86e0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xfbe0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x83fe);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c02);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d02);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1b10);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf86);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xe002);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xaf2f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbd02);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x2cac);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0286);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x65af);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x212b);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x022c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x6002);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x86b6);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xaf21);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cd1);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x03bf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8710);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x870d);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8719);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8716);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x871f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x871c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8728);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8725);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8707);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xfbad);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x281c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd100);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a02);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1302);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x2202);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x2b02);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xae1a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd101);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a02);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1302);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x2202);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x2b02);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd101);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x3402);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x3102);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x3d02);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x3a02);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4302);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4002);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4c02);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4902);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd100);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x2e02);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x3702);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4602);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf87);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4f02);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ab7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xaf35);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x7ff8);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xfaef);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x69bf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x86e3);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xfbbf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x86fb);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x86e6);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xfbbf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x86fe);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x86e9);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xfbbf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8701);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x86ec);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xfbbf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8704);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x025a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7bf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x86ef);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0262);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x7cbf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x86f2);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0262);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x7cbf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x86f5);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0262);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x7cbf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x86f8);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0262);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x7cef);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x96fe);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xfc04);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf8fa);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xef69);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf86);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xef02);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x6273);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf86);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf202);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x6273);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf86);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf502);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x6273);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbf86);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf802);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x6273);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xef96);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xfefc);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0420);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb540);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x53b5);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4086);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb540);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb9b5);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x40c8);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb03a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xc8b0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbac8);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb13a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xc8b1);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xba77);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbd26);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xffbd);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x2677);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbd28);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xffbd);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x2840);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbd26);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xc8bd);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x2640);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbd28);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xc8bd);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x28bb);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa430);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x98b0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1eba);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb01e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xdcb0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1e98);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb09e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbab0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x9edc);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb09e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x98b1);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1eba);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb11e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xdcb1);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1e98);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb19e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbab1);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x9edc);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb19e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x11b0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1e22);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb01e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x33b0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1e11);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb09e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x22b0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x9e33);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb09e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x11b1);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1e22);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb11e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x33b1);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1e11);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb19e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x22b1);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x9e33);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb19e);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xb85e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x2f71);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xb860);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x20d9);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xb862);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x2109);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xb864);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x34e7);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xb878);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x000f);
+
+
+        ClearEthPhyOcpBit(tp, 0xB820, BIT_7);
+
+
+        rtl8125_release_phy_mcu_patch_key_lock(tp);
+}
+
+static void
+rtl8125_set_phy_mcu_8125a_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_real_set_phy_mcu_8125a_1(dev);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+}
+
+static void
+rtl8125_real_set_phy_mcu_8125a_2(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_acquire_phy_mcu_patch_key_lock(tp);
+
+
+        SetEthPhyOcpBit(tp, 0xB820, BIT_7);
+
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA016);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA012);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA014);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x808b);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x808f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8093);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8097);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x809d);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x80a1);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x80aa);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd718);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x607b);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x40da);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf00e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x42da);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf01e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd718);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x615b);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1456);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x14a4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x14bc);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd718);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5f2e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf01c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1456);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x14a4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x14bc);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd718);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5f2e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf024);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1456);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x14a4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x14bc);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd718);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5f2e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf02c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1456);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x14a4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x14bc);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd718);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5f2e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf034);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd719);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4118);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xac11);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd501);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xce01);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa410);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xce00);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4779);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xac0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xae01);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1444);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf034);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd719);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4118);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xac22);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd501);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xce01);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa420);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xce00);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4559);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xac0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xae01);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1444);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf023);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd719);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4118);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xac44);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd501);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xce01);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa440);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xce00);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4339);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xac0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xae01);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1444);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf012);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd719);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4118);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xac88);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd501);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xce01);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa480);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xce00);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4119);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xac0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xae01);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1444);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf001);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1456);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd718);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5fac);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xc48f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x141b);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd504);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x121a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd0b4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd1bb);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0898);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd0b4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd1bb);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a0e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd064);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd18a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0b7e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x401c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd501);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa804);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8804);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x053b);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd500);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa301);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0648);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xc520);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa201);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x252d);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1646);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd708);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4006);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1646);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0308);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA026);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0307);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA024);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1645);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA022);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0647);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA020);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x053a);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA006);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0b7c);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA004);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0a0c);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA002);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0896);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x11a1);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA008);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xff00);
+
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA016);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0010);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA012);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA014);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8015);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x801a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x801a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x801a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x801a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x801a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x801a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xad02);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x02d7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x00ed);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0509);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xc100);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x008f);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA08E);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA08C);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA08A);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA088);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA086);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA084);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA082);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x008d);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA080);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x00eb);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA090);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0103);
+
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA016);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0020);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA012);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA014);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8014);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8018);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8024);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8051);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8055);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8072);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x80dc);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xfffd);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xfffd);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8301);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x800a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8190);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x82a0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8404);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa70c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x9402);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x890c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8840);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa380);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x066e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xcb91);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4063);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd139);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf002);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd140);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd040);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb404);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d00);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x07e0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa610);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa110);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa2a0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa404);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd704);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4085);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa180);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa404);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8280);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd704);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x405d);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa720);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0743);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x07f0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5f74);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0743);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd702);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x7fb6);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8190);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x82a0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8404);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8610);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0c0f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d01);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x07e0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x066e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd158);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd04d);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x03d4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x94bc);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x870c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8380);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd10d);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd040);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x07c4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5fb4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa190);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa00a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa280);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa404);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa220);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd130);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd040);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x07c4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5fb4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xbb80);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd1c4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd074);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa301);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd704);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x604b);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa90c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0556);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xcb92);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4063);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd116);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf002);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd119);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd040);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd703);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x60a0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x6241);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x63e2);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x6583);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf054);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x611e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x40da);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d10);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8740);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf02f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d50);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf02a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x611e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x40da);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d20);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8740);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf021);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d60);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf01c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x611e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x40da);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d30);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8740);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf013);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d70);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf00e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x611e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x40da);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d40);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8740);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf005);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d80);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x07e8);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa610);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd704);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x405d);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa720);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd700);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x5ff4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa008);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd704);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x4046);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa002);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0743);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x07fb);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd703);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x7f6f);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x7f4e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x7f2d);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x7f0c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x800a);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0cf0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0d00);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x07e8);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8010);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa740);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0743);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd702);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x7fb5);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd701);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x3ad4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0556);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8610);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x066e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd1f5);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xd049);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x1800);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x01ec);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA10E);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x01ea);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA10C);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x06a9);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA10A);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x078a);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA108);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x03d2);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA106);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x067f);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA104);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0665);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA102);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA100);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xA110);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x00fc);
+
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xb87c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8530);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xb87e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xaf85);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x3caf);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8545);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xaf85);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x45af);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8545);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xee82);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf900);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0103);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xaf03);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb7f8);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xe0a6);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x00e1);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa601);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xef01);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x58f0);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa080);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x37a1);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8402);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xae16);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa185);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x02ae);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x11a1);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8702);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xae0c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xa188);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x02ae);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x07a1);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8902);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xae02);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xae1c);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xe0b4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x62e1);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb463);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x6901);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xe4b4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x62e5);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb463);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xe0b4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x62e1);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb463);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x6901);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xe4b4);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x62e5);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xb463);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xfc04);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xb85e);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x03b3);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xb860);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xb862);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xb864);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xffff);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0xb878);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0001);
+
+
+        ClearEthPhyOcpBit(tp, 0xB820, BIT_7);
+
+
+        rtl8125_release_phy_mcu_patch_key_lock(tp);
+}
+
+static void
+rtl8125_set_phy_mcu_8125a_2(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_real_set_phy_mcu_8125a_2(dev);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+}
+
+static const u16 phy_mcu_ram_code_8125b_1[] = {
+        0xa436, 0x8024, 0xa438, 0x3700, 0xa436, 0xB82E, 0xa438, 0x0001,
+        0xb820, 0x0090, 0xa436, 0xA016, 0xa438, 0x0000, 0xa436, 0xA012,
+        0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+        0xa438, 0x1800, 0xa438, 0x8025, 0xa438, 0x1800, 0xa438, 0x803a,
+        0xa438, 0x1800, 0xa438, 0x8044, 0xa438, 0x1800, 0xa438, 0x8083,
+        0xa438, 0x1800, 0xa438, 0x808d, 0xa438, 0x1800, 0xa438, 0x808d,
+        0xa438, 0x1800, 0xa438, 0x808d, 0xa438, 0xd712, 0xa438, 0x4077,
+        0xa438, 0xd71e, 0xa438, 0x4159, 0xa438, 0xd71e, 0xa438, 0x6099,
+        0xa438, 0x7f44, 0xa438, 0x1800, 0xa438, 0x1a14, 0xa438, 0x9040,
+        0xa438, 0x9201, 0xa438, 0x1800, 0xa438, 0x1b1a, 0xa438, 0xd71e,
+        0xa438, 0x2425, 0xa438, 0x1a14, 0xa438, 0xd71f, 0xa438, 0x3ce5,
+        0xa438, 0x1afb, 0xa438, 0x1800, 0xa438, 0x1b00, 0xa438, 0xd712,
+        0xa438, 0x4077, 0xa438, 0xd71e, 0xa438, 0x4159, 0xa438, 0xd71e,
+        0xa438, 0x60b9, 0xa438, 0x2421, 0xa438, 0x1c17, 0xa438, 0x1800,
+        0xa438, 0x1a14, 0xa438, 0x9040, 0xa438, 0x1800, 0xa438, 0x1c2c,
+        0xa438, 0xd71e, 0xa438, 0x2425, 0xa438, 0x1a14, 0xa438, 0xd71f,
+        0xa438, 0x3ce5, 0xa438, 0x1c0f, 0xa438, 0x1800, 0xa438, 0x1c13,
+        0xa438, 0xd702, 0xa438, 0xd501, 0xa438, 0x6072, 0xa438, 0x8401,
+        0xa438, 0xf002, 0xa438, 0xa401, 0xa438, 0x1000, 0xa438, 0x146e,
+        0xa438, 0x1800, 0xa438, 0x0b77, 0xa438, 0xd703, 0xa438, 0x665d,
+        0xa438, 0x653e, 0xa438, 0x641f, 0xa438, 0xd700, 0xa438, 0x62c4,
+        0xa438, 0x6185, 0xa438, 0x6066, 0xa438, 0x1800, 0xa438, 0x165a,
+        0xa438, 0xc101, 0xa438, 0xcb00, 0xa438, 0x1000, 0xa438, 0x1945,
+        0xa438, 0xd700, 0xa438, 0x7fa6, 0xa438, 0x1800, 0xa438, 0x807d,
+        0xa438, 0xc102, 0xa438, 0xcb00, 0xa438, 0x1000, 0xa438, 0x1945,
+        0xa438, 0xd700, 0xa438, 0x2569, 0xa438, 0x8058, 0xa438, 0x1800,
+        0xa438, 0x807d, 0xa438, 0xc104, 0xa438, 0xcb00, 0xa438, 0x1000,
+        0xa438, 0x1945, 0xa438, 0xd700, 0xa438, 0x7fa4, 0xa438, 0x1800,
+        0xa438, 0x807d, 0xa438, 0xc120, 0xa438, 0xcb00, 0xa438, 0x1000,
+        0xa438, 0x1945, 0xa438, 0xd703, 0xa438, 0x7fbf, 0xa438, 0x1800,
+        0xa438, 0x807d, 0xa438, 0xc140, 0xa438, 0xcb00, 0xa438, 0x1000,
+        0xa438, 0x1945, 0xa438, 0xd703, 0xa438, 0x7fbe, 0xa438, 0x1800,
+        0xa438, 0x807d, 0xa438, 0xc180, 0xa438, 0xcb00, 0xa438, 0x1000,
+        0xa438, 0x1945, 0xa438, 0xd703, 0xa438, 0x7fbd, 0xa438, 0xc100,
+        0xa438, 0xcb00, 0xa438, 0xd708, 0xa438, 0x6018, 0xa438, 0x1800,
+        0xa438, 0x165a, 0xa438, 0x1000, 0xa438, 0x14f6, 0xa438, 0xd014,
+        0xa438, 0xd1e3, 0xa438, 0x1000, 0xa438, 0x1356, 0xa438, 0xd705,
+        0xa438, 0x5fbe, 0xa438, 0x1800, 0xa438, 0x1559, 0xa436, 0xA026,
+        0xa438, 0xffff, 0xa436, 0xA024, 0xa438, 0xffff, 0xa436, 0xA022,
+        0xa438, 0xffff, 0xa436, 0xA020, 0xa438, 0x1557, 0xa436, 0xA006,
+        0xa438, 0x1677, 0xa436, 0xA004, 0xa438, 0x0b75, 0xa436, 0xA002,
+        0xa438, 0x1c17, 0xa436, 0xA000, 0xa438, 0x1b04, 0xa436, 0xA008,
+        0xa438, 0x1f00, 0xa436, 0xA016, 0xa438, 0x0020, 0xa436, 0xA012,
+        0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+        0xa438, 0x1800, 0xa438, 0x817f, 0xa438, 0x1800, 0xa438, 0x82ab,
+        0xa438, 0x1800, 0xa438, 0x83f8, 0xa438, 0x1800, 0xa438, 0x8444,
+        0xa438, 0x1800, 0xa438, 0x8454, 0xa438, 0x1800, 0xa438, 0x8459,
+        0xa438, 0x1800, 0xa438, 0x8465, 0xa438, 0xcb11, 0xa438, 0xa50c,
+        0xa438, 0x8310, 0xa438, 0xd701, 0xa438, 0x4076, 0xa438, 0x0c03,
+        0xa438, 0x0903, 0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f,
+        0xa438, 0x0d00, 0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d00,
+        0xa438, 0x1000, 0xa438, 0x0a7d, 0xa438, 0x1000, 0xa438, 0x0a4d,
+        0xa438, 0xcb12, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x5f84, 0xa438, 0xd102, 0xa438, 0xd040, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xd701,
+        0xa438, 0x60f3, 0xa438, 0xd413, 0xa438, 0x1000, 0xa438, 0x0a37,
+        0xa438, 0xd410, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0xcb13,
+        0xa438, 0xa108, 0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8108,
+        0xa438, 0xa00a, 0xa438, 0xa910, 0xa438, 0xa780, 0xa438, 0xd14a,
+        0xa438, 0xd048, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd701,
+        0xa438, 0x6255, 0xa438, 0xd700, 0xa438, 0x5f74, 0xa438, 0x6326,
+        0xa438, 0xd702, 0xa438, 0x5f07, 0xa438, 0x800a, 0xa438, 0xa004,
+        0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8004, 0xa438, 0xa001,
+        0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8001, 0xa438, 0x0c03,
+        0xa438, 0x0902, 0xa438, 0xffe2, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd71f, 0xa438, 0x5fab, 0xa438, 0xba08, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f8b, 0xa438, 0x9a08,
+        0xa438, 0x800a, 0xa438, 0xd702, 0xa438, 0x6535, 0xa438, 0xd40d,
+        0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0xcb14, 0xa438, 0xa004,
+        0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8004, 0xa438, 0xa001,
+        0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8001, 0xa438, 0xa00a,
+        0xa438, 0xa780, 0xa438, 0xd14a, 0xa438, 0xd048, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0x6206,
+        0xa438, 0xd702, 0xa438, 0x5f47, 0xa438, 0x800a, 0xa438, 0xa004,
+        0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8004, 0xa438, 0xa001,
+        0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8001, 0xa438, 0x0c03,
+        0xa438, 0x0902, 0xa438, 0x1800, 0xa438, 0x8064, 0xa438, 0x800a,
+        0xa438, 0xd40e, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0xb920,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac,
+        0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x7f8c, 0xa438, 0xd701, 0xa438, 0x6073, 0xa438, 0xd701,
+        0xa438, 0x4216, 0xa438, 0xa004, 0xa438, 0x1000, 0xa438, 0x0a42,
+        0xa438, 0x8004, 0xa438, 0xa001, 0xa438, 0x1000, 0xa438, 0x0a42,
+        0xa438, 0x8001, 0xa438, 0xd120, 0xa438, 0xd040, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0x8504,
+        0xa438, 0xcb21, 0xa438, 0xa301, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd700, 0xa438, 0x5f9f, 0xa438, 0x8301, 0xa438, 0xd704,
+        0xa438, 0x40e0, 0xa438, 0xd196, 0xa438, 0xd04d, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xcb22,
+        0xa438, 0x1000, 0xa438, 0x0a6d, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xa640, 0xa438, 0x9503, 0xa438, 0x8910, 0xa438, 0x8720,
+        0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f, 0xa438, 0x0d01,
+        0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d01, 0xa438, 0x1000,
+        0xa438, 0x0a7d, 0xa438, 0x0c1f, 0xa438, 0x0f14, 0xa438, 0xcb23,
+        0xa438, 0x8fc0, 0xa438, 0x1000, 0xa438, 0x0a25, 0xa438, 0xaf40,
+        0xa438, 0x1000, 0xa438, 0x0a25, 0xa438, 0x0cc0, 0xa438, 0x0f80,
+        0xa438, 0x1000, 0xa438, 0x0a25, 0xa438, 0xafc0, 0xa438, 0x1000,
+        0xa438, 0x0a25, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd701,
+        0xa438, 0x5dee, 0xa438, 0xcb24, 0xa438, 0x8f1f, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd701, 0xa438, 0x7f6e, 0xa438, 0xa111,
+        0xa438, 0xa215, 0xa438, 0xa401, 0xa438, 0x8404, 0xa438, 0xa720,
+        0xa438, 0xcb25, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8640,
+        0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x0b43, 0xa438, 0x1000,
+        0xa438, 0x0b86, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xb920,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac,
+        0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x7f8c, 0xa438, 0xcb26, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd71f, 0xa438, 0x5f82, 0xa438, 0x8111, 0xa438, 0x8205,
+        0xa438, 0x8404, 0xa438, 0xcb27, 0xa438, 0xd404, 0xa438, 0x1000,
+        0xa438, 0x0a37, 0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f,
+        0xa438, 0x0d02, 0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d02,
+        0xa438, 0x1000, 0xa438, 0x0a7d, 0xa438, 0xa710, 0xa438, 0xa104,
+        0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8104, 0xa438, 0xa001,
+        0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8001, 0xa438, 0xa120,
+        0xa438, 0xaa0f, 0xa438, 0x8110, 0xa438, 0xa284, 0xa438, 0xa404,
+        0xa438, 0xa00a, 0xa438, 0xd193, 0xa438, 0xd046, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xcb28,
+        0xa438, 0xa110, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+        0xa438, 0x5fa8, 0xa438, 0x8110, 0xa438, 0x8284, 0xa438, 0xa404,
+        0xa438, 0x800a, 0xa438, 0x8710, 0xa438, 0xb804, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f82, 0xa438, 0x9804,
+        0xa438, 0xcb29, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x5f85, 0xa438, 0xa710, 0xa438, 0xb820, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f65, 0xa438, 0x9820,
+        0xa438, 0xcb2a, 0xa438, 0xa190, 0xa438, 0xa284, 0xa438, 0xa404,
+        0xa438, 0xa00a, 0xa438, 0xd13d, 0xa438, 0xd04a, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x3444, 0xa438, 0x8149,
+        0xa438, 0xa220, 0xa438, 0xd1a0, 0xa438, 0xd040, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x3444, 0xa438, 0x8151,
+        0xa438, 0xd702, 0xa438, 0x5f51, 0xa438, 0xcb2f, 0xa438, 0xa302,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd708, 0xa438, 0x5f63,
+        0xa438, 0xd411, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0x8302,
+        0xa438, 0xd409, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0xb920,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac,
+        0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x7f8c, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x5fa3, 0xa438, 0x8190, 0xa438, 0x82a4, 0xa438, 0x8404,
+        0xa438, 0x800a, 0xa438, 0xb808, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd71f, 0xa438, 0x7fa3, 0xa438, 0x9808, 0xa438, 0x1800,
+        0xa438, 0x0433, 0xa438, 0xcb15, 0xa438, 0xa508, 0xa438, 0xd700,
+        0xa438, 0x6083, 0xa438, 0x0c1f, 0xa438, 0x0d01, 0xa438, 0xf003,
+        0xa438, 0x0c1f, 0xa438, 0x0d01, 0xa438, 0x1000, 0xa438, 0x0a7d,
+        0xa438, 0x1000, 0xa438, 0x0a4d, 0xa438, 0xa301, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5f9f, 0xa438, 0x8301,
+        0xa438, 0xd704, 0xa438, 0x40e0, 0xa438, 0xd115, 0xa438, 0xd04f,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4,
+        0xa438, 0xd413, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0xcb16,
+        0xa438, 0x1000, 0xa438, 0x0a6d, 0xa438, 0x0c03, 0xa438, 0x1502,
+        0xa438, 0xa640, 0xa438, 0x9503, 0xa438, 0x8720, 0xa438, 0xd17a,
+        0xa438, 0xd04c, 0xa438, 0x0c1f, 0xa438, 0x0f14, 0xa438, 0xcb17,
+        0xa438, 0x8fc0, 0xa438, 0x1000, 0xa438, 0x0a25, 0xa438, 0xaf40,
+        0xa438, 0x1000, 0xa438, 0x0a25, 0xa438, 0x0cc0, 0xa438, 0x0f80,
+        0xa438, 0x1000, 0xa438, 0x0a25, 0xa438, 0xafc0, 0xa438, 0x1000,
+        0xa438, 0x0a25, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd701,
+        0xa438, 0x61ce, 0xa438, 0xd700, 0xa438, 0x5db4, 0xa438, 0xcb18,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8640, 0xa438, 0x9503,
+        0xa438, 0xa720, 0xa438, 0x1000, 0xa438, 0x0b43, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xffd6, 0xa438, 0x8f1f, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd701, 0xa438, 0x7f8e, 0xa438, 0xa131,
+        0xa438, 0xaa0f, 0xa438, 0xa2d5, 0xa438, 0xa407, 0xa438, 0xa720,
+        0xa438, 0x8310, 0xa438, 0xa308, 0xa438, 0x8308, 0xa438, 0xcb19,
+        0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8640, 0xa438, 0x9503,
+        0xa438, 0x1000, 0xa438, 0x0b43, 0xa438, 0x1000, 0xa438, 0x0b86,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xb920, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac, 0xa438, 0x9920,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f8c,
+        0xa438, 0xcb1a, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x5f82, 0xa438, 0x8111, 0xa438, 0x82c5, 0xa438, 0xa404,
+        0xa438, 0x8402, 0xa438, 0xb804, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd71f, 0xa438, 0x7f82, 0xa438, 0x9804, 0xa438, 0xcb1b,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5f85,
+        0xa438, 0xa710, 0xa438, 0xb820, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd71f, 0xa438, 0x7f65, 0xa438, 0x9820, 0xa438, 0xcb1c,
+        0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f, 0xa438, 0x0d02,
+        0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d02, 0xa438, 0x1000,
+        0xa438, 0x0a7d, 0xa438, 0xa110, 0xa438, 0xa284, 0xa438, 0xa404,
+        0xa438, 0x8402, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+        0xa438, 0x5fa8, 0xa438, 0xcb1d, 0xa438, 0xa180, 0xa438, 0xa402,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fa8,
+        0xa438, 0xa220, 0xa438, 0xd1f5, 0xa438, 0xd049, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x3444, 0xa438, 0x8221,
+        0xa438, 0xd702, 0xa438, 0x5f51, 0xa438, 0xb920, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac, 0xa438, 0x9920,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f8c,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fa3,
+        0xa438, 0xa504, 0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f,
+        0xa438, 0x0d00, 0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d00,
+        0xa438, 0x1000, 0xa438, 0x0a7d, 0xa438, 0xa00a, 0xa438, 0x8190,
+        0xa438, 0x82a4, 0xa438, 0x8402, 0xa438, 0xa404, 0xa438, 0xb808,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7fa3,
+        0xa438, 0x9808, 0xa438, 0xcb2b, 0xa438, 0xcb2c, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5f84, 0xa438, 0xd14a,
+        0xa438, 0xd048, 0xa438, 0xa780, 0xa438, 0xcb2d, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5f94, 0xa438, 0x6208,
+        0xa438, 0xd702, 0xa438, 0x5f27, 0xa438, 0x800a, 0xa438, 0xa004,
+        0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8004, 0xa438, 0xa001,
+        0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8001, 0xa438, 0x0c03,
+        0xa438, 0x0902, 0xa438, 0xa00a, 0xa438, 0xffe9, 0xa438, 0xcb2e,
+        0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f, 0xa438, 0x0d02,
+        0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d02, 0xa438, 0x1000,
+        0xa438, 0x0a7d, 0xa438, 0xa190, 0xa438, 0xa284, 0xa438, 0xa406,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fa8,
+        0xa438, 0xa220, 0xa438, 0xd1a0, 0xa438, 0xd040, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x3444, 0xa438, 0x827d,
+        0xa438, 0xd702, 0xa438, 0x5f51, 0xa438, 0xcb2f, 0xa438, 0xa302,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd708, 0xa438, 0x5f63,
+        0xa438, 0xd411, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0x8302,
+        0xa438, 0xd409, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0xb920,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac,
+        0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x7f8c, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x5fa3, 0xa438, 0x8190, 0xa438, 0x82a4, 0xa438, 0x8406,
+        0xa438, 0x800a, 0xa438, 0xb808, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd71f, 0xa438, 0x7fa3, 0xa438, 0x9808, 0xa438, 0x1800,
+        0xa438, 0x0433, 0xa438, 0xcb30, 0xa438, 0x8380, 0xa438, 0xcb31,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5f86,
+        0xa438, 0x9308, 0xa438, 0xb204, 0xa438, 0xb301, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd701, 0xa438, 0x5fa2, 0xa438, 0xb302,
+        0xa438, 0x9204, 0xa438, 0xcb32, 0xa438, 0xd408, 0xa438, 0x1000,
+        0xa438, 0x0a37, 0xa438, 0xd141, 0xa438, 0xd043, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xd704,
+        0xa438, 0x4ccc, 0xa438, 0xd700, 0xa438, 0x4c81, 0xa438, 0xd702,
+        0xa438, 0x609e, 0xa438, 0xd1e5, 0xa438, 0xd04d, 0xa438, 0xf003,
+        0xa438, 0xd1e5, 0xa438, 0xd04d, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xd700, 0xa438, 0x6083,
+        0xa438, 0x0c1f, 0xa438, 0x0d01, 0xa438, 0xf003, 0xa438, 0x0c1f,
+        0xa438, 0x0d01, 0xa438, 0x1000, 0xa438, 0x0a7d, 0xa438, 0x8710,
+        0xa438, 0xa108, 0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8108,
+        0xa438, 0xa203, 0xa438, 0x8120, 0xa438, 0x8a0f, 0xa438, 0xa111,
+        0xa438, 0x8204, 0xa438, 0xa140, 0xa438, 0x1000, 0xa438, 0x0a42,
+        0xa438, 0x8140, 0xa438, 0xd17a, 0xa438, 0xd04b, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xa204,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fa7,
+        0xa438, 0xb920, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x5fac, 0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd71f, 0xa438, 0x7f8c, 0xa438, 0xd404, 0xa438, 0x1000,
+        0xa438, 0x0a37, 0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f,
+        0xa438, 0x0d02, 0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d02,
+        0xa438, 0x1000, 0xa438, 0x0a7d, 0xa438, 0xa710, 0xa438, 0x8101,
+        0xa438, 0x8201, 0xa438, 0xa104, 0xa438, 0x1000, 0xa438, 0x0a42,
+        0xa438, 0x8104, 0xa438, 0xa120, 0xa438, 0xaa0f, 0xa438, 0x8110,
+        0xa438, 0xa284, 0xa438, 0xa404, 0xa438, 0xa00a, 0xa438, 0xd193,
+        0xa438, 0xd047, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+        0xa438, 0x5fb4, 0xa438, 0xa110, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd700, 0xa438, 0x5fa8, 0xa438, 0xa180, 0xa438, 0xd13d,
+        0xa438, 0xd04a, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+        0xa438, 0x5fb4, 0xa438, 0xf024, 0xa438, 0xa710, 0xa438, 0xa00a,
+        0xa438, 0x8190, 0xa438, 0x8204, 0xa438, 0xa280, 0xa438, 0xa404,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fa7,
+        0xa438, 0x8710, 0xa438, 0xb920, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd71f, 0xa438, 0x5fac, 0xa438, 0x9920, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f8c, 0xa438, 0x800a,
+        0xa438, 0x8190, 0xa438, 0x8284, 0xa438, 0x8406, 0xa438, 0xd700,
+        0xa438, 0x4121, 0xa438, 0xd701, 0xa438, 0x60f3, 0xa438, 0xd1e5,
+        0xa438, 0xd04d, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+        0xa438, 0x5fb4, 0xa438, 0x8710, 0xa438, 0xa00a, 0xa438, 0x8190,
+        0xa438, 0x8204, 0xa438, 0xa280, 0xa438, 0xa404, 0xa438, 0xb920,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac,
+        0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+        0xa438, 0x7f8c, 0xa438, 0xcb33, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd71f, 0xa438, 0x5f85, 0xa438, 0xa710, 0xa438, 0xb820,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f65,
+        0xa438, 0x9820, 0xa438, 0xcb34, 0xa438, 0xa00a, 0xa438, 0xa190,
+        0xa438, 0xa284, 0xa438, 0xa404, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd700, 0xa438, 0x5fa9, 0xa438, 0xd701, 0xa438, 0x6853,
+        0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f, 0xa438, 0x0d00,
+        0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d00, 0xa438, 0x1000,
+        0xa438, 0x0a7d, 0xa438, 0x8190, 0xa438, 0x8284, 0xa438, 0xcb35,
+        0xa438, 0xd407, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0x8110,
+        0xa438, 0x8204, 0xa438, 0xa280, 0xa438, 0xa00a, 0xa438, 0xd704,
+        0xa438, 0x4215, 0xa438, 0xa304, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd700, 0xa438, 0x5fb8, 0xa438, 0xd1c3, 0xa438, 0xd043,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4,
+        0xa438, 0x8304, 0xa438, 0xd700, 0xa438, 0x4109, 0xa438, 0xf01e,
+        0xa438, 0xcb36, 0xa438, 0xd412, 0xa438, 0x1000, 0xa438, 0x0a37,
+        0xa438, 0xd700, 0xa438, 0x6309, 0xa438, 0xd702, 0xa438, 0x42c7,
+        0xa438, 0x800a, 0xa438, 0x8180, 0xa438, 0x8280, 0xa438, 0x8404,
+        0xa438, 0xa004, 0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8004,
+        0xa438, 0xa001, 0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8001,
+        0xa438, 0x0c03, 0xa438, 0x0902, 0xa438, 0xa00a, 0xa438, 0xd14a,
+        0xa438, 0xd048, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+        0xa438, 0x5fb4, 0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f,
+        0xa438, 0x0d02, 0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d02,
+        0xa438, 0x1000, 0xa438, 0x0a7d, 0xa438, 0xcc55, 0xa438, 0xcb37,
+        0xa438, 0xa00a, 0xa438, 0xa190, 0xa438, 0xa2a4, 0xa438, 0xa404,
+        0xa438, 0xd700, 0xa438, 0x6041, 0xa438, 0xa402, 0xa438, 0xd13d,
+        0xa438, 0xd04a, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+        0xa438, 0x5fb4, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+        0xa438, 0x5fa9, 0xa438, 0xd702, 0xa438, 0x5f71, 0xa438, 0xcb38,
+        0xa438, 0x8224, 0xa438, 0xa288, 0xa438, 0x8180, 0xa438, 0xa110,
+        0xa438, 0xa404, 0xa438, 0x800a, 0xa438, 0xd700, 0xa438, 0x6041,
+        0xa438, 0x8402, 0xa438, 0xd415, 0xa438, 0x1000, 0xa438, 0x0a37,
+        0xa438, 0xd13d, 0xa438, 0xd04a, 0xa438, 0x1000, 0xa438, 0x0a5e,
+        0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xcb39, 0xa438, 0xa00a,
+        0xa438, 0xa190, 0xa438, 0xa2a0, 0xa438, 0xa404, 0xa438, 0xd700,
+        0xa438, 0x6041, 0xa438, 0xa402, 0xa438, 0xd17a, 0xa438, 0xd047,
+        0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4,
+        0xa438, 0x1800, 0xa438, 0x0560, 0xa438, 0xa111, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0xd3f5,
+        0xa438, 0xd219, 0xa438, 0x1000, 0xa438, 0x0c31, 0xa438, 0xd708,
+        0xa438, 0x5fa5, 0xa438, 0xa215, 0xa438, 0xd30e, 0xa438, 0xd21a,
+        0xa438, 0x1000, 0xa438, 0x0c31, 0xa438, 0xd708, 0xa438, 0x63e9,
+        0xa438, 0xd708, 0xa438, 0x5f65, 0xa438, 0xd708, 0xa438, 0x7f36,
+        0xa438, 0xa004, 0xa438, 0x1000, 0xa438, 0x0c35, 0xa438, 0x8004,
+        0xa438, 0xa001, 0xa438, 0x1000, 0xa438, 0x0c35, 0xa438, 0x8001,
+        0xa438, 0xd708, 0xa438, 0x4098, 0xa438, 0xd102, 0xa438, 0x9401,
+        0xa438, 0xf003, 0xa438, 0xd103, 0xa438, 0xb401, 0xa438, 0x1000,
+        0xa438, 0x0c27, 0xa438, 0xa108, 0xa438, 0x1000, 0xa438, 0x0c35,
+        0xa438, 0x8108, 0xa438, 0x8110, 0xa438, 0x8294, 0xa438, 0xa202,
+        0xa438, 0x1800, 0xa438, 0x0bdb, 0xa438, 0xd39c, 0xa438, 0xd210,
+        0xa438, 0x1000, 0xa438, 0x0c31, 0xa438, 0xd708, 0xa438, 0x5fa5,
+        0xa438, 0xd39c, 0xa438, 0xd210, 0xa438, 0x1000, 0xa438, 0x0c31,
+        0xa438, 0xd708, 0xa438, 0x5fa5, 0xa438, 0x1000, 0xa438, 0x0c31,
+        0xa438, 0xd708, 0xa438, 0x29b5, 0xa438, 0x840e, 0xa438, 0xd708,
+        0xa438, 0x5f4a, 0xa438, 0x0c1f, 0xa438, 0x1014, 0xa438, 0x1000,
+        0xa438, 0x0c31, 0xa438, 0xd709, 0xa438, 0x7fa4, 0xa438, 0x901f,
+        0xa438, 0x1800, 0xa438, 0x0c23, 0xa438, 0xcb43, 0xa438, 0xa508,
+        0xa438, 0xd701, 0xa438, 0x3699, 0xa438, 0x844a, 0xa438, 0xa504,
+        0xa438, 0xa190, 0xa438, 0xa2a0, 0xa438, 0xa404, 0xa438, 0xa00a,
+        0xa438, 0xd700, 0xa438, 0x2109, 0xa438, 0x05ea, 0xa438, 0xa402,
+        0xa438, 0x1800, 0xa438, 0x05ea, 0xa438, 0xcb90, 0xa438, 0x0cf0,
+        0xa438, 0x0ca0, 0xa438, 0x1800, 0xa438, 0x06db, 0xa438, 0xd1ff,
+        0xa438, 0xd052, 0xa438, 0xa508, 0xa438, 0x8718, 0xa438, 0xa00a,
+        0xa438, 0xa190, 0xa438, 0xa2a0, 0xa438, 0xa404, 0xa438, 0x0cf0,
+        0xa438, 0x0c50, 0xa438, 0x1800, 0xa438, 0x09ef, 0xa438, 0x1000,
+        0xa438, 0x0a5e, 0xa438, 0xd704, 0xa438, 0x2e70, 0xa438, 0x06da,
+        0xa438, 0xd700, 0xa438, 0x5f55, 0xa438, 0xa90c, 0xa438, 0x1800,
+        0xa438, 0x0645, 0xa436, 0xA10E, 0xa438, 0x0644, 0xa436, 0xA10C,
+        0xa438, 0x09e9, 0xa436, 0xA10A, 0xa438, 0x06da, 0xa436, 0xA108,
+        0xa438, 0x05e1, 0xa436, 0xA106, 0xa438, 0x0be4, 0xa436, 0xA104,
+        0xa438, 0x0435, 0xa436, 0xA102, 0xa438, 0x0141, 0xa436, 0xA100,
+        0xa438, 0x026d, 0xa436, 0xA110, 0xa438, 0x00ff, 0xa436, 0xb87c,
+        0xa438, 0x85fe, 0xa436, 0xb87e, 0xa438, 0xaf86, 0xa438, 0x16af,
+        0xa438, 0x8699, 0xa438, 0xaf86, 0xa438, 0xe5af, 0xa438, 0x86f9,
+        0xa438, 0xaf87, 0xa438, 0x7aaf, 0xa438, 0x883a, 0xa438, 0xaf88,
+        0xa438, 0x58af, 0xa438, 0x8b6c, 0xa438, 0xd48b, 0xa438, 0x7c02,
+        0xa438, 0x8644, 0xa438, 0x2c00, 0xa438, 0x503c, 0xa438, 0xffd6,
+        0xa438, 0xac27, 0xa438, 0x18e1, 0xa438, 0x82fe, 0xa438, 0xad28,
+        0xa438, 0x0cd4, 0xa438, 0x8b84, 0xa438, 0x0286, 0xa438, 0x442c,
+        0xa438, 0x003c, 0xa438, 0xac27, 0xa438, 0x06ee, 0xa438, 0x8299,
+        0xa438, 0x01ae, 0xa438, 0x04ee, 0xa438, 0x8299, 0xa438, 0x00af,
+        0xa438, 0x23dc, 0xa438, 0xf9fa, 0xa438, 0xcefa, 0xa438, 0xfbef,
+        0xa438, 0x79fb, 0xa438, 0xc4bf, 0xa438, 0x8b76, 0xa438, 0x026c,
+        0xa438, 0x6dac, 0xa438, 0x2804, 0xa438, 0xd203, 0xa438, 0xae02,
+        0xa438, 0xd201, 0xa438, 0xbdd8, 0xa438, 0x19d9, 0xa438, 0xef94,
+        0xa438, 0x026c, 0xa438, 0x6d78, 0xa438, 0x03ef, 0xa438, 0x648a,
+        0xa438, 0x0002, 0xa438, 0xbdd8, 0xa438, 0x19d9, 0xa438, 0xef94,
+        0xa438, 0x026c, 0xa438, 0x6d78, 0xa438, 0x03ef, 0xa438, 0x7402,
+        0xa438, 0x72cd, 0xa438, 0xac50, 0xa438, 0x02ef, 0xa438, 0x643a,
+        0xa438, 0x019f, 0xa438, 0xe4ef, 0xa438, 0x4678, 0xa438, 0x03ac,
+        0xa438, 0x2002, 0xa438, 0xae02, 0xa438, 0xd0ff, 0xa438, 0xffef,
+        0xa438, 0x97ff, 0xa438, 0xfec6, 0xa438, 0xfefd, 0xa438, 0x041f,
+        0xa438, 0x771f, 0xa438, 0x221c, 0xa438, 0x450d, 0xa438, 0x481f,
+        0xa438, 0x00ac, 0xa438, 0x7f04, 0xa438, 0x1a94, 0xa438, 0xae08,
+        0xa438, 0x1a94, 0xa438, 0xac7f, 0xa438, 0x03d7, 0xa438, 0x0100,
+        0xa438, 0xef46, 0xa438, 0x0d48, 0xa438, 0x1f00, 0xa438, 0x1c45,
+        0xa438, 0xef69, 0xa438, 0xef57, 0xa438, 0xef74, 0xa438, 0x0272,
+        0xa438, 0xe8a7, 0xa438, 0xffff, 0xa438, 0x0d1a, 0xa438, 0x941b,
+        0xa438, 0x979e, 0xa438, 0x072d, 0xa438, 0x0100, 0xa438, 0x1a64,
+        0xa438, 0xef76, 0xa438, 0xef97, 0xa438, 0x0d98, 0xa438, 0xd400,
+        0xa438, 0xff1d, 0xa438, 0x941a, 0xa438, 0x89cf, 0xa438, 0x1a75,
+        0xa438, 0xaf74, 0xa438, 0xf9bf, 0xa438, 0x8b79, 0xa438, 0x026c,
+        0xa438, 0x6da1, 0xa438, 0x0005, 0xa438, 0xe180, 0xa438, 0xa0ae,
+        0xa438, 0x03e1, 0xa438, 0x80a1, 0xa438, 0xaf26, 0xa438, 0x9aac,
+        0xa438, 0x284d, 0xa438, 0xe08f, 0xa438, 0xffef, 0xa438, 0x10c0,
+        0xa438, 0xe08f, 0xa438, 0xfe10, 0xa438, 0x1b08, 0xa438, 0xa000,
+        0xa438, 0x04c8, 0xa438, 0xaf40, 0xa438, 0x67c8, 0xa438, 0xbf8b,
+        0xa438, 0x8c02, 0xa438, 0x6c4e, 0xa438, 0xc4bf, 0xa438, 0x8b8f,
+        0xa438, 0x026c, 0xa438, 0x6def, 0xa438, 0x74e0, 0xa438, 0x830c,
+        0xa438, 0xad20, 0xa438, 0x0302, 0xa438, 0x74ac, 0xa438, 0xccef,
+        0xa438, 0x971b, 0xa438, 0x76ad, 0xa438, 0x5f02, 0xa438, 0xae13,
+        0xa438, 0xef69, 0xa438, 0xef30, 0xa438, 0x1b32, 0xa438, 0xc4ef,
+        0xa438, 0x46e4, 0xa438, 0x8ffb, 0xa438, 0xe58f, 0xa438, 0xfce7,
+        0xa438, 0x8ffd, 0xa438, 0xcc10, 0xa438, 0x11ae, 0xa438, 0xb8d1,
+        0xa438, 0x00a1, 0xa438, 0x1f03, 0xa438, 0xaf40, 0xa438, 0x4fbf,
+        0xa438, 0x8b8c, 0xa438, 0x026c, 0xa438, 0x4ec4, 0xa438, 0xbf8b,
+        0xa438, 0x8f02, 0xa438, 0x6c6d, 0xa438, 0xef74, 0xa438, 0xe083,
+        0xa438, 0x0cad, 0xa438, 0x2003, 0xa438, 0x0274, 0xa438, 0xaccc,
+        0xa438, 0xef97, 0xa438, 0x1b76, 0xa438, 0xad5f, 0xa438, 0x02ae,
+        0xa438, 0x04ef, 0xa438, 0x69ef, 0xa438, 0x3111, 0xa438, 0xaed1,
+        0xa438, 0x0287, 0xa438, 0x80af, 0xa438, 0x2293, 0xa438, 0xf8f9,
+        0xa438, 0xfafb, 0xa438, 0xef59, 0xa438, 0xe080, 0xa438, 0x13ad,
+        0xa438, 0x252f, 0xa438, 0xbf88, 0xa438, 0x2802, 0xa438, 0x6c6d,
+        0xa438, 0xef64, 0xa438, 0x1f44, 0xa438, 0xe18f, 0xa438, 0xb91b,
+        0xa438, 0x64ad, 0xa438, 0x4f1d, 0xa438, 0xd688, 0xa438, 0x2bd7,
+        0xa438, 0x882e, 0xa438, 0x0274, 0xa438, 0x73ad, 0xa438, 0x5008,
+        0xa438, 0xbf88, 0xa438, 0x3102, 0xa438, 0x737c, 0xa438, 0xae03,
+        0xa438, 0x0287, 0xa438, 0xd0bf, 0xa438, 0x882b, 0xa438, 0x0273,
+        0xa438, 0x73e0, 0xa438, 0x824c, 0xa438, 0xf621, 0xa438, 0xe482,
+        0xa438, 0x4cbf, 0xa438, 0x8834, 0xa438, 0x0273, 0xa438, 0x7cef,
+        0xa438, 0x95ff, 0xa438, 0xfefd, 0xa438, 0xfc04, 0xa438, 0xf8f9,
+        0xa438, 0xfafb, 0xa438, 0xef79, 0xa438, 0xbf88, 0xa438, 0x1f02,
+        0xa438, 0x737c, 0xa438, 0x1f22, 0xa438, 0xac32, 0xa438, 0x31ef,
+        0xa438, 0x12bf, 0xa438, 0x8822, 0xa438, 0x026c, 0xa438, 0x4ed6,
+        0xa438, 0x8fba, 0xa438, 0x1f33, 0xa438, 0xac3c, 0xa438, 0x1eef,
+        0xa438, 0x13bf, 0xa438, 0x8837, 0xa438, 0x026c, 0xa438, 0x4eef,
+        0xa438, 0x96d8, 0xa438, 0x19d9, 0xa438, 0xbf88, 0xa438, 0x2502,
+        0xa438, 0x6c4e, 0xa438, 0xbf88, 0xa438, 0x2502, 0xa438, 0x6c4e,
+        0xa438, 0x1616, 0xa438, 0x13ae, 0xa438, 0xdf12, 0xa438, 0xaecc,
+        0xa438, 0xbf88, 0xa438, 0x1f02, 0xa438, 0x7373, 0xa438, 0xef97,
+        0xa438, 0xfffe, 0xa438, 0xfdfc, 0xa438, 0x0466, 0xa438, 0xac88,
+        0xa438, 0x54ac, 0xa438, 0x88f0, 0xa438, 0xac8a, 0xa438, 0x92ac,
+        0xa438, 0xbadd, 0xa438, 0xac6c, 0xa438, 0xeeac, 0xa438, 0x6cff,
+        0xa438, 0xad02, 0xa438, 0x99ac, 0xa438, 0x0030, 0xa438, 0xac88,
+        0xa438, 0xd4c3, 0xa438, 0x5000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+        0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x00b4, 0xa438, 0xecee,
+        0xa438, 0x8298, 0xa438, 0x00af, 0xa438, 0x1412, 0xa438, 0xf8bf,
+        0xa438, 0x8b5d, 0xa438, 0x026c, 0xa438, 0x6d58, 0xa438, 0x03e1,
+        0xa438, 0x8fb8, 0xa438, 0x2901, 0xa438, 0xe58f, 0xa438, 0xb8a0,
+        0xa438, 0x0049, 0xa438, 0xef47, 0xa438, 0xe483, 0xa438, 0x02e5,
+        0xa438, 0x8303, 0xa438, 0xbfc2, 0xa438, 0x5f1a, 0xa438, 0x95f7,
+        0xa438, 0x05ee, 0xa438, 0xffd2, 0xa438, 0x00d8, 0xa438, 0xf605,
+        0xa438, 0x1f11, 0xa438, 0xef60, 0xa438, 0xbf8b, 0xa438, 0x3002,
+        0xa438, 0x6c4e, 0xa438, 0xbf8b, 0xa438, 0x3302, 0xa438, 0x6c6d,
+        0xa438, 0xf728, 0xa438, 0xbf8b, 0xa438, 0x3302, 0xa438, 0x6c4e,
+        0xa438, 0xf628, 0xa438, 0xbf8b, 0xa438, 0x3302, 0xa438, 0x6c4e,
+        0xa438, 0x0c64, 0xa438, 0xef46, 0xa438, 0xbf8b, 0xa438, 0x6002,
+        0xa438, 0x6c4e, 0xa438, 0x0289, 0xa438, 0x9902, 0xa438, 0x3920,
+        0xa438, 0xaf89, 0xa438, 0x96a0, 0xa438, 0x0149, 0xa438, 0xef47,
+        0xa438, 0xe483, 0xa438, 0x04e5, 0xa438, 0x8305, 0xa438, 0xbfc2,
+        0xa438, 0x5f1a, 0xa438, 0x95f7, 0xa438, 0x05ee, 0xa438, 0xffd2,
+        0xa438, 0x00d8, 0xa438, 0xf605, 0xa438, 0x1f11, 0xa438, 0xef60,
+        0xa438, 0xbf8b, 0xa438, 0x3002, 0xa438, 0x6c4e, 0xa438, 0xbf8b,
+        0xa438, 0x3302, 0xa438, 0x6c6d, 0xa438, 0xf729, 0xa438, 0xbf8b,
+        0xa438, 0x3302, 0xa438, 0x6c4e, 0xa438, 0xf629, 0xa438, 0xbf8b,
+        0xa438, 0x3302, 0xa438, 0x6c4e, 0xa438, 0x0c64, 0xa438, 0xef46,
+        0xa438, 0xbf8b, 0xa438, 0x6302, 0xa438, 0x6c4e, 0xa438, 0x0289,
+        0xa438, 0x9902, 0xa438, 0x3920, 0xa438, 0xaf89, 0xa438, 0x96a0,
+        0xa438, 0x0249, 0xa438, 0xef47, 0xa438, 0xe483, 0xa438, 0x06e5,
+        0xa438, 0x8307, 0xa438, 0xbfc2, 0xa438, 0x5f1a, 0xa438, 0x95f7,
+        0xa438, 0x05ee, 0xa438, 0xffd2, 0xa438, 0x00d8, 0xa438, 0xf605,
+        0xa438, 0x1f11, 0xa438, 0xef60, 0xa438, 0xbf8b, 0xa438, 0x3002,
+        0xa438, 0x6c4e, 0xa438, 0xbf8b, 0xa438, 0x3302, 0xa438, 0x6c6d,
+        0xa438, 0xf72a, 0xa438, 0xbf8b, 0xa438, 0x3302, 0xa438, 0x6c4e,
+        0xa438, 0xf62a, 0xa438, 0xbf8b, 0xa438, 0x3302, 0xa438, 0x6c4e,
+        0xa438, 0x0c64, 0xa438, 0xef46, 0xa438, 0xbf8b, 0xa438, 0x6602,
+        0xa438, 0x6c4e, 0xa438, 0x0289, 0xa438, 0x9902, 0xa438, 0x3920,
+        0xa438, 0xaf89, 0xa438, 0x96ef, 0xa438, 0x47e4, 0xa438, 0x8308,
+        0xa438, 0xe583, 0xa438, 0x09bf, 0xa438, 0xc25f, 0xa438, 0x1a95,
+        0xa438, 0xf705, 0xa438, 0xeeff, 0xa438, 0xd200, 0xa438, 0xd8f6,
+        0xa438, 0x051f, 0xa438, 0x11ef, 0xa438, 0x60bf, 0xa438, 0x8b30,
+        0xa438, 0x026c, 0xa438, 0x4ebf, 0xa438, 0x8b33, 0xa438, 0x026c,
+        0xa438, 0x6df7, 0xa438, 0x2bbf, 0xa438, 0x8b33, 0xa438, 0x026c,
+        0xa438, 0x4ef6, 0xa438, 0x2bbf, 0xa438, 0x8b33, 0xa438, 0x026c,
+        0xa438, 0x4e0c, 0xa438, 0x64ef, 0xa438, 0x46bf, 0xa438, 0x8b69,
+        0xa438, 0x026c, 0xa438, 0x4e02, 0xa438, 0x8999, 0xa438, 0x0239,
+        0xa438, 0x20af, 0xa438, 0x8996, 0xa438, 0xaf39, 0xa438, 0x1ef8,
+        0xa438, 0xf9fa, 0xa438, 0xe08f, 0xa438, 0xb838, 0xa438, 0x02ad,
+        0xa438, 0x2702, 0xa438, 0xae03, 0xa438, 0xaf8b, 0xa438, 0x201f,
+        0xa438, 0x66ef, 0xa438, 0x65bf, 0xa438, 0xc21f, 0xa438, 0x1a96,
+        0xa438, 0xf705, 0xa438, 0xeeff, 0xa438, 0xd200, 0xa438, 0xdaf6,
+        0xa438, 0x05bf, 0xa438, 0xc22f, 0xa438, 0x1a96, 0xa438, 0xf705,
+        0xa438, 0xeeff, 0xa438, 0xd200, 0xa438, 0xdbf6, 0xa438, 0x05ef,
+        0xa438, 0x021f, 0xa438, 0x110d, 0xa438, 0x42bf, 0xa438, 0x8b3c,
+        0xa438, 0x026c, 0xa438, 0x4eef, 0xa438, 0x021b, 0xa438, 0x031f,
+        0xa438, 0x110d, 0xa438, 0x42bf, 0xa438, 0x8b36, 0xa438, 0x026c,
+        0xa438, 0x4eef, 0xa438, 0x021a, 0xa438, 0x031f, 0xa438, 0x110d,
+        0xa438, 0x42bf, 0xa438, 0x8b39, 0xa438, 0x026c, 0xa438, 0x4ebf,
+        0xa438, 0xc23f, 0xa438, 0x1a96, 0xa438, 0xf705, 0xa438, 0xeeff,
+        0xa438, 0xd200, 0xa438, 0xdaf6, 0xa438, 0x05bf, 0xa438, 0xc24f,
+        0xa438, 0x1a96, 0xa438, 0xf705, 0xa438, 0xeeff, 0xa438, 0xd200,
+        0xa438, 0xdbf6, 0xa438, 0x05ef, 0xa438, 0x021f, 0xa438, 0x110d,
+        0xa438, 0x42bf, 0xa438, 0x8b45, 0xa438, 0x026c, 0xa438, 0x4eef,
+        0xa438, 0x021b, 0xa438, 0x031f, 0xa438, 0x110d, 0xa438, 0x42bf,
+        0xa438, 0x8b3f, 0xa438, 0x026c, 0xa438, 0x4eef, 0xa438, 0x021a,
+        0xa438, 0x031f, 0xa438, 0x110d, 0xa438, 0x42bf, 0xa438, 0x8b42,
+        0xa438, 0x026c, 0xa438, 0x4eef, 0xa438, 0x56d0, 0xa438, 0x201f,
+        0xa438, 0x11bf, 0xa438, 0x8b4e, 0xa438, 0x026c, 0xa438, 0x4ebf,
+        0xa438, 0x8b48, 0xa438, 0x026c, 0xa438, 0x4ebf, 0xa438, 0x8b4b,
+        0xa438, 0x026c, 0xa438, 0x4ee1, 0xa438, 0x8578, 0xa438, 0xef03,
+        0xa438, 0x480a, 0xa438, 0x2805, 0xa438, 0xef20, 0xa438, 0x1b01,
+        0xa438, 0xad27, 0xa438, 0x3f1f, 0xa438, 0x44e0, 0xa438, 0x8560,
+        0xa438, 0xe185, 0xa438, 0x61bf, 0xa438, 0x8b51, 0xa438, 0x026c,
+        0xa438, 0x4ee0, 0xa438, 0x8566, 0xa438, 0xe185, 0xa438, 0x67bf,
+        0xa438, 0x8b54, 0xa438, 0x026c, 0xa438, 0x4ee0, 0xa438, 0x856c,
+        0xa438, 0xe185, 0xa438, 0x6dbf, 0xa438, 0x8b57, 0xa438, 0x026c,
+        0xa438, 0x4ee0, 0xa438, 0x8572, 0xa438, 0xe185, 0xa438, 0x73bf,
+        0xa438, 0x8b5a, 0xa438, 0x026c, 0xa438, 0x4ee1, 0xa438, 0x8fb8,
+        0xa438, 0x5900, 0xa438, 0xf728, 0xa438, 0xe58f, 0xa438, 0xb8af,
+        0xa438, 0x8b2c, 0xa438, 0xe185, 0xa438, 0x791b, 0xa438, 0x21ad,
+        0xa438, 0x373e, 0xa438, 0x1f44, 0xa438, 0xe085, 0xa438, 0x62e1,
+        0xa438, 0x8563, 0xa438, 0xbf8b, 0xa438, 0x5102, 0xa438, 0x6c4e,
+        0xa438, 0xe085, 0xa438, 0x68e1, 0xa438, 0x8569, 0xa438, 0xbf8b,
+        0xa438, 0x5402, 0xa438, 0x6c4e, 0xa438, 0xe085, 0xa438, 0x6ee1,
+        0xa438, 0x856f, 0xa438, 0xbf8b, 0xa438, 0x5702, 0xa438, 0x6c4e,
+        0xa438, 0xe085, 0xa438, 0x74e1, 0xa438, 0x8575, 0xa438, 0xbf8b,
+        0xa438, 0x5a02, 0xa438, 0x6c4e, 0xa438, 0xe18f, 0xa438, 0xb859,
+        0xa438, 0x00f7, 0xa438, 0x28e5, 0xa438, 0x8fb8, 0xa438, 0xae4a,
+        0xa438, 0x1f44, 0xa438, 0xe085, 0xa438, 0x64e1, 0xa438, 0x8565,
+        0xa438, 0xbf8b, 0xa438, 0x5102, 0xa438, 0x6c4e, 0xa438, 0xe085,
+        0xa438, 0x6ae1, 0xa438, 0x856b, 0xa438, 0xbf8b, 0xa438, 0x5402,
+        0xa438, 0x6c4e, 0xa438, 0xe085, 0xa438, 0x70e1, 0xa438, 0x8571,
+        0xa438, 0xbf8b, 0xa438, 0x5702, 0xa438, 0x6c4e, 0xa438, 0xe085,
+        0xa438, 0x76e1, 0xa438, 0x8577, 0xa438, 0xbf8b, 0xa438, 0x5a02,
+        0xa438, 0x6c4e, 0xa438, 0xe18f, 0xa438, 0xb859, 0xa438, 0x00f7,
+        0xa438, 0x28e5, 0xa438, 0x8fb8, 0xa438, 0xae0c, 0xa438, 0xe18f,
+        0xa438, 0xb839, 0xa438, 0x04ac, 0xa438, 0x2f04, 0xa438, 0xee8f,
+        0xa438, 0xb800, 0xa438, 0xfefd, 0xa438, 0xfc04, 0xa438, 0xf0ac,
+        0xa438, 0x8efc, 0xa438, 0xac8c, 0xa438, 0xf0ac, 0xa438, 0xfaf0,
+        0xa438, 0xacf8, 0xa438, 0xf0ac, 0xa438, 0xf6f0, 0xa438, 0xad00,
+        0xa438, 0xf0ac, 0xa438, 0xfef0, 0xa438, 0xacfc, 0xa438, 0xf0ac,
+        0xa438, 0xf4f0, 0xa438, 0xacf2, 0xa438, 0xf0ac, 0xa438, 0xf0f0,
+        0xa438, 0xacb0, 0xa438, 0xf0ac, 0xa438, 0xaef0, 0xa438, 0xacac,
+        0xa438, 0xf0ac, 0xa438, 0xaaf0, 0xa438, 0xacee, 0xa438, 0xf0b0,
+        0xa438, 0x24f0, 0xa438, 0xb0a4, 0xa438, 0xf0b1, 0xa438, 0x24f0,
+        0xa438, 0xb1a4, 0xa438, 0xee8f, 0xa438, 0xb800, 0xa438, 0xd400,
+        0xa438, 0x00af, 0xa438, 0x3976, 0xa438, 0x66ac, 0xa438, 0xeabb,
+        0xa438, 0xa430, 0xa438, 0x6e50, 0xa438, 0x6e53, 0xa438, 0x6e56,
+        0xa438, 0x6e59, 0xa438, 0x6e5c, 0xa438, 0x6e5f, 0xa438, 0x6e62,
+        0xa438, 0x6e65, 0xa438, 0xd9ac, 0xa438, 0x70f0, 0xa438, 0xac6a,
+        0xa436, 0xb85e, 0xa438, 0x23b7, 0xa436, 0xb860, 0xa438, 0x74db,
+        0xa436, 0xb862, 0xa438, 0x268c, 0xa436, 0xb864, 0xa438, 0x3FE5,
+        0xa436, 0xb886, 0xa438, 0x2250, 0xa436, 0xb888, 0xa438, 0x140e,
+        0xa436, 0xb88a, 0xa438, 0x3696, 0xa436, 0xb88c, 0xa438, 0x3973,
+        0xa436, 0xb838, 0xa438, 0x00ff, 0xb820, 0x0010, 0xa436, 0x8464,
+        0xa438, 0xaf84, 0xa438, 0x7caf, 0xa438, 0x8485, 0xa438, 0xaf85,
+        0xa438, 0x13af, 0xa438, 0x851e, 0xa438, 0xaf85, 0xa438, 0xb9af,
+        0xa438, 0x8684, 0xa438, 0xaf87, 0xa438, 0x01af, 0xa438, 0x8701,
+        0xa438, 0xac38, 0xa438, 0x03af, 0xa438, 0x38bb, 0xa438, 0xaf38,
+        0xa438, 0xc302, 0xa438, 0x4618, 0xa438, 0xbf85, 0xa438, 0x0a02,
+        0xa438, 0x54b7, 0xa438, 0xbf85, 0xa438, 0x1002, 0xa438, 0x54c0,
+        0xa438, 0xd400, 0xa438, 0x0fbf, 0xa438, 0x8507, 0xa438, 0x024f,
+        0xa438, 0x48bf, 0xa438, 0x8504, 0xa438, 0x024f, 0xa438, 0x6759,
+        0xa438, 0xf0a1, 0xa438, 0x3008, 0xa438, 0xbf85, 0xa438, 0x0d02,
+        0xa438, 0x54c0, 0xa438, 0xae06, 0xa438, 0xbf85, 0xa438, 0x0d02,
+        0xa438, 0x54b7, 0xa438, 0xbf85, 0xa438, 0x0402, 0xa438, 0x4f67,
+        0xa438, 0xa183, 0xa438, 0x02ae, 0xa438, 0x15a1, 0xa438, 0x8502,
+        0xa438, 0xae10, 0xa438, 0x59f0, 0xa438, 0xa180, 0xa438, 0x16bf,
+        0xa438, 0x8501, 0xa438, 0x024f, 0xa438, 0x67a1, 0xa438, 0x381b,
+        0xa438, 0xae0b, 0xa438, 0xe18f, 0xa438, 0xffbf, 0xa438, 0x84fe,
+        0xa438, 0x024f, 0xa438, 0x48ae, 0xa438, 0x17bf, 0xa438, 0x84fe,
+        0xa438, 0x0254, 0xa438, 0xb7bf, 0xa438, 0x84fb, 0xa438, 0x0254,
+        0xa438, 0xb7ae, 0xa438, 0x09a1, 0xa438, 0x5006, 0xa438, 0xbf84,
+        0xa438, 0xfb02, 0xa438, 0x54c0, 0xa438, 0xaf04, 0xa438, 0x4700,
+        0xa438, 0xad34, 0xa438, 0xfdad, 0xa438, 0x0670, 0xa438, 0xae14,
+        0xa438, 0xf0a6, 0xa438, 0x00b8, 0xa438, 0xbd32, 0xa438, 0x30bd,
+        0xa438, 0x30aa, 0xa438, 0xbd2c, 0xa438, 0xccbd, 0xa438, 0x2ca1,
+        0xa438, 0x0705, 0xa438, 0xec80, 0xa438, 0xaf40, 0xa438, 0xf7af,
+        0xa438, 0x40f5, 0xa438, 0xd101, 0xa438, 0xbf85, 0xa438, 0xa402,
+        0xa438, 0x4f48, 0xa438, 0xbf85, 0xa438, 0xa702, 0xa438, 0x54c0,
+        0xa438, 0xd10f, 0xa438, 0xbf85, 0xa438, 0xaa02, 0xa438, 0x4f48,
+        0xa438, 0x024d, 0xa438, 0x6abf, 0xa438, 0x85ad, 0xa438, 0x024f,
+        0xa438, 0x67bf, 0xa438, 0x8ff7, 0xa438, 0xddbf, 0xa438, 0x85b0,
+        0xa438, 0x024f, 0xa438, 0x67bf, 0xa438, 0x8ff8, 0xa438, 0xddbf,
+        0xa438, 0x85b3, 0xa438, 0x024f, 0xa438, 0x67bf, 0xa438, 0x8ff9,
+        0xa438, 0xddbf, 0xa438, 0x85b6, 0xa438, 0x024f, 0xa438, 0x67bf,
+        0xa438, 0x8ffa, 0xa438, 0xddd1, 0xa438, 0x00bf, 0xa438, 0x85aa,
+        0xa438, 0x024f, 0xa438, 0x4802, 0xa438, 0x4d6a, 0xa438, 0xbf85,
+        0xa438, 0xad02, 0xa438, 0x4f67, 0xa438, 0xbf8f, 0xa438, 0xfbdd,
+        0xa438, 0xbf85, 0xa438, 0xb002, 0xa438, 0x4f67, 0xa438, 0xbf8f,
+        0xa438, 0xfcdd, 0xa438, 0xbf85, 0xa438, 0xb302, 0xa438, 0x4f67,
+        0xa438, 0xbf8f, 0xa438, 0xfddd, 0xa438, 0xbf85, 0xa438, 0xb602,
+        0xa438, 0x4f67, 0xa438, 0xbf8f, 0xa438, 0xfedd, 0xa438, 0xbf85,
+        0xa438, 0xa702, 0xa438, 0x54b7, 0xa438, 0xbf85, 0xa438, 0xa102,
+        0xa438, 0x54b7, 0xa438, 0xaf3c, 0xa438, 0x2066, 0xa438, 0xb800,
+        0xa438, 0xb8bd, 0xa438, 0x30ee, 0xa438, 0xbd2c, 0xa438, 0xb8bd,
+        0xa438, 0x7040, 0xa438, 0xbd86, 0xa438, 0xc8bd, 0xa438, 0x8640,
+        0xa438, 0xbd88, 0xa438, 0xc8bd, 0xa438, 0x8802, 0xa438, 0x1929,
+        0xa438, 0xa202, 0xa438, 0x02ae, 0xa438, 0x03a2, 0xa438, 0x032e,
+        0xa438, 0xd10f, 0xa438, 0xbf85, 0xa438, 0xaa02, 0xa438, 0x4f48,
+        0xa438, 0xe18f, 0xa438, 0xf7bf, 0xa438, 0x85ad, 0xa438, 0x024f,
+        0xa438, 0x48e1, 0xa438, 0x8ff8, 0xa438, 0xbf85, 0xa438, 0xb002,
+        0xa438, 0x4f48, 0xa438, 0xe18f, 0xa438, 0xf9bf, 0xa438, 0x85b3,
+        0xa438, 0x024f, 0xa438, 0x48e1, 0xa438, 0x8ffa, 0xa438, 0xbf85,
+        0xa438, 0xb602, 0xa438, 0x4f48, 0xa438, 0xae2c, 0xa438, 0xd100,
+        0xa438, 0xbf85, 0xa438, 0xaa02, 0xa438, 0x4f48, 0xa438, 0xe18f,
+        0xa438, 0xfbbf, 0xa438, 0x85ad, 0xa438, 0x024f, 0xa438, 0x48e1,
+        0xa438, 0x8ffc, 0xa438, 0xbf85, 0xa438, 0xb002, 0xa438, 0x4f48,
+        0xa438, 0xe18f, 0xa438, 0xfdbf, 0xa438, 0x85b3, 0xa438, 0x024f,
+        0xa438, 0x48e1, 0xa438, 0x8ffe, 0xa438, 0xbf85, 0xa438, 0xb602,
+        0xa438, 0x4f48, 0xa438, 0xbf86, 0xa438, 0x7e02, 0xa438, 0x4f67,
+        0xa438, 0xa100, 0xa438, 0x02ae, 0xa438, 0x25a1, 0xa438, 0x041d,
+        0xa438, 0xe18f, 0xa438, 0xf1bf, 0xa438, 0x8675, 0xa438, 0x024f,
+        0xa438, 0x48e1, 0xa438, 0x8ff2, 0xa438, 0xbf86, 0xa438, 0x7802,
+        0xa438, 0x4f48, 0xa438, 0xe18f, 0xa438, 0xf3bf, 0xa438, 0x867b,
+        0xa438, 0x024f, 0xa438, 0x48ae, 0xa438, 0x29a1, 0xa438, 0x070b,
+        0xa438, 0xae24, 0xa438, 0xbf86, 0xa438, 0x8102, 0xa438, 0x4f67,
+        0xa438, 0xad28, 0xa438, 0x1be1, 0xa438, 0x8ff4, 0xa438, 0xbf86,
+        0xa438, 0x7502, 0xa438, 0x4f48, 0xa438, 0xe18f, 0xa438, 0xf5bf,
+        0xa438, 0x8678, 0xa438, 0x024f, 0xa438, 0x48e1, 0xa438, 0x8ff6,
+        0xa438, 0xbf86, 0xa438, 0x7b02, 0xa438, 0x4f48, 0xa438, 0xaf09,
+        0xa438, 0x8420, 0xa438, 0xbc32, 0xa438, 0x20bc, 0xa438, 0x3e76,
+        0xa438, 0xbc08, 0xa438, 0xfda6, 0xa438, 0x1a00, 0xa438, 0xb64e,
+        0xa438, 0xd101, 0xa438, 0xbf85, 0xa438, 0xa402, 0xa438, 0x4f48,
+        0xa438, 0xbf85, 0xa438, 0xa702, 0xa438, 0x54c0, 0xa438, 0xd10f,
+        0xa438, 0xbf85, 0xa438, 0xaa02, 0xa438, 0x4f48, 0xa438, 0x024d,
+        0xa438, 0x6abf, 0xa438, 0x85ad, 0xa438, 0x024f, 0xa438, 0x67bf,
+        0xa438, 0x8ff7, 0xa438, 0xddbf, 0xa438, 0x85b0, 0xa438, 0x024f,
+        0xa438, 0x67bf, 0xa438, 0x8ff8, 0xa438, 0xddbf, 0xa438, 0x85b3,
+        0xa438, 0x024f, 0xa438, 0x67bf, 0xa438, 0x8ff9, 0xa438, 0xddbf,
+        0xa438, 0x85b6, 0xa438, 0x024f, 0xa438, 0x67bf, 0xa438, 0x8ffa,
+        0xa438, 0xddd1, 0xa438, 0x00bf, 0xa438, 0x85aa, 0xa438, 0x024f,
+        0xa438, 0x4802, 0xa438, 0x4d6a, 0xa438, 0xbf85, 0xa438, 0xad02,
+        0xa438, 0x4f67, 0xa438, 0xbf8f, 0xa438, 0xfbdd, 0xa438, 0xbf85,
+        0xa438, 0xb002, 0xa438, 0x4f67, 0xa438, 0xbf8f, 0xa438, 0xfcdd,
+        0xa438, 0xbf85, 0xa438, 0xb302, 0xa438, 0x4f67, 0xa438, 0xbf8f,
+        0xa438, 0xfddd, 0xa438, 0xbf85, 0xa438, 0xb602, 0xa438, 0x4f67,
+        0xa438, 0xbf8f, 0xa438, 0xfedd, 0xa438, 0xbf85, 0xa438, 0xa702,
+        0xa438, 0x54b7, 0xa438, 0xaf00, 0xa438, 0x8800, 0xa436, 0xb818,
+        0xa438, 0x38b8, 0xa436, 0xb81a, 0xa438, 0x0444, 0xa436, 0xb81c,
+        0xa438, 0x40ee, 0xa436, 0xb81e, 0xa438, 0x3C1A, 0xa436, 0xb850,
+        0xa438, 0x0981, 0xa436, 0xb852, 0xa438, 0x0085, 0xa436, 0xb878,
+        0xa438, 0xffff, 0xa436, 0xb884, 0xa438, 0xffff, 0xa436, 0xb832,
+        0xa438, 0x003f, 0xa436, 0x0000, 0xa438, 0x0000, 0xa436, 0xB82E,
+        0xa438, 0x0000, 0xa436, 0x8024, 0xa438, 0x0000, 0xb820, 0x0000,
+        0xa436, 0x801E, 0xa438, 0x0021, 0xFFFF, 0xFFFF
+};
+
+static const u16 phy_mcu_ram_code_8125b_2[] = {
+        0xa436, 0x8024, 0xa438, 0x3701, 0xa436, 0xB82E, 0xa438, 0x0001,
+        0xb820, 0x0090, 0xa436, 0xA016, 0xa438, 0x0000, 0xa436, 0xA012,
+        0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+        0xa438, 0x1800, 0xa438, 0x801a, 0xa438, 0x1800, 0xa438, 0x803f,
+        0xa438, 0x1800, 0xa438, 0x8045, 0xa438, 0x1800, 0xa438, 0x8067,
+        0xa438, 0x1800, 0xa438, 0x806d, 0xa438, 0x1800, 0xa438, 0x8071,
+        0xa438, 0x1800, 0xa438, 0x80b1, 0xa438, 0xd093, 0xa438, 0xd1c4,
+        0xa438, 0x1000, 0xa438, 0x135c, 0xa438, 0xd704, 0xa438, 0x5fbc,
+        0xa438, 0xd504, 0xa438, 0xc9f1, 0xa438, 0x1800, 0xa438, 0x0fc9,
+        0xa438, 0xbb50, 0xa438, 0xd505, 0xa438, 0xa202, 0xa438, 0xd504,
+        0xa438, 0x8c0f, 0xa438, 0xd500, 0xa438, 0x1000, 0xa438, 0x1519,
+        0xa438, 0x1000, 0xa438, 0x135c, 0xa438, 0xd75e, 0xa438, 0x5fae,
+        0xa438, 0x9b50, 0xa438, 0x1000, 0xa438, 0x135c, 0xa438, 0xd75e,
+        0xa438, 0x7fae, 0xa438, 0x1000, 0xa438, 0x135c, 0xa438, 0xd707,
+        0xa438, 0x40a7, 0xa438, 0xd719, 0xa438, 0x4071, 0xa438, 0x1800,
+        0xa438, 0x1557, 0xa438, 0xd719, 0xa438, 0x2f70, 0xa438, 0x803b,
+        0xa438, 0x2f73, 0xa438, 0x156a, 0xa438, 0x5e70, 0xa438, 0x1800,
+        0xa438, 0x155d, 0xa438, 0xd505, 0xa438, 0xa202, 0xa438, 0xd500,
+        0xa438, 0xffed, 0xa438, 0xd709, 0xa438, 0x4054, 0xa438, 0xa788,
+        0xa438, 0xd70b, 0xa438, 0x1800, 0xa438, 0x172a, 0xa438, 0xc0c1,
+        0xa438, 0xc0c0, 0xa438, 0xd05a, 0xa438, 0xd1ba, 0xa438, 0xd701,
+        0xa438, 0x2529, 0xa438, 0x022a, 0xa438, 0xd0a7, 0xa438, 0xd1b9,
+        0xa438, 0xa208, 0xa438, 0x1000, 0xa438, 0x080e, 0xa438, 0xd701,
+        0xa438, 0x408b, 0xa438, 0x1000, 0xa438, 0x0a65, 0xa438, 0xf003,
+        0xa438, 0x1000, 0xa438, 0x0a6b, 0xa438, 0xd701, 0xa438, 0x1000,
+        0xa438, 0x0920, 0xa438, 0x1000, 0xa438, 0x0915, 0xa438, 0x1000,
+        0xa438, 0x0909, 0xa438, 0x228f, 0xa438, 0x804e, 0xa438, 0x9801,
+        0xa438, 0xd71e, 0xa438, 0x5d61, 0xa438, 0xd701, 0xa438, 0x1800,
+        0xa438, 0x022a, 0xa438, 0x2005, 0xa438, 0x091a, 0xa438, 0x3bd9,
+        0xa438, 0x0919, 0xa438, 0x1800, 0xa438, 0x0916, 0xa438, 0xd090,
+        0xa438, 0xd1c9, 0xa438, 0x1800, 0xa438, 0x1064, 0xa438, 0xd096,
+        0xa438, 0xd1a9, 0xa438, 0xd503, 0xa438, 0xa104, 0xa438, 0x0c07,
+        0xa438, 0x0902, 0xa438, 0xd500, 0xa438, 0xbc10, 0xa438, 0xd501,
+        0xa438, 0xce01, 0xa438, 0xa201, 0xa438, 0x8201, 0xa438, 0xce00,
+        0xa438, 0xd500, 0xa438, 0xc484, 0xa438, 0xd503, 0xa438, 0xcc02,
+        0xa438, 0xcd0d, 0xa438, 0xaf01, 0xa438, 0xd500, 0xa438, 0xd703,
+        0xa438, 0x4371, 0xa438, 0xbd08, 0xa438, 0x1000, 0xa438, 0x135c,
+        0xa438, 0xd75e, 0xa438, 0x5fb3, 0xa438, 0xd503, 0xa438, 0xd0f5,
+        0xa438, 0xd1c6, 0xa438, 0x0cf0, 0xa438, 0x0e50, 0xa438, 0xd704,
+        0xa438, 0x401c, 0xa438, 0xd0f5, 0xa438, 0xd1c6, 0xa438, 0x0cf0,
+        0xa438, 0x0ea0, 0xa438, 0x401c, 0xa438, 0xd07b, 0xa438, 0xd1c5,
+        0xa438, 0x8ef0, 0xa438, 0x401c, 0xa438, 0x9d08, 0xa438, 0x1000,
+        0xa438, 0x135c, 0xa438, 0xd75e, 0xa438, 0x7fb3, 0xa438, 0x1000,
+        0xa438, 0x135c, 0xa438, 0xd75e, 0xa438, 0x5fad, 0xa438, 0x1000,
+        0xa438, 0x14c5, 0xa438, 0xd703, 0xa438, 0x3181, 0xa438, 0x80af,
+        0xa438, 0x60ad, 0xa438, 0x1000, 0xa438, 0x135c, 0xa438, 0xd703,
+        0xa438, 0x5fba, 0xa438, 0x1800, 0xa438, 0x0cc7, 0xa438, 0xa802,
+        0xa438, 0xa301, 0xa438, 0xa801, 0xa438, 0xc004, 0xa438, 0xd710,
+        0xa438, 0x4000, 0xa438, 0x1800, 0xa438, 0x1e79, 0xa436, 0xA026,
+        0xa438, 0x1e78, 0xa436, 0xA024, 0xa438, 0x0c93, 0xa436, 0xA022,
+        0xa438, 0x1062, 0xa436, 0xA020, 0xa438, 0x0915, 0xa436, 0xA006,
+        0xa438, 0x020a, 0xa436, 0xA004, 0xa438, 0x1726, 0xa436, 0xA002,
+        0xa438, 0x1542, 0xa436, 0xA000, 0xa438, 0x0fc7, 0xa436, 0xA008,
+        0xa438, 0xff00, 0xa436, 0xA016, 0xa438, 0x0010, 0xa436, 0xA012,
+        0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+        0xa438, 0x1800, 0xa438, 0x801d, 0xa438, 0x1800, 0xa438, 0x802c,
+        0xa438, 0x1800, 0xa438, 0x802c, 0xa438, 0x1800, 0xa438, 0x802c,
+        0xa438, 0x1800, 0xa438, 0x802c, 0xa438, 0x1800, 0xa438, 0x802c,
+        0xa438, 0x1800, 0xa438, 0x802c, 0xa438, 0xd700, 0xa438, 0x6090,
+        0xa438, 0x60d1, 0xa438, 0xc95c, 0xa438, 0xf007, 0xa438, 0x60b1,
+        0xa438, 0xc95a, 0xa438, 0xf004, 0xa438, 0xc956, 0xa438, 0xf002,
+        0xa438, 0xc94e, 0xa438, 0x1800, 0xa438, 0x00cd, 0xa438, 0xd700,
+        0xa438, 0x6090, 0xa438, 0x60d1, 0xa438, 0xc95c, 0xa438, 0xf007,
+        0xa438, 0x60b1, 0xa438, 0xc95a, 0xa438, 0xf004, 0xa438, 0xc956,
+        0xa438, 0xf002, 0xa438, 0xc94e, 0xa438, 0x1000, 0xa438, 0x022a,
+        0xa438, 0x1800, 0xa438, 0x0132, 0xa436, 0xA08E, 0xa438, 0xffff,
+        0xa436, 0xA08C, 0xa438, 0xffff, 0xa436, 0xA08A, 0xa438, 0xffff,
+        0xa436, 0xA088, 0xa438, 0xffff, 0xa436, 0xA086, 0xa438, 0xffff,
+        0xa436, 0xA084, 0xa438, 0xffff, 0xa436, 0xA082, 0xa438, 0x012f,
+        0xa436, 0xA080, 0xa438, 0x00cc, 0xa436, 0xA090, 0xa438, 0x0103,
+        0xa436, 0xA016, 0xa438, 0x0020, 0xa436, 0xA012, 0xa438, 0x0000,
+        0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010, 0xa438, 0x1800,
+        0xa438, 0x8020, 0xa438, 0x1800, 0xa438, 0x802a, 0xa438, 0x1800,
+        0xa438, 0x8035, 0xa438, 0x1800, 0xa438, 0x803c, 0xa438, 0x1800,
+        0xa438, 0x803c, 0xa438, 0x1800, 0xa438, 0x803c, 0xa438, 0x1800,
+        0xa438, 0x803c, 0xa438, 0xd107, 0xa438, 0xd042, 0xa438, 0xa404,
+        0xa438, 0x1000, 0xa438, 0x09df, 0xa438, 0xd700, 0xa438, 0x5fb4,
+        0xa438, 0x8280, 0xa438, 0xd700, 0xa438, 0x6065, 0xa438, 0xd125,
+        0xa438, 0xf002, 0xa438, 0xd12b, 0xa438, 0xd040, 0xa438, 0x1800,
+        0xa438, 0x077f, 0xa438, 0x0cf0, 0xa438, 0x0c50, 0xa438, 0xd104,
+        0xa438, 0xd040, 0xa438, 0x1000, 0xa438, 0x0aa8, 0xa438, 0xd700,
+        0xa438, 0x5fb4, 0xa438, 0x1800, 0xa438, 0x0a2e, 0xa438, 0xcb9b,
+        0xa438, 0xd110, 0xa438, 0xd040, 0xa438, 0x1000, 0xa438, 0x0b7b,
+        0xa438, 0x1000, 0xa438, 0x09df, 0xa438, 0xd700, 0xa438, 0x5fb4,
+        0xa438, 0x1800, 0xa438, 0x081b, 0xa438, 0x1000, 0xa438, 0x09df,
+        0xa438, 0xd704, 0xa438, 0x7fb8, 0xa438, 0xa718, 0xa438, 0x1800,
+        0xa438, 0x074e, 0xa436, 0xA10E, 0xa438, 0xffff, 0xa436, 0xA10C,
+        0xa438, 0xffff, 0xa436, 0xA10A, 0xa438, 0xffff, 0xa436, 0xA108,
+        0xa438, 0xffff, 0xa436, 0xA106, 0xa438, 0x074d, 0xa436, 0xA104,
+        0xa438, 0x0818, 0xa436, 0xA102, 0xa438, 0x0a2c, 0xa436, 0xA100,
+        0xa438, 0x077e, 0xa436, 0xA110, 0xa438, 0x000f, 0xa436, 0xb87c,
+        0xa438, 0x8625, 0xa436, 0xb87e, 0xa438, 0xaf86, 0xa438, 0x3daf,
+        0xa438, 0x8689, 0xa438, 0xaf88, 0xa438, 0x69af, 0xa438, 0x8887,
+        0xa438, 0xaf88, 0xa438, 0x9caf, 0xa438, 0x889c, 0xa438, 0xaf88,
+        0xa438, 0x9caf, 0xa438, 0x889c, 0xa438, 0xbf86, 0xa438, 0x49d7,
+        0xa438, 0x0040, 0xa438, 0x0277, 0xa438, 0x7daf, 0xa438, 0x2727,
+        0xa438, 0x0000, 0xa438, 0x7205, 0xa438, 0x0000, 0xa438, 0x7208,
+        0xa438, 0x0000, 0xa438, 0x71f3, 0xa438, 0x0000, 0xa438, 0x71f6,
+        0xa438, 0x0000, 0xa438, 0x7229, 0xa438, 0x0000, 0xa438, 0x722c,
+        0xa438, 0x0000, 0xa438, 0x7217, 0xa438, 0x0000, 0xa438, 0x721a,
+        0xa438, 0x0000, 0xa438, 0x721d, 0xa438, 0x0000, 0xa438, 0x7211,
+        0xa438, 0x0000, 0xa438, 0x7220, 0xa438, 0x0000, 0xa438, 0x7214,
+        0xa438, 0x0000, 0xa438, 0x722f, 0xa438, 0x0000, 0xa438, 0x7223,
+        0xa438, 0x0000, 0xa438, 0x7232, 0xa438, 0x0000, 0xa438, 0x7226,
+        0xa438, 0xf8f9, 0xa438, 0xfae0, 0xa438, 0x85b3, 0xa438, 0x3802,
+        0xa438, 0xad27, 0xa438, 0x02ae, 0xa438, 0x03af, 0xa438, 0x8830,
+        0xa438, 0x1f66, 0xa438, 0xef65, 0xa438, 0xbfc2, 0xa438, 0x1f1a,
+        0xa438, 0x96f7, 0xa438, 0x05ee, 0xa438, 0xffd2, 0xa438, 0x00da,
+        0xa438, 0xf605, 0xa438, 0xbfc2, 0xa438, 0x2f1a, 0xa438, 0x96f7,
+        0xa438, 0x05ee, 0xa438, 0xffd2, 0xa438, 0x00db, 0xa438, 0xf605,
+        0xa438, 0xef02, 0xa438, 0x1f11, 0xa438, 0x0d42, 0xa438, 0xbf88,
+        0xa438, 0x4202, 0xa438, 0x6e7d, 0xa438, 0xef02, 0xa438, 0x1b03,
+        0xa438, 0x1f11, 0xa438, 0x0d42, 0xa438, 0xbf88, 0xa438, 0x4502,
+        0xa438, 0x6e7d, 0xa438, 0xef02, 0xa438, 0x1a03, 0xa438, 0x1f11,
+        0xa438, 0x0d42, 0xa438, 0xbf88, 0xa438, 0x4802, 0xa438, 0x6e7d,
+        0xa438, 0xbfc2, 0xa438, 0x3f1a, 0xa438, 0x96f7, 0xa438, 0x05ee,
+        0xa438, 0xffd2, 0xa438, 0x00da, 0xa438, 0xf605, 0xa438, 0xbfc2,
+        0xa438, 0x4f1a, 0xa438, 0x96f7, 0xa438, 0x05ee, 0xa438, 0xffd2,
+        0xa438, 0x00db, 0xa438, 0xf605, 0xa438, 0xef02, 0xa438, 0x1f11,
+        0xa438, 0x0d42, 0xa438, 0xbf88, 0xa438, 0x4b02, 0xa438, 0x6e7d,
+        0xa438, 0xef02, 0xa438, 0x1b03, 0xa438, 0x1f11, 0xa438, 0x0d42,
+        0xa438, 0xbf88, 0xa438, 0x4e02, 0xa438, 0x6e7d, 0xa438, 0xef02,
+        0xa438, 0x1a03, 0xa438, 0x1f11, 0xa438, 0x0d42, 0xa438, 0xbf88,
+        0xa438, 0x5102, 0xa438, 0x6e7d, 0xa438, 0xef56, 0xa438, 0xd020,
+        0xa438, 0x1f11, 0xa438, 0xbf88, 0xa438, 0x5402, 0xa438, 0x6e7d,
+        0xa438, 0xbf88, 0xa438, 0x5702, 0xa438, 0x6e7d, 0xa438, 0xbf88,
+        0xa438, 0x5a02, 0xa438, 0x6e7d, 0xa438, 0xe185, 0xa438, 0xa0ef,
+        0xa438, 0x0348, 0xa438, 0x0a28, 0xa438, 0x05ef, 0xa438, 0x201b,
+        0xa438, 0x01ad, 0xa438, 0x2735, 0xa438, 0x1f44, 0xa438, 0xe085,
+        0xa438, 0x88e1, 0xa438, 0x8589, 0xa438, 0xbf88, 0xa438, 0x5d02,
+        0xa438, 0x6e7d, 0xa438, 0xe085, 0xa438, 0x8ee1, 0xa438, 0x858f,
+        0xa438, 0xbf88, 0xa438, 0x6002, 0xa438, 0x6e7d, 0xa438, 0xe085,
+        0xa438, 0x94e1, 0xa438, 0x8595, 0xa438, 0xbf88, 0xa438, 0x6302,
+        0xa438, 0x6e7d, 0xa438, 0xe085, 0xa438, 0x9ae1, 0xa438, 0x859b,
+        0xa438, 0xbf88, 0xa438, 0x6602, 0xa438, 0x6e7d, 0xa438, 0xaf88,
+        0xa438, 0x3cbf, 0xa438, 0x883f, 0xa438, 0x026e, 0xa438, 0x9cad,
+        0xa438, 0x2835, 0xa438, 0x1f44, 0xa438, 0xe08f, 0xa438, 0xf8e1,
+        0xa438, 0x8ff9, 0xa438, 0xbf88, 0xa438, 0x5d02, 0xa438, 0x6e7d,
+        0xa438, 0xe08f, 0xa438, 0xfae1, 0xa438, 0x8ffb, 0xa438, 0xbf88,
+        0xa438, 0x6002, 0xa438, 0x6e7d, 0xa438, 0xe08f, 0xa438, 0xfce1,
+        0xa438, 0x8ffd, 0xa438, 0xbf88, 0xa438, 0x6302, 0xa438, 0x6e7d,
+        0xa438, 0xe08f, 0xa438, 0xfee1, 0xa438, 0x8fff, 0xa438, 0xbf88,
+        0xa438, 0x6602, 0xa438, 0x6e7d, 0xa438, 0xaf88, 0xa438, 0x3ce1,
+        0xa438, 0x85a1, 0xa438, 0x1b21, 0xa438, 0xad37, 0xa438, 0x341f,
+        0xa438, 0x44e0, 0xa438, 0x858a, 0xa438, 0xe185, 0xa438, 0x8bbf,
+        0xa438, 0x885d, 0xa438, 0x026e, 0xa438, 0x7de0, 0xa438, 0x8590,
+        0xa438, 0xe185, 0xa438, 0x91bf, 0xa438, 0x8860, 0xa438, 0x026e,
+        0xa438, 0x7de0, 0xa438, 0x8596, 0xa438, 0xe185, 0xa438, 0x97bf,
+        0xa438, 0x8863, 0xa438, 0x026e, 0xa438, 0x7de0, 0xa438, 0x859c,
+        0xa438, 0xe185, 0xa438, 0x9dbf, 0xa438, 0x8866, 0xa438, 0x026e,
+        0xa438, 0x7dae, 0xa438, 0x401f, 0xa438, 0x44e0, 0xa438, 0x858c,
+        0xa438, 0xe185, 0xa438, 0x8dbf, 0xa438, 0x885d, 0xa438, 0x026e,
+        0xa438, 0x7de0, 0xa438, 0x8592, 0xa438, 0xe185, 0xa438, 0x93bf,
+        0xa438, 0x8860, 0xa438, 0x026e, 0xa438, 0x7de0, 0xa438, 0x8598,
+        0xa438, 0xe185, 0xa438, 0x99bf, 0xa438, 0x8863, 0xa438, 0x026e,
+        0xa438, 0x7de0, 0xa438, 0x859e, 0xa438, 0xe185, 0xa438, 0x9fbf,
+        0xa438, 0x8866, 0xa438, 0x026e, 0xa438, 0x7dae, 0xa438, 0x0ce1,
+        0xa438, 0x85b3, 0xa438, 0x3904, 0xa438, 0xac2f, 0xa438, 0x04ee,
+        0xa438, 0x85b3, 0xa438, 0x00af, 0xa438, 0x39d9, 0xa438, 0x22ac,
+        0xa438, 0xeaf0, 0xa438, 0xacf6, 0xa438, 0xf0ac, 0xa438, 0xfaf0,
+        0xa438, 0xacf8, 0xa438, 0xf0ac, 0xa438, 0xfcf0, 0xa438, 0xad00,
+        0xa438, 0xf0ac, 0xa438, 0xfef0, 0xa438, 0xacf0, 0xa438, 0xf0ac,
+        0xa438, 0xf4f0, 0xa438, 0xacf2, 0xa438, 0xf0ac, 0xa438, 0xb0f0,
+        0xa438, 0xacae, 0xa438, 0xf0ac, 0xa438, 0xacf0, 0xa438, 0xacaa,
+        0xa438, 0xa100, 0xa438, 0x0ce1, 0xa438, 0x8ff7, 0xa438, 0xbf88,
+        0xa438, 0x8402, 0xa438, 0x6e7d, 0xa438, 0xaf26, 0xa438, 0xe9e1,
+        0xa438, 0x8ff6, 0xa438, 0xbf88, 0xa438, 0x8402, 0xa438, 0x6e7d,
+        0xa438, 0xaf26, 0xa438, 0xf520, 0xa438, 0xac86, 0xa438, 0xbf88,
+        0xa438, 0x3f02, 0xa438, 0x6e9c, 0xa438, 0xad28, 0xa438, 0x03af,
+        0xa438, 0x3324, 0xa438, 0xad38, 0xa438, 0x03af, 0xa438, 0x32e6,
+        0xa438, 0xaf32, 0xa438, 0xfb00, 0xa436, 0xb87c, 0xa438, 0x8ff6,
+        0xa436, 0xb87e, 0xa438, 0x0705, 0xa436, 0xb87c, 0xa438, 0x8ff8,
+        0xa436, 0xb87e, 0xa438, 0x19cc, 0xa436, 0xb87c, 0xa438, 0x8ffa,
+        0xa436, 0xb87e, 0xa438, 0x28e3, 0xa436, 0xb87c, 0xa438, 0x8ffc,
+        0xa436, 0xb87e, 0xa438, 0x1047, 0xa436, 0xb87c, 0xa438, 0x8ffe,
+        0xa436, 0xb87e, 0xa438, 0x0a45, 0xa436, 0xb85e, 0xa438, 0x271E,
+        0xa436, 0xb860, 0xa438, 0x3846, 0xa436, 0xb862, 0xa438, 0x26E6,
+        0xa436, 0xb864, 0xa438, 0x32E3, 0xa436, 0xb886, 0xa438, 0xffff,
+        0xa436, 0xb888, 0xa438, 0xffff, 0xa436, 0xb88a, 0xa438, 0xffff,
+        0xa436, 0xb88c, 0xa438, 0xffff, 0xa436, 0xb838, 0xa438, 0x000f,
+        0xb820, 0x0010, 0xa436, 0x846e, 0xa438, 0xaf84, 0xa438, 0x86af,
+        0xa438, 0x8690, 0xa438, 0xaf86, 0xa438, 0xa4af, 0xa438, 0x86a4,
+        0xa438, 0xaf86, 0xa438, 0xa4af, 0xa438, 0x86a4, 0xa438, 0xaf86,
+        0xa438, 0xa4af, 0xa438, 0x86a4, 0xa438, 0xee82, 0xa438, 0x5f00,
+        0xa438, 0x0284, 0xa438, 0x90af, 0xa438, 0x0441, 0xa438, 0xf8e0,
+        0xa438, 0x8ff3, 0xa438, 0xa000, 0xa438, 0x0502, 0xa438, 0x84a4,
+        0xa438, 0xae06, 0xa438, 0xa001, 0xa438, 0x0302, 0xa438, 0x84c8,
+        0xa438, 0xfc04, 0xa438, 0xf8f9, 0xa438, 0xef59, 0xa438, 0xe080,
+        0xa438, 0x15ad, 0xa438, 0x2702, 0xa438, 0xae03, 0xa438, 0xaf84,
+        0xa438, 0xc3bf, 0xa438, 0x53ca, 0xa438, 0x0252, 0xa438, 0xc8ad,
+        0xa438, 0x2807, 0xa438, 0x0285, 0xa438, 0x2cee, 0xa438, 0x8ff3,
+        0xa438, 0x01ef, 0xa438, 0x95fd, 0xa438, 0xfc04, 0xa438, 0xf8f9,
+        0xa438, 0xfaef, 0xa438, 0x69bf, 0xa438, 0x53ca, 0xa438, 0x0252,
+        0xa438, 0xc8ac, 0xa438, 0x2822, 0xa438, 0xd480, 0xa438, 0x00bf,
+        0xa438, 0x8684, 0xa438, 0x0252, 0xa438, 0xa9bf, 0xa438, 0x8687,
+        0xa438, 0x0252, 0xa438, 0xa9bf, 0xa438, 0x868a, 0xa438, 0x0252,
+        0xa438, 0xa9bf, 0xa438, 0x868d, 0xa438, 0x0252, 0xa438, 0xa9ee,
+        0xa438, 0x8ff3, 0xa438, 0x00af, 0xa438, 0x8526, 0xa438, 0xe08f,
+        0xa438, 0xf4e1, 0xa438, 0x8ff5, 0xa438, 0xe28f, 0xa438, 0xf6e3,
+        0xa438, 0x8ff7, 0xa438, 0x1b45, 0xa438, 0xac27, 0xa438, 0x0eee,
+        0xa438, 0x8ff4, 0xa438, 0x00ee, 0xa438, 0x8ff5, 0xa438, 0x0002,
+        0xa438, 0x852c, 0xa438, 0xaf85, 0xa438, 0x26e0, 0xa438, 0x8ff4,
+        0xa438, 0xe18f, 0xa438, 0xf52c, 0xa438, 0x0001, 0xa438, 0xe48f,
+        0xa438, 0xf4e5, 0xa438, 0x8ff5, 0xa438, 0xef96, 0xa438, 0xfefd,
+        0xa438, 0xfc04, 0xa438, 0xf8f9, 0xa438, 0xef59, 0xa438, 0xbf53,
+        0xa438, 0x2202, 0xa438, 0x52c8, 0xa438, 0xa18b, 0xa438, 0x02ae,
+        0xa438, 0x03af, 0xa438, 0x85da, 0xa438, 0xbf57, 0xa438, 0x7202,
+        0xa438, 0x52c8, 0xa438, 0xe48f, 0xa438, 0xf8e5, 0xa438, 0x8ff9,
+        0xa438, 0xbf57, 0xa438, 0x7502, 0xa438, 0x52c8, 0xa438, 0xe48f,
+        0xa438, 0xfae5, 0xa438, 0x8ffb, 0xa438, 0xbf57, 0xa438, 0x7802,
+        0xa438, 0x52c8, 0xa438, 0xe48f, 0xa438, 0xfce5, 0xa438, 0x8ffd,
+        0xa438, 0xbf57, 0xa438, 0x7b02, 0xa438, 0x52c8, 0xa438, 0xe48f,
+        0xa438, 0xfee5, 0xa438, 0x8fff, 0xa438, 0xbf57, 0xa438, 0x6c02,
+        0xa438, 0x52c8, 0xa438, 0xa102, 0xa438, 0x13ee, 0xa438, 0x8ffc,
+        0xa438, 0x80ee, 0xa438, 0x8ffd, 0xa438, 0x00ee, 0xa438, 0x8ffe,
+        0xa438, 0x80ee, 0xa438, 0x8fff, 0xa438, 0x00af, 0xa438, 0x8599,
+        0xa438, 0xa101, 0xa438, 0x0cbf, 0xa438, 0x534c, 0xa438, 0x0252,
+        0xa438, 0xc8a1, 0xa438, 0x0303, 0xa438, 0xaf85, 0xa438, 0x77bf,
+        0xa438, 0x5322, 0xa438, 0x0252, 0xa438, 0xc8a1, 0xa438, 0x8b02,
+        0xa438, 0xae03, 0xa438, 0xaf86, 0xa438, 0x64e0, 0xa438, 0x8ff8,
+        0xa438, 0xe18f, 0xa438, 0xf9bf, 0xa438, 0x8684, 0xa438, 0x0252,
+        0xa438, 0xa9e0, 0xa438, 0x8ffa, 0xa438, 0xe18f, 0xa438, 0xfbbf,
+        0xa438, 0x8687, 0xa438, 0x0252, 0xa438, 0xa9e0, 0xa438, 0x8ffc,
+        0xa438, 0xe18f, 0xa438, 0xfdbf, 0xa438, 0x868a, 0xa438, 0x0252,
+        0xa438, 0xa9e0, 0xa438, 0x8ffe, 0xa438, 0xe18f, 0xa438, 0xffbf,
+        0xa438, 0x868d, 0xa438, 0x0252, 0xa438, 0xa9af, 0xa438, 0x867f,
+        0xa438, 0xbf53, 0xa438, 0x2202, 0xa438, 0x52c8, 0xa438, 0xa144,
+        0xa438, 0x3cbf, 0xa438, 0x547b, 0xa438, 0x0252, 0xa438, 0xc8e4,
+        0xa438, 0x8ff8, 0xa438, 0xe58f, 0xa438, 0xf9bf, 0xa438, 0x547e,
+        0xa438, 0x0252, 0xa438, 0xc8e4, 0xa438, 0x8ffa, 0xa438, 0xe58f,
+        0xa438, 0xfbbf, 0xa438, 0x5481, 0xa438, 0x0252, 0xa438, 0xc8e4,
+        0xa438, 0x8ffc, 0xa438, 0xe58f, 0xa438, 0xfdbf, 0xa438, 0x5484,
+        0xa438, 0x0252, 0xa438, 0xc8e4, 0xa438, 0x8ffe, 0xa438, 0xe58f,
+        0xa438, 0xffbf, 0xa438, 0x5322, 0xa438, 0x0252, 0xa438, 0xc8a1,
+        0xa438, 0x4448, 0xa438, 0xaf85, 0xa438, 0xa7bf, 0xa438, 0x5322,
+        0xa438, 0x0252, 0xa438, 0xc8a1, 0xa438, 0x313c, 0xa438, 0xbf54,
+        0xa438, 0x7b02, 0xa438, 0x52c8, 0xa438, 0xe48f, 0xa438, 0xf8e5,
+        0xa438, 0x8ff9, 0xa438, 0xbf54, 0xa438, 0x7e02, 0xa438, 0x52c8,
+        0xa438, 0xe48f, 0xa438, 0xfae5, 0xa438, 0x8ffb, 0xa438, 0xbf54,
+        0xa438, 0x8102, 0xa438, 0x52c8, 0xa438, 0xe48f, 0xa438, 0xfce5,
+        0xa438, 0x8ffd, 0xa438, 0xbf54, 0xa438, 0x8402, 0xa438, 0x52c8,
+        0xa438, 0xe48f, 0xa438, 0xfee5, 0xa438, 0x8fff, 0xa438, 0xbf53,
+        0xa438, 0x2202, 0xa438, 0x52c8, 0xa438, 0xa131, 0xa438, 0x03af,
+        0xa438, 0x85a7, 0xa438, 0xd480, 0xa438, 0x00bf, 0xa438, 0x8684,
+        0xa438, 0x0252, 0xa438, 0xa9bf, 0xa438, 0x8687, 0xa438, 0x0252,
+        0xa438, 0xa9bf, 0xa438, 0x868a, 0xa438, 0x0252, 0xa438, 0xa9bf,
+        0xa438, 0x868d, 0xa438, 0x0252, 0xa438, 0xa9ef, 0xa438, 0x95fd,
+        0xa438, 0xfc04, 0xa438, 0xf0d1, 0xa438, 0x2af0, 0xa438, 0xd12c,
+        0xa438, 0xf0d1, 0xa438, 0x44f0, 0xa438, 0xd146, 0xa438, 0xbf86,
+        0xa438, 0xa102, 0xa438, 0x52c8, 0xa438, 0xbf86, 0xa438, 0xa102,
+        0xa438, 0x52c8, 0xa438, 0xd101, 0xa438, 0xaf06, 0xa438, 0xa570,
+        0xa438, 0xce42, 0xa436, 0xb818, 0xa438, 0x043d, 0xa436, 0xb81a,
+        0xa438, 0x06a3, 0xa436, 0xb81c, 0xa438, 0xffff, 0xa436, 0xb81e,
+        0xa438, 0xffff, 0xa436, 0xb850, 0xa438, 0xffff, 0xa436, 0xb852,
+        0xa438, 0xffff, 0xa436, 0xb878, 0xa438, 0xffff, 0xa436, 0xb884,
+        0xa438, 0xffff, 0xa436, 0xb832, 0xa438, 0x0003, 0xa436, 0x0000,
+        0xa438, 0x0000, 0xa436, 0xB82E, 0xa438, 0x0000, 0xa436, 0x8024,
+        0xa438, 0x0000, 0xa436, 0x801E, 0xa438, 0x0021, 0xb820, 0x0000,
+        0xFFFF, 0xFFFF
+};
+
+static void
+rtl8125_real_set_phy_mcu_8125b_1(struct net_device *dev)
+{
+        rtl8125_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8125b_1,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8125b_1)
+                                    );
+}
+
+static void
+rtl8125_set_phy_mcu_8125b_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_real_set_phy_mcu_8125b_1(dev);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+}
+
+static void
+rtl8125_real_set_phy_mcu_8125b_2(struct net_device *dev)
+{
+        rtl8125_set_phy_mcu_ram_code(dev,
+                                     phy_mcu_ram_code_8125b_2,
+                                     ARRAY_SIZE(phy_mcu_ram_code_8125b_2)
+                                    );
+}
+
+static void
+rtl8125_set_phy_mcu_8125b_2(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        rtl8125_real_set_phy_mcu_8125b_2(dev);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+}
+
+static void
+rtl8125_init_hw_phy_mcu(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u8 require_disable_phy_disable_mode = FALSE;
+
+        if (tp->NotWrRamCodeToMicroP == TRUE) return;
+        if (rtl8125_check_hw_phy_mcu_code_ver(dev)) return;
+
+        if (HW_SUPPORT_CHECK_PHY_DISABLE_MODE(tp) && rtl8125_is_in_phy_disable_mode(dev))
+                require_disable_phy_disable_mode = TRUE;
+
+        if (require_disable_phy_disable_mode)
+                rtl8125_disable_phy_disable_mode(dev);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+                rtl8125_set_phy_mcu_8125a_1(dev);
+                break;
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                rtl8125_set_phy_mcu_8125a_2(dev);
+                break;
+        case CFG_METHOD_4:
+                rtl8125_set_phy_mcu_8125b_1(dev);
+                break;
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                rtl8125_set_phy_mcu_8125b_2(dev);
+                break;
+        }
+
+        if (require_disable_phy_disable_mode)
+                rtl8125_enable_phy_disable_mode(dev);
+
+        rtl8125_write_hw_phy_mcu_code_ver(dev);
+
+        rtl8125_mdio_write(tp,0x1F, 0x0000);
+
+        tp->HwHasWrRamCodeToMicroP = TRUE;
+}
+#endif
+
+static void
+rtl8125_enable_phy_aldps(struct rtl8125_private *tp)
+{
+        //enable aldps
+        //GPHY OCP 0xA430 bit[2] = 0x1 (en_aldps)
+        SetEthPhyOcpBit(tp, 0xA430, BIT_2);
+}
+
+static void
+rtl8125_hw_phy_config_8125a_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xAD40,
+                                0x03FF,
+                                0x84
+                               );
+
+        SetEthPhyOcpBit(tp, 0xAD4E, BIT_4);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xAD16,
+                                0x03FF,
+                                0x0006
+                               );
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xAD32,
+                                0x003F,
+                                0x0006
+                               );
+        ClearEthPhyOcpBit(tp, 0xAC08, BIT_12);
+        ClearEthPhyOcpBit(tp, 0xAC08, BIT_8);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xAC8A,
+                                BIT_15|BIT_14|BIT_13|BIT_12,
+                                BIT_14|BIT_13|BIT_12
+                               );
+        SetEthPhyOcpBit(tp, 0xAD18, BIT_10);
+        SetEthPhyOcpBit(tp, 0xAD1A, 0x3FF);
+        SetEthPhyOcpBit(tp, 0xAD1C, 0x3FF);
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80EA);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                0xFF00,
+                                0xC400
+                               );
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80EB);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                0x0700,
+                                0x0300
+                               );
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80F8);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                0xFF00,
+                                0x1C00
+                               );
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80F1);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                0xFF00,
+                                0x3000
+                               );
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80FE);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                0xFF00,
+                                0xA500
+                               );
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x8102);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                0xFF00,
+                                0x5000
+                               );
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x8105);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                0xFF00,
+                                0x3300
+                               );
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x8100);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                0xFF00,
+                                0x7000
+                               );
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x8104);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                0xFF00,
+                                0xF000
+                               );
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x8106);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                0xFF00,
+                                0x6500
+                               );
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80DC);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                0xFF00,
+                                0xED00
+                               );
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80DF);
+        SetEthPhyOcpBit(tp, 0xA438, BIT_8);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80E1);
+        ClearEthPhyOcpBit(tp, 0xA438, BIT_8);
+
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xBF06,
+                                0x003F,
+                                0x38
+                               );
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x819F);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xD0B6);
+
+        mdio_direct_write_phy_ocp(tp, 0xBC34, 0x5555);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xBF0A,
+                                BIT_11|BIT_10|BIT_9,
+                                BIT_11|BIT_9
+                               );
+
+        ClearEthPhyOcpBit(tp, 0xA5C0, BIT_10);
+
+        SetEthPhyOcpBit(tp, 0xA442, BIT_11);
+
+        //enable aldps
+        //GPHY OCP 0xA430 bit[2] = 0x1 (en_aldps)
+        if (aspm) {
+                if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
+                        rtl8125_enable_phy_aldps(tp);
+                }
+        }
+}
+
+static void
+rtl8125_hw_phy_config_8125a_2(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        SetEthPhyOcpBit(tp, 0xAD4E, BIT_4);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xAD16,
+                                0x03FF,
+                                0x03FF
+                               );
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xAD32,
+                                0x003F,
+                                0x0006
+                               );
+        ClearEthPhyOcpBit(tp, 0xAC08, BIT_12);
+        ClearEthPhyOcpBit(tp, 0xAC08, BIT_8);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xACC0,
+                                BIT_1|BIT_0,
+                                BIT_1
+                               );
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xAD40,
+                                BIT_7|BIT_6|BIT_5,
+                                BIT_6
+                               );
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xAD40,
+                                BIT_2|BIT_1|BIT_0,
+                                BIT_2
+                               );
+        ClearEthPhyOcpBit(tp, 0xAC14, BIT_7);
+        ClearEthPhyOcpBit(tp, 0xAC80, BIT_9|BIT_8);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xAC5E,
+                                BIT_2|BIT_1|BIT_0,
+                                BIT_1
+                               );
+        mdio_direct_write_phy_ocp(tp, 0xAD4C, 0x00A8);
+        mdio_direct_write_phy_ocp(tp, 0xAC5C, 0x01FF);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xAC8A,
+                                BIT_7|BIT_6|BIT_5|BIT_4,
+                                BIT_5|BIT_4
+                               );
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8157);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xB87E,
+                                0xFF00,
+                                0x0500
+                               );
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8159);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xB87E,
+                                0xFF00,
+                                0x0700
+                               );
+
+
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x80A2);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0153);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x809C);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0153);
+
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x81B3);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0043);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x00A7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x00D6);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x00EC);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x00F6);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x00FB);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x00FD);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x00FF);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x00BB);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0058);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0029);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0013);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0009);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0004);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0002);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0000);
+
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x8257);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x020F);
+
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80EA);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x7843);
+
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        ClearEthPhyOcpBit(tp, 0xB896, BIT_0);
+        ClearEthPhyOcpBit(tp, 0xB892, 0xFF00);
+
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC091);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x6E12);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC092);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x1214);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC094);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x1516);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC096);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x171B);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC098);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x1B1C);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC09A);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x1F1F);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC09C);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x2021);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC09E);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x2224);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC0A0);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x2424);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC0A2);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x2424);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC0A4);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x2424);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC018);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x0AF2);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC01A);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x0D4A);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC01C);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x0F26);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC01E);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x118D);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC020);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x14F3);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC022);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x175A);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC024);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x19C0);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC026);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x1C26);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC089);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x6050);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC08A);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x5F6E);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC08C);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x6E6E);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC08E);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x6E6E);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC090);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x6E12);
+
+        SetEthPhyOcpBit(tp, 0xB896, BIT_0);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+
+
+        SetEthPhyOcpBit(tp, 0xD068, BIT_13);
+
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x81A2);
+        SetEthPhyOcpBit(tp, 0xA438, BIT_8);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xB54C,
+                                0xFF00,
+                                0xDB00);
+
+
+        ClearEthPhyOcpBit(tp, 0xA454, BIT_0);
+
+
+        SetEthPhyOcpBit(tp, 0xA5D4, BIT_5);
+        ClearEthPhyOcpBit(tp, 0xAD4E, BIT_4);
+        ClearEthPhyOcpBit(tp, 0xA86A, BIT_0);
+
+
+        SetEthPhyOcpBit(tp, 0xA442, BIT_11);
+
+
+        if (tp->RequirePhyMdiSwapPatch) {
+                u16 adccal_offset_p0;
+                u16 adccal_offset_p1;
+                u16 adccal_offset_p2;
+                u16 adccal_offset_p3;
+                u16 rg_lpf_cap_xg_p0;
+                u16 rg_lpf_cap_xg_p1;
+                u16 rg_lpf_cap_xg_p2;
+                u16 rg_lpf_cap_xg_p3;
+                u16 rg_lpf_cap_p0;
+                u16 rg_lpf_cap_p1;
+                u16 rg_lpf_cap_p2;
+                u16 rg_lpf_cap_p3;
+
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xD068,
+                                        0x0007,
+                                        0x0001
+                                       );
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xD068,
+                                        0x0018,
+                                        0x0000
+                                       );
+                adccal_offset_p0 = mdio_direct_read_phy_ocp(tp, 0xD06A);
+                adccal_offset_p0 &= 0x07FF;
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xD068,
+                                        0x0018,
+                                        0x0008
+                                       );
+                adccal_offset_p1 = mdio_direct_read_phy_ocp(tp, 0xD06A);
+                adccal_offset_p1 &= 0x07FF;
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xD068,
+                                        0x0018,
+                                        0x0010
+                                       );
+                adccal_offset_p2 = mdio_direct_read_phy_ocp(tp, 0xD06A);
+                adccal_offset_p2 &= 0x07FF;
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xD068,
+                                        0x0018,
+                                        0x0018
+                                       );
+                adccal_offset_p3 = mdio_direct_read_phy_ocp(tp, 0xD06A);
+                adccal_offset_p3 &= 0x07FF;
+
+
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xD068,
+                                        0x0018,
+                                        0x0000
+                                       );
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xD06A,
+                                        0x07FF,
+                                        adccal_offset_p3
+                                       );
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xD068,
+                                        0x0018,
+                                        0x0008
+                                       );
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xD06A,
+                                        0x07FF,
+                                        adccal_offset_p2
+                                       );
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xD068,
+                                        0x0018,
+                                        0x0010
+                                       );
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xD06A,
+                                        0x07FF,
+                                        adccal_offset_p1
+                                       );
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xD068,
+                                        0x0018,
+                                        0x0018
+                                       );
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xD06A,
+                                        0x07FF,
+                                        adccal_offset_p0
+                                       );
+
+
+                rg_lpf_cap_xg_p0 = mdio_direct_read_phy_ocp(tp, 0xBD5A);
+                rg_lpf_cap_xg_p0 &= 0x001F;
+                rg_lpf_cap_xg_p1 = mdio_direct_read_phy_ocp(tp, 0xBD5A);
+                rg_lpf_cap_xg_p1 &= 0x1F00;
+                rg_lpf_cap_xg_p2 = mdio_direct_read_phy_ocp(tp, 0xBD5C);
+                rg_lpf_cap_xg_p2 &= 0x001F;
+                rg_lpf_cap_xg_p3 = mdio_direct_read_phy_ocp(tp, 0xBD5C);
+                rg_lpf_cap_xg_p3 &= 0x1F00;
+                rg_lpf_cap_p0 = mdio_direct_read_phy_ocp(tp, 0xBC18);
+                rg_lpf_cap_p0 &= 0x001F;
+                rg_lpf_cap_p1 = mdio_direct_read_phy_ocp(tp, 0xBC18);
+                rg_lpf_cap_p1 &= 0x1F00;
+                rg_lpf_cap_p2 = mdio_direct_read_phy_ocp(tp, 0xBC1A);
+                rg_lpf_cap_p2 &= 0x001F;
+                rg_lpf_cap_p3 = mdio_direct_read_phy_ocp(tp, 0xBC1A);
+                rg_lpf_cap_p3 &= 0x1F00;
+
+
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xBD5A,
+                                        0x001F,
+                                        rg_lpf_cap_xg_p3 >> 8
+                                       );
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xBD5A,
+                                        0x1F00,
+                                        rg_lpf_cap_xg_p2 << 8
+                                       );
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xBD5C,
+                                        0x001F,
+                                        rg_lpf_cap_xg_p1 >> 8
+                                       );
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xBD5C,
+                                        0x1F00,
+                                        rg_lpf_cap_xg_p0 << 8
+                                       );
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xBC18,
+                                        0x001F,
+                                        rg_lpf_cap_p3 >> 8
+                                       );
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xBC18,
+                                        0x1F00,
+                                        rg_lpf_cap_p2 << 8
+                                       );
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xBC1A,
+                                        0x001F,
+                                        rg_lpf_cap_p1 >> 8
+                                       );
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xBC1A,
+                                        0x1F00,
+                                        rg_lpf_cap_p0 << 8
+                                       );
+        }
+
+
+        if (aspm) {
+                if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
+                        rtl8125_enable_phy_aldps(tp);
+                }
+        }
+}
+
+static void
+rtl8125_hw_phy_config_8125b_1(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        SetEthPhyOcpBit(tp, 0xA442, BIT_11);
+
+
+        SetEthPhyOcpBit(tp, 0xBC08, (BIT_3 | BIT_2));
+
+
+        if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
+                mdio_direct_write_phy_ocp(tp, 0xA436, 0x8FFF);
+                ClearAndSetEthPhyOcpBit(tp,
+                                        0xA438,
+                                        0xFF00,
+                                        0x0400
+                                       );
+        }
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8560);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x19CC);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8562);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x19CC);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8564);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x19CC);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8566);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x147D);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8568);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x147D);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x856A);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x147D);
+        if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
+                mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FFE);
+                mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0907);
+        }
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xACDA,
+                                0xFF00,
+                                0xFF00
+                               );
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xACDE,
+                                0xF000,
+                                0xF000
+                               );
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x80D6);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x2801);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x80F2);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x2801);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x80F4);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x6077);
+        mdio_direct_write_phy_ocp(tp, 0xB506, 0x01E7);
+        mdio_direct_write_phy_ocp(tp, 0xAC8C, 0x0FFC);
+        mdio_direct_write_phy_ocp(tp, 0xAC46, 0xB7B4);
+        mdio_direct_write_phy_ocp(tp, 0xAC50, 0x0FBC);
+        mdio_direct_write_phy_ocp(tp, 0xAC3C, 0x9240);
+        mdio_direct_write_phy_ocp(tp, 0xAC4E, 0x0DB4);
+        mdio_direct_write_phy_ocp(tp, 0xACC6, 0x0707);
+        mdio_direct_write_phy_ocp(tp, 0xACC8, 0xA0D3);
+        mdio_direct_write_phy_ocp(tp, 0xAD08, 0x0007);
+
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8013);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0700);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FB9);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x2801);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FBA);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0100);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FBC);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x1900);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FBE);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0xE100);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FC0);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0800);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FC2);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0xE500);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FC4);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0F00);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FC6);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0xF100);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FC8);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0400);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FCa);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0xF300);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FCc);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0xFD00);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FCe);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0xFF00);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FD0);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0xFB00);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FD2);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0100);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FD4);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0xF400);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FD6);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0xFF00);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8FD8);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0xF600);
+
+
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x813D);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x390E);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x814F);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x790E);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x80B0);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0F31);
+        SetEthPhyOcpBit(tp, 0xBF4C, BIT_1);
+        SetEthPhyOcpBit(tp, 0xBCCA, (BIT_9 | BIT_8));
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8141);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x320E);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8153);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x720E);
+        ClearEthPhyOcpBit(tp, 0xA432, BIT_6);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8529);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x050E);
+
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x816C);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xC4A0);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x8170);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xC4A0);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x8174);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x04A0);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x8178);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x04A0);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x817C);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0719);
+        if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
+                mdio_direct_write_phy_ocp(tp, 0xA436, 0x8FF4);
+                mdio_direct_write_phy_ocp(tp, 0xA438, 0x0400);
+                mdio_direct_write_phy_ocp(tp, 0xA436, 0x8FF1);
+                mdio_direct_write_phy_ocp(tp, 0xA438, 0x0404);
+        }
+        mdio_direct_write_phy_ocp(tp, 0xBF4A, 0x001B);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8033);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x7C13);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8037);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x7C13);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x803B);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0xFC32);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x803F);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x7C13);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8043);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x7C13);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8047);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x7C13);
+
+
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8145);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x370E);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8157);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x770E);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8169);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x0D0A);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x817B);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x1D0A);
+
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x8217);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                0xFF00,
+                                0x5000
+                               );
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x821A);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                0xFF00,
+                                0x5000
+                               );
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80DA);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0403);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80DC);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                0xFF00,
+                                0x1000
+                               );
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80B3);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x0384);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80B7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x2007);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80BA);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                0xFF00,
+                                0x6C00
+                               );
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80B5);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xF009);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80BD);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                0xFF00,
+                                0x9F00
+                               );
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80C7);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xf083);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80DD);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x03f0);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80DF);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                0xFF00,
+                                0x1000
+                               );
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80CB);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x2007);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80CE);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                0xFF00,
+                                0x6C00
+                               );
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80C9);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x8009);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80D1);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                0xFF00,
+                                0x8000
+                               );
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80A3);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x200A);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80A5);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0xF0AD);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x809F);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x6073);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80A1);
+        mdio_direct_write_phy_ocp(tp, 0xA438, 0x000B);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x80A9);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                0xFF00,
+                                0xC000
+                               );
+
+        rtl8125_set_phy_mcu_patch_request(tp);
+
+        ClearEthPhyOcpBit(tp, 0xB896, BIT_0);
+        ClearEthPhyOcpBit(tp, 0xB892, 0xFF00);
+
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC23E);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x0000);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC240);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x0103);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC242);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x0507);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC244);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x090B);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC246);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x0C0E);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC248);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x1012);
+        mdio_direct_write_phy_ocp(tp, 0xB88E, 0xC24A);
+        mdio_direct_write_phy_ocp(tp, 0xB890, 0x1416);
+
+        SetEthPhyOcpBit(tp, 0xB896, BIT_0);
+
+        rtl8125_clear_phy_mcu_patch_request(tp);
+
+
+        SetEthPhyOcpBit(tp, 0xA86A, BIT_0);
+        SetEthPhyOcpBit(tp, 0xA6F0, BIT_0);
+
+
+        mdio_direct_write_phy_ocp(tp, 0xBFA0, 0xD70D);
+        mdio_direct_write_phy_ocp(tp, 0xBFA2, 0x4100);
+        mdio_direct_write_phy_ocp(tp, 0xBFA4, 0xE868);
+        mdio_direct_write_phy_ocp(tp, 0xBFA6, 0xDC59);
+        mdio_direct_write_phy_ocp(tp, 0xB54C, 0x3C18);
+        ClearEthPhyOcpBit(tp, 0xBFA4, BIT_5);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x817D);
+        SetEthPhyOcpBit(tp, 0xA438, BIT_12);
+
+
+        if (aspm) {
+                if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
+                        rtl8125_enable_phy_aldps(tp);
+                }
+        }
+}
+
+static void
+rtl8125_hw_phy_config_8125b_2(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        SetEthPhyOcpBit(tp, 0xA442, BIT_11);
+
+
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xAC46,
+                                0x00F0,
+                                0x0090
+                               );
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xAD30,
+                                0x0003,
+                                0x0001
+                               );
+
+
+        RTL_W16(tp, EEE_TXIDLE_TIMER_8125, tp->eee.tx_lpi_timer);
+
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x80F5);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x760E);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8107);
+        mdio_direct_write_phy_ocp(tp, 0xB87E, 0x360E);
+        mdio_direct_write_phy_ocp(tp, 0xB87C, 0x8551);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xB87E,
+                                BIT_15 | BIT_14 | BIT_13 | BIT_12 | BIT_11 | BIT_10 | BIT_9 | BIT_8,
+                                BIT_11
+                               );
+
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xbf00,
+                                0xE000,
+                                0xA000
+                               );
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xbf46,
+                                0x0F00,
+                                0x0300
+                               );
+        mdio_direct_write_phy_ocp(tp, 0xa436, 0x8044);
+        mdio_direct_write_phy_ocp(tp, 0xa438, 0x2417);
+        mdio_direct_write_phy_ocp(tp, 0xa436, 0x804A);
+        mdio_direct_write_phy_ocp(tp, 0xa438, 0x2417);
+        mdio_direct_write_phy_ocp(tp, 0xa436, 0x8050);
+        mdio_direct_write_phy_ocp(tp, 0xa438, 0x2417);
+        mdio_direct_write_phy_ocp(tp, 0xa436, 0x8056);
+        mdio_direct_write_phy_ocp(tp, 0xa438, 0x2417);
+        mdio_direct_write_phy_ocp(tp, 0xa436, 0x805C);
+        mdio_direct_write_phy_ocp(tp, 0xa438, 0x2417);
+        mdio_direct_write_phy_ocp(tp, 0xa436, 0x8062);
+        mdio_direct_write_phy_ocp(tp, 0xa438, 0x2417);
+        mdio_direct_write_phy_ocp(tp, 0xa436, 0x8068);
+        mdio_direct_write_phy_ocp(tp, 0xa438, 0x2417);
+        mdio_direct_write_phy_ocp(tp, 0xa436, 0x806E);
+        mdio_direct_write_phy_ocp(tp, 0xa438, 0x2417);
+        mdio_direct_write_phy_ocp(tp, 0xa436, 0x8074);
+        mdio_direct_write_phy_ocp(tp, 0xa438, 0x2417);
+        mdio_direct_write_phy_ocp(tp, 0xa436, 0x807A);
+        mdio_direct_write_phy_ocp(tp, 0xa438, 0x2417);
+
+
+        SetEthPhyOcpBit(tp, 0xA4CA, BIT_6);
+
+
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xBF84,
+                                BIT_15 | BIT_14 | BIT_13,
+                                BIT_15 | BIT_13
+                               );
+
+
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x8170);
+        ClearAndSetEthPhyOcpBit(tp,
+                                0xA438,
+                                BIT_13 | BIT_10 | BIT_9 | BIT_8,
+                                BIT_15 | BIT_14 | BIT_12 | BIT_11
+                               );
+
+        /*
+        mdio_direct_write_phy_ocp(tp, 0xBFA0, 0xD70D);
+        mdio_direct_write_phy_ocp(tp, 0xBFA2, 0x4100);
+        mdio_direct_write_phy_ocp(tp, 0xBFA4, 0xE868);
+        mdio_direct_write_phy_ocp(tp, 0xBFA6, 0xDC59);
+        mdio_direct_write_phy_ocp(tp, 0xB54C, 0x3C18);
+        ClearEthPhyOcpBit(tp, 0xBFA4, BIT_5);
+        mdio_direct_write_phy_ocp(tp, 0xA436, 0x817D);
+        SetEthPhyOcpBit(tp, 0xA438, BIT_12);
+        */
+
+
+        if (aspm) {
+                if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
+                        rtl8125_enable_phy_aldps(tp);
+                }
+        }
+}
+
+static void
+rtl8125_hw_phy_config(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (tp->resume_not_chg_speed) return;
+
+        tp->phy_reset_enable(dev);
+
+        if (HW_DASH_SUPPORT_TYPE_3(tp) && tp->HwPkgDet == 0x06) return;
+
+#ifndef ENABLE_USE_FIRMWARE_FILE
+        if (!tp->rtl_fw) {
+                rtl8125_set_hw_phy_before_init_phy_mcu(dev);
+
+                rtl8125_init_hw_phy_mcu(dev);
+        }
+#endif
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+                rtl8125_hw_phy_config_8125a_1(dev);
+                break;
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                rtl8125_hw_phy_config_8125a_2(dev);
+                break;
+        case CFG_METHOD_4:
+                rtl8125_hw_phy_config_8125b_1(dev);
+                break;
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                rtl8125_hw_phy_config_8125b_2(dev);
+                break;
+        }
+
+        //legacy force mode(Chap 22)
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+        default:
+                rtl8125_mdio_write(tp, 0x1F, 0x0A5B);
+                rtl8125_clear_eth_phy_bit(tp, 0x12, BIT_15);
+                rtl8125_mdio_write(tp, 0x1F, 0x0000);
+                break;
+        }
+
+        /*ocp phy power saving*/
+        /*
+        if (aspm) {
+        if (tp->mcfg == CFG_METHOD_2 || tp->mcfg == CFG_METHOD_3 ||
+            tp->mcfg == CFG_METHOD_6)
+                rtl8125_enable_ocp_phy_power_saving(dev);
+        }
+        */
+
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+
+        if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(tp)) {
+                if (tp->eee.eee_enabled)
+                        rtl8125_enable_eee(tp);
+                else
+                        rtl8125_disable_eee(tp);
+        }
+}
+
+static void
+rtl8125_up(struct net_device *dev)
+{
+        rtl8125_hw_init(dev);
+        rtl8125_hw_reset(dev);
+        rtl8125_powerup_pll(dev);
+        rtl8125_hw_ephy_config(dev);
+        rtl8125_hw_phy_config(dev);
+        rtl8125_hw_config(dev);
+}
+
+/*
+static inline void rtl8125_delete_esd_timer(struct net_device *dev, struct timer_list *timer)
+{
+        del_timer_sync(timer);
+}
+
+static inline void rtl8125_request_esd_timer(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct timer_list *timer = &tp->esd_timer;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+        setup_timer(timer, rtl8125_esd_timer, (unsigned long)dev);
+#else
+        timer_setup(timer, rtl8125_esd_timer, 0);
+#endif
+        mod_timer(timer, jiffies + RTL8125_ESD_TIMEOUT);
+}
+*/
+
+/*
+static inline void rtl8125_delete_link_timer(struct net_device *dev, struct timer_list *timer)
+{
+        del_timer_sync(timer);
+}
+
+static inline void rtl8125_request_link_timer(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct timer_list *timer = &tp->link_timer;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+        setup_timer(timer, rtl8125_link_timer, (unsigned long)dev);
+#else
+        timer_setup(timer, rtl8125_link_timer, 0);
+#endif
+        mod_timer(timer, jiffies + RTL8125_LINK_TIMEOUT);
+}
+*/
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+/*
+ * Polling 'interrupt' - used by things like netconsole to send skbs
+ * without having to re-enable interrupts. It's not called while
+ * the interrupt routine is executing.
+ */
+static void
+rtl8125_netpoll(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+        for (i = 0; i < tp->irq_nvecs; i++) {
+                struct r8125_irq *irq = &tp->irq_tbl[i];
+                struct r8125_napi *r8125napi = &tp->r8125napi[i];
+
+                disable_irq(irq->vector);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
+                irq->handler(irq->vector, r8125napi);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+                irq->handler(irq->vector, r8125napi, NULL);
+#else
+                irq->handler(irq->vector, r8125napi);
+#endif
+
+                enable_irq(irq->vector);
+        }
+}
+#endif //CONFIG_NET_POLL_CONTROLLER
+
+static void
+rtl8125_get_bios_setting(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                tp->bios_setting = RTL_R32(tp, TimeInt2);
+                break;
+        }
+}
+
+static void
+rtl8125_set_bios_setting(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                RTL_W32(tp, TimeInt2, tp->bios_setting);
+                break;
+        }
+}
+
+static void
+rtl8125_setup_mqs_reg(struct rtl8125_private *tp)
+{
+        int i;
+
+        //tx
+        tp->tx_ring[0].tdsar_reg = TxDescStartAddrLow;
+        for (i = 1; i < R8125_MAX_TX_QUEUES; i++) {
+                tp->tx_ring[i].tdsar_reg = (u16)(TNPDS_Q1_LOW_8125 + (i - 1) * 8);
+        }
+
+        for (i = 0; i < R8125_MAX_TX_QUEUES; i++) {
+                tp->tx_ring[i].hw_clo_ptr_reg = (u16)(HW_CLO_PTR0_8125 + i * 4);
+                tp->tx_ring[i].sw_tail_ptr_reg = (u16)(SW_TAIL_PTR0_8125 + i * 4);
+        }
+
+        //rx
+        tp->rx_ring[0].rdsar_reg = RxDescAddrLow;
+        for (i = 1; i < R8125_MAX_RX_QUEUES; i++) {
+                tp->rx_ring[i].rdsar_reg = (u16)(RDSAR_Q1_LOW_8125 + (i - 1) * 8);
+        }
+
+        tp->isr_reg[0] = ISR0_8125;
+        for (i = 1; i < R8125_MAX_QUEUES; i++) {
+                tp->isr_reg[i] = (u16)(ISR1_8125 + (i - 1) * 4);
+        }
+
+        tp->imr_reg[0] = IMR0_8125;
+        for (i = 1; i < R8125_MAX_QUEUES; i++) {
+                tp->imr_reg[i] = (u16)(IMR1_8125 + (i - 1) * 4);
+        }
+}
+
+static void
+rtl8125_init_software_variable(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct pci_dev *pdev = tp->pci_dev;
+
+        rtl8125_get_bios_setting(dev);
+
+#ifdef ENABLE_LIB_SUPPORT
+        tp->ring_lib_enabled = 1;
+#endif
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+                //tp->HwSuppDashVer = 3;
+                break;
+        default:
+                tp->HwSuppDashVer = 0;
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                tp->HwPkgDet = rtl8125_mac_ocp_read(tp, 0xDC00);
+                tp->HwPkgDet = (tp->HwPkgDet >> 3) & 0x07;
+                break;
+        }
+
+        if (HW_DASH_SUPPORT_TYPE_3(tp) && tp->HwPkgDet == 0x06)
+                eee_enable = 0;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                tp->HwSuppNowIsOobVer = 1;
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                tp->HwPcieSNOffset = 0x16C;
+                break;
+        }
+
+#ifdef ENABLE_REALWOW_SUPPORT
+        rtl8125_get_realwow_hw_version(dev);
+#endif //ENABLE_REALWOW_SUPPORT
+
+        if (HW_DASH_SUPPORT_DASH(tp) && rtl8125_check_dash(tp))
+                tp->DASH = 1;
+        else
+                tp->DASH = 0;
+
+        if (tp->DASH) {
+                if (HW_DASH_SUPPORT_TYPE_3(tp)) {
+                        u64 CmacMemPhysAddress;
+                        void __iomem *cmac_ioaddr = NULL;
+
+                        //map CMAC IO space
+                        CmacMemPhysAddress = rtl8125_csi_other_fun_read(tp, 0, 0x18);
+                        if (!(CmacMemPhysAddress & BIT_0)) {
+                                if (CmacMemPhysAddress & BIT_2)
+                                        CmacMemPhysAddress |=  (u64)rtl8125_csi_other_fun_read(tp, 0, 0x1C) << 32;
+
+                                CmacMemPhysAddress &=  0xFFFFFFF0;
+                                /* ioremap MMIO region */
+                                cmac_ioaddr = ioremap(CmacMemPhysAddress, R8125_REGS_SIZE);
+                        }
+
+                        if (cmac_ioaddr == NULL) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                                if (netif_msg_probe(tp))
+                                        dev_err(&pdev->dev, "cannot remap CMAC MMIO, aborting\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                        }
+
+                        if (cmac_ioaddr == NULL) {
+                                tp->DASH = 0;
+                        } else {
+                                tp->mapped_cmac_ioaddr = cmac_ioaddr;
+                        }
+                }
+
+                eee_enable = 0;
+        }
+
+        if	(HW_DASH_SUPPORT_TYPE_3(tp))
+                tp->cmac_ioaddr = tp->mapped_cmac_ioaddr;
+
+        if (aspm) {
+                switch (tp->mcfg) {
+                case CFG_METHOD_2:
+                case CFG_METHOD_3:
+                case CFG_METHOD_4:
+                case CFG_METHOD_5:
+                case CFG_METHOD_6:
+                case CFG_METHOD_7:
+                        tp->org_pci_offset_99 = rtl8125_csi_fun0_read_byte(tp, 0x99);
+                        tp->org_pci_offset_99 &= ~(BIT_5|BIT_6);
+                        break;
+                }
+
+                switch (tp->mcfg) {
+                case CFG_METHOD_2:
+                case CFG_METHOD_3:
+                case CFG_METHOD_6:
+                        tp->org_pci_offset_180 = rtl8125_csi_fun0_read_byte(tp, 0x264);
+                        break;
+                case CFG_METHOD_4:
+                case CFG_METHOD_5:
+                case CFG_METHOD_7:
+                        tp->org_pci_offset_180 = rtl8125_csi_fun0_read_byte(tp, 0x214);
+                        break;
+                }
+        }
+
+        pci_read_config_byte(pdev, 0x80, &tp->org_pci_offset_80);
+        pci_read_config_byte(pdev, 0x81, &tp->org_pci_offset_81);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+        default:
+                tp->use_timer_interrrupt = TRUE;
+                break;
+        }
+
+        if (timer_count == 0 || tp->mcfg == CFG_METHOD_DEFAULT)
+                tp->use_timer_interrrupt = FALSE;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                tp->HwSuppMagicPktVer = WAKEUP_MAGIC_PACKET_V3;
+                break;
+        default:
+                tp->HwSuppMagicPktVer = WAKEUP_MAGIC_PACKET_NOT_SUPPORT;
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                tp->HwSuppLinkChgWakeUpVer = 3;
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                tp->HwSuppD0SpeedUpVer = 1;
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                tp->HwSuppCheckPhyDisableModeVer = 3;
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                tp->HwSuppTxNoCloseVer = 3;
+                break;
+        }
+
+        if (tp->HwSuppTxNoCloseVer > 0 && tx_no_close_enable == 1)
+                tp->EnableTxNoClose = TRUE;
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                tp->RequireLSOPatch = TRUE;
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+                tp->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_2;
+                break;
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                tp->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_3;
+                break;
+        case CFG_METHOD_4:
+                tp->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_4;
+                break;
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                tp->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_5;
+                break;
+        }
+
+        if (tp->HwIcVerUnknown) {
+                tp->NotWrRamCodeToMicroP = TRUE;
+                tp->NotWrMcuPatchCode = TRUE;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                if ((rtl8125_mac_ocp_read(tp, 0xD442) & BIT_5) &&
+                    (mdio_direct_read_phy_ocp(tp, 0xD068) & BIT_1))
+                        tp->RequirePhyMdiSwapPatch = TRUE;
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                tp->HwSuppMacMcuVer = 2;
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                tp->MacMcuPageSize = RTL8125_MAC_MCU_PAGE_SIZE;
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                tp->HwSuppNumTxQueues = 2;
+                tp->HwSuppNumRxQueues = 4;
+                break;
+        default:
+                tp->HwSuppNumTxQueues = 1;
+                tp->HwSuppNumRxQueues = 1;
+                break;
+        }
+
+        tp->num_tx_rings = 1;
+#ifdef ENABLE_MULTIPLE_TX_QUEUE
+#ifndef ENABLE_LIB_SUPPORT
+        tp->num_tx_rings = tp->HwSuppNumTxQueues;
+#endif
+#endif
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                tp->HwSuppRssVer = 5;
+                tp->HwSuppIndirTblEntries = 128;
+                break;
+        }
+
+        tp->num_rx_rings = 1;
+#ifdef ENABLE_RSS_SUPPORT
+#ifdef ENABLE_LIB_SUPPORT
+        if (tp->HwSuppRssVer > 0)
+                tp->EnableRss = 1;
+#else
+        if (tp->HwSuppRssVer > 0) {
+                u8 rss_queue_num = netif_get_num_default_rss_queues();
+                tp->num_rx_rings = (tp->HwSuppNumRxQueues > rss_queue_num)?
+                                   rss_queue_num : tp->HwSuppNumRxQueues;
+
+                if (!(tp->num_rx_rings >= 2 && tp->irq_nvecs >= tp->num_rx_rings))
+                        tp->num_rx_rings = 1;
+
+                if (tp->num_rx_rings >= 2)
+                        tp->EnableRss = 1;
+        }
+#endif
+#endif
+
+        rtl8125_setup_mqs_reg(tp);
+
+        rtl8125_set_ring_size(tp, NUM_RX_DESC, NUM_TX_DESC);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                tp->HwSuppPtpVer = 1;
+                break;
+        }
+#ifdef ENABLE_PTP_SUPPORT
+        if (tp->HwSuppPtpVer > 0)
+                tp->EnablePtp = 1;
+#endif
+
+        //init interrupt
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                tp->HwSuppIsrVer = 2;
+                break;
+        default:
+                tp->HwSuppIsrVer = 1;
+                break;
+        }
+
+        tp->HwCurrIsrVer = tp->HwSuppIsrVer;
+        if (tp->HwSuppIsrVer == 2) {
+                if (!(tp->features & RTL_FEATURE_MSIX) ||
+                    tp->irq_nvecs < R8125_MIN_MSIX_VEC_8125B)
+                        tp->HwCurrIsrVer = 1;
+        }
+
+        if (tp->HwCurrIsrVer < 2 || tp->irq_nvecs < 19)
+                tp->num_tx_rings = 1;
+
+        if (tp->HwCurrIsrVer == 2) {
+                int i;
+
+                tp->intr_mask = ISRIMR_V2_LINKCHG | ISRIMR_TOK_Q0;
+                if (tp->num_tx_rings > 1)
+                        tp->intr_mask |= ISRIMR_TOK_Q1;
+
+                for (i = 0; i < tp->num_rx_rings; i++)
+                        tp->intr_mask |= ISRIMR_V2_ROK_Q0 << i;
+        } else {
+                tp->intr_mask = LinkChg | RxDescUnavail | TxOK | RxOK | SWInt;
+                tp->timer_intr_mask = LinkChg | PCSTimeout;
+
+#ifdef ENABLE_DASH_SUPPORT
+                if (tp->DASH) {
+                        if (HW_DASH_SUPPORT_TYPE_3(tp)) {
+                                tp->timer_intr_mask |= ( ISRIMR_DASH_INTR_EN | ISRIMR_DASH_INTR_CMAC_RESET);
+                                tp->intr_mask |= ( ISRIMR_DASH_INTR_EN | ISRIMR_DASH_INTR_CMAC_RESET);
+                        }
+                }
+#endif
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_6:
+                tp->HwSuppIntMitiVer = 3;
+                break;
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                tp->HwSuppIntMitiVer = 4;
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                tp->HwSuppExtendTallyCounterVer = 1;
+                break;
+        }
+
+        timer_count_v2 = (timer_count / 0x100);
+
+#ifndef ENABLE_LIB_SUPPORT
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                if (tp->HwSuppIsrVer == 2) {
+                        tp->RequireRduNonStopPatch = 1;
+                        tp->EnableRss = 0;
+                }
+                break;
+        }
+#endif
+
+        tp->InitRxDescType = RX_DESC_RING_TYPE_1;
+        if (tp->EnableRss || tp->EnablePtp)
+                tp->InitRxDescType = RX_DESC_RING_TYPE_3;
+
+        tp->RxDescLength = RX_DESC_LEN_TYPE_1;
+        if (tp->InitRxDescType == RX_DESC_RING_TYPE_3)
+                tp->RxDescLength = RX_DESC_LEN_TYPE_3;
+
+        tp->rtl8125_rx_config = rtl_chip_info[tp->chipset].RCR_Cfg;
+        if (tp->InitRxDescType == RX_DESC_RING_TYPE_3)
+                tp->rtl8125_rx_config |= EnableRxDescV3;
+
+        tp->NicCustLedValue = RTL_R16(tp, CustomLED);
+
+        tp->wol_opts = rtl8125_get_hw_wol(tp);
+        tp->wol_enabled = (tp->wol_opts) ? WOL_ENABLED : WOL_DISABLED;
+
+        if (tp->mcfg == CFG_METHOD_6 || tp->mcfg == CFG_METHOD_7)
+                rtl8125_link_option_giga((u8*)&autoneg_mode, (u32*)&speed_mode, (u8*)&duplex_mode, (u32*)&advertising_mode);
+        else
+                rtl8125_link_option((u8*)&autoneg_mode, (u32*)&speed_mode, (u8*)&duplex_mode, (u32*)&advertising_mode);
+
+        tp->autoneg = autoneg_mode;
+        tp->speed = speed_mode;
+        tp->duplex = duplex_mode;
+        tp->advertising = advertising_mode;
+        tp->fcpause = rtl8125_fc_full;
+
+        tp->max_jumbo_frame_size = rtl_chip_info[tp->chipset].jumbo_frame_sz;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+        /* MTU range: 60 - hw-specific max */
+        dev->min_mtu = ETH_MIN_MTU;
+        dev->max_mtu = tp->max_jumbo_frame_size;
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+
+        if (tp->mcfg != CFG_METHOD_DEFAULT) {
+                struct ethtool_eee *eee = &tp->eee;
+
+                eee->eee_enabled = eee_enable;
+                eee->supported  = SUPPORTED_100baseT_Full |
+                                  SUPPORTED_1000baseT_Full;
+                switch (tp->mcfg) {
+                case CFG_METHOD_4:
+                case CFG_METHOD_5:
+                        eee->supported |= SUPPORTED_2500baseX_Full;
+                        break;
+                }
+                eee->advertised = mmd_eee_adv_to_ethtool_adv_t(MDIO_EEE_1000T | MDIO_EEE_100TX);
+                eee->tx_lpi_timer = dev->mtu + ETH_HLEN + 0x20;
+        }
+
+        tp->ptp_master_mode = enable_ptp_master_mode;
+
+#ifdef ENABLE_RSS_SUPPORT
+        if (tp->EnableRss)
+                rtl8125_init_rss(tp);
+#endif
+}
+
+static void
+rtl8125_release_board(struct pci_dev *pdev,
+                      struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        void __iomem *ioaddr = tp->mmio_addr;
+
+        rtl8125_set_bios_setting(dev);
+        rtl8125_rar_set(tp, tp->org_mac_addr);
+        tp->wol_enabled = WOL_DISABLED;
+
+        if (!tp->DASH)
+                rtl8125_phy_power_down(dev);
+
+#ifdef ENABLE_DASH_SUPPORT
+        if (tp->DASH)
+                FreeAllocatedDashShareMemory(dev);
+#endif
+
+        if (tp->mapped_cmac_ioaddr != NULL)
+                iounmap(tp->mapped_cmac_ioaddr);
+
+        iounmap(ioaddr);
+        pci_release_regions(pdev);
+        pci_clear_mwi(pdev);
+        pci_disable_device(pdev);
+        free_netdev(dev);
+}
+
+static void
+rtl8125_hw_address_set(struct net_device *dev, u8 mac_addr[MAC_ADDR_LEN])
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+        eth_hw_addr_set(dev, mac_addr);
+#else
+        memcpy(dev->dev_addr, mac_addr, MAC_ADDR_LEN);
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,17,0)
+}
+
+static int
+rtl8125_get_mac_address(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+        u8 mac_addr[MAC_ADDR_LEN];
+
+        for (i = 0; i < MAC_ADDR_LEN; i++)
+                mac_addr[i] = RTL_R8(tp, MAC0 + i);
+
+        if(tp->mcfg == CFG_METHOD_2 ||
+            tp->mcfg == CFG_METHOD_3 ||
+            tp->mcfg == CFG_METHOD_4 ||
+            tp->mcfg == CFG_METHOD_5 ||
+            tp->mcfg == CFG_METHOD_6 ||
+            tp->mcfg == CFG_METHOD_7) {
+                *(u32*)&mac_addr[0] = RTL_R32(tp, BACKUP_ADDR0_8125);
+                *(u16*)&mac_addr[4] = RTL_R16(tp, BACKUP_ADDR1_8125);
+        }
+
+        if (!is_valid_ether_addr(mac_addr)) {
+                netif_err(tp, probe, dev, "Invalid ether addr %pM\n",
+                          mac_addr);
+                eth_random_addr(mac_addr);
+                dev->addr_assign_type = NET_ADDR_RANDOM;
+                netif_info(tp, probe, dev, "Random ether addr %pM\n",
+                           mac_addr);
+                tp->random_mac = 1;
+        }
+
+        rtl8125_hw_address_set(dev, mac_addr);
+        rtl8125_rar_set(tp, mac_addr);
+
+        /* keep the original MAC address */
+        memcpy(tp->org_mac_addr, dev->dev_addr, MAC_ADDR_LEN);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13)
+        memcpy(dev->perm_addr, dev->dev_addr, dev->addr_len);
+#endif
+        return 0;
+}
+
+/**
+ * rtl8125_set_mac_address - Change the Ethernet Address of the NIC
+ * @dev: network interface device structure
+ * @p:   pointer to an address structure
+ *
+ * Return 0 on success, negative on failure
+ **/
+static int
+rtl8125_set_mac_address(struct net_device *dev,
+                        void *p)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct sockaddr *addr = p;
+
+        if (!is_valid_ether_addr(addr->sa_data))
+                return -EADDRNOTAVAIL;
+
+        rtl8125_hw_address_set(dev, addr->sa_data);
+
+        rtl8125_rar_set(tp, dev->dev_addr);
+
+        return 0;
+}
+
+/******************************************************************************
+ * rtl8125_rar_set - Puts an ethernet address into a receive address register.
+ *
+ * tp - The private data structure for driver
+ * addr - Address to put into receive address register
+ *****************************************************************************/
+void
+rtl8125_rar_set(struct rtl8125_private *tp,
+                const u8 *addr)
+{
+        uint32_t rar_low = 0;
+        uint32_t rar_high = 0;
+
+        rar_low = ((uint32_t) addr[0] |
+                   ((uint32_t) addr[1] << 8) |
+                   ((uint32_t) addr[2] << 16) |
+                   ((uint32_t) addr[3] << 24));
+
+        rar_high = ((uint32_t) addr[4] |
+                    ((uint32_t) addr[5] << 8));
+
+        rtl8125_enable_cfg9346_write(tp);
+        RTL_W32(tp, MAC0, rar_low);
+        RTL_W32(tp, MAC4, rar_high);
+
+        rtl8125_disable_cfg9346_write(tp);
+}
+
+#ifdef ETHTOOL_OPS_COMPAT
+static int ethtool_get_settings(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_cmd cmd = { ETHTOOL_GSET };
+        int err;
+
+        if (!ethtool_ops->get_settings)
+                return -EOPNOTSUPP;
+
+        err = ethtool_ops->get_settings(dev, &cmd);
+        if (err < 0)
+                return err;
+
+        if (copy_to_user(useraddr, &cmd, sizeof(cmd)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_settings(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_cmd cmd;
+
+        if (!ethtool_ops->set_settings)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&cmd, useraddr, sizeof(cmd)))
+                return -EFAULT;
+
+        return ethtool_ops->set_settings(dev, &cmd);
+}
+
+static int ethtool_get_drvinfo(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_drvinfo info;
+        struct ethtool_ops *ops = ethtool_ops;
+
+        if (!ops->get_drvinfo)
+                return -EOPNOTSUPP;
+
+        memset(&info, 0, sizeof(info));
+        info.cmd = ETHTOOL_GDRVINFO;
+        ops->get_drvinfo(dev, &info);
+
+        if (ops->self_test_count)
+                info.testinfo_len = ops->self_test_count(dev);
+        if (ops->get_stats_count)
+                info.n_stats = ops->get_stats_count(dev);
+        if (ops->get_regs_len)
+                info.regdump_len = ops->get_regs_len(dev);
+        if (ops->get_eeprom_len)
+                info.eedump_len = ops->get_eeprom_len(dev);
+
+        if (copy_to_user(useraddr, &info, sizeof(info)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_get_regs(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_regs regs;
+        struct ethtool_ops *ops = ethtool_ops;
+        void *regbuf;
+        int reglen, ret;
+
+        if (!ops->get_regs || !ops->get_regs_len)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&regs, useraddr, sizeof(regs)))
+                return -EFAULT;
+
+        reglen = ops->get_regs_len(dev);
+        if (regs.len > reglen)
+                regs.len = reglen;
+
+        regbuf = kmalloc(reglen, GFP_USER);
+        if (!regbuf)
+                return -ENOMEM;
+
+        ops->get_regs(dev, &regs, regbuf);
+
+        ret = -EFAULT;
+        if (copy_to_user(useraddr, &regs, sizeof(regs)))
+                goto out;
+        useraddr += offsetof(struct ethtool_regs, data);
+        if (copy_to_user(useraddr, regbuf, reglen))
+                goto out;
+        ret = 0;
+
+out:
+        kfree(regbuf);
+        return ret;
+}
+
+static int ethtool_get_wol(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_wolinfo wol = { ETHTOOL_GWOL };
+
+        if (!ethtool_ops->get_wol)
+                return -EOPNOTSUPP;
+
+        ethtool_ops->get_wol(dev, &wol);
+
+        if (copy_to_user(useraddr, &wol, sizeof(wol)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_wol(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_wolinfo wol;
+
+        if (!ethtool_ops->set_wol)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&wol, useraddr, sizeof(wol)))
+                return -EFAULT;
+
+        return ethtool_ops->set_wol(dev, &wol);
+}
+
+static int ethtool_get_msglevel(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata = { ETHTOOL_GMSGLVL };
+
+        if (!ethtool_ops->get_msglevel)
+                return -EOPNOTSUPP;
+
+        edata.data = ethtool_ops->get_msglevel(dev);
+
+        if (copy_to_user(useraddr, &edata, sizeof(edata)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_msglevel(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata;
+
+        if (!ethtool_ops->set_msglevel)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&edata, useraddr, sizeof(edata)))
+                return -EFAULT;
+
+        ethtool_ops->set_msglevel(dev, edata.data);
+        return 0;
+}
+
+static int ethtool_nway_reset(struct net_device *dev)
+{
+        if (!ethtool_ops->nway_reset)
+                return -EOPNOTSUPP;
+
+        return ethtool_ops->nway_reset(dev);
+}
+
+static int ethtool_get_link(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_value edata = { ETHTOOL_GLINK };
+
+        if (!ethtool_ops->get_link)
+                return -EOPNOTSUPP;
+
+        edata.data = ethtool_ops->get_link(dev);
+
+        if (copy_to_user(useraddr, &edata, sizeof(edata)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_get_eeprom(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_eeprom eeprom;
+        struct ethtool_ops *ops = ethtool_ops;
+        u8 *data;
+        int ret;
+
+        if (!ops->get_eeprom || !ops->get_eeprom_len)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&eeprom, useraddr, sizeof(eeprom)))
+                return -EFAULT;
+
+        /* Check for wrap and zero */
+        if (eeprom.offset + eeprom.len <= eeprom.offset)
+                return -EINVAL;
+
+        /* Check for exceeding total eeprom len */
+        if (eeprom.offset + eeprom.len > ops->get_eeprom_len(dev))
+                return -EINVAL;
+
+        data = kmalloc(eeprom.len, GFP_USER);
+        if (!data)
+                return -ENOMEM;
+
+        ret = -EFAULT;
+        if (copy_from_user(data, useraddr + sizeof(eeprom), eeprom.len))
+                goto out;
+
+        ret = ops->get_eeprom(dev, &eeprom, data);
+        if (ret)
+                goto out;
+
+        ret = -EFAULT;
+        if (copy_to_user(useraddr, &eeprom, sizeof(eeprom)))
+                goto out;
+        if (copy_to_user(useraddr + sizeof(eeprom), data, eeprom.len))
+                goto out;
+        ret = 0;
+
+out:
+        kfree(data);
+        return ret;
+}
+
+static int ethtool_set_eeprom(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_eeprom eeprom;
+        struct ethtool_ops *ops = ethtool_ops;
+        u8 *data;
+        int ret;
+
+        if (!ops->set_eeprom || !ops->get_eeprom_len)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&eeprom, useraddr, sizeof(eeprom)))
+                return -EFAULT;
+
+        /* Check for wrap and zero */
+        if (eeprom.offset + eeprom.len <= eeprom.offset)
+                return -EINVAL;
+
+        /* Check for exceeding total eeprom len */
+        if (eeprom.offset + eeprom.len > ops->get_eeprom_len(dev))
+                return -EINVAL;
+
+        data = kmalloc(eeprom.len, GFP_USER);
+        if (!data)
+                return -ENOMEM;
+
+        ret = -EFAULT;
+        if (copy_from_user(data, useraddr + sizeof(eeprom), eeprom.len))
+                goto out;
+
+        ret = ops->set_eeprom(dev, &eeprom, data);
+        if (ret)
+                goto out;
+
+        if (copy_to_user(useraddr + sizeof(eeprom), data, eeprom.len))
+                ret = -EFAULT;
+
+out:
+        kfree(data);
+        return ret;
+}
+
+static int ethtool_get_coalesce(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_coalesce coalesce = { ETHTOOL_GCOALESCE };
+
+        if (!ethtool_ops->get_coalesce)
+                return -EOPNOTSUPP;
+
+        ethtool_ops->get_coalesce(dev, &coalesce);
+
+        if (copy_to_user(useraddr, &coalesce, sizeof(coalesce)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_coalesce(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_coalesce coalesce;
+
+        if (!ethtool_ops->get_coalesce)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&coalesce, useraddr, sizeof(coalesce)))
+                return -EFAULT;
+
+        return ethtool_ops->set_coalesce(dev, &coalesce);
+}
+
+static int ethtool_get_ringparam(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_ringparam ringparam = { ETHTOOL_GRINGPARAM };
+
+        if (!ethtool_ops->get_ringparam)
+                return -EOPNOTSUPP;
+
+        ethtool_ops->get_ringparam(dev, &ringparam);
+
+        if (copy_to_user(useraddr, &ringparam, sizeof(ringparam)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_ringparam(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_ringparam ringparam;
+
+        if (!ethtool_ops->get_ringparam)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&ringparam, useraddr, sizeof(ringparam)))
+                return -EFAULT;
+
+        return ethtool_ops->set_ringparam(dev, &ringparam);
+}
+
+static int ethtool_get_pauseparam(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_pauseparam pauseparam = { ETHTOOL_GPAUSEPARAM };
+
+        if (!ethtool_ops->get_pauseparam)
+                return -EOPNOTSUPP;
+
+        ethtool_ops->get_pauseparam(dev, &pauseparam);
+
+        if (copy_to_user(useraddr, &pauseparam, sizeof(pauseparam)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_pauseparam(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_pauseparam pauseparam;
+
+        if (!ethtool_ops->get_pauseparam)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&pauseparam, useraddr, sizeof(pauseparam)))
+                return -EFAULT;
+
+        return ethtool_ops->set_pauseparam(dev, &pauseparam);
+}
+
+static int ethtool_get_rx_csum(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata = { ETHTOOL_GRXCSUM };
+
+        if (!ethtool_ops->get_rx_csum)
+                return -EOPNOTSUPP;
+
+        edata.data = ethtool_ops->get_rx_csum(dev);
+
+        if (copy_to_user(useraddr, &edata, sizeof(edata)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_rx_csum(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata;
+
+        if (!ethtool_ops->set_rx_csum)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&edata, useraddr, sizeof(edata)))
+                return -EFAULT;
+
+        ethtool_ops->set_rx_csum(dev, edata.data);
+        return 0;
+}
+
+static int ethtool_get_tx_csum(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata = { ETHTOOL_GTXCSUM };
+
+        if (!ethtool_ops->get_tx_csum)
+                return -EOPNOTSUPP;
+
+        edata.data = ethtool_ops->get_tx_csum(dev);
+
+        if (copy_to_user(useraddr, &edata, sizeof(edata)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_tx_csum(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata;
+
+        if (!ethtool_ops->set_tx_csum)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&edata, useraddr, sizeof(edata)))
+                return -EFAULT;
+
+        return ethtool_ops->set_tx_csum(dev, edata.data);
+}
+
+static int ethtool_get_sg(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata = { ETHTOOL_GSG };
+
+        if (!ethtool_ops->get_sg)
+                return -EOPNOTSUPP;
+
+        edata.data = ethtool_ops->get_sg(dev);
+
+        if (copy_to_user(useraddr, &edata, sizeof(edata)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_sg(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata;
+
+        if (!ethtool_ops->set_sg)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&edata, useraddr, sizeof(edata)))
+                return -EFAULT;
+
+        return ethtool_ops->set_sg(dev, edata.data);
+}
+
+static int ethtool_get_tso(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata = { ETHTOOL_GTSO };
+
+        if (!ethtool_ops->get_tso)
+                return -EOPNOTSUPP;
+
+        edata.data = ethtool_ops->get_tso(dev);
+
+        if (copy_to_user(useraddr, &edata, sizeof(edata)))
+                return -EFAULT;
+        return 0;
+}
+
+static int ethtool_set_tso(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_value edata;
+
+        if (!ethtool_ops->set_tso)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&edata, useraddr, sizeof(edata)))
+                return -EFAULT;
+
+        return ethtool_ops->set_tso(dev, edata.data);
+}
+
+static int ethtool_self_test(struct net_device *dev, char *useraddr)
+{
+        struct ethtool_test test;
+        struct ethtool_ops *ops = ethtool_ops;
+        u64 *data;
+        int ret;
+
+        if (!ops->self_test || !ops->self_test_count)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&test, useraddr, sizeof(test)))
+                return -EFAULT;
+
+        test.len = ops->self_test_count(dev);
+        data = kmalloc(test.len * sizeof(u64), GFP_USER);
+        if (!data)
+                return -ENOMEM;
+
+        ops->self_test(dev, &test, data);
+
+        ret = -EFAULT;
+        if (copy_to_user(useraddr, &test, sizeof(test)))
+                goto out;
+        useraddr += sizeof(test);
+        if (copy_to_user(useraddr, data, test.len * sizeof(u64)))
+                goto out;
+        ret = 0;
+
+out:
+        kfree(data);
+        return ret;
+}
+
+static int ethtool_get_strings(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_gstrings gstrings;
+        struct ethtool_ops *ops = ethtool_ops;
+        u8 *data;
+        int ret;
+
+        if (!ops->get_strings)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&gstrings, useraddr, sizeof(gstrings)))
+                return -EFAULT;
+
+        switch (gstrings.string_set) {
+        case ETH_SS_TEST:
+                if (!ops->self_test_count)
+                        return -EOPNOTSUPP;
+                gstrings.len = ops->self_test_count(dev);
+                break;
+        case ETH_SS_STATS:
+                if (!ops->get_stats_count)
+                        return -EOPNOTSUPP;
+                gstrings.len = ops->get_stats_count(dev);
+                break;
+        default:
+                return -EINVAL;
+        }
+
+        data = kmalloc(gstrings.len * ETH_GSTRING_LEN, GFP_USER);
+        if (!data)
+                return -ENOMEM;
+
+        ops->get_strings(dev, gstrings.string_set, data);
+
+        ret = -EFAULT;
+        if (copy_to_user(useraddr, &gstrings, sizeof(gstrings)))
+                goto out;
+        useraddr += sizeof(gstrings);
+        if (copy_to_user(useraddr, data, gstrings.len * ETH_GSTRING_LEN))
+                goto out;
+        ret = 0;
+
+out:
+        kfree(data);
+        return ret;
+}
+
+static int ethtool_phys_id(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_value id;
+
+        if (!ethtool_ops->phys_id)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&id, useraddr, sizeof(id)))
+                return -EFAULT;
+
+        return ethtool_ops->phys_id(dev, id.data);
+}
+
+static int ethtool_get_stats(struct net_device *dev, void *useraddr)
+{
+        struct ethtool_stats stats;
+        struct ethtool_ops *ops = ethtool_ops;
+        u64 *data;
+        int ret;
+
+        if (!ops->get_ethtool_stats || !ops->get_stats_count)
+                return -EOPNOTSUPP;
+
+        if (copy_from_user(&stats, useraddr, sizeof(stats)))
+                return -EFAULT;
+
+        stats.n_stats = ops->get_stats_count(dev);
+        data = kmalloc(stats.n_stats * sizeof(u64), GFP_USER);
+        if (!data)
+                return -ENOMEM;
+
+        ops->get_ethtool_stats(dev, &stats, data);
+
+        ret = -EFAULT;
+        if (copy_to_user(useraddr, &stats, sizeof(stats)))
+                goto out;
+        useraddr += sizeof(stats);
+        if (copy_to_user(useraddr, data, stats.n_stats * sizeof(u64)))
+                goto out;
+        ret = 0;
+
+out:
+        kfree(data);
+        return ret;
+}
+
+static int ethtool_ioctl(struct ifreq *ifr)
+{
+        struct net_device *dev = __dev_get_by_name(ifr->ifr_name);
+        void *useraddr = (void *) ifr->ifr_data;
+        u32 ethcmd;
+
+        /*
+         * XXX: This can be pushed down into the ethtool_* handlers that
+         * need it.  Keep existing behaviour for the moment.
+         */
+        if (!capable(CAP_NET_ADMIN))
+                return -EPERM;
+
+        if (!dev || !netif_device_present(dev))
+                return -ENODEV;
+
+        if (copy_from_user(&ethcmd, useraddr, sizeof (ethcmd)))
+                return -EFAULT;
+
+        switch (ethcmd) {
+        case ETHTOOL_GSET:
+                return ethtool_get_settings(dev, useraddr);
+        case ETHTOOL_SSET:
+                return ethtool_set_settings(dev, useraddr);
+        case ETHTOOL_GDRVINFO:
+                return ethtool_get_drvinfo(dev, useraddr);
+        case ETHTOOL_GREGS:
+                return ethtool_get_regs(dev, useraddr);
+        case ETHTOOL_GWOL:
+                return ethtool_get_wol(dev, useraddr);
+        case ETHTOOL_SWOL:
+                return ethtool_set_wol(dev, useraddr);
+        case ETHTOOL_GMSGLVL:
+                return ethtool_get_msglevel(dev, useraddr);
+        case ETHTOOL_SMSGLVL:
+                return ethtool_set_msglevel(dev, useraddr);
+        case ETHTOOL_NWAY_RST:
+                return ethtool_nway_reset(dev);
+        case ETHTOOL_GLINK:
+                return ethtool_get_link(dev, useraddr);
+        case ETHTOOL_GEEPROM:
+                return ethtool_get_eeprom(dev, useraddr);
+        case ETHTOOL_SEEPROM:
+                return ethtool_set_eeprom(dev, useraddr);
+        case ETHTOOL_GCOALESCE:
+                return ethtool_get_coalesce(dev, useraddr);
+        case ETHTOOL_SCOALESCE:
+                return ethtool_set_coalesce(dev, useraddr);
+        case ETHTOOL_GRINGPARAM:
+                return ethtool_get_ringparam(dev, useraddr);
+        case ETHTOOL_SRINGPARAM:
+                return ethtool_set_ringparam(dev, useraddr);
+        case ETHTOOL_GPAUSEPARAM:
+                return ethtool_get_pauseparam(dev, useraddr);
+        case ETHTOOL_SPAUSEPARAM:
+                return ethtool_set_pauseparam(dev, useraddr);
+        case ETHTOOL_GRXCSUM:
+                return ethtool_get_rx_csum(dev, useraddr);
+        case ETHTOOL_SRXCSUM:
+                return ethtool_set_rx_csum(dev, useraddr);
+        case ETHTOOL_GTXCSUM:
+                return ethtool_get_tx_csum(dev, useraddr);
+        case ETHTOOL_STXCSUM:
+                return ethtool_set_tx_csum(dev, useraddr);
+        case ETHTOOL_GSG:
+                return ethtool_get_sg(dev, useraddr);
+        case ETHTOOL_SSG:
+                return ethtool_set_sg(dev, useraddr);
+        case ETHTOOL_GTSO:
+                return ethtool_get_tso(dev, useraddr);
+        case ETHTOOL_STSO:
+                return ethtool_set_tso(dev, useraddr);
+        case ETHTOOL_TEST:
+                return ethtool_self_test(dev, useraddr);
+        case ETHTOOL_GSTRINGS:
+                return ethtool_get_strings(dev, useraddr);
+        case ETHTOOL_PHYS_ID:
+                return ethtool_phys_id(dev, useraddr);
+        case ETHTOOL_GSTATS:
+                return ethtool_get_stats(dev, useraddr);
+        default:
+                return -EOPNOTSUPP;
+        }
+
+        return -EOPNOTSUPP;
+}
+#endif //ETHTOOL_OPS_COMPAT
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,15,0)
+static int rtl8125_siocdevprivate(struct net_device *dev, struct ifreq *ifr,
+                                  void __user *data, int cmd)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int ret = 0;
+
+        switch (cmd) {
+#ifdef ENABLE_DASH_SUPPORT
+        case SIOCDEVPRIVATE_RTLDASH:
+                if (!netif_running(dev)) {
+                        ret = -ENODEV;
+                        break;
+                }
+                if (!capable(CAP_NET_ADMIN)) {
+                        ret = -EPERM;
+                        break;
+                }
+
+                ret = rtl8125_dash_ioctl(dev, ifr);
+                break;
+#endif
+
+#ifdef ENABLE_REALWOW_SUPPORT
+        case SIOCDEVPRIVATE_RTLREALWOW:
+                if (!netif_running(dev)) {
+                        ret = -ENODEV;
+                        break;
+                }
+
+                ret = rtl8125_realwow_ioctl(dev, ifr);
+                break;
+#endif
+
+        case SIOCRTLTOOL:
+                if (!capable(CAP_NET_ADMIN)) {
+                        ret = -EPERM;
+                        break;
+                }
+
+                ret = rtl8125_tool_ioctl(tp, ifr);
+                break;
+
+        default:
+                ret = -EOPNOTSUPP;
+        }
+
+        return ret;
+}
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(5,15,0)
+
+static int
+rtl8125_do_ioctl(struct net_device *dev,
+                 struct ifreq *ifr,
+                 int cmd)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct mii_ioctl_data *data = if_mii(ifr);
+        int ret = 0;
+
+        switch (cmd) {
+        case SIOCGMIIPHY:
+                data->phy_id = 32; /* Internal PHY */
+                break;
+
+        case SIOCGMIIREG:
+                rtl8125_mdio_write(tp, 0x1F, 0x0000);
+                data->val_out = rtl8125_mdio_read(tp, data->reg_num);
+                break;
+
+        case SIOCSMIIREG:
+                if (!capable(CAP_NET_ADMIN))
+                        return -EPERM;
+                rtl8125_mdio_write(tp, 0x1F, 0x0000);
+                rtl8125_mdio_write(tp, data->reg_num, data->val_in);
+                break;
+
+#ifdef ETHTOOL_OPS_COMPAT
+        case SIOCETHTOOL:
+                ret = ethtool_ioctl(ifr);
+                break;
+#endif
+
+#ifdef ENABLE_PTP_SUPPORT
+        case SIOCSHWTSTAMP:
+        case SIOCGHWTSTAMP:
+                if (tp->EnablePtp)
+                        ret = rtl8125_ptp_ioctl(dev, ifr, cmd);
+                else
+                        ret = -EOPNOTSUPP;
+                break;
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+#ifdef ENABLE_DASH_SUPPORT
+        case SIOCDEVPRIVATE_RTLDASH:
+                if (!netif_running(dev)) {
+                        ret = -ENODEV;
+                        break;
+                }
+                if (!capable(CAP_NET_ADMIN)) {
+                        ret = -EPERM;
+                        break;
+                }
+
+                ret = rtl8125_dash_ioctl(dev, ifr);
+                break;
+#endif
+
+#ifdef ENABLE_REALWOW_SUPPORT
+        case SIOCDEVPRIVATE_RTLREALWOW:
+                if (!netif_running(dev)) {
+                        ret = -ENODEV;
+                        break;
+                }
+
+                if (!capable(CAP_NET_ADMIN)) {
+                        ret = -EPERM;
+                        break;
+                }
+
+                ret = rtl8125_realwow_ioctl(dev, ifr);
+                break;
+#endif
+
+        case SIOCRTLTOOL:
+                if (!capable(CAP_NET_ADMIN)) {
+                        ret = -EPERM;
+                        break;
+                }
+
+                ret = rtl8125_tool_ioctl(tp, ifr);
+                break;
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+
+        default:
+                ret = -EOPNOTSUPP;
+                break;
+        }
+
+        return ret;
+}
+
+static void
+rtl8125_phy_power_up(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (rtl8125_is_in_phy_disable_mode(dev)) {
+                return;
+        }
+
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+        rtl8125_mdio_write(tp, MII_BMCR, BMCR_ANENABLE);
+
+        //wait ups resume (phy state 3)
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                rtl8125_wait_phy_ups_resume(dev, 3);
+                break;
+        };
+}
+
+static void
+rtl8125_phy_power_down(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtl8125_mdio_write(tp, 0x1F, 0x0000);
+        rtl8125_mdio_write(tp, MII_BMCR, BMCR_ANENABLE | BMCR_PDOWN);
+}
+
+static int __devinit
+rtl8125_init_board(struct pci_dev *pdev,
+                   struct net_device **dev_out,
+                   void __iomem **ioaddr_out)
+{
+        void __iomem *ioaddr;
+        struct net_device *dev;
+        struct rtl8125_private *tp;
+        int rc = -ENOMEM, i, pm_cap;
+
+        assert(ioaddr_out != NULL);
+
+        /* dev zeroed in alloc_etherdev */
+        dev = alloc_etherdev_mq(sizeof (*tp), R8125_MAX_QUEUES);
+        if (dev == NULL) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_drv(&debug))
+                        dev_err(&pdev->dev, "unable to alloc new ethernet\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                goto err_out;
+        }
+
+        SET_MODULE_OWNER(dev);
+        SET_NETDEV_DEV(dev, &pdev->dev);
+        tp = netdev_priv(dev);
+        tp->dev = dev;
+        tp->pci_dev = pdev;
+        tp->msg_enable = netif_msg_init(debug.msg_enable, R8125_MSG_DEFAULT);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+        if (!aspm)
+                pci_disable_link_state(pdev, PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1 |
+                                       PCIE_LINK_STATE_CLKPM);
+#endif
+
+        /* enable device (incl. PCI PM wakeup and hotplug setup) */
+        rc = pci_enable_device(pdev);
+        if (rc < 0) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp))
+                        dev_err(&pdev->dev, "enable failure\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                goto err_out_free_dev;
+        }
+
+        if (pci_set_mwi(pdev) < 0) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_drv(&debug))
+                        dev_info(&pdev->dev, "Mem-Wr-Inval unavailable.\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        }
+
+        /* save power state before pci_enable_device overwrites it */
+        pm_cap = pci_find_capability(pdev, PCI_CAP_ID_PM);
+        if (pm_cap) {
+                u16 pwr_command;
+
+                pci_read_config_word(pdev, pm_cap + PCI_PM_CTRL, &pwr_command);
+        } else {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp)) {
+                        dev_err(&pdev->dev, "PowerManagement capability not found.\n");
+                }
+#else
+                printk("PowerManagement capability not found.\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+
+        }
+
+        /* make sure PCI base addr 1 is MMIO */
+        if (!(pci_resource_flags(pdev, 2) & IORESOURCE_MEM)) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp))
+                        dev_err(&pdev->dev, "region #1 not an MMIO resource, aborting\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                rc = -ENODEV;
+                goto err_out_mwi;
+        }
+        /* check for weird/broken PCI region reporting */
+        if (pci_resource_len(pdev, 2) < R8125_REGS_SIZE) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp))
+                        dev_err(&pdev->dev, "Invalid PCI region size(s), aborting\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                rc = -ENODEV;
+                goto err_out_mwi;
+        }
+
+        rc = pci_request_regions(pdev, MODULENAME);
+        if (rc < 0) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp))
+                        dev_err(&pdev->dev, "could not request regions.\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                goto err_out_mwi;
+        }
+
+        if ((sizeof(dma_addr_t) > 4) &&
+            use_dac &&
+            !pci_set_dma_mask(pdev, DMA_BIT_MASK(64)) &&
+            !pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64))) {
+                dev->features |= NETIF_F_HIGHDMA;
+        } else {
+                rc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));
+                if (rc < 0) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                        if (netif_msg_probe(tp))
+                                dev_err(&pdev->dev, "DMA configuration failed.\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                        goto err_out_free_res;
+                }
+        }
+
+        /* ioremap MMIO region */
+        ioaddr = ioremap(pci_resource_start(pdev, 2), pci_resource_len(pdev, 2));
+        if (ioaddr == NULL) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp))
+                        dev_err(&pdev->dev, "cannot remap MMIO, aborting\n");
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                rc = -EIO;
+                goto err_out_free_res;
+        }
+
+        tp->mmio_addr = ioaddr;
+
+        /* Identify chip attached to board */
+        rtl8125_get_mac_version(tp);
+
+        rtl8125_print_mac_version(tp);
+
+        for (i = ARRAY_SIZE(rtl_chip_info) - 1; i >= 0; i--) {
+                if (tp->mcfg == rtl_chip_info[i].mcfg)
+                        break;
+        }
+
+        if (i < 0) {
+                /* Unknown chip: assume array element #0, original RTL-8125 */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                if (netif_msg_probe(tp))
+                        dev_printk(KERN_DEBUG, &pdev->dev, "unknown chip version, assuming %s\n", rtl_chip_info[0].name);
+#else
+                printk("Realtek unknown chip version, assuming %s\n", rtl_chip_info[0].name);
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+                i++;
+        }
+
+        tp->chipset = i;
+
+        *ioaddr_out = ioaddr;
+        *dev_out = dev;
+out:
+        return rc;
+
+err_out_free_res:
+        pci_release_regions(pdev);
+err_out_mwi:
+        pci_clear_mwi(pdev);
+        pci_disable_device(pdev);
+err_out_free_dev:
+        free_netdev(dev);
+err_out:
+        *ioaddr_out = NULL;
+        *dev_out = NULL;
+        goto out;
+}
+
+static void
+rtl8125_esd_checker(struct rtl8125_private *tp)
+{
+        struct net_device *dev = tp->dev;
+        struct pci_dev *pdev = tp->pci_dev;
+        u8 cmd;
+        u16 io_base_l;
+        u16 mem_base_l;
+        u16 mem_base_h;
+        u8 ilr;
+        u16 resv_0x1c_h;
+        u16 resv_0x1c_l;
+        u16 resv_0x20_l;
+        u16 resv_0x20_h;
+        u16 resv_0x24_l;
+        u16 resv_0x24_h;
+        u16 resv_0x2c_h;
+        u16 resv_0x2c_l;
+        u32 pci_sn_l;
+        u32 pci_sn_h;
+
+        tp->esd_flag = 0;
+
+        pci_read_config_byte(pdev, PCI_COMMAND, &cmd);
+        if (cmd != tp->pci_cfg_space.cmd) {
+                printk(KERN_ERR "%s: cmd = 0x%02x, should be 0x%02x \n.", dev->name, cmd, tp->pci_cfg_space.cmd);
+                pci_write_config_byte(pdev, PCI_COMMAND, tp->pci_cfg_space.cmd);
+                tp->esd_flag |= BIT_0;
+
+                pci_read_config_byte(pdev, PCI_COMMAND, &cmd);
+                if (cmd == 0xff) {
+                        printk(KERN_ERR "%s: pci link is down \n.", dev->name);
+                        goto exit;
+                }
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_0, &io_base_l);
+        if (io_base_l != tp->pci_cfg_space.io_base_l) {
+                printk(KERN_ERR "%s: io_base_l = 0x%04x, should be 0x%04x \n.", dev->name, io_base_l, tp->pci_cfg_space.io_base_l);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_0, tp->pci_cfg_space.io_base_l);
+                tp->esd_flag |= BIT_1;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_2, &mem_base_l);
+        if (mem_base_l != tp->pci_cfg_space.mem_base_l) {
+                printk(KERN_ERR "%s: mem_base_l = 0x%04x, should be 0x%04x \n.", dev->name, mem_base_l, tp->pci_cfg_space.mem_base_l);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_2, tp->pci_cfg_space.mem_base_l);
+                tp->esd_flag |= BIT_2;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_2 + 2, &mem_base_h);
+        if (mem_base_h!= tp->pci_cfg_space.mem_base_h) {
+                printk(KERN_ERR "%s: mem_base_h = 0x%04x, should be 0x%04x \n.", dev->name, mem_base_h, tp->pci_cfg_space.mem_base_h);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_2 + 2, tp->pci_cfg_space.mem_base_h);
+                tp->esd_flag |= BIT_3;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_3, &resv_0x1c_l);
+        if (resv_0x1c_l != tp->pci_cfg_space.resv_0x1c_l) {
+                printk(KERN_ERR "%s: resv_0x1c_l = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x1c_l, tp->pci_cfg_space.resv_0x1c_l);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_3, tp->pci_cfg_space.resv_0x1c_l);
+                tp->esd_flag |= BIT_4;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_3 + 2, &resv_0x1c_h);
+        if (resv_0x1c_h != tp->pci_cfg_space.resv_0x1c_h) {
+                printk(KERN_ERR "%s: resv_0x1c_h = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x1c_h, tp->pci_cfg_space.resv_0x1c_h);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_3 + 2, tp->pci_cfg_space.resv_0x1c_h);
+                tp->esd_flag |= BIT_5;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_4, &resv_0x20_l);
+        if (resv_0x20_l != tp->pci_cfg_space.resv_0x20_l) {
+                printk(KERN_ERR "%s: resv_0x20_l = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x20_l, tp->pci_cfg_space.resv_0x20_l);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_4, tp->pci_cfg_space.resv_0x20_l);
+                tp->esd_flag |= BIT_6;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_4 + 2, &resv_0x20_h);
+        if (resv_0x20_h != tp->pci_cfg_space.resv_0x20_h) {
+                printk(KERN_ERR "%s: resv_0x20_h = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x20_h, tp->pci_cfg_space.resv_0x20_h);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_4 + 2, tp->pci_cfg_space.resv_0x20_h);
+                tp->esd_flag |= BIT_7;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_5, &resv_0x24_l);
+        if (resv_0x24_l != tp->pci_cfg_space.resv_0x24_l) {
+                printk(KERN_ERR "%s: resv_0x24_l = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x24_l, tp->pci_cfg_space.resv_0x24_l);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_5, tp->pci_cfg_space.resv_0x24_l);
+                tp->esd_flag |= BIT_8;
+        }
+
+        pci_read_config_word(pdev, PCI_BASE_ADDRESS_5 + 2, &resv_0x24_h);
+        if (resv_0x24_h != tp->pci_cfg_space.resv_0x24_h) {
+                printk(KERN_ERR "%s: resv_0x24_h = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x24_h, tp->pci_cfg_space.resv_0x24_h);
+                pci_write_config_word(pdev, PCI_BASE_ADDRESS_5 + 2, tp->pci_cfg_space.resv_0x24_h);
+                tp->esd_flag |= BIT_9;
+        }
+
+        pci_read_config_byte(pdev, PCI_INTERRUPT_LINE, &ilr);
+        if (ilr != tp->pci_cfg_space.ilr) {
+                printk(KERN_ERR "%s: ilr = 0x%02x, should be 0x%02x \n.", dev->name, ilr, tp->pci_cfg_space.ilr);
+                pci_write_config_byte(pdev, PCI_INTERRUPT_LINE, tp->pci_cfg_space.ilr);
+                tp->esd_flag |= BIT_10;
+        }
+
+        pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID, &resv_0x2c_l);
+        if (resv_0x2c_l != tp->pci_cfg_space.resv_0x2c_l) {
+                printk(KERN_ERR "%s: resv_0x2c_l = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x2c_l, tp->pci_cfg_space.resv_0x2c_l);
+                pci_write_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID, tp->pci_cfg_space.resv_0x2c_l);
+                tp->esd_flag |= BIT_11;
+        }
+
+        pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID + 2, &resv_0x2c_h);
+        if (resv_0x2c_h != tp->pci_cfg_space.resv_0x2c_h) {
+                printk(KERN_ERR "%s: resv_0x2c_h = 0x%04x, should be 0x%04x \n.", dev->name, resv_0x2c_h, tp->pci_cfg_space.resv_0x2c_h);
+                pci_write_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID + 2, tp->pci_cfg_space.resv_0x2c_h);
+                tp->esd_flag |= BIT_12;
+        }
+
+        if (tp->HwPcieSNOffset > 0) {
+                pci_sn_l = rtl8125_csi_read(tp, tp->HwPcieSNOffset);
+                if (pci_sn_l != tp->pci_cfg_space.pci_sn_l) {
+                        printk(KERN_ERR "%s: pci_sn_l = 0x%08x, should be 0x%08x \n.", dev->name, pci_sn_l, tp->pci_cfg_space.pci_sn_l);
+                        rtl8125_csi_write(tp, tp->HwPcieSNOffset, tp->pci_cfg_space.pci_sn_l);
+                        tp->esd_flag |= BIT_13;
+                }
+
+                pci_sn_h = rtl8125_csi_read(tp, tp->HwPcieSNOffset + 4);
+                if (pci_sn_h != tp->pci_cfg_space.pci_sn_h) {
+                        printk(KERN_ERR "%s: pci_sn_h = 0x%08x, should be 0x%08x \n.", dev->name, pci_sn_h, tp->pci_cfg_space.pci_sn_h);
+                        rtl8125_csi_write(tp, tp->HwPcieSNOffset + 4, tp->pci_cfg_space.pci_sn_h);
+                        tp->esd_flag |= BIT_14;
+                }
+        }
+
+        if (tp->esd_flag != 0) {
+                printk(KERN_ERR "%s: esd_flag = 0x%04x\n.\n", dev->name, tp->esd_flag);
+                netif_tx_stop_all_queues(dev);
+                netif_carrier_off(dev);
+                rtl8125_hw_reset(dev);
+                rtl8125_tx_clear(tp);
+                rtl8125_rx_clear(tp);
+                rtl8125_init_ring(dev);
+                rtl8125_up(dev);
+                rtl8125_enable_hw_linkchg_interrupt(tp);
+                rtl8125_set_speed(dev, tp->autoneg, tp->speed, tp->duplex, tp->advertising);
+                tp->esd_flag = 0;
+        }
+exit:
+        return;
+}
+/*
+static void
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+rtl8125_esd_timer(unsigned long __opaque)
+#else
+rtl8125_esd_timer(struct timer_list *t)
+#endif
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+        struct net_device *dev = (struct net_device *)__opaque;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct timer_list *timer = &tp->esd_timer;
+#else
+        struct rtl8125_private *tp = from_timer(tp, t, esd_timer);
+        //struct net_device *dev = tp->dev;
+        struct timer_list *timer = t;
+#endif
+        rtl8125_esd_checker(tp);
+
+        mod_timer(timer, jiffies + timeout);
+}
+*/
+
+/*
+static void
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+rtl8125_link_timer(unsigned long __opaque)
+#else
+rtl8125_link_timer(struct timer_list *t)
+#endif
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+        struct net_device *dev = (struct net_device *)__opaque;
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct timer_list *timer = &tp->link_timer;
+#else
+        struct rtl8125_private *tp = from_timer(tp, t, link_timer);
+        struct net_device *dev = tp->dev;
+        struct timer_list *timer = t;
+#endif
+        rtl8125_check_link_status(dev);
+
+        mod_timer(timer, jiffies + RTL8125_LINK_TIMEOUT);
+}
+*/
+
+int
+rtl8125_enable_msix(struct rtl8125_private *tp)
+{
+        int i, nvecs = 0;
+        struct msix_entry msix_ent[R8125_MAX_MSIX_VEC];
+        //struct net_device *dev = tp->dev;
+        //const int len = sizeof(tp->irq_tbl[0].name);
+
+        for (i = 0; i < R8125_MAX_MSIX_VEC; i++) {
+                msix_ent[i].entry = i;
+                msix_ent[i].vector = 0;
+        }
+
+        nvecs = pci_enable_msix_range(tp->pci_dev, msix_ent,
+                                      tp->min_irq_nvecs, tp->max_irq_nvecs);
+        if (nvecs < 0)
+                goto out;
+
+        for (i = 0; i < nvecs; i++) {
+                struct r8125_irq *irq = &tp->irq_tbl[i];
+                irq->vector = msix_ent[i].vector;
+                //snprintf(irq->name, len, "%s-%d", dev->name, i);
+                //irq->handler = rtl8125_interrupt_msix;
+        }
+
+out:
+        return nvecs;
+}
+
+void rtl8125_dump_msix_tbl(struct rtl8125_private *tp)
+{
+        void __iomem *ioaddr;
+
+        /* ioremap MMIO region */
+        ioaddr = ioremap(pci_resource_start(tp->pci_dev, 4), pci_resource_len(tp->pci_dev, 4));
+        if (ioaddr) {
+                int i = 0;
+                for (i=0; i<tp->irq_nvecs; i++) {
+                        printk("entry 0x%d %08X %08X %08X %08X \n",
+                               i,
+                               readl(ioaddr + 16 * i),
+                               readl(ioaddr + 16 * i + 4),
+                               readl(ioaddr + 16 * i + 8),
+                               readl(ioaddr + 16 * i + 12));
+                }
+                iounmap(ioaddr);
+        }
+}
+
+/* Cfg9346_Unlock assumed. */
+static int rtl8125_try_msi(struct rtl8125_private *tp)
+{
+        struct pci_dev *pdev = tp->pci_dev;
+        unsigned msi = 0;
+        int nvecs = 1;
+
+        tp->max_irq_nvecs = 1;
+        tp->min_irq_nvecs = 1;
+#ifndef DISABLE_MULTI_MSIX_VECTOR
+        switch (tp->mcfg) {
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_7:
+                tp->max_irq_nvecs = R8125_MAX_MSIX_VEC_8125B;
+                tp->min_irq_nvecs = R8125_MIN_MSIX_VEC_8125B;
+                break;
+        }
+#endif
+
+#if defined(RTL_USE_NEW_INTR_API)
+        if ((nvecs = pci_alloc_irq_vectors(pdev, tp->min_irq_nvecs, tp->max_irq_nvecs, PCI_IRQ_MSIX)) > 0)
+                msi |= RTL_FEATURE_MSIX;
+        else if ((nvecs = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES)) > 0 &&
+                 pci_dev_msi_enabled(pdev))
+                msi |= RTL_FEATURE_MSI;
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13)
+        if ((nvecs = rtl8125_enable_msix(tp)) > 0)
+                msi |= RTL_FEATURE_MSIX;
+        else if (!pci_enable_msi(pdev))
+                msi |= RTL_FEATURE_MSI;
+#endif
+        if (!(msi & (RTL_FEATURE_MSI | RTL_FEATURE_MSIX)))
+                dev_info(&pdev->dev, "no MSI/MSI-X. Back to INTx.\n");
+
+        if (!(msi & RTL_FEATURE_MSIX) || nvecs < 1)
+                nvecs = 1;
+
+        tp->irq_nvecs = nvecs;
+
+        tp->features |= msi;
+
+        return nvecs;
+}
+
+static void rtl8125_disable_msi(struct pci_dev *pdev, struct rtl8125_private *tp)
+{
+#if defined(RTL_USE_NEW_INTR_API)
+        if (tp->features & (RTL_FEATURE_MSI | RTL_FEATURE_MSIX))
+                pci_free_irq_vectors(pdev);
+#elif LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13)
+        if (tp->features & (RTL_FEATURE_MSIX))
+                pci_disable_msix(pdev);
+        else if (tp->features & (RTL_FEATURE_MSI))
+                pci_disable_msi(pdev);
+#endif
+        tp->features &= ~(RTL_FEATURE_MSI | RTL_FEATURE_MSIX);
+}
+
+static int rtl8125_get_irq(struct pci_dev *pdev)
+{
+#if defined(RTL_USE_NEW_INTR_API)
+        return pci_irq_vector(pdev, 0);
+#else
+        return pdev->irq;
+#endif
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+static const struct net_device_ops rtl8125_netdev_ops = {
+        .ndo_open       = rtl8125_open,
+        .ndo_stop       = rtl8125_close,
+        .ndo_get_stats      = rtl8125_get_stats,
+        .ndo_start_xmit     = rtl8125_start_xmit,
+        .ndo_tx_timeout     = rtl8125_tx_timeout,
+        .ndo_change_mtu     = rtl8125_change_mtu,
+        .ndo_set_mac_address    = rtl8125_set_mac_address,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+        .ndo_do_ioctl       = rtl8125_do_ioctl,
+#else
+        .ndo_siocdevprivate = rtl8125_siocdevprivate,
+        .ndo_eth_ioctl      = rtl8125_do_ioctl,
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(5,15,0)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0)
+        .ndo_set_multicast_list = rtl8125_set_rx_mode,
+#else
+        .ndo_set_rx_mode    = rtl8125_set_rx_mode,
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+#ifdef CONFIG_R8125_VLAN
+        .ndo_vlan_rx_register   = rtl8125_vlan_rx_register,
+#endif
+#else
+        .ndo_fix_features   = rtl8125_fix_features,
+        .ndo_set_features   = rtl8125_set_features,
+#endif
+#ifdef CONFIG_NET_POLL_CONTROLLER
+        .ndo_poll_controller    = rtl8125_netpoll,
+#endif
+};
+#endif
+
+
+#ifdef  CONFIG_R8125_NAPI
+
+static int rtl8125_poll(napi_ptr napi, napi_budget budget)
+{
+        struct r8125_napi *r8125napi = RTL_GET_PRIV(napi, struct r8125_napi);
+        struct rtl8125_private *tp = r8125napi->priv;
+        RTL_GET_NETDEV(tp)
+        unsigned int work_to_do = RTL_NAPI_QUOTA(budget, dev);
+        unsigned int work_done = 0;
+        int i;
+
+        for (i = 0; i < tp->num_tx_rings; i++)
+                rtl8125_tx_interrupt(&tp->tx_ring[i], budget);
+
+        for (i = 0; i < tp->num_rx_rings; i++)
+                work_done += rtl8125_rx_interrupt(dev, tp, &tp->rx_ring[i], budget);
+
+        RTL_NAPI_QUOTA_UPDATE(dev, work_done, budget);
+
+        if (work_done < work_to_do) {
+#ifdef ENABLE_DASH_SUPPORT
+                if (tp->DASH)
+                        HandleDashInterrupt(tp->dev);
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+                if (RTL_NETIF_RX_COMPLETE(dev, napi, work_done) == FALSE) return RTL_NAPI_RETURN_VALUE;
+#else
+                RTL_NETIF_RX_COMPLETE(dev, napi, work_done);
+#endif
+                /*
+                 * 20040426: the barrier is not strictly required but the
+                 * behavior of the irq handler could be less predictable
+                 * without it. Btw, the lack of flush for the posted pci
+                 * write is safe - FR
+                 */
+                smp_wmb();
+
+                rtl8125_switch_to_timer_interrupt(tp);
+        }
+
+        return RTL_NAPI_RETURN_VALUE;
+}
+
+#if 0
+static int rtl8125_poll_msix_ring(napi_ptr napi, napi_budget budget)
+{
+        struct r8125_napi *r8125napi = RTL_GET_PRIV(napi, struct r8125_napi);
+        struct rtl8125_private *tp = r8125napi->priv;
+        RTL_GET_NETDEV(tp)
+        unsigned int work_to_do = RTL_NAPI_QUOTA(budget, dev);
+        unsigned int work_done = 0;
+        const int message_id = r8125napi->index;
+
+        rtl8125_tx_interrupt_with_vector(tp, message_id, budget);
+
+        work_done += rtl8125_rx_interrupt(dev, tp, &tp->rx_ring[message_id], budget);
+
+        RTL_NAPI_QUOTA_UPDATE(dev, work_done, budget);
+
+        if (work_done < work_to_do) {
+#ifdef ENABLE_DASH_SUPPORT
+                if (tp->DASH && message_id == 0)
+                        HandleDashInterrupt(tp->dev);
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+                if (RTL_NETIF_RX_COMPLETE(dev, napi, work_done) == FALSE) return RTL_NAPI_RETURN_VALUE;
+#else
+                RTL_NETIF_RX_COMPLETE(dev, napi, work_done);
+#endif
+                /*
+                 * 20040426: the barrier is not strictly required but the
+                 * behavior of the irq handler could be less predictable
+                 * without it. Btw, the lack of flush for the posted pci
+                 * write is safe - FR
+                 */
+                smp_wmb();
+
+                rtl8125_enable_hw_interrupt_v2(tp, message_id);
+        }
+
+        return RTL_NAPI_RETURN_VALUE;
+}
+#endif
+
+static int rtl8125_poll_msix_tx(napi_ptr napi, napi_budget budget)
+{
+        struct r8125_napi *r8125napi = RTL_GET_PRIV(napi, struct r8125_napi);
+        struct rtl8125_private *tp = r8125napi->priv;
+        RTL_GET_NETDEV(tp)
+        unsigned int work_to_do = RTL_NAPI_QUOTA(budget, dev);
+        unsigned int work_done = 0;
+        const int message_id = r8125napi->index;
+
+        //suppress unused variable
+        (void)(dev);
+
+        rtl8125_tx_interrupt_with_vector(tp, message_id, budget);
+
+        RTL_NAPI_QUOTA_UPDATE(dev, work_done, budget);
+
+        if (work_done < work_to_do) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+                if (RTL_NETIF_RX_COMPLETE(dev, napi, work_done) == FALSE) return RTL_NAPI_RETURN_VALUE;
+#else
+                RTL_NETIF_RX_COMPLETE(dev, napi, work_done);
+#endif
+                /*
+                 * 20040426: the barrier is not strictly required but the
+                 * behavior of the irq handler could be less predictable
+                 * without it. Btw, the lack of flush for the posted pci
+                 * write is safe - FR
+                 */
+                smp_wmb();
+
+                rtl8125_enable_hw_interrupt_v2(tp, message_id);
+        }
+
+        return RTL_NAPI_RETURN_VALUE;
+}
+
+static int rtl8125_poll_msix_other(napi_ptr napi, napi_budget budget)
+{
+        struct r8125_napi *r8125napi = RTL_GET_PRIV(napi, struct r8125_napi);
+        struct rtl8125_private *tp = r8125napi->priv;
+        RTL_GET_NETDEV(tp)
+        unsigned int work_to_do = RTL_NAPI_QUOTA(budget, dev);
+        const int message_id = r8125napi->index;
+
+        //suppress unused variable
+        (void)(dev);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+        RTL_NETIF_RX_COMPLETE(dev, napi, work_to_do);
+#else
+        RTL_NETIF_RX_COMPLETE(dev, napi, work_to_do);
+#endif
+
+        rtl8125_enable_hw_interrupt_v2(tp, message_id);
+
+        return 1;
+}
+
+static int rtl8125_poll_msix_rx(napi_ptr napi, napi_budget budget)
+{
+        struct r8125_napi *r8125napi = RTL_GET_PRIV(napi, struct r8125_napi);
+        struct rtl8125_private *tp = r8125napi->priv;
+        RTL_GET_NETDEV(tp)
+        unsigned int work_to_do = RTL_NAPI_QUOTA(budget, dev);
+        unsigned int work_done = 0;
+        const int message_id = r8125napi->index;
+
+        work_done += rtl8125_rx_interrupt(dev, tp, &tp->rx_ring[message_id], budget);
+
+        RTL_NAPI_QUOTA_UPDATE(dev, work_done, budget);
+
+        if (work_done < work_to_do) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+                if (RTL_NETIF_RX_COMPLETE(dev, napi, work_done) == FALSE) return RTL_NAPI_RETURN_VALUE;
+#else
+                RTL_NETIF_RX_COMPLETE(dev, napi, work_done);
+#endif
+                /*
+                 * 20040426: the barrier is not strictly required but the
+                 * behavior of the irq handler could be less predictable
+                 * without it. Btw, the lack of flush for the posted pci
+                 * write is safe - FR
+                 */
+                smp_wmb();
+
+                rtl8125_enable_hw_interrupt_v2(tp, message_id);
+        }
+
+        return RTL_NAPI_RETURN_VALUE;
+}
+
+static void rtl8125_enable_napi(struct rtl8125_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        int i;
+
+        for (i = 0; i < tp->irq_nvecs; i++)
+                RTL_NAPI_ENABLE(tp->dev, &tp->r8125napi[i].napi);
+#endif
+}
+
+static void rtl8125_disable_napi(struct rtl8125_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        int i;
+
+        for (i = 0; i < tp->irq_nvecs; i++)
+                RTL_NAPI_DISABLE(tp->dev, &tp->r8125napi[i].napi);
+#endif
+}
+
+static void rtl8125_del_napi(struct rtl8125_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        int i;
+
+        for (i = 0; i < tp->irq_nvecs; i++)
+                RTL_NAPI_DEL((&tp->r8125napi[i]));
+#endif
+}
+#endif //CONFIG_R8125_NAPI
+
+static void rtl8125_init_napi(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i=0; i<tp->irq_nvecs; i++) {
+                struct r8125_napi *r8125napi = &tp->r8125napi[i];
+#ifdef CONFIG_R8125_NAPI
+                int (*poll)(struct napi_struct *, int);
+
+                if (tp->features & RTL_FEATURE_MSIX &&
+                    tp->HwCurrIsrVer == 2) {
+                        if (i < R8125_MAX_RX_QUEUES_VEC_V3)
+                                poll = rtl8125_poll_msix_rx;
+                        else if (i == 16 || i == 18)
+                                poll = rtl8125_poll_msix_tx;
+                        else
+                                poll = rtl8125_poll_msix_other;
+                } else {
+                        poll = rtl8125_poll;
+                }
+
+                RTL_NAPI_CONFIG(tp->dev, r8125napi, poll, R8125_NAPI_WEIGHT);
+#endif
+
+                r8125napi->priv = tp;
+                r8125napi->index = i;
+        }
+}
+
+static int
+rtl8125_set_real_num_queue(struct rtl8125_private *tp)
+{
+        int retval = 0;
+
+        retval = netif_set_real_num_tx_queues(tp->dev, tp->num_tx_rings);
+        if (retval < 0)
+                goto exit;
+
+        retval = netif_set_real_num_rx_queues(tp->dev, tp->num_rx_rings);
+        if (retval < 0)
+                goto exit;
+
+exit:
+        return retval;
+}
+
+static int __devinit
+rtl8125_init_one(struct pci_dev *pdev,
+                 const struct pci_device_id *ent)
+{
+        struct net_device *dev = NULL;
+        struct rtl8125_private *tp;
+        void __iomem *ioaddr = NULL;
+        static int board_idx = -1;
+
+        int rc;
+
+        assert(pdev != NULL);
+        assert(ent != NULL);
+
+        board_idx++;
+
+        if (netif_msg_drv(&debug))
+                printk(KERN_INFO "%s 2.5Gigabit Ethernet driver %s loaded\n",
+                       MODULENAME, RTL8125_VERSION);
+
+        rc = rtl8125_init_board(pdev, &dev, &ioaddr);
+        if (rc)
+                goto out;
+
+        tp = netdev_priv(dev);
+        assert(ioaddr != NULL);
+
+        tp->set_speed = rtl8125_set_speed_xmii;
+        tp->get_settings = rtl8125_gset_xmii;
+        tp->phy_reset_enable = rtl8125_xmii_reset_enable;
+        tp->phy_reset_pending = rtl8125_xmii_reset_pending;
+        tp->link_ok = rtl8125_xmii_link_ok;
+
+        rc = rtl8125_try_msi(tp);
+        if (rc < 0) {
+                dev_err(&pdev->dev, "Can't allocate interrupt\n");
+                goto err_out_1;
+        }
+#ifdef ENABLE_PTP_SUPPORT
+        spin_lock_init(&tp->lock);
+#endif
+        rtl8125_init_software_variable(dev);
+
+        RTL_NET_DEVICE_OPS(rtl8125_netdev_ops);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,22)
+        SET_ETHTOOL_OPS(dev, &rtl8125_ethtool_ops);
+#endif
+
+        dev->watchdog_timeo = RTL8125_TX_TIMEOUT;
+        dev->irq = rtl8125_get_irq(pdev);
+        dev->base_addr = (unsigned long) ioaddr;
+
+        rtl8125_init_napi(tp);
+
+#ifdef CONFIG_R8125_VLAN
+        if (tp->mcfg != CFG_METHOD_DEFAULT) {
+                dev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+                dev->vlan_rx_kill_vid = rtl8125_vlan_rx_kill_vid;
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+        }
+#endif
+
+        /* There has been a number of reports that using SG/TSO results in
+         * tx timeouts. However for a lot of people SG/TSO works fine.
+         * Therefore disable both features by default, but allow users to
+         * enable them. Use at own risk!
+         */
+        tp->cp_cmd |= RTL_R16(tp, CPlusCmd);
+        if (tp->mcfg != CFG_METHOD_DEFAULT) {
+                dev->features |= NETIF_F_IP_CSUM;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+                tp->cp_cmd |= RxChkSum;
+#else
+                //dev->features |= NETIF_F_RXCSUM;
+                dev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO |
+                                   NETIF_F_RXCSUM | NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
+                dev->vlan_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO |
+                                     NETIF_F_HIGHDMA;
+                dev->features |= dev->hw_features;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0)
+                dev->priv_flags |= IFF_LIVE_ADDR_CHANGE;
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(3,15,0)
+                dev->hw_features |= NETIF_F_RXALL;
+                dev->hw_features |= NETIF_F_RXFCS;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+                dev->hw_features |= NETIF_F_IPV6_CSUM | NETIF_F_TSO6;
+                dev->features |=  NETIF_F_IPV6_CSUM;
+                netif_set_gso_max_size(dev, LSO_64K);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,0)
+                dev->gso_max_segs = NIC_MAX_PHYS_BUF_COUNT_LSO2;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+                dev->gso_min_segs = NIC_MIN_PHYS_BUF_COUNT;
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,7,0)
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(3,18,0)
+
+#endif //LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+
+#ifdef ENABLE_RSS_SUPPORT
+                if (tp->EnableRss) {
+                        dev->hw_features |= NETIF_F_RXHASH;
+                        dev->features |=  NETIF_F_RXHASH;
+                }
+#endif
+        }
+
+#ifdef ENABLE_DASH_SUPPORT
+        if (tp->DASH)
+                AllocateDashShareMemory(dev);
+#endif
+
+#ifdef ENABLE_LIB_SUPPORT
+        ATOMIC_INIT_NOTIFIER_HEAD(&tp->lib_nh);
+#endif
+        rtl8125_init_all_schedule_work(tp);
+
+        rc = rtl8125_set_real_num_queue(tp);
+        if (rc < 0)
+                goto err_out;
+
+        rtl8125_exit_oob(dev);
+
+        rtl8125_powerup_pll(dev);
+
+        rtl8125_hw_init(dev);
+
+        rtl8125_hw_reset(dev);
+
+        /* Get production from EEPROM */
+        rtl8125_eeprom_type(tp);
+
+        if (tp->eeprom_type == EEPROM_TYPE_93C46 || tp->eeprom_type == EEPROM_TYPE_93C56)
+                rtl8125_set_eeprom_sel_low(tp);
+
+        rtl8125_get_mac_address(dev);
+
+        tp->fw_name = rtl_chip_fw_infos[tp->mcfg].fw_name;
+
+        tp->tally_vaddr = dma_alloc_coherent(&pdev->dev, sizeof(*tp->tally_vaddr),
+                                             &tp->tally_paddr, GFP_KERNEL);
+        if (!tp->tally_vaddr) {
+                rc = -ENOMEM;
+                goto err_out;
+        }
+
+        rtl8125_tally_counter_clear(tp);
+
+        pci_set_drvdata(pdev, dev);
+
+        rc = register_netdev(dev);
+        if (rc)
+                goto err_out;
+
+        printk(KERN_INFO "%s: This product is covered by one or more of the following patents: US6,570,884, US6,115,776, and US6,327,625.\n", MODULENAME);
+
+        rtl8125_disable_rxdvgate(dev);
+
+        device_set_wakeup_enable(&pdev->dev, tp->wol_enabled);
+
+        netif_carrier_off(dev);
+
+        printk("%s", GPL_CLAIM);
+
+out:
+        return rc;
+
+err_out:
+        if (tp->tally_vaddr != NULL) {
+                dma_free_coherent(&pdev->dev, sizeof(*tp->tally_vaddr), tp->tally_vaddr,
+                                  tp->tally_paddr);
+
+                tp->tally_vaddr = NULL;
+        }
+#ifdef  CONFIG_R8125_NAPI
+        rtl8125_del_napi(tp);
+#endif
+        rtl8125_disable_msi(pdev, tp);
+
+err_out_1:
+        rtl8125_release_board(pdev, dev);
+
+        goto out;
+}
+
+static void __devexit
+rtl8125_remove_one(struct pci_dev *pdev)
+{
+        struct net_device *dev = pci_get_drvdata(pdev);
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        assert(dev != NULL);
+        assert(tp != NULL);
+
+        set_bit(R8125_FLAG_DOWN, tp->task_flags);
+
+        rtl8125_cancel_all_schedule_work(tp);
+
+#ifdef  CONFIG_R8125_NAPI
+        rtl8125_del_napi(tp);
+#endif
+        if (tp->DASH)
+                rtl8125_driver_stop(tp);
+
+        unregister_netdev(dev);
+        rtl8125_disable_msi(pdev, tp);
+#ifdef ENABLE_R8125_PROCFS
+        rtl8125_proc_remove(dev);
+#endif
+        if (tp->tally_vaddr != NULL) {
+                dma_free_coherent(&pdev->dev, sizeof(*tp->tally_vaddr), tp->tally_vaddr, tp->tally_paddr);
+                tp->tally_vaddr = NULL;
+        }
+
+        rtl8125_release_board(pdev, dev);
+
+#ifdef ENABLE_USE_FIRMWARE_FILE
+        rtl8125_release_firmware(tp);
+#endif
+
+        pci_set_drvdata(pdev, NULL);
+}
+
+static void
+rtl8125_set_rxbufsize(struct rtl8125_private *tp,
+                      struct net_device *dev)
+{
+        unsigned int mtu = dev->mtu;
+
+        tp->rx_buf_sz = (mtu > ETH_DATA_LEN) ? mtu + ETH_HLEN + 8 + 1 : RX_BUF_SIZE;
+}
+
+static void rtl8125_free_irq(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i=0; i<tp->irq_nvecs; i++) {
+                struct r8125_irq *irq = &tp->irq_tbl[i];
+                struct r8125_napi *r8125napi = &tp->r8125napi[i];
+
+                if (irq->requested) {
+                        irq->requested = 0;
+#if defined(RTL_USE_NEW_INTR_API)
+                        pci_free_irq(tp->pci_dev, i, r8125napi);
+#else
+                        free_irq(irq->vector, r8125napi);
+#endif
+                }
+        }
+}
+
+static int rtl8125_alloc_irq(struct rtl8125_private *tp)
+{
+        struct net_device *dev = tp->dev;
+        int rc = 0;
+        struct r8125_irq *irq;
+        struct r8125_napi *r8125napi;
+        int i = 0;
+        const int len = sizeof(tp->irq_tbl[0].name);
+
+#if defined(RTL_USE_NEW_INTR_API)
+        for (i=0; i<tp->irq_nvecs; i++) {
+                irq = &tp->irq_tbl[i];
+                if (tp->features & RTL_FEATURE_MSIX &&
+                    tp->HwCurrIsrVer == 2)
+                        irq->handler = rtl8125_interrupt_msix;
+                else
+                        irq->handler = rtl8125_interrupt;
+
+                r8125napi = &tp->r8125napi[i];
+                snprintf(irq->name, len, "%s-%d", dev->name, i);
+                rc = pci_request_irq(tp->pci_dev, i, irq->handler, NULL, r8125napi,
+                                     irq->name);
+                if (rc)
+                        break;
+
+                irq->vector = pci_irq_vector(tp->pci_dev, i);
+                irq->requested = 1;
+        }
+#else
+        unsigned long irq_flags = 0;
+#ifdef ENABLE_LIB_SUPPORT
+        irq_flags |= IRQF_NO_SUSPEND;
+#endif
+        if (tp->features & RTL_FEATURE_MSIX &&
+            tp->HwCurrIsrVer == 2) {
+                for (i=0; i<tp->irq_nvecs; i++) {
+                        irq = &tp->irq_tbl[i];
+                        irq->handler = rtl8125_interrupt_msix;
+                        r8125napi = &tp->r8125napi[i];
+                        snprintf(irq->name, len, "%s-%d", dev->name, i);
+                        rc = request_irq(irq->vector, irq->handler, irq_flags, irq->name, r8125napi);
+
+                        if (rc)
+                                break;
+
+                        irq->requested = 1;
+                }
+        } else {
+                irq = &tp->irq_tbl[0];
+                irq->handler = rtl8125_interrupt;
+                r8125napi = &tp->r8125napi[0];
+                snprintf(irq->name, len, "%s-0", dev->name);
+                if (!(tp->features & RTL_FEATURE_MSIX))
+                        irq->vector = dev->irq;
+                irq_flags |= (tp->features & (RTL_FEATURE_MSI | RTL_FEATURE_MSIX)) ? 0 : SA_SHIRQ;
+                rc = request_irq(irq->vector, irq->handler, irq_flags, irq->name, r8125napi);
+
+                if (rc == 0)
+                        irq->requested = 1;
+        }
+#endif
+        if (rc)
+                rtl8125_free_irq(tp);
+
+        return rc;
+}
+
+static int rtl8125_alloc_tx_desc(struct rtl8125_private *tp)
+{
+        struct rtl8125_tx_ring *ring;
+        struct pci_dev *pdev = tp->pci_dev;
+        int i;
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                ring = &tp->tx_ring[i];
+                ring->TxDescArray = dma_alloc_coherent(&pdev->dev,
+                                                       (ring->num_tx_desc * sizeof(struct TxDesc)),
+                                                       &ring->TxPhyAddr,
+                                                       GFP_KERNEL);
+
+                if (!ring->TxDescArray)
+                        return -1;
+        }
+
+        return 0;
+}
+
+static int rtl8125_alloc_rx_desc(struct rtl8125_private *tp)
+{
+        struct rtl8125_rx_ring *ring;
+        struct pci_dev *pdev = tp->pci_dev;
+        int i;
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                ring = &tp->rx_ring[i];
+                ring->RxDescArray = dma_alloc_coherent(&pdev->dev,
+                                                       (ring->num_rx_desc * tp->RxDescLength),
+                                                       &ring->RxPhyAddr,
+                                                       GFP_KERNEL);
+
+                if (!ring->RxDescArray)
+                        return -1;
+        }
+
+        return 0;
+}
+
+static int rtl8125_alloc_patch_mem(struct rtl8125_private *tp)
+{
+        struct pci_dev *pdev = tp->pci_dev;
+
+        if (tp->RequireRduNonStopPatch) {
+                tp->ShortPacketEmptyBuffer = dma_alloc_coherent(&pdev->dev,
+                                             SHORT_PACKET_PADDING_BUF_SIZE,
+                                             &tp->ShortPacketEmptyBufferPhy,
+                                             GFP_KERNEL);
+                if (!tp->ShortPacketEmptyBuffer)
+                        return -1;
+
+                memset(tp->ShortPacketEmptyBuffer, 0x0, SHORT_PACKET_PADDING_BUF_SIZE);
+        }
+
+        return 0;
+}
+
+static void rtl8125_free_tx_desc(struct rtl8125_private *tp)
+{
+        struct rtl8125_tx_ring *ring;
+        struct pci_dev *pdev = tp->pci_dev;
+        int i;
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                ring = &tp->tx_ring[i];
+                if (ring->TxDescArray) {
+                        dma_free_coherent(&pdev->dev,
+                                          (ring->num_tx_desc * sizeof(struct TxDesc)),
+                                          ring->TxDescArray,
+                                          ring->TxPhyAddr);
+                        ring->TxDescArray = NULL;
+                }
+        }
+}
+
+static void rtl8125_free_rx_desc(struct rtl8125_private *tp)
+{
+        struct rtl8125_rx_ring *ring;
+        struct pci_dev *pdev = tp->pci_dev;
+        int i;
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                ring = &tp->rx_ring[i];
+                if (ring->RxDescArray) {
+                        dma_free_coherent(&pdev->dev,
+                                          (ring->num_rx_desc * tp->RxDescLength),
+                                          ring->RxDescArray,
+                                          ring->RxPhyAddr);
+                        ring->RxDescArray = NULL;
+                }
+        }
+}
+
+static void rtl8125_free_patch_mem(struct rtl8125_private *tp)
+{
+        struct pci_dev *pdev = tp->pci_dev;
+
+        if (tp->ShortPacketEmptyBuffer) {
+                dma_free_coherent(&pdev->dev,
+                                  SHORT_PACKET_PADDING_BUF_SIZE,
+                                  tp->ShortPacketEmptyBuffer,
+                                  tp->ShortPacketEmptyBufferPhy);
+                tp->ShortPacketEmptyBuffer = NULL;
+        }
+}
+
+static void rtl8125_free_alloc_resources(struct rtl8125_private *tp)
+{
+        rtl8125_free_rx_desc(tp);
+
+        rtl8125_free_tx_desc(tp);
+
+        rtl8125_free_patch_mem(tp);
+}
+
+#ifdef ENABLE_USE_FIRMWARE_FILE
+static void rtl8125_request_firmware(struct rtl8125_private *tp)
+{
+        struct rtl8125_fw *rtl_fw;
+
+        /* firmware loaded already or no firmware available */
+        if (tp->rtl_fw || !tp->fw_name)
+                return;
+
+        rtl_fw = kzalloc(sizeof(*rtl_fw), GFP_KERNEL);
+        if (!rtl_fw)
+                return;
+
+        rtl_fw->phy_write = rtl8125_mdio_write;
+        rtl_fw->phy_read = rtl8125_mdio_read;
+        rtl_fw->mac_mcu_write = mac_mcu_write;
+        rtl_fw->mac_mcu_read = mac_mcu_read;
+        rtl_fw->fw_name = tp->fw_name;
+        rtl_fw->dev = tp_to_dev(tp);
+
+        if (rtl8125_fw_request_firmware(rtl_fw))
+                kfree(rtl_fw);
+        else
+                tp->rtl_fw = rtl_fw;
+}
+#endif
+
+int rtl8125_open(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int retval;
+
+        retval = -ENOMEM;
+
+#ifdef ENABLE_R8125_PROCFS
+        rtl8125_proc_init(dev);
+#endif
+        rtl8125_set_rxbufsize(tp, dev);
+        /*
+         * Rx and Tx descriptors needs 256 bytes alignment.
+         * pci_alloc_consistent provides more.
+         */
+        if (rtl8125_alloc_tx_desc(tp) < 0 || rtl8125_alloc_rx_desc(tp) < 0)
+                goto err_free_all_allocated_mem;
+
+        retval = rtl8125_init_ring(dev);
+        if (retval < 0)
+                goto err_free_all_allocated_mem;
+
+        retval = rtl8125_alloc_patch_mem(tp);
+        if (retval < 0)
+                goto err_free_all_allocated_mem;
+
+        retval = rtl8125_alloc_irq(tp);
+        if (retval < 0)
+                goto err_free_all_allocated_mem;
+
+        if (netif_msg_probe(tp)) {
+                printk(KERN_INFO "%s: 0x%lx, "
+                       "%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x, "
+                       "IRQ %d\n",
+                       dev->name,
+                       dev->base_addr,
+                       dev->dev_addr[0], dev->dev_addr[1],
+                       dev->dev_addr[2], dev->dev_addr[3],
+                       dev->dev_addr[4], dev->dev_addr[5], dev->irq);
+        }
+
+#ifdef ENABLE_USE_FIRMWARE_FILE
+        rtl8125_request_firmware(tp);
+#endif
+        pci_set_master(tp->pci_dev);
+
+#ifdef  CONFIG_R8125_NAPI
+        rtl8125_enable_napi(tp);
+#endif
+
+        rtl8125_exit_oob(dev);
+
+        rtl8125_up(dev);
+
+#ifdef ENABLE_PTP_SUPPORT
+        if (tp->EnablePtp)
+                rtl8125_ptp_init(tp);
+#endif
+        clear_bit(R8125_FLAG_DOWN, tp->task_flags);
+
+        if (tp->resume_not_chg_speed)
+                rtl8125_check_link_status(dev);
+        else
+                rtl8125_set_speed(dev, tp->autoneg, tp->speed, tp->duplex, tp->advertising);
+
+        if (tp->esd_flag == 0) {
+                //rtl8125_request_esd_timer(dev);
+
+                rtl8125_schedule_esd_work(tp);
+        }
+
+        //rtl8125_request_link_timer(dev);
+
+        rtl8125_enable_hw_linkchg_interrupt(tp);
+
+out:
+
+        return retval;
+
+err_free_all_allocated_mem:
+        rtl8125_free_alloc_resources(tp);
+
+        goto out;
+}
+
+static void
+set_offset70F(struct rtl8125_private *tp, u8 setting)
+{
+        u32 csi_tmp;
+        u32 temp = (u32)setting;
+        temp = temp << 24;
+        /*set PCI configuration space offset 0x70F to setting*/
+        /*When the register offset of PCI configuration space larger than 0xff, use CSI to access it.*/
+
+        csi_tmp = rtl8125_csi_read(tp, 0x70c) & 0x00ffffff;
+        rtl8125_csi_write(tp, 0x70c, csi_tmp | temp);
+}
+
+static void
+set_offset79(struct rtl8125_private *tp, u8 setting)
+{
+        //Set PCI configuration space offset 0x79 to setting
+
+        struct pci_dev *pdev = tp->pci_dev;
+        u8 device_control;
+
+        if (hwoptimize & HW_PATCH_SOC_LAN) return;
+
+        pci_read_config_byte(pdev, 0x79, &device_control);
+        device_control &= ~0x70;
+        device_control |= setting;
+        pci_write_config_byte(pdev, 0x79, device_control);
+}
+
+void
+rtl8125_hw_set_rx_packet_filter(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        u32 mc_filter[2];   /* Multicast hash filter */
+        int rx_mode;
+        u32 tmp = 0;
+
+        if (dev->flags & IFF_PROMISC) {
+                /* Unconditionally log net taps. */
+                if (netif_msg_link(tp))
+                        printk(KERN_NOTICE "%s: Promiscuous mode enabled.\n",
+                               dev->name);
+
+                rx_mode =
+                        AcceptBroadcast | AcceptMulticast | AcceptMyPhys |
+                        AcceptAllPhys;
+                mc_filter[1] = mc_filter[0] = 0xffffffff;
+        } else if ((netdev_mc_count(dev) > multicast_filter_limit)
+                   || (dev->flags & IFF_ALLMULTI)) {
+                /* Too many to filter perfectly -- accept all multicasts. */
+                rx_mode = AcceptBroadcast | AcceptMulticast | AcceptMyPhys;
+                mc_filter[1] = mc_filter[0] = 0xffffffff;
+        } else {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
+                struct dev_mc_list *mclist;
+                unsigned int i;
+
+                rx_mode = AcceptBroadcast | AcceptMyPhys;
+                mc_filter[1] = mc_filter[0] = 0;
+                for (i = 0, mclist = dev->mc_list; mclist && i < dev->mc_count;
+                     i++, mclist = mclist->next) {
+                        int bit_nr = ether_crc(ETH_ALEN, mclist->dmi_addr) >> 26;
+                        mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+                        rx_mode |= AcceptMulticast;
+                }
+#else
+                struct netdev_hw_addr *ha;
+
+                rx_mode = AcceptBroadcast | AcceptMyPhys;
+                mc_filter[1] = mc_filter[0] = 0;
+                netdev_for_each_mc_addr(ha, dev) {
+                        int bit_nr = ether_crc(ETH_ALEN, ha->addr) >> 26;
+                        mc_filter[bit_nr >> 5] |= 1 << (bit_nr & 31);
+                        rx_mode |= AcceptMulticast;
+                }
+#endif
+        }
+
+        if (dev->features & NETIF_F_RXALL)
+                rx_mode |= (AcceptErr | AcceptRunt);
+
+        tmp = mc_filter[0];
+        mc_filter[0] = swab32(mc_filter[1]);
+        mc_filter[1] = swab32(tmp);
+
+        tmp = tp->rtl8125_rx_config | rx_mode | (RTL_R32(tp, RxConfig) & rtl_chip_info[tp->chipset].RxConfigMask);
+
+        RTL_W32(tp, RxConfig, tmp);
+        RTL_W32(tp, MAR0 + 0, mc_filter[0]);
+        RTL_W32(tp, MAR0 + 4, mc_filter[1]);
+}
+
+static void
+rtl8125_set_rx_mode(struct net_device *dev)
+{
+        rtl8125_hw_set_rx_packet_filter(dev);
+}
+
+void
+rtl8125_set_rx_q_num(struct rtl8125_private *tp,
+                     unsigned int num_rx_queues)
+{
+        u16 q_ctrl;
+        u16 rx_q_num;
+
+        rx_q_num = (u16)ilog2(num_rx_queues);
+        rx_q_num &= (BIT_0 | BIT_1 | BIT_2);
+        rx_q_num <<= 2;
+        q_ctrl = RTL_R16(tp, Q_NUM_CTRL_8125);
+        q_ctrl &= ~(BIT_2 | BIT_3 | BIT_4);
+        q_ctrl |= rx_q_num;
+        RTL_W16(tp, Q_NUM_CTRL_8125, q_ctrl);
+}
+
+void
+rtl8125_set_tx_q_num(struct rtl8125_private *tp,
+                     unsigned int num_tx_queues)
+{
+        u16 mac_ocp_data;
+
+        mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xE63E);
+        mac_ocp_data &= ~(BIT_11 | BIT_10);
+        mac_ocp_data |= ((ilog2(num_tx_queues) & 0x03) << 10);
+        rtl8125_mac_ocp_write(tp, 0xE63E, mac_ocp_data);
+}
+
+void
+rtl8125_hw_config(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        struct pci_dev *pdev = tp->pci_dev;
+        u16 mac_ocp_data;
+        int i;
+
+        RTL_W32(tp, RxConfig, (RX_DMA_BURST << RxCfgDMAShift));
+
+        rtl8125_hw_reset(dev);
+
+        rtl8125_enable_cfg9346_write(tp);
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                RTL_W8(tp, 0xF1, RTL_R8(tp, 0xF1) & ~BIT_7);
+                RTL_W8(tp, Config2, RTL_R8(tp, Config2) & ~BIT_7);
+                RTL_W8(tp, Config5, RTL_R8(tp, Config5) & ~BIT_0);
+                break;
+        }
+
+        //clear io_rdy_l23
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                RTL_W8(tp, Config3, RTL_R8(tp, Config3) & ~BIT_1);
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                //IntMITI_0-IntMITI_31
+                for (i=0xA00; i<0xB00; i+=4)
+                        RTL_W32(tp, i, 0x00000000);
+                break;
+        }
+
+        //keep magic packet only
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xC0B6);
+                mac_ocp_data &= BIT_0;
+                rtl8125_mac_ocp_write(tp, 0xC0B6, mac_ocp_data);
+                break;
+        }
+
+        rtl8125_tally_counter_addr_fill(tp);
+
+        rtl8125_enable_extend_tally_couter(tp);
+
+        rtl8125_desc_addr_fill(tp);
+
+        /* Set DMA burst size and Interframe Gap Time */
+        RTL_W32(tp, TxConfig, (TX_DMA_BURST_unlimited << TxDMAShift) |
+                (InterFrameGap << TxInterFrameGapShift));
+
+        if (tp->EnableTxNoClose)
+                RTL_W32(tp, TxConfig, (RTL_R32(tp, TxConfig) | BIT_6));
+
+        if (tp->mcfg == CFG_METHOD_2 ||
+            tp->mcfg == CFG_METHOD_3 ||
+            tp->mcfg == CFG_METHOD_4 ||
+            tp->mcfg == CFG_METHOD_5 ||
+            tp->mcfg == CFG_METHOD_6 ||
+            tp->mcfg == CFG_METHOD_7) {
+                set_offset70F(tp, 0x27);
+                set_offset79(tp, 0x50);
+
+                RTL_W16(tp, 0x382, 0x221B);
+
+#ifdef ENABLE_RSS_SUPPORT
+                rtl8125_config_rss(tp);
+#else
+                RTL_W32(tp, RSS_CTRL_8125, 0x00);
+#endif
+                rtl8125_set_rx_q_num(tp, rtl8125_tot_rx_rings(tp));
+
+                RTL_W8(tp, Config1, RTL_R8(tp, Config1) & ~0x10);
+
+                rtl8125_mac_ocp_write(tp, 0xC140, 0xFFFF);
+                rtl8125_mac_ocp_write(tp, 0xC142, 0xFFFF);
+
+                //new tx desc format
+                mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xEB58);
+                mac_ocp_data |= (BIT_0);
+                rtl8125_mac_ocp_write(tp, 0xEB58, mac_ocp_data);
+
+                mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xE614);
+                mac_ocp_data &= ~( BIT_10 | BIT_9 | BIT_8);
+                if (tp->mcfg == CFG_METHOD_4 || tp->mcfg == CFG_METHOD_5 ||
+                    tp->mcfg == CFG_METHOD_7)
+                        mac_ocp_data |= ((2 & 0x07) << 8);
+                else
+                        mac_ocp_data |= ((3 & 0x07) << 8);
+                rtl8125_mac_ocp_write(tp, 0xE614, mac_ocp_data);
+
+                rtl8125_set_tx_q_num(tp, rtl8125_tot_tx_rings(tp));
+
+                mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xE63E);
+                mac_ocp_data &= ~(BIT_5 | BIT_4);
+                if (tp->mcfg == CFG_METHOD_2 || tp->mcfg == CFG_METHOD_3 ||
+                    tp->mcfg == CFG_METHOD_6)
+                        mac_ocp_data |= ((0x02 & 0x03) << 4);
+                rtl8125_mac_ocp_write(tp, 0xE63E, mac_ocp_data);
+
+                mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xC0B4);
+                mac_ocp_data &= ~BIT_0;
+                rtl8125_mac_ocp_write(tp, 0xC0B4, mac_ocp_data);
+                mac_ocp_data |= BIT_0;
+                rtl8125_mac_ocp_write(tp, 0xC0B4, mac_ocp_data);
+
+                mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xC0B4);
+                mac_ocp_data |= (BIT_3|BIT_2);
+                rtl8125_mac_ocp_write(tp, 0xC0B4, mac_ocp_data);
+
+                mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xEB6A);
+                mac_ocp_data &= ~(BIT_7 | BIT_6 | BIT_5 | BIT_4 | BIT_3 | BIT_2 | BIT_1 | BIT_0);
+                mac_ocp_data |= (BIT_5 | BIT_4 | BIT_1 | BIT_0);
+                rtl8125_mac_ocp_write(tp, 0xEB6A, mac_ocp_data);
+
+                mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xEB50);
+                mac_ocp_data &= ~(BIT_9 | BIT_8 | BIT_7 | BIT_6 | BIT_5);
+                mac_ocp_data |= (BIT_6);
+                rtl8125_mac_ocp_write(tp, 0xEB50, mac_ocp_data);
+
+                mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xE056);
+                mac_ocp_data &= ~(BIT_7 | BIT_6 | BIT_5 | BIT_4);
+                //mac_ocp_data |= (BIT_4 | BIT_5);
+                rtl8125_mac_ocp_write(tp, 0xE056, mac_ocp_data);
+
+                RTL_W8(tp, TDFNR, 0x10);
+
+                RTL_W8(tp, 0xD0, RTL_R8(tp, 0xD0) | BIT_7);
+
+                mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xE040);
+                mac_ocp_data &= ~(BIT_12);
+                rtl8125_mac_ocp_write(tp, 0xE040, mac_ocp_data);
+
+                mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xEA1C);
+                mac_ocp_data &= ~(BIT_1 | BIT_0);
+                mac_ocp_data |= (BIT_0);
+                rtl8125_mac_ocp_write(tp, 0xEA1C, mac_ocp_data);
+
+                rtl8125_mac_ocp_write(tp, 0xE0C0, 0x4000);
+
+                SetMcuAccessRegBit(tp, 0xE052, (BIT_6 | BIT_5));
+                ClearMcuAccessRegBit(tp, 0xE052, BIT_3 | BIT_7);
+
+                mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xD430);
+                mac_ocp_data &= ~(BIT_11 | BIT_10 | BIT_9 | BIT_8 | BIT_7 | BIT_6 | BIT_5 | BIT_4 | BIT_3 | BIT_2 | BIT_1 | BIT_0);
+                mac_ocp_data |= 0x45F;
+                rtl8125_mac_ocp_write(tp, 0xD430, mac_ocp_data);
+
+                //rtl8125_mac_ocp_write(tp, 0xE0C0, 0x4F87);
+                if (!tp->DASH)
+                        RTL_W8(tp, 0xD0, RTL_R8(tp, 0xD0) | BIT_6 | BIT_7);
+                else
+                        RTL_W8(tp, 0xD0, (RTL_R8(tp, 0xD0) & ~BIT_6) | BIT_7);
+
+                if (tp->mcfg == CFG_METHOD_2 || tp->mcfg == CFG_METHOD_3 ||
+                    tp->mcfg == CFG_METHOD_6)
+                        RTL_W8(tp, MCUCmd_reg, RTL_R8(tp, MCUCmd_reg) | BIT_0);
+
+                rtl8125_disable_eee_plus(tp);
+
+                mac_ocp_data = rtl8125_mac_ocp_read(tp, 0xEA1C);
+                mac_ocp_data &= ~(BIT_2);
+                rtl8125_mac_ocp_write(tp, 0xEA1C, mac_ocp_data);
+
+                SetMcuAccessRegBit(tp, 0xEB54, BIT_0);
+                udelay(1);
+                ClearMcuAccessRegBit(tp, 0xEB54, BIT_0);
+                RTL_W16(tp, 0x1880, RTL_R16(tp, 0x1880) & ~(BIT_4 | BIT_5));
+        }
+
+        /* csum offload command for RTL8125 */
+        tp->tx_tcp_csum_cmd = TxTCPCS_C;
+        tp->tx_udp_csum_cmd = TxUDPCS_C;
+        tp->tx_ip_csum_cmd = TxIPCS_C;
+        tp->tx_ipv6_csum_cmd = TxIPV6F_C;
+
+        /* config interrupt type for RTL8125B */
+        if (tp->HwSuppIsrVer == 2)
+                rtl8125_hw_set_interrupt_type(tp, tp->HwCurrIsrVer);
+
+        //other hw parameters
+        rtl8125_hw_clear_timer_int(dev);
+
+        rtl8125_hw_clear_int_miti(dev);
+
+        if (tp->RequireRduNonStopPatch &&
+            tp->ShortPacketEmptyBuffer) {
+                RTL_W32(tp, RSS_INDIRECTION_TBL_8125_V2, ((u64)tp->ShortPacketEmptyBufferPhy & DMA_BIT_MASK(32)));
+                RTL_W32(tp, RSS_INDIRECTION_TBL_8125_V2 + 4, ((u64)tp->ShortPacketEmptyBufferPhy >> 32));
+        }
+
+        if (tp->use_timer_interrrupt &&
+            (tp->HwCurrIsrVer == 2) &&
+            (tp->HwSuppIntMitiVer == 4) &&
+            (tp->features & RTL_FEATURE_MSIX)) {
+                int i;
+                for (i = 0; i < tp->irq_nvecs; i++)
+                        rtl8125_hw_set_timer_int_8125(tp, i, timer_count_v2);
+        }
+
+        rtl8125_enable_exit_l1_mask(tp);
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                rtl8125_mac_ocp_write(tp, 0xE098, 0xC302);
+                break;
+        }
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                if (aspm) {
+                        rtl8125_init_pci_offset_99(tp);
+                }
+                break;
+        }
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                if (aspm) {
+                        rtl8125_init_pci_offset_180(tp);
+                }
+                break;
+        }
+
+        tp->cp_cmd &= ~(EnableBist | Macdbgo_oe | Force_halfdup |
+                        Force_rxflow_en | Force_txflow_en | Cxpl_dbg_sel |
+                        ASF | Macdbgo_sel);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
+        RTL_W16(tp, CPlusCmd, tp->cp_cmd);
+#else
+        rtl8125_hw_set_features(dev, dev->features);
+#endif
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7: {
+                int timeout;
+                for (timeout = 0; timeout < 10; timeout++) {
+                        if ((rtl8125_mac_ocp_read(tp, 0xE00E) & BIT_13)==0)
+                                break;
+                        mdelay(1);
+                }
+        }
+        break;
+        }
+
+        RTL_W16(tp, RxMaxSize, tp->rx_buf_sz);
+
+        rtl8125_disable_rxdvgate(dev);
+
+        if (!tp->pci_cfg_is_read) {
+                pci_read_config_byte(pdev, PCI_COMMAND, &tp->pci_cfg_space.cmd);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_0, &tp->pci_cfg_space.io_base_l);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_0 + 2, &tp->pci_cfg_space.io_base_h);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_2, &tp->pci_cfg_space.mem_base_l);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_2 + 2, &tp->pci_cfg_space.mem_base_h);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_3, &tp->pci_cfg_space.resv_0x1c_l);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_3 + 2, &tp->pci_cfg_space.resv_0x1c_h);
+                pci_read_config_byte(pdev, PCI_INTERRUPT_LINE, &tp->pci_cfg_space.ilr);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_4, &tp->pci_cfg_space.resv_0x20_l);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_4 + 2, &tp->pci_cfg_space.resv_0x20_h);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_5, &tp->pci_cfg_space.resv_0x24_l);
+                pci_read_config_word(pdev, PCI_BASE_ADDRESS_5 + 2, &tp->pci_cfg_space.resv_0x24_h);
+                pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID, &tp->pci_cfg_space.resv_0x2c_l);
+                pci_read_config_word(pdev, PCI_SUBSYSTEM_VENDOR_ID + 2, &tp->pci_cfg_space.resv_0x2c_h);
+                if (tp->HwPcieSNOffset > 0) {
+                        tp->pci_cfg_space.pci_sn_l = rtl8125_csi_read(tp, tp->HwPcieSNOffset);
+                        tp->pci_cfg_space.pci_sn_h = rtl8125_csi_read(tp, tp->HwPcieSNOffset + 4);
+                }
+
+                tp->pci_cfg_is_read = 1;
+        }
+
+        /* Set Rx packet filter */
+        rtl8125_hw_set_rx_packet_filter(dev);
+
+#ifdef ENABLE_DASH_SUPPORT
+        if (tp->DASH && !tp->dash_printer_enabled)
+                NICChkTypeEnableDashInterrupt(tp);
+#endif
+
+        switch (tp->mcfg) {
+        case CFG_METHOD_2:
+        case CFG_METHOD_3:
+        case CFG_METHOD_4:
+        case CFG_METHOD_5:
+        case CFG_METHOD_6:
+        case CFG_METHOD_7:
+                if (aspm) {
+                        RTL_W8(tp, Config5, RTL_R8(tp, Config5) | BIT_0);
+                        RTL_W8(tp, Config2, RTL_R8(tp, Config2) | BIT_7);
+                } else {
+                        RTL_W8(tp, Config2, RTL_R8(tp, Config2) & ~BIT_7);
+                        RTL_W8(tp, Config5, RTL_R8(tp, Config5) & ~BIT_0);
+                }
+                break;
+        }
+
+        rtl8125_disable_cfg9346_write(tp);
+
+        udelay(10);
+}
+
+void
+rtl8125_hw_start(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        RTL_W8(tp, ChipCmd, CmdTxEnb | CmdRxEnb);
+
+        rtl8125_enable_hw_interrupt(tp);
+
+        rtl8125_lib_reset_complete(tp);
+}
+
+static int
+rtl8125_change_mtu(struct net_device *dev,
+                   int new_mtu)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int ret = 0;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+        if (new_mtu < ETH_MIN_MTU)
+                return -EINVAL;
+        else if (new_mtu > tp->max_jumbo_frame_size)
+                new_mtu = tp->max_jumbo_frame_size;
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+
+        dev->mtu = new_mtu;
+
+        if (!netif_running(dev))
+                goto out;
+
+        rtl8125_down(dev);
+
+        rtl8125_set_rxbufsize(tp, dev);
+
+        ret = rtl8125_init_ring(dev);
+
+        if (ret < 0)
+                goto err_out;
+
+#ifdef CONFIG_R8125_NAPI
+        rtl8125_enable_napi(tp);
+#endif//CONFIG_R8125_NAPI
+
+        //netif_tx_stop_all_queues(dev);
+        //netif_carrier_off(dev);
+        rtl8125_hw_config(dev);
+        rtl8125_enable_hw_linkchg_interrupt(tp);
+
+        rtl8125_set_speed(dev, tp->autoneg, tp->speed, tp->duplex, tp->advertising);
+
+        //mod_timer(&tp->esd_timer, jiffies + RTL8125_ESD_TIMEOUT);
+        //mod_timer(&tp->link_timer, jiffies + RTL8125_LINK_TIMEOUT);
+out:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0)
+        netdev_update_features(dev);
+#endif
+
+err_out:
+        return ret;
+}
+
+static void
+rtl8125_free_rx_skb(struct rtl8125_private *tp,
+                    struct rtl8125_rx_ring *ring,
+                    struct sk_buff **sk_buff,
+                    struct RxDesc *desc,
+                    const u32 cur_rx)
+{
+        struct pci_dev *pdev = tp->pci_dev;
+
+        dma_unmap_single(&pdev->dev, ring->RxDescPhyAddr[cur_rx], tp->rx_buf_sz,
+                         DMA_FROM_DEVICE);
+        dev_kfree_skb(*sk_buff);
+        *sk_buff = NULL;
+        rtl8125_make_unusable_by_asic(tp, desc);
+}
+
+static inline void
+rtl8125_mark_to_asic_v3(struct RxDescV3 *descv3,
+                        u32 rx_buf_sz)
+{
+        u32 eor = le32_to_cpu(descv3->RxDescNormalDDWord4.opts1) & RingEnd;
+
+        WRITE_ONCE(descv3->RxDescNormalDDWord4.opts1, cpu_to_le32(DescOwn | eor | rx_buf_sz));
+}
+
+void
+rtl8125_mark_to_asic(struct rtl8125_private *tp,
+                     struct RxDesc *desc,
+                     u32 rx_buf_sz)
+{
+        if (tp->InitRxDescType == RX_DESC_RING_TYPE_3)
+                rtl8125_mark_to_asic_v3((struct RxDescV3 *)desc, rx_buf_sz);
+        else {
+                u32 eor = le32_to_cpu(desc->opts1) & RingEnd;
+
+                WRITE_ONCE(desc->opts1, cpu_to_le32(DescOwn | eor | rx_buf_sz));
+        }
+}
+
+static inline void
+rtl8125_map_to_asic(struct rtl8125_private *tp,
+                    struct rtl8125_rx_ring *ring,
+                    struct RxDesc *desc,
+                    dma_addr_t mapping,
+                    u32 rx_buf_sz,
+                    const u32 cur_rx)
+{
+        ring->RxDescPhyAddr[cur_rx] = mapping;
+        if (tp->InitRxDescType == RX_DESC_RING_TYPE_3)
+                ((struct RxDescV3 *)desc)->addr = cpu_to_le64(mapping);
+        else
+                desc->addr = cpu_to_le64(mapping);
+        wmb();
+        rtl8125_mark_to_asic(tp, desc, rx_buf_sz);
+}
+
+static int
+rtl8125_alloc_rx_skb(struct rtl8125_private *tp,
+                     struct rtl8125_rx_ring *ring,
+                     struct sk_buff **sk_buff,
+                     struct RxDesc *desc,
+                     int rx_buf_sz,
+                     const u32 cur_rx,
+                     u8 in_intr)
+{
+        struct sk_buff *skb;
+        dma_addr_t mapping;
+        int ret = 0;
+
+        if (in_intr)
+                skb = RTL_ALLOC_SKB_INTR(&tp->r8125napi[ring->index].napi, rx_buf_sz + RTK_RX_ALIGN);
+        else
+                skb = dev_alloc_skb(rx_buf_sz + RTK_RX_ALIGN);
+
+        if (unlikely(!skb))
+                goto err_out;
+
+        skb_reserve(skb, RTK_RX_ALIGN);
+
+        mapping = dma_map_single(tp_to_dev(tp), skb->data, rx_buf_sz,
+                                 DMA_FROM_DEVICE);
+        if (unlikely(dma_mapping_error(tp_to_dev(tp), mapping))) {
+                if (unlikely(net_ratelimit()))
+                        netif_err(tp, drv, tp->dev, "Failed to map RX DMA!\n");
+                goto err_out;
+        }
+
+        *sk_buff = skb;
+        rtl8125_map_to_asic(tp, ring, desc, mapping, rx_buf_sz, cur_rx);
+out:
+        return ret;
+
+err_out:
+        if (skb)
+                dev_kfree_skb(skb);
+        ret = -ENOMEM;
+        rtl8125_make_unusable_by_asic(tp, desc);
+        goto out;
+}
+
+static void
+_rtl8125_rx_clear(struct rtl8125_private *tp, struct rtl8125_rx_ring *ring)
+{
+        int i;
+
+        for (i = 0; i < ring->num_rx_desc; i++) {
+                if (ring->Rx_skbuff[i]) {
+                        rtl8125_free_rx_skb(tp,
+                                            ring,
+                                            ring->Rx_skbuff + i,
+                                            rtl8125_get_rxdesc(tp, ring->RxDescArray, i),
+                                            i);
+                        ring->Rx_skbuff[i] = NULL;
+                }
+        }
+}
+
+void
+rtl8125_rx_clear(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i = 0; i < tp->num_rx_rings; i++)
+                _rtl8125_rx_clear(tp, &tp->rx_ring[i]);
+}
+
+static u32
+rtl8125_rx_fill(struct rtl8125_private *tp,
+                struct rtl8125_rx_ring *ring,
+                struct net_device *dev,
+                u32 start,
+                u32 end,
+                u8 in_intr)
+{
+        u32 cur;
+
+        for (cur = start; end - cur > 0; cur++) {
+                int ret, i = cur % ring->num_rx_desc;
+
+                if (ring->Rx_skbuff[i])
+                        continue;
+
+                ret = rtl8125_alloc_rx_skb(tp,
+                                           ring,
+                                           ring->Rx_skbuff + i,
+                                           rtl8125_get_rxdesc(tp, ring->RxDescArray, i),
+                                           tp->rx_buf_sz,
+                                           i,
+                                           in_intr
+                                          );
+                if (ret < 0)
+                        break;
+        }
+        return cur - start;
+}
+
+static inline void
+rtl8125_mark_as_last_descriptor_8125(struct RxDescV3 *descv3)
+{
+        descv3->RxDescNormalDDWord4.opts1 |= cpu_to_le32(RingEnd);
+}
+
+static inline void
+rtl8125_mark_as_last_descriptor(struct rtl8125_private *tp,
+                                struct RxDesc *desc)
+{
+        if (tp->InitRxDescType == RX_DESC_RING_TYPE_3)
+                rtl8125_mark_as_last_descriptor_8125((struct RxDescV3 *)desc);
+        else
+                desc->opts1 |= cpu_to_le32(RingEnd);
+}
+
+static void
+rtl8125_desc_addr_fill(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                struct rtl8125_tx_ring *ring = &tp->tx_ring[i];
+                RTL_W32(tp, ring->tdsar_reg, ((u64)ring->TxPhyAddr & DMA_BIT_MASK(32)));
+                RTL_W32(tp, ring->tdsar_reg + 4, ((u64)ring->TxPhyAddr >> 32));
+        }
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                struct rtl8125_rx_ring *ring = &tp->rx_ring[i];
+                RTL_W32(tp, ring->rdsar_reg, ((u64)ring->RxPhyAddr & DMA_BIT_MASK(32)));
+                RTL_W32(tp, ring->rdsar_reg + 4, ((u64)ring->RxPhyAddr >> 32));
+        }
+}
+
+static void
+rtl8125_tx_desc_init(struct rtl8125_private *tp)
+{
+        int i = 0;
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                struct rtl8125_tx_ring *ring = &tp->tx_ring[i];
+                memset(ring->TxDescArray, 0x0, (ring->num_tx_desc * sizeof(struct TxDesc)));
+
+                ring->TxDescArray[ring->num_tx_desc - 1].opts1 = cpu_to_le32(RingEnd);
+        }
+}
+
+static void
+rtl8125_rx_desc_init(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                struct rtl8125_rx_ring *ring = &tp->rx_ring[i];
+                memset(ring->RxDescArray, 0x0,
+                       (ring->num_rx_desc * tp->RxDescLength));
+        }
+}
+
+int
+rtl8125_init_ring(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+
+        rtl8125_init_ring_indexes(tp);
+
+        rtl8125_tx_desc_init(tp);
+        rtl8125_rx_desc_init(tp);
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                struct rtl8125_tx_ring *ring = &tp->tx_ring[i];
+                memset(ring->tx_skb, 0x0, sizeof(ring->tx_skb));
+        }
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+                struct rtl8125_rx_ring *ring = &tp->rx_ring[i];
+
+                memset(ring->Rx_skbuff, 0x0, sizeof(ring->Rx_skbuff));
+                if (rtl8125_rx_fill(tp, ring, dev, 0, ring->num_rx_desc, 0) != ring->num_rx_desc)
+                        goto err_out;
+
+                rtl8125_mark_as_last_descriptor(tp, rtl8125_get_rxdesc(tp, ring->RxDescArray, ring->num_rx_desc - 1));
+        }
+
+        return 0;
+
+err_out:
+        rtl8125_rx_clear(tp);
+        return -ENOMEM;
+}
+
+static void
+rtl8125_unmap_tx_skb(struct pci_dev *pdev,
+                     struct ring_info *tx_skb,
+                     struct TxDesc *desc)
+{
+        unsigned int len = tx_skb->len;
+
+        dma_unmap_single(&pdev->dev, le64_to_cpu(desc->addr), len, DMA_TO_DEVICE);
+
+        desc->opts1 = cpu_to_le32(RTK_MAGIC_DEBUG_VALUE);
+        desc->opts2 = 0x00;
+        desc->addr = RTL8125_MAGIC_NUMBER;
+        tx_skb->len = 0;
+}
+
+static void
+rtl8125_tx_clear_range(struct rtl8125_private *tp,
+                       struct rtl8125_tx_ring *ring,
+                       u32 start,
+                       unsigned int n)
+{
+        unsigned int i;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,22)
+        struct net_device *dev = tp->dev;
+#endif
+
+        for (i = 0; i < n; i++) {
+                unsigned int entry = (start + i) % ring->num_tx_desc;
+                struct ring_info *tx_skb = ring->tx_skb + entry;
+                unsigned int len = tx_skb->len;
+
+                if (len) {
+                        struct sk_buff *skb = tx_skb->skb;
+
+                        rtl8125_unmap_tx_skb(tp->pci_dev, tx_skb,
+                                             ring->TxDescArray + entry);
+                        if (skb) {
+                                RTLDEV->stats.tx_dropped++;
+                                dev_kfree_skb_any(skb);
+                                tx_skb->skb = NULL;
+                        }
+                }
+        }
+}
+
+void
+rtl8125_tx_clear(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i = 0; i < tp->num_tx_rings; i++) {
+                struct rtl8125_tx_ring *ring = &tp->tx_ring[i];
+                rtl8125_tx_clear_range(tp, ring, ring->dirty_tx, ring->num_tx_desc);
+                ring->cur_tx = ring->dirty_tx = 0;
+        }
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+static void rtl8125_schedule_reset_work(struct rtl8125_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        set_bit(R8125_FLAG_TASK_RESET_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->reset_task, 4);
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+}
+
+static void rtl8125_schedule_esd_work(struct rtl8125_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        set_bit(R8125_FLAG_TASK_ESD_CHECK_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->esd_task, RTL8125_ESD_TIMEOUT);
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+}
+
+static void rtl8125_schedule_linkchg_work(struct rtl8125_private *tp)
+{
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        set_bit(R8125_FLAG_TASK_LINKCHG_CHECK_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->linkchg_task, 4);
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+}
+
+#define rtl8125_cancel_schedule_reset_work(a)
+#define rtl8125_cancel_schedule_esd_work(a)
+#define rtl8125_cancel_schedule_linkchg_work(a)
+
+#else
+static void rtl8125_schedule_reset_work(struct rtl8125_private *tp)
+{
+        set_bit(R8125_FLAG_TASK_RESET_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->reset_task, 4);
+}
+
+static void rtl8125_cancel_schedule_reset_work(struct rtl8125_private *tp)
+{
+        struct work_struct *work = &tp->reset_task.work;
+
+        if (!work->func) return;
+
+        cancel_delayed_work_sync(&tp->reset_task);
+}
+
+static void rtl8125_schedule_esd_work(struct rtl8125_private *tp)
+{
+        set_bit(R8125_FLAG_TASK_ESD_CHECK_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->esd_task, RTL8125_ESD_TIMEOUT);
+}
+
+static void rtl8125_cancel_schedule_esd_work(struct rtl8125_private *tp)
+{
+        struct work_struct *work = &tp->esd_task.work;
+
+        if (!work->func) return;
+
+        cancel_delayed_work_sync(&tp->esd_task);
+}
+
+static void rtl8125_schedule_linkchg_work(struct rtl8125_private *tp)
+{
+        set_bit(R8125_FLAG_TASK_LINKCHG_CHECK_PENDING, tp->task_flags);
+        schedule_delayed_work(&tp->linkchg_task, RTL8125_ESD_TIMEOUT);
+}
+
+static void rtl8125_cancel_schedule_linkchg_work(struct rtl8125_private *tp)
+{
+        struct work_struct *work = &tp->linkchg_task.work;
+
+        if (!work->func) return;
+
+        cancel_delayed_work_sync(&tp->linkchg_task);
+}
+#endif
+
+static void rtl8125_init_all_schedule_work(struct rtl8125_private *tp)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+        INIT_WORK(&tp->reset_task, rtl8125_reset_task, dev);
+        INIT_WORK(&tp->esd_task, rtl8125_esd_task, dev);
+        INIT_WORK(&tp->linkchg_task, rtl8125_linkchg_task, dev);
+#else
+        INIT_DELAYED_WORK(&tp->reset_task, rtl8125_reset_task);
+        INIT_DELAYED_WORK(&tp->esd_task, rtl8125_esd_task);
+        INIT_DELAYED_WORK(&tp->linkchg_task, rtl8125_linkchg_task);
+#endif
+}
+
+static void rtl8125_cancel_all_schedule_work(struct rtl8125_private *tp)
+{
+        rtl8125_cancel_schedule_reset_work(tp);
+        rtl8125_cancel_schedule_esd_work(tp);
+        rtl8125_cancel_schedule_linkchg_work(tp);
+}
+
+static void
+rtl8125_wait_for_irq_complete(struct rtl8125_private *tp)
+{
+        if (tp->features & RTL_FEATURE_MSIX) {
+                int i;
+                for (i = 0; i < tp->irq_nvecs; i++)
+                        synchronize_irq(tp->irq_tbl[i].vector);
+        } else {
+                synchronize_irq(tp->dev->irq);
+        }
+}
+
+static void
+_rtl8125_wait_for_quiescence(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        /* Wait for any pending NAPI task to complete */
+#ifdef CONFIG_R8125_NAPI
+        rtl8125_disable_napi(tp);
+#endif//CONFIG_R8125_NAPI
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,5,67)
+        /* Give a racing hard_start_xmit a few cycles to complete. */
+        synchronize_net();
+#endif
+
+        rtl8125_irq_mask_and_ack(tp);
+
+        rtl8125_wait_for_irq_complete(tp);
+}
+
+static void
+rtl8125_wait_for_quiescence(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        //suppress unused variable
+        (void)(tp);
+
+        _rtl8125_wait_for_quiescence(dev);
+
+#ifdef CONFIG_R8125_NAPI
+        rtl8125_enable_napi(tp);
+#endif//CONFIG_R8125_NAPI
+}
+
+static int rtl8125_rx_nostuck(struct rtl8125_private *tp)
+{
+        int i, ret = 1;
+        for (i = 0; i < tp->num_rx_rings; i++)
+                ret &= (tp->rx_ring[i].dirty_rx == tp->rx_ring[i].cur_rx);
+        return ret;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+static void rtl8125_reset_task(void *_data)
+{
+        struct net_device *dev = _data;
+        struct rtl8125_private *tp = netdev_priv(dev);
+#else
+static void rtl8125_reset_task(struct work_struct *work)
+{
+        struct rtl8125_private *tp =
+                container_of(work, struct rtl8125_private, reset_task.work);
+        struct net_device *dev = tp->dev;
+#endif
+        u32 budget = ~(u32)0;
+        int i;
+
+        rtnl_lock();
+
+        if (!netif_running(dev) ||
+            test_bit(R8125_FLAG_DOWN, tp->task_flags) ||
+            !test_and_clear_bit(R8125_FLAG_TASK_RESET_PENDING, tp->task_flags))
+                goto out_unlock;
+
+        rtl8125_wait_for_quiescence(dev);
+
+        for (i = 0; i < tp->num_rx_rings; i++) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+                rtl8125_rx_interrupt(dev, tp,  &tp->rx_ring[i], &budget);
+#else
+                rtl8125_rx_interrupt(dev, tp,  &tp->rx_ring[i], budget);
+#endif	//LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+        }
+
+        netif_tx_stop_all_queues(dev);
+        netif_carrier_off(dev);
+        rtl8125_hw_reset(dev);
+
+        rtl8125_tx_clear(tp);
+
+        if (rtl8125_rx_nostuck(tp)) {
+                rtl8125_rx_clear(tp);
+                rtl8125_init_ring(dev);
+#ifdef ENABLE_PTP_SUPPORT
+                rtl8125_ptp_reset(tp);
+#endif
+                if (tp->resume_not_chg_speed) {
+                        _rtl8125_check_link_status(dev);
+
+                        tp->resume_not_chg_speed = 0;
+                } else {
+                        rtl8125_enable_hw_linkchg_interrupt(tp);
+
+                        rtl8125_set_speed(dev, tp->autoneg, tp->speed, tp->duplex, tp->advertising);
+                }
+        } else {
+                if (unlikely(net_ratelimit())) {
+                        struct rtl8125_private *tp = netdev_priv(dev);
+
+                        if (netif_msg_intr(tp)) {
+                                printk(PFX KERN_EMERG
+                                       "%s: Rx buffers shortage\n", dev->name);
+                        }
+                }
+                rtl8125_schedule_reset_work(tp);
+        }
+
+out_unlock:
+        rtnl_unlock();
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+static void rtl8125_esd_task(void *_data)
+{
+        struct net_device *dev = _data;
+        struct rtl8125_private *tp = netdev_priv(dev);
+#else
+static void rtl8125_esd_task(struct work_struct *work)
+{
+        struct rtl8125_private *tp =
+                container_of(work, struct rtl8125_private, esd_task.work);
+        struct net_device *dev = tp->dev;
+#endif
+        rtnl_lock();
+
+        if (!netif_running(dev) ||
+            test_bit(R8125_FLAG_DOWN, tp->task_flags) ||
+            !test_and_clear_bit(R8125_FLAG_TASK_ESD_CHECK_PENDING, tp->task_flags))
+                goto out_unlock;
+
+        rtl8125_esd_checker(tp);
+
+        rtl8125_schedule_esd_work(tp);
+
+out_unlock:
+        rtnl_unlock();
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+static void rtl8125_linkchg_task(void *_data)
+{
+        struct net_device *dev = _data;
+        //struct rtl8125_private *tp = netdev_priv(dev);
+#else
+static void rtl8125_linkchg_task(struct work_struct *work)
+{
+        struct rtl8125_private *tp =
+                container_of(work, struct rtl8125_private, linkchg_task.work);
+        struct net_device *dev = tp->dev;
+#endif
+        rtnl_lock();
+
+        if (!netif_running(dev) ||
+            test_bit(R8125_FLAG_DOWN, tp->task_flags) ||
+            !test_and_clear_bit(R8125_FLAG_TASK_LINKCHG_CHECK_PENDING, tp->task_flags))
+                goto out_unlock;
+
+        rtl8125_check_link_status(dev);
+
+out_unlock:
+        rtnl_unlock();
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0)
+static void
+rtl8125_tx_timeout(struct net_device *dev, unsigned int txqueue)
+#else
+static void
+rtl8125_tx_timeout(struct net_device *dev)
+#endif
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        /* Let's wait a bit while any (async) irq lands on */
+        rtl8125_schedule_reset_work(tp);
+}
+
+static u32
+rtl8125_get_txd_opts1(struct rtl8125_tx_ring *ring,
+                      u32 opts1,
+                      u32 len,
+                      unsigned int entry)
+{
+        u32 status = opts1 | len;
+
+        if (entry == ring->num_tx_desc - 1)
+                status |= RingEnd;
+
+        return status;
+}
+
+static int
+rtl8125_xmit_frags(struct rtl8125_private *tp,
+                   struct rtl8125_tx_ring *ring,
+                   struct sk_buff *skb,
+                   const u32 *opts)
+{
+        struct skb_shared_info *info = skb_shinfo(skb);
+        unsigned int cur_frag, entry;
+        struct TxDesc *txd = NULL;
+        const unsigned char nr_frags = info->nr_frags;
+        unsigned long PktLenCnt = 0;
+        bool LsoPatchEnabled = FALSE;
+
+        entry = ring->cur_tx;
+        for (cur_frag = 0; cur_frag < nr_frags; cur_frag++) {
+                skb_frag_t *frag = info->frags + cur_frag;
+                dma_addr_t mapping;
+                u32 status, len;
+                void *addr;
+
+                entry = (entry + 1) % ring->num_tx_desc;
+
+                txd = ring->TxDescArray + entry;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,2,0)
+                len = frag->size;
+                addr = ((void *) page_address(frag->page)) + frag->page_offset;
+#else
+                len = skb_frag_size(frag);
+                addr = skb_frag_address(frag);
+#endif
+                if (tp->RequireLSOPatch  &&
+                    (cur_frag == nr_frags - 1) &&
+                    (opts[0] & (GiantSendv4|GiantSendv6)) &&
+                    PktLenCnt < ETH_FRAME_LEN &&
+                    len > 1) {
+                        len -= 1;
+                        mapping = dma_map_single(tp_to_dev(tp), addr, len, DMA_TO_DEVICE);
+
+                        if (unlikely(dma_mapping_error(tp_to_dev(tp), mapping))) {
+                                if (unlikely(net_ratelimit()))
+                                        netif_err(tp, drv, tp->dev,
+                                                  "Failed to map TX fragments DMA!\n");
+                                goto err_out;
+                        }
+
+                        /* anti gcc 2.95.3 bugware (sic) */
+                        status = rtl8125_get_txd_opts1(ring, opts[0], len, entry);
+
+                        txd->addr = cpu_to_le64(mapping);
+
+                        ring->tx_skb[entry].len = len;
+
+                        txd->opts2 = cpu_to_le32(opts[1]);
+                        wmb();
+                        txd->opts1 = cpu_to_le32(status);
+
+                        //second txd
+                        addr += len;
+                        len = 1;
+                        entry = (entry + 1) % ring->num_tx_desc;
+                        txd = ring->TxDescArray + entry;
+                        cur_frag += 1;
+
+                        LsoPatchEnabled = TRUE;
+                }
+
+                mapping = dma_map_single(tp_to_dev(tp), addr, len, DMA_TO_DEVICE);
+
+                if (unlikely(dma_mapping_error(tp_to_dev(tp), mapping))) {
+                        if (unlikely(net_ratelimit()))
+                                netif_err(tp, drv, tp->dev,
+                                          "Failed to map TX fragments DMA!\n");
+                        goto err_out;
+                }
+
+                /* anti gcc 2.95.3 bugware (sic) */
+                status = rtl8125_get_txd_opts1(ring, opts[0], len, entry);
+                if (cur_frag == (nr_frags - 1) || LsoPatchEnabled == TRUE) {
+                        //ring->tx_skb[entry].skb = skb;
+                        status |= LastFrag;
+                }
+
+                txd->addr = cpu_to_le64(mapping);
+
+                ring->tx_skb[entry].len = len;
+
+                txd->opts2 = cpu_to_le32(opts[1]);
+                wmb();
+                txd->opts1 = cpu_to_le32(status);
+
+                PktLenCnt += len;
+        }
+
+        return cur_frag;
+
+err_out:
+        rtl8125_tx_clear_range(tp, ring, ring->cur_tx + 1, cur_frag);
+        return -EIO;
+}
+
+static inline
+__be16 get_protocol(struct sk_buff *skb)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
+        return vlan_get_protocol(skb);
+#else
+        __be16 protocol;
+
+        if (skb->protocol == htons(ETH_P_8021Q))
+                protocol = vlan_eth_hdr(skb)->h_vlan_encapsulated_proto;
+        else
+                protocol = skb->protocol;
+
+        return protocol;
+#endif
+}
+
+static inline
+u8 rtl8125_get_l4_protocol(struct sk_buff *skb)
+{
+        int no = skb_network_offset(skb);
+        struct ipv6hdr *i6h, _i6h;
+        struct iphdr *ih, _ih;
+        u8 ip_protocol = IPPROTO_RAW;
+
+        switch (get_protocol(skb)) {
+        case  __constant_htons(ETH_P_IP):
+                ih = skb_header_pointer(skb, no, sizeof(_ih), &_ih);
+                if (ih)
+                        ip_protocol = ih->protocol;
+                break;
+        case  __constant_htons(ETH_P_IPV6):
+                i6h = skb_header_pointer(skb, no, sizeof(_i6h), &_i6h);
+                if (i6h)
+                        ip_protocol = i6h->nexthdr;
+                break;
+        }
+
+        return ip_protocol;
+}
+
+static bool rtl8125_skb_pad_with_len(struct sk_buff *skb, unsigned int len)
+{
+        if (skb_padto(skb, len))
+                return false;
+        skb_put(skb, len - skb->len);
+        return true;
+}
+
+static bool rtl8125_skb_pad(struct sk_buff *skb)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,19,0)
+        return rtl8125_skb_pad_with_len(skb, ETH_ZLEN);
+#else
+        return !eth_skb_pad(skb);
+#endif
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
+/* msdn_giant_send_check()
+ * According to the document of microsoft, the TCP Pseudo Header excludes the
+ * packet length for IPv6 TCP large packets.
+ */
+static int msdn_giant_send_check(struct sk_buff *skb)
+{
+        const struct ipv6hdr *ipv6h;
+        struct tcphdr *th;
+        int ret;
+
+        ret = skb_cow_head(skb, 0);
+        if (ret)
+                return ret;
+
+        ipv6h = ipv6_hdr(skb);
+        th = tcp_hdr(skb);
+
+        th->check = 0;
+        th->check = ~tcp_v6_check(0, &ipv6h->saddr, &ipv6h->daddr, 0);
+
+        return ret;
+}
+#endif
+
+#define MIN_PATCH_LEN (47)
+static u32
+rtl8125_get_patch_pad_len(struct sk_buff *skb)
+{
+        u32 pad_len = 0;
+        int trans_data_len;
+        u32 hdr_len;
+        u32 pkt_len = skb->len;
+        u8 ip_protocol;
+        bool has_trans = skb_transport_header_was_set(skb);
+
+        if (!(has_trans && (pkt_len < 175))) //128 + MIN_PATCH_LEN
+                goto no_padding;
+
+        ip_protocol = rtl8125_get_l4_protocol(skb);
+        if (!(ip_protocol == IPPROTO_TCP || ip_protocol == IPPROTO_UDP))
+                goto no_padding;
+
+        trans_data_len = pkt_len -
+                         (skb->transport_header -
+                          skb_headroom(skb));
+        if (ip_protocol == IPPROTO_UDP) {
+                if (trans_data_len > 3 && trans_data_len < MIN_PATCH_LEN) {
+                        u16 dest_port = 0;
+
+                        skb_copy_bits(skb, skb->transport_header - skb_headroom(skb) + 2, &dest_port, 2);
+                        dest_port = ntohs(dest_port);
+
+                        if (dest_port == 0x13f ||
+                            dest_port == 0x140) {
+                                pad_len = MIN_PATCH_LEN - trans_data_len;
+                                goto out;
+                        }
+                }
+        }
+
+        hdr_len = 0;
+        if (ip_protocol == IPPROTO_TCP)
+                hdr_len = 20;
+        else if (ip_protocol == IPPROTO_UDP)
+                hdr_len = 8;
+        if (trans_data_len < hdr_len)
+                pad_len = hdr_len - trans_data_len;
+
+out:
+        if ((pkt_len + pad_len) < ETH_ZLEN)
+                pad_len = ETH_ZLEN - pkt_len;
+
+        return pad_len;
+
+no_padding:
+
+        return 0;
+}
+
+static bool
+rtl8125_tso_csum(struct sk_buff *skb,
+                 struct net_device *dev,
+                 u32 *opts)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        unsigned long large_send = 0;
+        u32 csum_cmd = 0;
+        u8 sw_calc_csum = false;
+        u8 check_patch_required = true;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+        if (dev->features & (NETIF_F_TSO | NETIF_F_TSO6)) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+                u32 mss = skb_shinfo(skb)->tso_size;
+#else
+                u32 mss = skb_shinfo(skb)->gso_size;
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+
+                /* TCP Segmentation Offload (or TCP Large Send) */
+                if (mss) {
+                        u32 transport_offset = (u32)skb_transport_offset(skb);
+                        assert((transport_offset%2) == 0);
+                        switch (get_protocol(skb)) {
+                        case __constant_htons(ETH_P_IP):
+                                if (transport_offset <= GTTCPHO_MAX) {
+                                        opts[0] |= GiantSendv4;
+                                        opts[0] |= transport_offset << GTTCPHO_SHIFT;
+                                        opts[1] |= min(mss, MSS_MAX) << 18;
+                                        large_send = 1;
+                                }
+                                break;
+                        case __constant_htons(ETH_P_IPV6):
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
+                                if (msdn_giant_send_check(skb))
+                                        return false;
+#endif
+                                if (transport_offset <= GTTCPHO_MAX) {
+                                        opts[0] |= GiantSendv6;
+                                        opts[0] |= transport_offset << GTTCPHO_SHIFT;
+                                        opts[1] |= min(mss, MSS_MAX) << 18;
+                                        large_send = 1;
+                                }
+                                break;
+                        default:
+                                if (unlikely(net_ratelimit()))
+                                        dprintk("tso proto=%x!\n", skb->protocol);
+                                break;
+                        }
+
+                        if (large_send == 0)
+                                return false;
+
+                        return true;
+                }
+        }
+#endif //LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+
+        if (skb->ip_summed == CHECKSUM_PARTIAL) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+                const struct iphdr *ip = skb->nh.iph;
+
+                if (dev->features & NETIF_F_IP_CSUM) {
+                        if (ip->protocol == IPPROTO_TCP)
+                                csum_cmd = tp->tx_ip_csum_cmd | tp->tx_tcp_csum_cmd;
+                        else if (ip->protocol == IPPROTO_UDP)
+                                csum_cmd = tp->tx_ip_csum_cmd | tp->tx_udp_csum_cmd;
+                        else if (ip->protocol == IPPROTO_IP)
+                                csum_cmd = tp->tx_ip_csum_cmd;
+                }
+#else
+                u8 ip_protocol = IPPROTO_RAW;
+
+                switch (get_protocol(skb)) {
+                case  __constant_htons(ETH_P_IP):
+                        if (dev->features & NETIF_F_IP_CSUM) {
+                                ip_protocol = ip_hdr(skb)->protocol;
+                                csum_cmd = tp->tx_ip_csum_cmd;
+                        }
+                        break;
+                case  __constant_htons(ETH_P_IPV6):
+                        if (dev->features & NETIF_F_IPV6_CSUM) {
+                                u32 transport_offset = (u32)skb_transport_offset(skb);
+                                if (transport_offset > 0 && transport_offset <= TCPHO_MAX) {
+                                        ip_protocol = ipv6_hdr(skb)->nexthdr;
+                                        csum_cmd = tp->tx_ipv6_csum_cmd;
+                                        csum_cmd |= transport_offset << TCPHO_SHIFT;
+                                }
+                        }
+                        break;
+                default:
+                        if (unlikely(net_ratelimit()))
+                                dprintk("checksum_partial proto=%x!\n", skb->protocol);
+                        break;
+                }
+
+                if (ip_protocol == IPPROTO_TCP)
+                        csum_cmd |= tp->tx_tcp_csum_cmd;
+                else if (ip_protocol == IPPROTO_UDP)
+                        csum_cmd |= tp->tx_udp_csum_cmd;
+#endif
+                if (csum_cmd == 0) {
+                        sw_calc_csum = true;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+                        WARN_ON(1); /* we need a WARN() */
+#endif
+                }
+
+                if (ip_protocol == IPPROTO_TCP)
+                        check_patch_required = false;
+        }
+
+        if (check_patch_required) {
+                u32 pad_len = rtl8125_get_patch_pad_len(skb);
+
+                if (pad_len > 0) {
+                        if (!rtl8125_skb_pad_with_len(skb, skb->len + pad_len))
+                                return false;
+
+                        if (csum_cmd != 0)
+                                sw_calc_csum = true;
+                }
+        }
+
+        if (skb->len < ETH_ZLEN) {
+                if (tp->UseSwPaddingShortPkt ||
+                    (tp->ShortPacketSwChecksum && csum_cmd != 0)) {
+                        if (!rtl8125_skb_pad(skb))
+                                return false;
+
+                        if (csum_cmd != 0)
+                                sw_calc_csum = true;
+                }
+        }
+
+        if (sw_calc_csum) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10) && LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,7)
+                skb_checksum_help(&skb, 0);
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19) && LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,10)
+                skb_checksum_help(skb, 0);
+#else
+                skb_checksum_help(skb);
+#endif
+        } else
+                opts[1] |= csum_cmd;
+
+        return true;
+}
+
+static bool rtl8125_tx_slots_avail(struct rtl8125_private *tp,
+                                   struct rtl8125_tx_ring *ring)
+{
+        unsigned int slots_avail = READ_ONCE(ring->dirty_tx) + ring->num_tx_desc
+                                   - READ_ONCE(ring->cur_tx);
+
+        /* A skbuff with nr_frags needs nr_frags+1 entries in the tx queue */
+        return slots_avail > MAX_SKB_FRAGS;
+}
+
+static netdev_tx_t
+rtl8125_start_xmit(struct sk_buff *skb,
+                   struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        unsigned int entry;
+        struct TxDesc *txd;
+        dma_addr_t mapping;
+        u32 len;
+        u32 opts[2];
+        netdev_tx_t ret = NETDEV_TX_OK;
+        int frags;
+        u8 EnableTxNoClose = tp->EnableTxNoClose;
+        const u16 queue_mapping = skb_get_queue_mapping(skb);
+        struct rtl8125_tx_ring *ring;
+        bool stop_queue;
+
+        assert(queue_mapping < tp->num_tx_rings);
+
+        ring = &tp->tx_ring[queue_mapping];
+
+        if (unlikely(!rtl8125_tx_slots_avail(tp, ring))) {
+                if (netif_msg_drv(tp)) {
+                        printk(KERN_ERR
+                               "%s: BUG! Tx Ring[%d] full when queue awake!\n",
+                               dev->name,
+                               queue_mapping);
+                }
+                goto err_stop;
+        }
+
+        entry = ring->cur_tx % ring->num_tx_desc;
+        txd = ring->TxDescArray + entry;
+
+        if (!EnableTxNoClose) {
+                if (unlikely(le32_to_cpu(txd->opts1) & DescOwn)) {
+                        if (netif_msg_drv(tp)) {
+                                printk(KERN_ERR
+                                       "%s: BUG! Tx Desc is own by hardware!\n",
+                                       dev->name);
+                        }
+                        goto err_stop;
+                }
+        }
+
+        opts[0] = DescOwn;
+        opts[1] = rtl8125_tx_vlan_tag(tp, skb);
+
+        if (unlikely(!rtl8125_tso_csum(skb, dev, opts)))
+                goto err_dma_0;
+
+        frags = rtl8125_xmit_frags(tp, ring, skb, opts);
+        if (unlikely(frags < 0))
+                goto err_dma_0;
+        if (frags) {
+                len = skb_headlen(skb);
+                opts[0] |= FirstFrag;
+        } else {
+                len = skb->len;
+
+                //ring->tx_skb[entry].skb = skb;
+
+                opts[0] |= FirstFrag | LastFrag;
+        }
+
+        opts[0] = rtl8125_get_txd_opts1(ring, opts[0], len, entry);
+        mapping = dma_map_single(tp_to_dev(tp), skb->data, len, DMA_TO_DEVICE);
+        if (unlikely(dma_mapping_error(tp_to_dev(tp), mapping))) {
+                if (unlikely(net_ratelimit()))
+                        netif_err(tp, drv, dev, "Failed to map TX DMA!\n");
+                goto err_dma_1;
+        }
+        ring->tx_skb[entry].len = len;
+#ifdef ENABLE_PTP_SUPPORT
+        if (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) {
+                if (tp->hwtstamp_config.tx_type == HWTSTAMP_TX_ON &&
+                    !tp->ptp_tx_skb) {
+                        skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+
+                        tp->ptp_tx_skb = skb_get(skb);
+                        tp->ptp_tx_start = jiffies;
+                        schedule_work(&tp->ptp_tx_work);
+                } else {
+                        tp->tx_hwtstamp_skipped++;
+                }
+        }
+#endif
+        ring->tx_skb[entry].skb = skb;
+        txd->addr = cpu_to_le64(mapping);
+        txd->opts2 = cpu_to_le32(opts[1]);
+        wmb();
+        txd->opts1 = cpu_to_le32(opts[0]);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
+        dev->trans_start = jiffies;
+#else
+        skb_tx_timestamp(skb);
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0)
+
+        /* rtl_tx needs to see descriptor changes before updated tp->cur_tx */
+        smp_wmb();
+
+        WRITE_ONCE(ring->cur_tx, ring->cur_tx + frags + 1);
+
+        stop_queue = !rtl8125_tx_slots_avail(tp, ring);
+        if (unlikely(stop_queue)) {
+                /* Avoid wrongly optimistic queue wake-up: rtl_tx thread must
+                 * not miss a ring update when it notices a stopped queue.
+                 */
+                smp_wmb();
+                netif_stop_subqueue(dev, queue_mapping);
+        }
+
+        if (EnableTxNoClose)
+                RTL_W16(tp, ring->sw_tail_ptr_reg, ring->cur_tx % MAX_TX_NO_CLOSE_DESC_PTR_V2);
+        else
+                RTL_W16(tp, TPPOLL_8125, BIT(ring->index));    /* set polling bit */
+
+        if (unlikely(stop_queue)) {
+                /* Sync with rtl_tx:
+                 * - publish queue status and cur_tx ring index (write barrier)
+                 * - refresh dirty_tx ring index (read barrier).
+                 * May the current thread have a pessimistic view of the ring
+                 * status and forget to wake up queue, a racing rtl_tx thread
+                 * can't.
+                 */
+                smp_mb();
+                if (rtl8125_tx_slots_avail(tp, ring))
+                        netif_start_subqueue(dev, queue_mapping);
+        }
+out:
+        return ret;
+err_dma_1:
+        ring->tx_skb[entry].skb = NULL;
+        rtl8125_tx_clear_range(tp, ring, ring->cur_tx + 1, frags);
+err_dma_0:
+        RTLDEV->stats.tx_dropped++;
+        dev_kfree_skb_any(skb);
+        ret = NETDEV_TX_OK;
+        goto out;
+err_stop:
+        netif_stop_subqueue(dev, queue_mapping);
+        ret = NETDEV_TX_BUSY;
+        RTLDEV->stats.tx_dropped++;
+        goto out;
+}
+
+static inline u32
+rtl8125_fast_mod(const u32 input, const u32 ceil)
+{
+        return input >= ceil ? input % ceil : input;
+}
+
+static int
+rtl8125_tx_interrupt(struct rtl8125_tx_ring *ring, int budget)
+{
+        struct rtl8125_private *tp = ring->priv;
+        struct net_device *dev = tp->dev;
+        unsigned int dirty_tx, tx_left;
+        unsigned int count = 0;
+        u8 EnableTxNoClose = tp->EnableTxNoClose;
+
+        dirty_tx = ring->dirty_tx;
+        smp_rmb();
+        tx_left = READ_ONCE(ring->cur_tx) - dirty_tx;
+        if (EnableTxNoClose) {
+                unsigned int tx_desc_closed;
+                u32 NextHwDesCloPtr = RTL_R16(tp, ring->hw_clo_ptr_reg);
+                ring->NextHwDesCloPtr = NextHwDesCloPtr;
+                smp_rmb();
+                tx_desc_closed = rtl8125_fast_mod(NextHwDesCloPtr - ring->BeginHwDesCloPtr, MAX_TX_NO_CLOSE_DESC_PTR_V2);
+                if(tx_left > tx_desc_closed) tx_left = tx_desc_closed;
+                ring->BeginHwDesCloPtr = NextHwDesCloPtr;
+        }
+
+        while (tx_left > 0) {
+                unsigned int entry = dirty_tx % ring->num_tx_desc;
+                struct ring_info *tx_skb = ring->tx_skb + entry;
+
+                if (!EnableTxNoClose &&
+                    (le32_to_cpu(ring->TxDescArray[entry].opts1) & DescOwn))
+                        break;
+
+                RTLDEV->stats.tx_bytes += tx_skb->len;
+                RTLDEV->stats.tx_packets++;
+
+                rtl8125_unmap_tx_skb(tp->pci_dev,
+                                     tx_skb,
+                                     ring->TxDescArray + entry);
+
+                if (tx_skb->skb != NULL) {
+                        RTL_NAPI_CONSUME_SKB_ANY(tx_skb->skb, budget);
+                        tx_skb->skb = NULL;
+                }
+                dirty_tx++;
+                tx_left--;
+        }
+
+        if (ring->dirty_tx != dirty_tx) {
+                count = dirty_tx - ring->dirty_tx;
+                WRITE_ONCE(ring->dirty_tx, dirty_tx);
+                smp_wmb();
+                if (__netif_subqueue_stopped(dev, ring->index) &&
+                    (rtl8125_tx_slots_avail(tp, ring))) {
+                        netif_start_subqueue(dev, ring->index);
+                }
+                smp_rmb();
+                if (!EnableTxNoClose && (ring->cur_tx != dirty_tx)) {
+                        RTL_W16(tp, TPPOLL_8125, BIT(ring->index));
+                }
+        }
+
+        return count;
+}
+
+static int
+rtl8125_tx_interrupt_with_vector(struct rtl8125_private *tp,
+                                 const int message_id,
+                                 int budget)
+{
+        int count = 0;
+
+        if (message_id == 16)
+                count += rtl8125_tx_interrupt(&tp->tx_ring[0], budget);
+#ifdef ENABLE_MULTIPLE_TX_QUEUE
+        else if (message_id == 18)
+                count += rtl8125_tx_interrupt(&tp->tx_ring[1], budget);
+#endif
+
+        return count;
+}
+
+static inline int
+rtl8125_fragmented_frame(struct rtl8125_private *tp, u32 status)
+{
+        if (tp->InitRxDescType == RX_DESC_RING_TYPE_3)
+                return (status & (FirstFrag_V3 | LastFrag_V3)) != (FirstFrag_V3 | LastFrag_V3);
+        else
+                return (status & (FirstFrag | LastFrag)) != (FirstFrag | LastFrag);
+}
+
+static inline int
+rtl8125_rx_desc_type(u32 status)
+{
+        return ((status >> 26) & 0x0F);
+}
+
+static inline void
+rtl8125_rx_v3_csum(struct rtl8125_private *tp,
+                   struct sk_buff *skb,
+                   struct RxDescV3 *descv3)
+{
+        //u32 opts1 = le32_to_cpu(descv3->RxDescNormalDDWord4.opts1);
+        u32 opts2 = le32_to_cpu(descv3->RxDescNormalDDWord4.opts2);
+
+        /* rx csum offload for RTL8125 */
+        if (((opts2 & RxV4F_v3) && !(opts2 & RxIPF_v3)) || (opts2 & RxV6F_v3)) {
+                if (((opts2 & RxTCPT_v3) && !(opts2 & RxTCPF_v3)) ||
+                    ((opts2 & RxUDPT_v3) && !(opts2 & RxUDPF_v3)))
+                        skb->ip_summed = CHECKSUM_UNNECESSARY;
+                else
+                        skb->ip_summed = CHECKSUM_NONE;
+        } else
+                skb->ip_summed = CHECKSUM_NONE;
+}
+
+static inline void
+rtl8125_rx_csum(struct rtl8125_private *tp,
+                struct sk_buff *skb,
+                struct RxDesc *desc)
+{
+        if (tp->InitRxDescType == RX_DESC_RING_TYPE_3)
+                rtl8125_rx_v3_csum(tp, skb, (struct RxDescV3 *)desc);
+        else {
+                u32 opts1 = le32_to_cpu(rtl8125_rx_desc_opts1(tp, desc));
+                u32 opts2 = le32_to_cpu(rtl8125_rx_desc_opts2(tp, desc));
+
+                /* rx csum offload for RTL8125 */
+                if (((opts2 & RxV4F) && !(opts1 & RxIPF)) || (opts2 & RxV6F)) {
+                        if (((opts1 & RxTCPT) && !(opts1 & RxTCPF)) ||
+                            ((opts1 & RxUDPT) && !(opts1 & RxUDPF)))
+                                skb->ip_summed = CHECKSUM_UNNECESSARY;
+                        else
+                                skb->ip_summed = CHECKSUM_NONE;
+                } else
+                        skb->ip_summed = CHECKSUM_NONE;
+        }
+}
+
+static inline int
+rtl8125_try_rx_copy(struct rtl8125_private *tp,
+                    struct rtl8125_rx_ring *ring,
+                    struct sk_buff **sk_buff,
+                    int pkt_size,
+                    struct RxDesc *desc,
+                    int rx_buf_sz)
+{
+        int ret = -1;
+
+        if (pkt_size < rx_copybreak) {
+                struct sk_buff *skb;
+
+                skb = RTL_ALLOC_SKB_INTR(&tp->r8125napi[ring->index].napi, pkt_size + RTK_RX_ALIGN);
+                if (skb) {
+                        u8 *data;
+
+                        data = sk_buff[0]->data;
+                        skb_reserve(skb, RTK_RX_ALIGN);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,37)
+                        prefetch(data - RTK_RX_ALIGN);
+#endif
+                        eth_copy_and_sum(skb, data, pkt_size, 0);
+                        *sk_buff = skb;
+                        rtl8125_mark_to_asic(tp, desc, rx_buf_sz);
+                        ret = 0;
+                }
+        }
+        return ret;
+}
+
+static inline void
+rtl8125_rx_skb(struct rtl8125_private *tp,
+               struct sk_buff *skb,
+               u32 ring_index)
+{
+#ifdef CONFIG_R8125_NAPI
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+        netif_receive_skb(skb);
+#else
+        napi_gro_receive(&tp->r8125napi[ring_index].napi, skb);
+#endif
+#else
+        netif_rx(skb);
+#endif
+}
+
+static int
+rtl8125_check_rx_desc_error(struct net_device *dev,
+                            struct rtl8125_private *tp,
+                            u32 status)
+{
+        int ret = 0;
+
+        if (tp->InitRxDescType == RX_DESC_RING_TYPE_3) {
+                if (unlikely(status & RxRES_V3)) {
+                        if (status & (RxRWT_V3 | RxRUNT_V3))
+                                RTLDEV->stats.rx_length_errors++;
+                        if (status & RxCRC_V3)
+                                RTLDEV->stats.rx_crc_errors++;
+
+                        ret = -1;
+                }
+        } else {
+                if (unlikely(status & RxRES)) {
+                        if (status & (RxRWT | RxRUNT))
+                                RTLDEV->stats.rx_length_errors++;
+                        if (status & RxCRC)
+                                RTLDEV->stats.rx_crc_errors++;
+
+                        ret = -1;
+                }
+        }
+
+        return ret;
+}
+
+static int
+rtl8125_rx_interrupt(struct net_device *dev,
+                     struct rtl8125_private *tp,
+                     struct rtl8125_rx_ring *ring,
+                     napi_budget budget)
+{
+        unsigned int cur_rx, rx_left;
+        unsigned int delta, count = 0;
+        unsigned int entry;
+        struct RxDesc *desc;
+        u32 status;
+        u32 rx_quota;
+        u64 rx_buf_phy_addr;
+        u32 ring_index = ring->index;
+
+        assert(dev != NULL);
+        assert(tp != NULL);
+
+        if (ring->RxDescArray == NULL)
+                goto rx_out;
+
+        rx_quota = RTL_RX_QUOTA(budget);
+        cur_rx = ring->cur_rx;
+        entry = cur_rx % ring->num_rx_desc;
+        desc = rtl8125_get_rxdesc(tp, ring->RxDescArray, entry);
+        rx_left = ring->num_rx_desc + ring->dirty_rx - cur_rx;
+        rx_left = rtl8125_rx_quota(rx_left, (u32)rx_quota);
+
+        for (; rx_left > 0; rx_left--) {
+                rmb();
+                status = le32_to_cpu(rtl8125_rx_desc_opts1(tp, desc));
+                if (status & DescOwn)
+                        break;
+
+                if (unlikely(rtl8125_check_rx_desc_error(dev, tp, status) < 0)) {
+                        if (netif_msg_rx_err(tp)) {
+                                printk(KERN_INFO
+                                       "%s: Rx ERROR. status = %08x\n",
+                                       dev->name, status);
+                        }
+
+                        RTLDEV->stats.rx_errors++;
+
+                        if (dev->features & NETIF_F_RXALL)
+                                goto process_pkt;
+
+                        rtl8125_mark_to_asic(tp, desc, tp->rx_buf_sz);
+                } else {
+                        struct sk_buff *skb;
+                        int pkt_size;
+
+process_pkt:
+                        if (likely(!(dev->features & NETIF_F_RXFCS)))
+                                pkt_size = (status & 0x00003fff) - 4;
+                        else
+                                pkt_size = status & 0x00003fff;
+
+                        /*
+                         * The driver does not support incoming fragmented
+                         * frames. They are seen as a symptom of over-mtu
+                         * sized frames.
+                         */
+                        if (unlikely(rtl8125_fragmented_frame(tp, status))) {
+                                RTLDEV->stats.rx_dropped++;
+                                RTLDEV->stats.rx_length_errors++;
+                                rtl8125_mark_to_asic(tp, desc, tp->rx_buf_sz);
+                                continue;
+                        }
+
+                        skb = ring->Rx_skbuff[entry];
+
+                        if (!skb)
+                                break;
+
+#ifdef ENABLE_PTP_SUPPORT
+                        if (tp->EnablePtp) {
+                                u8 desc_type;
+
+                                desc_type = rtl8125_rx_desc_type(status);
+                                if (desc_type == RXDESC_TYPE_NEXT && rx_left > 0) {
+                                        u32 status_next;
+                                        struct RxDescV3 *desc_next;
+                                        unsigned int entry_next;
+                                        struct sk_buff *skb_next;
+
+                                        entry_next = (cur_rx + 1) % ring->num_rx_desc;
+                                        desc_next = (struct RxDescV3 *)rtl8125_get_rxdesc(tp, ring->RxDescArray, entry_next);
+                                        rmb();
+                                        status_next = le32_to_cpu(desc_next->RxDescNormalDDWord4.opts1);
+                                        if (unlikely(status_next & DescOwn)) {
+                                                udelay(1);
+                                                rmb();
+                                                status_next = le32_to_cpu(desc_next->RxDescNormalDDWord4.opts1);
+                                                if (unlikely(status_next & DescOwn)) {
+                                                        if (netif_msg_rx_err(tp)) {
+                                                                printk(KERN_ERR
+                                                                       "%s: Rx Next Desc ERROR. status = %08x\n",
+                                                                       dev->name, status_next);
+                                                        }
+                                                        break;
+                                                }
+                                        }
+
+                                        cur_rx++;
+                                        rx_left--;
+                                        desc_type = rtl8125_rx_desc_type(status_next);
+                                        if (desc_type == RXDESC_TYPE_PTP)
+                                                rtl8125_rx_ptp_pktstamp(tp, skb, desc_next);
+                                        else
+                                                WARN_ON(1);
+
+                                        rx_buf_phy_addr = ring->RxDescPhyAddr[entry_next];
+                                        dma_unmap_single(tp_to_dev(tp), rx_buf_phy_addr,
+                                                         tp->rx_buf_sz, DMA_FROM_DEVICE);
+                                        skb_next = ring->Rx_skbuff[entry_next];
+                                        dev_kfree_skb_any(skb_next);
+                                        ring->Rx_skbuff[entry_next] = NULL;
+                                } else
+                                        WARN_ON(desc_type != RXDESC_TYPE_NORMAL);
+                        }
+#endif
+                        rx_buf_phy_addr = ring->RxDescPhyAddr[entry];
+                        dma_sync_single_for_cpu(tp_to_dev(tp),
+                                                rx_buf_phy_addr, tp->rx_buf_sz,
+                                                DMA_FROM_DEVICE);
+
+                        if (rtl8125_try_rx_copy(tp, ring, &skb, pkt_size,
+                                                desc, tp->rx_buf_sz)) {
+                                ring->Rx_skbuff[entry] = NULL;
+                                dma_unmap_single(tp_to_dev(tp), rx_buf_phy_addr,
+                                                 tp->rx_buf_sz, DMA_FROM_DEVICE);
+                        } else {
+                                dma_sync_single_for_device(tp_to_dev(tp), rx_buf_phy_addr,
+                                                           tp->rx_buf_sz, DMA_FROM_DEVICE);
+                        }
+
+#ifdef ENABLE_RSS_SUPPORT
+                        rtl8125_rx_hash(tp, (struct RxDescV3 *)desc, skb);
+#endif
+
+                        if (tp->cp_cmd & RxChkSum)
+                                rtl8125_rx_csum(tp, skb, desc);
+
+                        skb->dev = dev;
+                        skb_put(skb, pkt_size);
+                        skb->protocol = eth_type_trans(skb, dev);
+
+                        if (skb->pkt_type == PACKET_MULTICAST)
+                                RTLDEV->stats.multicast++;
+
+                        if (rtl8125_rx_vlan_skb(tp, desc, skb) < 0)
+                                rtl8125_rx_skb(tp, skb, ring_index);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,11,0)
+                        dev->last_rx = jiffies;
+#endif //LINUX_VERSION_CODE < KERNEL_VERSION(4,11,0)
+                        RTLDEV->stats.rx_bytes += pkt_size;
+                        RTLDEV->stats.rx_packets++;
+                }
+
+                cur_rx++;
+                entry = cur_rx % ring->num_rx_desc;
+                desc = rtl8125_get_rxdesc(tp, ring->RxDescArray, entry);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,37)
+                prefetch(desc);
+#endif
+        }
+
+        count = cur_rx - ring->cur_rx;
+        ring->cur_rx = cur_rx;
+
+        delta = rtl8125_rx_fill(tp, ring, dev, ring->dirty_rx, ring->cur_rx, 1);
+        if (!delta && count && netif_msg_intr(tp))
+                printk(KERN_INFO "%s: no Rx buffer allocated\n", dev->name);
+        ring->dirty_rx += delta;
+
+        /*
+         * FIXME: until there is periodic timer to try and refill the ring,
+         * a temporary shortage may definitely kill the Rx process.
+         * - disable the asic to try and avoid an overflow and kick it again
+         *   after refill ?
+         * - how do others driver handle this condition (Uh oh...).
+         */
+        if ((ring->dirty_rx + ring->num_rx_desc == ring->cur_rx) && netif_msg_intr(tp))
+                printk(KERN_EMERG "%s: Rx buffers exhausted\n", dev->name);
+
+rx_out:
+        return count;
+}
+
+static bool
+rtl8125_linkchg_interrupt(struct rtl8125_private *tp, u32 status)
+{
+        if (tp->HwCurrIsrVer == 2)
+                return status & ISRIMR_V2_LINKCHG;
+
+        return status & LinkChg;
+}
+
+/*
+ *The interrupt handler does all of the Rx thread work and cleans up after
+ *the Tx thread.
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static irqreturn_t rtl8125_interrupt(int irq, void *dev_instance, struct pt_regs *regs)
+#else
+static irqreturn_t rtl8125_interrupt(int irq, void *dev_instance)
+#endif
+{
+        struct r8125_napi *r8125napi = dev_instance;
+        struct rtl8125_private *tp = r8125napi->priv;
+        struct net_device *dev = tp->dev;
+        u32 status;
+        int handled = 0;
+
+        do {
+                status = RTL_R32(tp, tp->isr_reg[0]);
+
+                if (!(tp->features & (RTL_FEATURE_MSI | RTL_FEATURE_MSIX))) {
+                        /* hotplug/major error/no more work/shared irq */
+                        if (!status)
+                                break;
+
+                        if (status == 0xFFFFFFFF)
+                                break;
+
+                        if (!(status & (tp->intr_mask | tp->timer_intr_mask)))
+                                break;
+                }
+
+                handled = 1;
+
+#if defined(RTL_USE_NEW_INTR_API)
+                if (!tp->irq_tbl[0].requested)
+                        break;
+#endif
+                rtl8125_disable_hw_interrupt(tp);
+
+                RTL_W32(tp, tp->isr_reg[0], status&~RxFIFOOver);
+
+                if (rtl8125_linkchg_interrupt(tp, status))
+                        rtl8125_schedule_linkchg_work(tp);
+
+#ifdef ENABLE_DASH_SUPPORT
+                if (tp->DASH) {
+                        if (HW_DASH_SUPPORT_TYPE_3(tp)) {
+                                u8 DashIntType2Status;
+
+                                if (status & ISRIMR_DASH_INTR_CMAC_RESET)
+                                        tp->CmacResetIntr = TRUE;
+
+                                DashIntType2Status = RTL_CMAC_R8(tp, CMAC_IBISR0);
+                                if (DashIntType2Status & ISRIMR_DASH_TYPE2_ROK) {
+                                        tp->RcvFwDashOkEvt = TRUE;
+                                }
+                                if (DashIntType2Status & ISRIMR_DASH_TYPE2_TOK) {
+                                        tp->SendFwHostOkEvt = TRUE;
+                                }
+                                if (DashIntType2Status & ISRIMR_DASH_TYPE2_RX_DISABLE_IDLE) {
+                                        tp->DashFwDisableRx = TRUE;
+                                }
+
+                                RTL_CMAC_W8(tp, CMAC_IBISR0, DashIntType2Status);
+                        }
+                }
+#endif
+
+#ifdef CONFIG_R8125_NAPI
+                if (status & tp->intr_mask || tp->keep_intr_cnt-- > 0) {
+                        if (status & tp->intr_mask)
+                                tp->keep_intr_cnt = RTK_KEEP_INTERRUPT_COUNT;
+
+                        if (likely(RTL_NETIF_RX_SCHEDULE_PREP(dev, &tp->r8125napi[0].napi)))
+                                __RTL_NETIF_RX_SCHEDULE(dev, &tp->r8125napi[0].napi);
+                        else if (netif_msg_intr(tp))
+                                printk(KERN_INFO "%s: interrupt %04x in poll\n",
+                                       dev->name, status);
+                } else {
+                        tp->keep_intr_cnt = RTK_KEEP_INTERRUPT_COUNT;
+                        rtl8125_switch_to_hw_interrupt(tp);
+                }
+#else
+                if (status & tp->intr_mask || tp->keep_intr_cnt-- > 0) {
+                        u32 budget = ~(u32)0;
+                        int i;
+
+                        if (status & tp->intr_mask)
+                                tp->keep_intr_cnt = RTK_KEEP_INTERRUPT_COUNT;
+
+                        for (i = 0; i < tp->num_tx_rings; i++)
+                                rtl8125_tx_interrupt(&tp->tx_ring[i], ~(u32)0);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+                        rtl8125_rx_interrupt(dev, tp, &tp->rx_ring[0], &budget);
+#else
+                        rtl8125_rx_interrupt(dev, tp, &tp->rx_ring[0], budget);
+#endif	//LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+
+#ifdef ENABLE_DASH_SUPPORT
+                        if (tp->DASH) {
+                                struct net_device *dev = tp->dev;
+
+                                HandleDashInterrupt(dev);
+                        }
+#endif
+
+                        rtl8125_switch_to_timer_interrupt(tp);
+                } else {
+                        tp->keep_intr_cnt = RTK_KEEP_INTERRUPT_COUNT;
+                        rtl8125_switch_to_hw_interrupt(tp);
+                }
+#endif
+        } while (false);
+
+        return IRQ_RETVAL(handled);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+static irqreturn_t rtl8125_interrupt_msix(int irq, void *dev_instance, struct pt_regs *regs)
+#else
+static irqreturn_t rtl8125_interrupt_msix(int irq, void *dev_instance)
+#endif
+{
+        struct r8125_napi *r8125napi = dev_instance;
+        struct rtl8125_private *tp = r8125napi->priv;
+        struct net_device *dev = tp->dev;
+        int message_id = r8125napi->index;
+#ifndef CONFIG_R8125_NAPI
+        u32 budget = ~(u32)0;
+#endif
+
+        do {
+#if defined(RTL_USE_NEW_INTR_API)
+                if (!tp->irq_tbl[message_id].requested)
+                        break;
+#endif
+                rtl8125_disable_hw_interrupt_v2(tp, message_id);
+
+                rtl8125_clear_hw_isr_v2(tp, message_id);
+
+                //link change
+                if (message_id == 21) {
+                        rtl8125_schedule_linkchg_work(tp);
+                        break;
+                }
+
+#ifdef CONFIG_R8125_NAPI
+                if (likely(RTL_NETIF_RX_SCHEDULE_PREP(dev, &r8125napi->napi)))
+                        __RTL_NETIF_RX_SCHEDULE(dev, &r8125napi->napi);
+                else if (netif_msg_intr(tp))
+                        printk(KERN_INFO "%s: interrupt message id %d in poll_msix\n",
+                               dev->name, message_id);
+#else
+                rtl8125_tx_interrupt_with_vector(tp, message_id, ~(u32)0);
+
+                if (message_id < tp->num_rx_rings) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+                        rtl8125_rx_interrupt(dev, tp, &tp->rx_ring[message_id], &budget);
+#else
+                        rtl8125_rx_interrupt(dev, tp, &tp->rx_ring[message_id], budget);
+#endif	//LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+                }
+
+                rtl8125_enable_hw_interrupt_v2(tp, message_id);
+#endif
+
+        } while (false);
+
+        return IRQ_HANDLED;
+}
+
+static void rtl8125_down(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        //rtl8125_delete_esd_timer(dev, &tp->esd_timer);
+
+        //rtl8125_delete_link_timer(dev, &tp->link_timer);
+
+        netif_tx_disable(dev);
+
+        _rtl8125_wait_for_quiescence(dev);
+
+        netif_carrier_off(dev);
+
+        rtl8125_hw_reset(dev);
+
+        rtl8125_tx_clear(tp);
+
+        rtl8125_rx_clear(tp);
+}
+
+static int rtl8125_resource_freed(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i = 0; i < tp->num_tx_rings; i++)
+                if (tp->tx_ring[i].TxDescArray) return 0;
+
+        for (i = 0; i < tp->num_rx_rings; i++)
+                if (tp->rx_ring[i].RxDescArray) return 0;
+
+        return 1;
+}
+
+int rtl8125_close(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        if (!rtl8125_resource_freed(tp)) {
+                set_bit(R8125_FLAG_DOWN, tp->task_flags);
+
+                rtl8125_down(dev);
+
+                pci_clear_master(tp->pci_dev);
+
+#ifdef ENABLE_PTP_SUPPORT
+                rtl8125_ptp_stop(tp);
+#endif
+                rtl8125_hw_d3_para(dev);
+
+                rtl8125_powerdown_pll(dev, 0);
+
+                rtl8125_free_irq(tp);
+
+                rtl8125_free_alloc_resources(tp);
+        } else {
+                rtl8125_hw_d3_para(dev);
+
+                rtl8125_powerdown_pll(dev, 0);
+        }
+
+        return 0;
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,11)
+static void rtl8125_shutdown(struct pci_dev *pdev)
+{
+        struct net_device *dev = pci_get_drvdata(pdev);
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        rtnl_lock();
+
+        if (tp->DASH)
+                rtl8125_driver_stop(tp);
+
+        rtl8125_set_bios_setting(dev);
+        if (s5_keep_curr_mac == 0 && tp->random_mac == 0)
+                rtl8125_rar_set(tp, tp->org_mac_addr);
+
+        if (s5wol == 0)
+                tp->wol_enabled = WOL_DISABLED;
+
+        rtl8125_close(dev);
+        rtl8125_disable_msi(pdev, tp);
+
+        rtnl_unlock();
+
+        if (system_state == SYSTEM_POWER_OFF) {
+                pci_clear_master(tp->pci_dev);
+                pci_wake_from_d3(pdev, tp->wol_enabled);
+                pci_set_power_state(pdev, PCI_D3hot);
+        }
+}
+#endif
+
+/**
+ *  rtl8125_get_stats - Get rtl8125 read/write statistics
+ *  @dev: The Ethernet Device to get statistics for
+ *
+ *  Get TX/RX statistics for rtl8125
+ */
+static struct
+net_device_stats *rtl8125_get_stats(struct net_device *dev)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+        struct rtl8125_private *tp = netdev_priv(dev);
+#endif
+        return &RTLDEV->stats;
+}
+
+#ifdef CONFIG_PM
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+static int
+rtl8125_suspend(struct pci_dev *pdev, u32 state)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+static int
+rtl8125_suspend(struct device *device)
+#else
+static int
+rtl8125_suspend(struct pci_dev *pdev, pm_message_t state)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+        struct pci_dev *pdev = to_pci_dev(device);
+        struct net_device *dev = pci_get_drvdata(pdev);
+#else
+        struct net_device *dev = pci_get_drvdata(pdev);
+#endif
+        struct rtl8125_private *tp = netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+        u32 pci_pm_state = pci_choose_state(pdev, state);
+#endif
+        if (!netif_running(dev))
+                goto out;
+
+        //rtl8125_cancel_all_schedule_work(tp);
+
+        //rtl8125_delete_esd_timer(dev, &tp->esd_timer);
+
+        //rtl8125_delete_link_timer(dev, &tp->link_timer);
+
+        rtnl_lock();
+
+        set_bit(R8125_FLAG_DOWN, tp->task_flags);
+
+        netif_tx_disable(dev);
+
+        netif_carrier_off(dev);
+
+        netif_device_detach(dev);
+
+#ifdef ENABLE_PTP_SUPPORT
+        rtl8125_ptp_suspend(tp);
+#endif
+        rtl8125_hw_reset(dev);
+
+        pci_clear_master(pdev);
+
+        rtl8125_hw_d3_para(dev);
+
+        rtl8125_powerdown_pll(dev, 1);
+
+        if (tp->DASH)
+                rtl8125_driver_stop(tp);
+
+        rtnl_unlock();
+out:
+
+        pci_disable_device(pdev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+        pci_save_state(pdev, &pci_pm_state);
+#else
+        pci_save_state(pdev);
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+        pci_enable_wake(pdev, pci_choose_state(pdev, state), tp->wol_enabled);
+#endif
+
+        pci_prepare_to_sleep(pdev);
+
+        return 0;
+}
+
+static int
+rtl8125_hw_d3_not_power_off(struct net_device *dev)
+{
+        return rtl8125_check_hw_phy_mcu_code_ver(dev);
+}
+
+static int rtl8125_wait_phy_nway_complete_sleep(struct rtl8125_private *tp)
+{
+        int i, val;
+
+        for (i = 0; i < 30; i++) {
+                val = rtl8125_mdio_read(tp, MII_BMSR) & BMSR_ANEGCOMPLETE;
+                if (val)
+                        return 0;
+
+                msleep(100);
+        }
+
+        return -1;
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+static int
+rtl8125_resume(struct pci_dev *pdev)
+#else
+static int
+rtl8125_resume(struct device *device)
+#endif
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+        struct pci_dev *pdev = to_pci_dev(device);
+        struct net_device *dev = pci_get_drvdata(pdev);
+#else
+        struct net_device *dev = pci_get_drvdata(pdev);
+#endif
+        struct rtl8125_private *tp = netdev_priv(dev);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+        u32 pci_pm_state = PCI_D0;
+#endif
+        u32 err;
+
+        rtnl_lock();
+
+        err = pci_enable_device(pdev);
+        if (err) {
+                dev_err(&pdev->dev, "Cannot enable PCI device from suspend\n");
+                goto out_unlock;
+        }
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+        pci_restore_state(pdev, &pci_pm_state);
+#else
+        pci_restore_state(pdev);
+#endif
+        pci_enable_wake(pdev, PCI_D0, 0);
+
+        /* restore last modified mac address */
+        rtl8125_rar_set(tp, dev->dev_addr);
+
+        tp->resume_not_chg_speed = 0;
+        if (tp->check_keep_link_speed &&
+            //tp->link_ok(dev) &&
+            rtl8125_hw_d3_not_power_off(dev) &&
+            rtl8125_wait_phy_nway_complete_sleep(tp) == 0)
+                tp->resume_not_chg_speed = 1;
+
+        if (!netif_running(dev))
+                goto out_unlock;
+
+        pci_set_master(pdev);
+
+        rtl8125_exit_oob(dev);
+
+        rtl8125_up(dev);
+
+        clear_bit(R8125_FLAG_DOWN, tp->task_flags);
+
+        rtl8125_schedule_reset_work(tp);
+
+        rtl8125_schedule_esd_work(tp);
+
+        //mod_timer(&tp->esd_timer, jiffies + RTL8125_ESD_TIMEOUT);
+        //mod_timer(&tp->link_timer, jiffies + RTL8125_LINK_TIMEOUT);
+out_unlock:
+        netif_device_attach(dev);
+
+        rtnl_unlock();
+
+        return err;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,29)
+
+static struct dev_pm_ops rtl8125_pm_ops = {
+        .suspend = rtl8125_suspend,
+        .resume = rtl8125_resume,
+        .freeze = rtl8125_suspend,
+        .thaw = rtl8125_resume,
+        .poweroff = rtl8125_suspend,
+        .restore = rtl8125_resume,
+};
+
+#define RTL8125_PM_OPS	(&rtl8125_pm_ops)
+
+#endif
+
+#else /* !CONFIG_PM */
+
+#define RTL8125_PM_OPS	NULL
+
+#endif /* CONFIG_PM */
+
+static struct pci_driver rtl8125_pci_driver = {
+        .name       = MODULENAME,
+        .id_table   = rtl8125_pci_tbl,
+        .probe      = rtl8125_init_one,
+        .remove     = __devexit_p(rtl8125_remove_one),
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,11)
+        .shutdown   = rtl8125_shutdown,
+#endif
+#ifdef CONFIG_PM
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+        .suspend    = rtl8125_suspend,
+        .resume     = rtl8125_resume,
+#else
+        .driver.pm	= RTL8125_PM_OPS,
+#endif
+#endif
+};
+
+static int __init
+rtl8125_init_module(void)
+{
+        int ret = 0;
+#ifdef ENABLE_R8125_PROCFS
+        rtl8125_proc_module_init();
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+
+        ret = pci_register_driver(&rtl8125_pci_driver);
+#else
+        ret = pci_module_init(&rtl8125_pci_driver);
+#endif
+
+        return ret;
+}
+
+static void __exit
+rtl8125_cleanup_module(void)
+{
+        pci_unregister_driver(&rtl8125_pci_driver);
+
+#ifdef ENABLE_R8125_PROCFS
+        if (rtl8125_proc) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+                remove_proc_subtree(MODULENAME, init_net.proc_net);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+                remove_proc_entry(MODULENAME, init_net.proc_net);
+#else
+                remove_proc_entry(MODULENAME, proc_net);
+#endif  //LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32)
+#endif  //LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+                rtl8125_proc = NULL;
+        }
+#endif
+}
+
+module_init(rtl8125_init_module);
+module_exit(rtl8125_cleanup_module);
Index: kernel-rockchip/drivers/net/ethernet/realtek/r8125/r8125_ptp.c
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/net/ethernet/realtek/r8125/r8125_ptp.c
@@ -0,0 +1,594 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2022 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <linux/mii.h>
+#include <linux/in.h>
+#include <linux/ethtool.h>
+
+#include "r8125.h"
+#include "r8125_ptp.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,6,0)
+static inline struct timespec timespec64_to_timespec(const struct timespec64 ts64)
+{
+        return *(const struct timespec *)&ts64;
+}
+
+static inline struct timespec64 timespec_to_timespec64(const struct timespec ts)
+{
+        return *(const struct timespec64 *)&ts;
+}
+#endif
+
+static int _rtl8125_phc_gettime(struct rtl8125_private *tp, struct timespec64 *ts64)
+{
+        //get local time
+        RTL_W16(tp, PTP_TIME_CORRECT_CMD_8125, (PTP_CMD_LATCHED_LOCAL_TIME | PTP_EXEC_CMD));
+
+        /* nanoseconds */
+        //0x6808[29:0]
+        ts64->tv_nsec = (RTL_R32(tp, PTP_SOFT_CONFIG_Time_NS_8125) & 0x3fffffff) +
+                        tp->ptp_adjust;
+
+        /* seconds */
+        //0x680C[47:0]
+        ts64->tv_sec = RTL_R16(tp, PTP_SOFT_CONFIG_Time_S_8125 + 4);
+        ts64->tv_sec <<= 32;
+        ts64->tv_sec |= RTL_R32(tp, PTP_SOFT_CONFIG_Time_S_8125);
+
+        return 0;
+}
+
+static int _rtl8125_phc_settime(struct rtl8125_private *tp, const struct timespec64 *ts64)
+{
+        /* nanoseconds */
+        //0x6808[29:0]
+        RTL_W32(tp, PTP_SOFT_CONFIG_Time_NS_8125, (ts64->tv_nsec & 0x3fffffff));
+
+        /* seconds */
+        //0x680C[47:0]
+        RTL_W32(tp, PTP_SOFT_CONFIG_Time_S_8125, ts64->tv_sec);
+        RTL_W16(tp, PTP_SOFT_CONFIG_Time_S_8125 + 4, (ts64->tv_sec >> 32));
+
+        //set local time
+        RTL_W16(tp, PTP_TIME_CORRECT_CMD_8125, (PTP_CMD_SET_LOCAL_TIME | PTP_EXEC_CMD));
+
+        return 0;
+}
+
+#if 0
+static int _rtl8125_phc_adjtime(struct rtl8125_private *tp, s64 delta)
+{
+        struct timespec64 now, then = ns_to_timespec64(delta);
+        u32 nsec;
+        u64 sec;
+
+        _rtl8125_phc_gettime(tp, &now);
+        now = timespec64_add(now, then);
+
+        nsec = now.tv_nsec & 0x3fffffff;
+        sec = now.tv_sec & 0x0000ffffffffffff;
+
+        /* nanoseconds */
+        //0x6808[29:0]
+        RTL_W32(tp, PTP_SOFT_CONFIG_Time_NS_8125, nsec);
+
+        /* seconds */
+        //0x680C[47:0]
+        RTL_W32(tp, PTP_SOFT_CONFIG_Time_S_8125, sec);
+        RTL_W16(tp, PTP_SOFT_CONFIG_Time_S_8125 + 4, (sec >> 32));
+
+        //adjust local time
+        //RTL_W16(tp, PTP_TIME_CORRECT_CMD_8125, (PTP_CMD_DRIFT_LOCAL_TIME | PTP_EXEC_CMD));
+        RTL_W16(tp, PTP_TIME_CORRECT_CMD_8125, (PTP_CMD_SET_LOCAL_TIME | PTP_EXEC_CMD));
+
+        return 0;
+}
+#endif
+
+static int rtl8125_phc_adjtime(struct ptp_clock_info *ptp, s64 delta)
+{
+        struct rtl8125_private *tp = container_of(ptp, struct rtl8125_private, ptp_clock_info);
+        unsigned long flags;
+        //int ret = 0;
+
+        //netif_info(tp, drv, tp->dev, "phc adjust time\n");
+
+        spin_lock_irqsave(&tp->lock, flags);
+        //ret = _rtl8125_phc_adjtime(tp, delta);
+        tp->ptp_adjust += delta;
+        spin_unlock_irqrestore(&tp->lock, flags);
+
+        return 0;
+}
+
+/*
+1ppm means every 125MHz plus 125Hz. It also means every 8ns minus 8ns*10^(-6)
+
+1ns=2^30 sub_ns
+
+8ns*10^(-6) = 8 * 2^30 sub_ns * 10^(-6) = 2^33 sub_ns * 10^(-6) = 8590 = 0x218E sub_ns
+
+1ppb means every 125MHz plus 0.125Hz. It also means every 8ns minus 8ns*10^(-9)
+
+1ns=2^30 sub_ns
+
+8ns*10^(-9) = 8 * 2^30 sub_ns * 10^(-9) = 2^33 sub_ns * 10^(-9) = 8.59 sub_ns = 9 sub_ns
+*/
+static int _rtl8125_phc_adjfreq(struct ptp_clock_info *ptp, s32 ppb)
+{
+        struct rtl8125_private *tp = container_of(ptp, struct rtl8125_private, ptp_clock_info);
+        bool negative = false;
+        u32 sub_ns;
+
+        if (ppb < 0) {
+                negative = true;
+                ppb = -ppb;
+        }
+
+        sub_ns = ppb * 9;
+        if (negative) {
+                sub_ns = -sub_ns;
+                sub_ns &= 0x3fffffff;
+                sub_ns |= PTP_ADJUST_TIME_NS_NEGATIVE;
+        } else
+                sub_ns &= 0x3fffffff;
+
+        /* nanoseconds */
+        //0x6808[29:0]
+        RTL_W32(tp, PTP_SOFT_CONFIG_Time_NS_8125, sub_ns);
+
+        //adjust local time
+        RTL_W16(tp, PTP_TIME_CORRECT_CMD_8125, (PTP_CMD_DRIFT_LOCAL_TIME | PTP_EXEC_CMD));
+        //RTL_W16(tp, PTP_TIME_CORRECT_CMD_8125, (PTP_CMD_SET_LOCAL_TIME | PTP_EXEC_CMD));
+
+        return 0;
+}
+
+static int rtl8125_phc_adjfreq(struct ptp_clock_info *ptp, s32 delta)
+{
+        //struct rtl8125_private *tp = container_of(ptp, struct rtl8125_private, ptp_clock_info);
+
+        //netif_info(tp, drv, tp->dev, "phc adjust freq\n");
+
+        if (delta > ptp->max_adj || delta < -ptp->max_adj)
+                return -EINVAL;
+
+        _rtl8125_phc_adjfreq(ptp, delta);
+
+        return 0;
+}
+
+static int rtl8125_phc_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts64)
+{
+        struct rtl8125_private *tp = container_of(ptp, struct rtl8125_private, ptp_clock_info);
+        unsigned long flags;
+        int ret;
+
+        //netif_info(tp, drv, tp->dev, "phc get ts\n");
+
+        spin_lock_irqsave(&tp->lock, flags);
+        ret = _rtl8125_phc_gettime(tp, ts64);
+        spin_unlock_irqrestore(&tp->lock, flags);
+
+        return ret;
+}
+
+static int rtl8125_phc_settime(struct ptp_clock_info *ptp,
+                               const struct timespec64 *ts64)
+{
+        struct rtl8125_private *tp = container_of(ptp, struct rtl8125_private, ptp_clock_info);
+        unsigned long flags;
+        int ret;
+
+        //netif_info(tp, drv, tp->dev, "phc set ts\n");
+
+        spin_lock_irqsave(&tp->lock, flags);
+        ret = _rtl8125_phc_settime(tp, ts64);
+        tp->ptp_adjust = 0;
+        spin_unlock_irqrestore(&tp->lock, flags);
+
+        return ret;
+}
+
+static int rtl8125_phc_enable(struct ptp_clock_info *ptp,
+                              struct ptp_clock_request *rq, int on)
+{
+        struct rtl8125_private *tp = container_of(ptp, struct rtl8125_private, ptp_clock_info);
+        unsigned long flags;
+        u16 ptp_ctrl;
+
+        //netif_info(tp, drv, tp->dev, "phc enable type %x on %d\n", rq->type, on);
+
+        switch (rq->type) {
+        case PTP_CLK_REQ_PPS:
+                spin_lock_irqsave(&tp->lock, flags);
+                ptp_ctrl = RTL_R16(tp, PTP_CTRL_8125);
+                ptp_ctrl &= ~BIT_15;
+                if (on)
+                        ptp_ctrl |= BIT_14;
+                else
+                        ptp_ctrl &= ~BIT_14;
+                RTL_W16(tp, PTP_CTRL_8125, ptp_ctrl);
+                spin_unlock_irqrestore(&tp->lock, flags);
+                return 0;
+        default:
+                return -EOPNOTSUPP;
+        }
+}
+
+int rtl8125_get_ts_info(struct net_device *netdev,
+                        struct ethtool_ts_info *info)
+{
+        struct rtl8125_private *tp = netdev_priv(netdev);
+
+        /* we always support timestamping disabled */
+        info->rx_filters = BIT(HWTSTAMP_FILTER_NONE);
+
+        if (tp->HwSuppPtpVer == 0)
+                return ethtool_op_get_ts_info(netdev, info);
+
+        info->so_timestamping =  SOF_TIMESTAMPING_TX_SOFTWARE |
+                                 SOF_TIMESTAMPING_RX_SOFTWARE |
+                                 SOF_TIMESTAMPING_SOFTWARE |
+                                 SOF_TIMESTAMPING_TX_HARDWARE |
+                                 SOF_TIMESTAMPING_RX_HARDWARE |
+                                 SOF_TIMESTAMPING_RAW_HARDWARE;
+
+        if (tp->ptp_clock)
+                info->phc_index = ptp_clock_index(tp->ptp_clock);
+        else
+                info->phc_index = -1;
+
+        info->tx_types = BIT(HWTSTAMP_TX_OFF) | BIT(HWTSTAMP_TX_ON);
+
+        info->rx_filters = BIT(HWTSTAMP_FILTER_NONE) |
+                           BIT(HWTSTAMP_FILTER_PTP_V2_EVENT) |
+                           BIT(HWTSTAMP_FILTER_PTP_V2_L4_EVENT) |
+                           BIT(HWTSTAMP_FILTER_PTP_V2_SYNC) |
+                           BIT(HWTSTAMP_FILTER_PTP_V2_L4_SYNC) |
+                           BIT(HWTSTAMP_FILTER_PTP_V2_DELAY_REQ) |
+                           BIT(HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ);
+
+        return 0;
+}
+
+static const struct ptp_clock_info rtl_ptp_clock_info = {
+        .owner      = THIS_MODULE,
+        .n_alarm    = 0,
+        .n_ext_ts   = 0,
+        .n_per_out  = 0,
+        .n_pins     = 0,
+        .pps        = 1,
+        .adjfreq    = rtl8125_phc_adjfreq,
+        .adjtime    = rtl8125_phc_adjtime,
+        .gettime64  = rtl8125_phc_gettime,
+        .settime64  = rtl8125_phc_settime,
+        .enable     = rtl8125_phc_enable,
+};
+
+static int rtl8125_get_tx_ptp_pkt_tstamp(struct rtl8125_private *tp, struct timespec64 *ts64)
+{
+        return _rtl8125_phc_gettime(tp, ts64);
+}
+
+static void rtl8125_ptp_tx_hwtstamp(struct rtl8125_private *tp)
+{
+        struct sk_buff *skb = tp->ptp_tx_skb;
+        struct skb_shared_hwtstamps shhwtstamps = {0};
+        struct timespec64 ts64;
+
+        RTL_W8(tp, PTP_ISR_8125, PTP_ISR_TOK | PTP_ISR_TER);
+
+        rtl8125_get_tx_ptp_pkt_tstamp(tp, &ts64);
+
+        /* Upper 32 bits contain s, lower 32 bits contain ns. */
+        shhwtstamps.hwtstamp = ktime_set(ts64.tv_sec,
+                                         ts64.tv_nsec);
+
+        /* Clear the lock early before calling skb_tstamp_tx so that
+         * applications are not woken up before the lock bit is clear. We use
+         * a copy of the skb pointer to ensure other threads can't change it
+         * while we're notifying the stack.
+         */
+        tp->ptp_tx_skb = NULL;
+
+        /* Notify the stack and free the skb after we've unlocked */
+        skb_tstamp_tx(skb, &shhwtstamps);
+        dev_kfree_skb_any(skb);
+}
+
+#define RTL8125_PTP_TX_TIMEOUT      (HZ * 15)
+static void rtl8125_ptp_tx_work(struct work_struct *work)
+{
+        struct rtl8125_private *tp = container_of(work, struct rtl8125_private,
+                                     ptp_tx_work);
+        unsigned long flags;
+
+        spin_lock_irqsave(&tp->lock, flags);
+
+        if (!tp->ptp_tx_skb)
+                goto Exit;
+
+        if (time_is_before_jiffies(tp->ptp_tx_start +
+                                   RTL8125_PTP_TX_TIMEOUT)) {
+                dev_kfree_skb_any(tp->ptp_tx_skb);
+                tp->ptp_tx_skb = NULL;
+                tp->tx_hwtstamp_timeouts++;
+                /* Clear the tx valid bit in TSYNCTXCTL register to enable
+                 * interrupt
+                 */
+                RTL_W8(tp, PTP_ISR_8125, PTP_ISR_TOK | PTP_ISR_TER);
+                goto Exit;
+        }
+
+        if (RTL_R8(tp, PTP_ISR_8125) & (PTP_ISR_TOK))
+                rtl8125_ptp_tx_hwtstamp(tp);
+        else
+                /* reschedule to check later */
+                schedule_work(&tp->ptp_tx_work);
+
+Exit:
+        spin_unlock_irqrestore(&tp->lock, flags);
+}
+
+static int rtl8125_hwtstamp_enable(struct rtl8125_private *tp, bool enable)
+{
+        RTL_W16(tp, PTP_CTRL_8125, 0);
+        if (enable) {
+                u16 ptp_ctrl;
+                struct timespec64 ts64;
+
+                //clear ptp isr
+                RTL_W8(tp, PTP_ISR_8125, 0xff);
+                //ptp source 0:gphy 1:mac
+                rtl8125_mac_ocp_write(tp, 0xDC00, rtl8125_mac_ocp_read(tp, 0xDC00) | BIT_6);
+                //enable ptp
+                ptp_ctrl = (BIT_0 | BIT_3 | BIT_4 | BIT_6 | BIT_10 | BIT_12 | BIT_13);
+                if (tp->ptp_master_mode) {
+                        ptp_ctrl &= ~BIT_13;
+                        ptp_ctrl |= BIT_1;
+                }
+                RTL_W16(tp, PTP_CTRL_8125, ptp_ctrl);
+
+                //set system time
+                /*
+                if (ktime_to_timespec64_cond(ktime_get_real(), &ts64))
+                _rtl8125_phc_settime(tp, timespec64_to_timespec(ts64));
+                */
+                ktime_get_real_ts64(&ts64);
+                ts64.tv_nsec += tp->ptp_adjust;
+                _rtl8125_phc_settime(tp, &ts64);
+                tp->ptp_adjust = 0;
+        }
+
+        return 0;
+}
+
+static long rtl8125_ptp_create_clock(struct rtl8125_private *tp)
+{
+        struct net_device *netdev = tp->dev;
+        long err;
+
+        if (!IS_ERR_OR_NULL(tp->ptp_clock))
+                return 0;
+
+        if (tp->HwSuppPtpVer == 0) {
+                tp->ptp_clock = NULL;
+                return -EOPNOTSUPP;
+        }
+
+        tp->ptp_clock_info = rtl_ptp_clock_info;
+        snprintf(tp->ptp_clock_info.name, sizeof(tp->ptp_clock_info.name),
+                 "%pm", tp->dev->dev_addr);
+        tp->ptp_clock_info.max_adj = 119304647;
+        tp->ptp_clock = ptp_clock_register(&tp->ptp_clock_info, &tp->pci_dev->dev);
+        if (IS_ERR(tp->ptp_clock)) {
+                err = PTR_ERR(tp->ptp_clock);
+                tp->ptp_clock = NULL;
+                netif_err(tp, drv, tp->dev, "ptp_clock_register failed\n");
+                return err;
+        } else
+                netif_info(tp, drv, tp->dev, "registered PHC device on %s\n", netdev->name);
+
+        return 0;
+}
+
+void rtl8125_ptp_reset(struct rtl8125_private *tp)
+{
+        if (!tp->ptp_clock)
+                return;
+
+        netif_info(tp, drv, tp->dev, "reset PHC clock\n");
+
+        rtl8125_hwtstamp_enable(tp, false);
+}
+
+void rtl8125_ptp_init(struct rtl8125_private *tp)
+{
+        /* obtain a PTP device, or re-use an existing device */
+        if (rtl8125_ptp_create_clock(tp))
+                return;
+
+        /* we have a clock so we can initialize work now */
+        INIT_WORK(&tp->ptp_tx_work, rtl8125_ptp_tx_work);
+
+        tp->ptp_adjust = 0;
+
+        /* reset the PTP related hardware bits */
+        rtl8125_ptp_reset(tp);
+
+        return;
+}
+
+void rtl8125_ptp_suspend(struct rtl8125_private *tp)
+{
+        if (!tp->ptp_clock)
+                return;
+
+        netif_info(tp, drv, tp->dev, "suspend PHC clock\n");
+
+        rtl8125_hwtstamp_enable(tp, false);
+
+        /* ensure that we cancel any pending PTP Tx work item in progress */
+        cancel_work_sync(&tp->ptp_tx_work);
+}
+
+void rtl8125_ptp_stop(struct rtl8125_private *tp)
+{
+        struct net_device *netdev = tp->dev;
+
+        netif_info(tp, drv, tp->dev, "stop PHC clock\n");
+
+        /* first, suspend PTP activity */
+        rtl8125_ptp_suspend(tp);
+
+        /* disable the PTP clock device */
+        if (tp->ptp_clock) {
+                ptp_clock_unregister(tp->ptp_clock);
+                tp->ptp_clock = NULL;
+                netif_info(tp, drv, tp->dev, "removed PHC on %s\n",
+                           netdev->name);
+        }
+}
+
+static int rtl8125_set_tstamp(struct net_device *netdev, struct ifreq *ifr)
+{
+        struct rtl8125_private *tp = netdev_priv(netdev);
+        struct hwtstamp_config config;
+        bool hwtstamp = 0;
+
+        //netif_info(tp, drv, tp->dev, "ptp set ts\n");
+
+        if (copy_from_user(&config, ifr->ifr_data, sizeof(config)))
+                return -EFAULT;
+
+        if (config.flags)
+                return -EINVAL;
+
+        switch (config.tx_type) {
+        case HWTSTAMP_TX_ON:
+                hwtstamp = 1;
+        case HWTSTAMP_TX_OFF:
+                break;
+        case HWTSTAMP_TX_ONESTEP_SYNC:
+        default:
+                return -ERANGE;
+        }
+
+        switch (config.rx_filter) {
+        case HWTSTAMP_FILTER_PTP_V2_EVENT:
+        case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
+        case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
+        case HWTSTAMP_FILTER_PTP_V2_SYNC:
+        case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
+        case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
+        case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
+        case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
+        case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
+                config.rx_filter = HWTSTAMP_FILTER_PTP_V2_EVENT;
+                hwtstamp = 1;
+        case HWTSTAMP_FILTER_NONE:
+                break;
+        default:
+                return -ERANGE;
+        }
+
+        if (tp->hwtstamp_config.tx_type != config.tx_type ||
+            tp->hwtstamp_config.rx_filter != config.rx_filter) {
+                tp->hwtstamp_config = config;
+                rtl8125_hwtstamp_enable(tp, hwtstamp);
+        }
+
+        return copy_to_user(ifr->ifr_data, &config,
+                            sizeof(config)) ? -EFAULT : 0;
+}
+
+static int rtl8125_get_tstamp(struct net_device *netdev, struct ifreq *ifr)
+{
+        struct rtl8125_private *tp = netdev_priv(netdev);
+
+        //netif_info(tp, drv, tp->dev, "ptp get ts\n");
+
+        return copy_to_user(ifr->ifr_data, &tp->hwtstamp_config,
+                            sizeof(tp->hwtstamp_config)) ? -EFAULT : 0;
+}
+
+int rtl8125_ptp_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
+{
+        struct rtl8125_private *tp = netdev_priv(netdev);
+        int ret;
+        unsigned long flags;
+
+        //netif_info(tp, drv, tp->dev, "ptp ioctl\n");
+
+        ret = 0;
+        switch (cmd) {
+#ifdef ENABLE_PTP_SUPPORT
+        case SIOCSHWTSTAMP:
+                spin_lock_irqsave(&tp->lock, flags);
+                ret = rtl8125_set_tstamp(netdev, ifr);
+                spin_unlock_irqrestore(&tp->lock, flags);
+                break;
+        case SIOCGHWTSTAMP:
+                spin_lock_irqsave(&tp->lock, flags);
+                ret = rtl8125_get_tstamp(netdev, ifr);
+                spin_unlock_irqrestore(&tp->lock, flags);
+                break;
+#endif
+        default:
+                ret = -EOPNOTSUPP;
+                break;
+        }
+
+        return ret;
+}
+
+void rtl8125_rx_ptp_pktstamp(struct rtl8125_private *tp, struct sk_buff *skb,
+                             struct RxDescV3 *descv3)
+{
+        time64_t tv_sec;
+        long tv_nsec;
+
+        tv_sec = le32_to_cpu(descv3->RxDescTimeStamp.TimeStampHigh) +
+                 ((u64)le32_to_cpu(descv3->RxDescPTPDDWord4.TimeStampHHigh) << 32);
+        tv_nsec = le32_to_cpu(descv3->RxDescTimeStamp.TimeStampLow) + tp->ptp_adjust;
+
+        skb_hwtstamps(skb)->hwtstamp = ktime_set(tv_sec, tv_nsec);
+}
Index: kernel-rockchip/drivers/net/ethernet/realtek/r8125/r8125_ptp.h
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/net/ethernet/realtek/r8125/r8125_ptp.h
@@ -0,0 +1,81 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2022 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_rtl8125_PTP_H
+#define _LINUX_rtl8125_PTP_H
+
+#include <linux/ktime.h>
+#include <linux/timecounter.h>
+#include <linux/net_tstamp.h>
+#include <linux/ptp_clock_kernel.h>
+#include <linux/ptp_classify.h>
+
+struct rtl8125_ptp_info {
+        s64 time_sec;
+        u32 time_ns;
+        u16 ts_info;
+};
+
+#ifndef _STRUCT_TIMESPEC
+#define _STRUCT_TIMESPEC
+struct timespec {
+        __kernel_old_time_t tv_sec;     /* seconds */
+        long            tv_nsec;    /* nanoseconds */
+};
+#endif
+
+enum PTP_CMD_TYPE {
+        PTP_CMD_SET_LOCAL_TIME = 0,
+        PTP_CMD_DRIFT_LOCAL_TIME,
+        PTP_CMD_LATCHED_LOCAL_TIME,
+};
+
+
+struct rtl8125_private;
+struct RxDescV3;
+
+int rtl8125_get_ts_info(struct net_device *netdev,
+                        struct ethtool_ts_info *info);
+
+void rtl8125_ptp_reset(struct rtl8125_private *tp);
+void rtl8125_ptp_init(struct rtl8125_private *tp);
+void rtl8125_ptp_suspend(struct rtl8125_private *tp);
+void rtl8125_ptp_stop(struct rtl8125_private *tp);
+
+int rtl8125_ptp_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd);
+
+void rtl8125_rx_ptp_pktstamp(struct rtl8125_private *tp, struct sk_buff *skb,
+                             struct RxDescV3 *descv3);
+
+#endif /* _LINUX_rtl8125_PTP_H */
Index: kernel-rockchip/drivers/net/ethernet/realtek/r8125/r8125_realwow.h
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/net/ethernet/realtek/r8125/r8125_realwow.h
@@ -0,0 +1,118 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2022 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_R8125_REALWOW_H
+#define _LINUX_R8125_REALWOW_H
+
+#define SIOCDEVPRIVATE_RTLREALWOW   SIOCDEVPRIVATE+3
+
+#define MAX_RealWoW_KCP_SIZE (100)
+#define MAX_RealWoW_Payload (64)
+
+#define KA_TX_PACKET_SIZE (100)
+#define KA_WAKEUP_PATTERN_SIZE (120)
+
+//HwSuppKeepAliveOffloadVer
+#define HW_SUPPORT_KCP_OFFLOAD(_M)        ((_M)->HwSuppKCPOffloadVer > 0)
+
+enum rtl_realwow_cmd {
+
+        RTL_REALWOW_SET_KCP_DISABLE=0,
+        RTL_REALWOW_SET_KCP_INFO,
+        RTL_REALWOW_SET_KCP_CONTENT,
+
+        RTL_REALWOW_SET_KCP_ACKPKTINFO,
+        RTL_REALWOW_SET_KCP_WPINFO,
+        RTL_REALWOW_SET_KCPDHCP_TIMEOUT,
+
+        RTLT_REALWOW_COMMAND_INVALID
+};
+
+struct rtl_realwow_ioctl_struct {
+        __u32	cmd;
+        __u32	offset;
+        __u32	len;
+        union {
+                __u32	data;
+                void *data_buffer;
+        };
+};
+
+typedef struct _MP_KCPInfo {
+        u8 DIPv4[4];
+        u8 MacID[6];
+        u16 UdpPort[2];
+        u8 PKTLEN[2];
+
+        u16 ackLostCnt;
+        u8 KCP_WakePattern[MAX_RealWoW_Payload];
+        u8 KCP_AckPacket[MAX_RealWoW_Payload];
+        u32 KCP_interval;
+        u8 KCP_WakePattern_Len;
+        u8 KCP_AckPacket_Len;
+        u8 KCP_TxPacket[2][KA_TX_PACKET_SIZE];
+} MP_KCP_INFO, *PMP_KCP_INFO;
+
+typedef struct _KCPInfo {
+        u32 nId; // = id
+        u8 DIPv4[4];
+        u8 MacID[6];
+        u16 UdpPort;
+        u16 PKTLEN;
+} KCPInfo, *PKCPInfo;
+
+typedef struct _KCPContent {
+        u32 id; // = id
+        u32 mSec; // = msec
+        u32 size; // =size
+        u8 bPacket[MAX_RealWoW_KCP_SIZE]; // put packet here
+} KCPContent, *PKCPContent;
+
+typedef struct _RealWoWAckPktInfo {
+        u16 ackLostCnt;
+        u16 patterntSize;
+        u8 pattern[MAX_RealWoW_Payload];
+} RealWoWAckPktInfo,*PRealWoWAckPktInfo;
+
+typedef struct _RealWoWWPInfo {
+        u16 patterntSize;
+        u8 pattern[MAX_RealWoW_Payload];
+} RealWoWWPInfo,*PRealWoWWPInfo;
+
+int rtl8125_realwow_ioctl(struct net_device *dev, struct ifreq *ifr);
+void rtl8125_realwow_hw_init(struct net_device *dev);
+void rtl8125_get_realwow_hw_version(struct net_device *dev);
+void rtl8125_set_realwow_d3_para(struct net_device *dev);
+
+#endif /* _LINUX_R8125_REALWOW_H */
Index: kernel-rockchip/drivers/net/ethernet/realtek/r8125/r8125_rss.c
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/net/ethernet/realtek/r8125/r8125_rss.c
@@ -0,0 +1,481 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+################################################################################
+#
+# r8168 is the Linux device driver released for Realtek Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2022 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#include <linux/version.h>
+#include "r8125.h"
+
+enum rtl8125_rss_register_content {
+        /* RSS */
+        RSS_CTRL_TCP_IPV4_SUPP = (1 << 0),
+        RSS_CTRL_IPV4_SUPP  = (1 << 1),
+        RSS_CTRL_TCP_IPV6_SUPP  = (1 << 2),
+        RSS_CTRL_IPV6_SUPP  = (1 << 3),
+        RSS_HALF_SUPP  = (1 << 7),
+        RSS_CTRL_UDP_IPV4_SUPP  = (1 << 11),
+        RSS_CTRL_UDP_IPV6_SUPP  = (1 << 12),
+        RSS_QUAD_CPU_EN  = (1 << 16),
+        RSS_HQ_Q_SUP_R  = (1 << 31),
+};
+
+static int rtl8125_get_rss_hash_opts(struct rtl8125_private *tp,
+                                     struct ethtool_rxnfc *cmd)
+{
+        cmd->data = 0;
+
+        /* Report default options for RSS */
+        switch (cmd->flow_type) {
+        case TCP_V4_FLOW:
+                cmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
+        /* fallthrough */
+        case UDP_V4_FLOW:
+                if (tp->rss_flags & RTL_8125_RSS_FLAG_HASH_UDP_IPV4)
+                        cmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
+        /* fallthrough */
+        case IPV4_FLOW:
+                cmd->data |= RXH_IP_SRC | RXH_IP_DST;
+                break;
+        case TCP_V6_FLOW:
+                cmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
+        /* fallthrough */
+        case UDP_V6_FLOW:
+                if (tp->rss_flags & RTL_8125_RSS_FLAG_HASH_UDP_IPV6)
+                        cmd->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
+        /* fallthrough */
+        case IPV6_FLOW:
+                cmd->data |= RXH_IP_SRC | RXH_IP_DST;
+                break;
+        default:
+                return -EINVAL;
+        }
+
+        return 0;
+}
+
+int rtl8125_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,
+                      u32 *rule_locs)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int ret = -EOPNOTSUPP;
+
+        netif_info(tp, drv, tp->dev, "rss get rxnfc\n");
+
+        if (!(dev->features & NETIF_F_RXHASH))
+                return ret;
+
+        switch (cmd->cmd) {
+        case ETHTOOL_GRXRINGS:
+                cmd->data = rtl8125_tot_rx_rings(tp);
+                ret = 0;
+                break;
+        case ETHTOOL_GRXFH:
+                ret = rtl8125_get_rss_hash_opts(tp, cmd);
+                break;
+        default:
+                break;
+        }
+
+        return ret;
+}
+
+u32 rtl8125_rss_indir_tbl_entries(struct rtl8125_private *tp)
+{
+        return tp->HwSuppIndirTblEntries;
+}
+
+#define RSS_MASK_BITS_OFFSET (8)
+#define RSS_CPU_NUM_OFFSET (16)
+#define RTL8125_UDP_RSS_FLAGS (RTL_8125_RSS_FLAG_HASH_UDP_IPV4 | \
+		       RTL_8125_RSS_FLAG_HASH_UDP_IPV6)
+static int _rtl8125_set_rss_hash_opt(struct rtl8125_private *tp)
+{
+        u32 rss_flags = tp->rss_flags;
+        u32 hash_mask_len;
+        u32 rss_ctrl;
+
+        rss_ctrl = ilog2(rtl8125_tot_rx_rings(tp));
+        rss_ctrl &= (BIT_0 | BIT_1 | BIT_2);
+        rss_ctrl <<= RSS_CPU_NUM_OFFSET;
+
+        /* Perform hash on these packet types */
+        rss_ctrl |= RSS_CTRL_TCP_IPV4_SUPP
+                    | RSS_CTRL_IPV4_SUPP
+                    | RSS_CTRL_IPV6_SUPP
+                    | RSS_CTRL_TCP_IPV6_SUPP;
+
+        if (rss_flags & RTL_8125_RSS_FLAG_HASH_UDP_IPV4)
+                rss_ctrl |= RSS_CTRL_UDP_IPV4_SUPP;
+
+        if (rss_flags & RTL_8125_RSS_FLAG_HASH_UDP_IPV6)
+                rss_ctrl |= RSS_CTRL_UDP_IPV6_SUPP;
+
+        hash_mask_len = ilog2(rtl8125_rss_indir_tbl_entries(tp));
+        hash_mask_len &= (BIT_0 | BIT_1 | BIT_2);
+        rss_ctrl |= hash_mask_len << RSS_MASK_BITS_OFFSET;
+
+        RTL_W32(tp, RSS_CTRL_8125, rss_ctrl);
+
+        return 0;
+}
+
+static int rtl8125_set_rss_hash_opt(struct rtl8125_private *tp,
+                                    struct ethtool_rxnfc *nfc)
+{
+        u32 rss_flags = tp->rss_flags;
+
+        netif_info(tp, drv, tp->dev, "rss set hash\n");
+
+        /*
+         * RSS does not support anything other than hashing
+         * to queues on src and dst IPs and ports
+         */
+        if (nfc->data & ~(RXH_IP_SRC | RXH_IP_DST |
+                          RXH_L4_B_0_1 | RXH_L4_B_2_3))
+                return -EINVAL;
+
+        switch (nfc->flow_type) {
+        case TCP_V4_FLOW:
+        case TCP_V6_FLOW:
+                if (!(nfc->data & RXH_IP_SRC) ||
+                    !(nfc->data & RXH_IP_DST) ||
+                    !(nfc->data & RXH_L4_B_0_1) ||
+                    !(nfc->data & RXH_L4_B_2_3))
+                        return -EINVAL;
+                break;
+        case UDP_V4_FLOW:
+                if (!(nfc->data & RXH_IP_SRC) ||
+                    !(nfc->data & RXH_IP_DST))
+                        return -EINVAL;
+                switch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {
+                case 0:
+                        rss_flags &= ~RTL_8125_RSS_FLAG_HASH_UDP_IPV4;
+                        break;
+                case (RXH_L4_B_0_1 | RXH_L4_B_2_3):
+                        rss_flags |= RTL_8125_RSS_FLAG_HASH_UDP_IPV4;
+                        break;
+                default:
+                        return -EINVAL;
+                }
+                break;
+        case UDP_V6_FLOW:
+                if (!(nfc->data & RXH_IP_SRC) ||
+                    !(nfc->data & RXH_IP_DST))
+                        return -EINVAL;
+                switch (nfc->data & (RXH_L4_B_0_1 | RXH_L4_B_2_3)) {
+                case 0:
+                        rss_flags &= ~RTL_8125_RSS_FLAG_HASH_UDP_IPV6;
+                        break;
+                case (RXH_L4_B_0_1 | RXH_L4_B_2_3):
+                        rss_flags |= RTL_8125_RSS_FLAG_HASH_UDP_IPV6;
+                        break;
+                default:
+                        return -EINVAL;
+                }
+                break;
+        case SCTP_V4_FLOW:
+        case AH_ESP_V4_FLOW:
+        case AH_V4_FLOW:
+        case ESP_V4_FLOW:
+        case SCTP_V6_FLOW:
+        case AH_ESP_V6_FLOW:
+        case AH_V6_FLOW:
+        case ESP_V6_FLOW:
+        case IP_USER_FLOW:
+        case ETHER_FLOW:
+                /* RSS is not supported for these protocols */
+                if (nfc->data) {
+                        netif_err(tp, drv, tp->dev, "Command parameters not supported\n");
+                        return -EINVAL;
+                }
+                return 0;
+                break;
+        default:
+                return -EINVAL;
+        }
+
+        /* if we changed something we need to update flags */
+        if (rss_flags != tp->rss_flags) {
+                u32 rss_ctrl = RTL_R32(tp, RSS_CTRL_8125);
+
+                if ((rss_flags & RTL8125_UDP_RSS_FLAGS) &&
+                    !(tp->rss_flags & RTL8125_UDP_RSS_FLAGS))
+                        netdev_warn(tp->dev,
+                                    "enabling UDP RSS: fragmented packets may "
+                                    "arrive out of order to the stack above\n");
+
+                tp->rss_flags = rss_flags;
+
+                /* Perform hash on these packet types */
+                rss_ctrl |= RSS_CTRL_TCP_IPV4_SUPP
+                            | RSS_CTRL_IPV4_SUPP
+                            | RSS_CTRL_IPV6_SUPP
+                            | RSS_CTRL_TCP_IPV6_SUPP;
+
+                rss_ctrl &= ~(RSS_CTRL_UDP_IPV4_SUPP |
+                              RSS_CTRL_UDP_IPV6_SUPP);
+
+                if (rss_flags & RTL_8125_RSS_FLAG_HASH_UDP_IPV4)
+                        rss_ctrl |= RSS_CTRL_UDP_IPV4_SUPP;
+
+                if (rss_flags & RTL_8125_RSS_FLAG_HASH_UDP_IPV6)
+                        rss_ctrl |= RSS_CTRL_UDP_IPV6_SUPP;
+
+                RTL_W32(tp, RSS_CTRL_8125, rss_ctrl);
+        }
+
+        return 0;
+}
+
+int rtl8125_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int ret = -EOPNOTSUPP;
+
+        netif_info(tp, drv, tp->dev, "rss set rxnfc\n");
+
+        if (!(dev->features & NETIF_F_RXHASH))
+                return ret;
+
+        switch (cmd->cmd) {
+        case ETHTOOL_SRXFH:
+                ret = rtl8125_set_rss_hash_opt(tp, cmd);
+                break;
+        default:
+                break;
+        }
+
+        return ret;
+}
+
+static u32 _rtl8125_get_rxfh_key_size(struct rtl8125_private *tp)
+{
+        return sizeof(tp->rss_key);
+}
+
+u32 rtl8125_get_rxfh_key_size(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        netif_info(tp, drv, tp->dev, "rss get key size\n");
+
+        if (!(dev->features & NETIF_F_RXHASH))
+                return 0;
+
+        return _rtl8125_get_rxfh_key_size(tp);
+}
+
+u32 rtl8125_rss_indir_size(struct net_device *dev)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        netif_info(tp, drv, tp->dev, "rss get indir tbl size\n");
+
+        if (!(dev->features & NETIF_F_RXHASH))
+                return 0;
+
+        return rtl8125_rss_indir_tbl_entries(tp);
+}
+
+static void rtl8125_get_reta(struct rtl8125_private *tp, u32 *indir)
+{
+        int i, reta_size = rtl8125_rss_indir_tbl_entries(tp);
+
+        for (i = 0; i < reta_size; i++)
+                indir[i] = tp->rss_indir_tbl[i];
+}
+
+int rtl8125_get_rxfh(struct net_device *dev, u32 *indir, u8 *key,
+                     u8 *hfunc)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+
+        netif_info(tp, drv, tp->dev, "rss get rxfh\n");
+
+        if (!(dev->features & NETIF_F_RXHASH))
+                return -EOPNOTSUPP;
+
+        if (hfunc)
+                *hfunc = ETH_RSS_HASH_TOP;
+
+        if (indir)
+                rtl8125_get_reta(tp, indir);
+
+        if (key)
+                memcpy(key, tp->rss_key, rtl8125_get_rxfh_key_size(dev));
+
+        return 0;
+}
+
+static u32 rtl8125_rss_key_reg(struct rtl8125_private *tp)
+{
+        return RSS_KEY_8125;
+}
+
+static u32 rtl8125_rss_indir_tbl_reg(struct rtl8125_private *tp)
+{
+        return RSS_INDIRECTION_TBL_8125_V2;
+}
+
+static void rtl8125_store_reta(struct rtl8125_private *tp)
+{
+        u16 indir_tbl_reg = rtl8125_rss_indir_tbl_reg(tp);
+        u32 i, reta_entries = rtl8125_rss_indir_tbl_entries(tp);
+        u32 reta = 0;
+        u8 *indir_tbl = tp->rss_indir_tbl;
+
+        /* Write redirection table to HW */
+        for (i = 0; i < reta_entries; i++) {
+                reta |= indir_tbl[i] << (i & 0x3) * 8;
+                if ((i & 3) == 3) {
+                        RTL_W32(tp, indir_tbl_reg, reta);
+
+                        indir_tbl_reg += 4;
+                        reta = 0;
+                }
+        }
+}
+
+static void rtl8125_store_rss_key(struct rtl8125_private *tp)
+{
+        const u16 rss_key_reg = rtl8125_rss_key_reg(tp);
+        u32 i, rss_key_size = _rtl8125_get_rxfh_key_size(tp);
+        u32 *rss_key = (u32*)tp->rss_key;
+
+        /* Write redirection table to HW */
+        for (i = 0; i < rss_key_size; i+=4)
+                RTL_W32(tp, rss_key_reg + i, *rss_key++);
+}
+
+int rtl8125_set_rxfh(struct net_device *dev, const u32 *indir,
+                     const u8 *key, const u8 hfunc)
+{
+        struct rtl8125_private *tp = netdev_priv(dev);
+        int i;
+        u32 reta_entries = rtl8125_rss_indir_tbl_entries(tp);
+
+        netif_info(tp, drv, tp->dev, "rss set rxfh\n");
+
+        /* We require at least one supported parameter to be changed and no
+         * change in any of the unsupported parameters
+         */
+        if (hfunc != ETH_RSS_HASH_NO_CHANGE && hfunc != ETH_RSS_HASH_TOP)
+                return -EOPNOTSUPP;
+
+        /* Fill out the redirection table */
+        if (indir) {
+                int max_queues = tp->num_rx_rings;
+
+                /* Verify user input. */
+                for (i = 0; i < reta_entries; i++)
+                        if (indir[i] >= max_queues)
+                                return -EINVAL;
+
+                for (i = 0; i < reta_entries; i++)
+                        tp->rss_indir_tbl[i] = indir[i];
+        }
+
+        /* Fill out the rss hash key */
+        if (key)
+                memcpy(tp->rss_key, key, rtl8125_get_rxfh_key_size(dev));
+
+        rtl8125_store_reta(tp);
+
+        rtl8125_store_rss_key(tp);
+
+        return 0;
+}
+
+static u32 rtl8125_get_rx_desc_hash(struct rtl8125_private *tp,
+                                    struct RxDescV3 *descv3)
+{
+        return le32_to_cpu(descv3->RxDescNormalDDWord2.RSSResult);
+}
+
+#define RXS_8125B_RSS_UDP BIT(9)
+#define RXS_8125_RSS_IPV4 BIT(10)
+#define RXS_8125_RSS_IPV6 BIT(12)
+#define RXS_8125_RSS_TCP BIT(13)
+#define RTL8125_RXS_RSS_L3_TYPE_MASK (RXS_8125_RSS_IPV4 | RXS_8125_RSS_IPV6)
+#define RTL8125_RXS_RSS_L4_TYPE_MASK (RXS_8125_RSS_TCP | RXS_8125B_RSS_UDP)
+void rtl8125_rx_hash(struct rtl8125_private *tp,
+                     struct RxDescV3 *descv3,
+                     struct sk_buff *skb)
+{
+        u16 rss_header_info;
+
+        if (!(tp->dev->features & NETIF_F_RXHASH))
+                return;
+
+        rss_header_info = le16_to_cpu(descv3->RxDescNormalDDWord2.HeaderInfo);
+
+        if (!(rss_header_info & RTL8125_RXS_RSS_L3_TYPE_MASK))
+                return;
+
+        skb_set_hash(skb, rtl8125_get_rx_desc_hash(tp, descv3),
+                     (RTL8125_RXS_RSS_L4_TYPE_MASK & rss_header_info) ?
+                     PKT_HASH_TYPE_L4 : PKT_HASH_TYPE_L3);
+}
+
+void rtl8125_disable_rss(struct rtl8125_private *tp)
+{
+        RTL_W32(tp, RSS_CTRL_8125, 0x00);
+}
+
+void _rtl8125_config_rss(struct rtl8125_private *tp)
+{
+        _rtl8125_set_rss_hash_opt(tp);
+
+        rtl8125_store_reta(tp);
+
+        rtl8125_store_rss_key(tp);
+}
+
+void rtl8125_config_rss(struct rtl8125_private *tp)
+{
+        if (!tp->EnableRss) {
+                rtl8125_disable_rss(tp);
+                return;
+        }
+
+        _rtl8125_config_rss(tp);
+}
+
+void rtl8125_init_rss(struct rtl8125_private *tp)
+{
+        int i;
+
+        for (i = 0; i < rtl8125_rss_indir_tbl_entries(tp); i++)
+                tp->rss_indir_tbl[i] = ethtool_rxfh_indir_default(i, tp->num_rx_rings);
+
+        netdev_rss_key_fill(tp->rss_key, RTL8125_RSS_KEY_SIZE);
+}
Index: kernel-rockchip/drivers/net/ethernet/realtek/r8125/r8125_rss.h
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/net/ethernet/realtek/r8125/r8125_rss.h
@@ -0,0 +1,69 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2022 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_rtl8125_RSS_H
+#define _LINUX_rtl8125_RSS_H
+
+#include <linux/netdevice.h>
+#include <linux/types.h>
+
+#define RTL8125_RSS_KEY_SIZE     40  /* size of RSS Hash Key in bytes */
+#define RTL8125_MAX_INDIRECTION_TABLE_ENTRIES 128
+
+enum rtl8125_rss_flag {
+        RTL_8125_RSS_FLAG_HASH_UDP_IPV4  = (1 << 0),
+        RTL_8125_RSS_FLAG_HASH_UDP_IPV6  = (1 << 1),
+};
+
+struct rtl8125_private;
+
+int rtl8125_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,
+                      u32 *rule_locs);
+int rtl8125_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd);
+u32 rtl8125_get_rxfh_key_size(struct net_device *netdev);
+u32 rtl8125_rss_indir_size(struct net_device *netdev);
+int rtl8125_get_rxfh(struct net_device *netdev, u32 *indir, u8 *key,
+                     u8 *hfunc);
+int rtl8125_set_rxfh(struct net_device *netdev, const u32 *indir,
+                     const u8 *key, const u8 hfunc);
+void rtl8125_rx_hash(struct rtl8125_private *tp,
+                     struct RxDescV3 *descv3,
+                     struct sk_buff *skb);
+void _rtl8125_config_rss(struct rtl8125_private *tp);
+void rtl8125_config_rss(struct rtl8125_private *tp);
+void rtl8125_init_rss(struct rtl8125_private *tp);
+u32 rtl8125_rss_indir_tbl_entries(struct rtl8125_private *tp);
+void rtl8125_disable_rss(struct rtl8125_private *tp);
+
+#endif /* _LINUX_rtl8125_RSS_H */
Index: kernel-rockchip/drivers/net/ethernet/realtek/r8125/rtl_eeprom.c
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/net/ethernet/realtek/r8125/rtl_eeprom.c
@@ -0,0 +1,289 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2022 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/ethtool.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+
+#include "r8125.h"
+#include "rtl_eeprom.h"
+
+//-------------------------------------------------------------------
+//rtl8125_eeprom_type():
+//  tell the eeprom type
+//return value:
+//  0: the eeprom type is 93C46
+//  1: the eeprom type is 93C56 or 93C66
+//-------------------------------------------------------------------
+void rtl8125_eeprom_type(struct rtl8125_private *tp)
+{
+        u16 magic = 0;
+
+        if (tp->mcfg == CFG_METHOD_DEFAULT)
+                goto out_no_eeprom;
+
+        if(RTL_R8(tp, 0xD2)&0x04) {
+                //not support
+                //tp->eeprom_type = EEPROM_TWSI;
+                //tp->eeprom_len = 256;
+                goto out_no_eeprom;
+        } else if(RTL_R32(tp, RxConfig) & RxCfg_9356SEL) {
+                tp->eeprom_type = EEPROM_TYPE_93C56;
+                tp->eeprom_len = 256;
+        } else {
+                tp->eeprom_type = EEPROM_TYPE_93C46;
+                tp->eeprom_len = 128;
+        }
+
+        magic = rtl8125_eeprom_read_sc(tp, 0);
+
+out_no_eeprom:
+        if ((magic != 0x8129) && (magic != 0x8128)) {
+                tp->eeprom_type = EEPROM_TYPE_NONE;
+                tp->eeprom_len = 0;
+        }
+}
+
+void rtl8125_eeprom_cleanup(struct rtl8125_private *tp)
+{
+        u8 x;
+
+        x = RTL_R8(tp, Cfg9346);
+        x &= ~(Cfg9346_EEDI | Cfg9346_EECS);
+
+        RTL_W8(tp, Cfg9346, x);
+
+        rtl8125_raise_clock(tp, &x);
+        rtl8125_lower_clock(tp, &x);
+}
+
+int rtl8125_eeprom_cmd_done(struct rtl8125_private *tp)
+{
+        u8 x;
+        int i;
+
+        rtl8125_stand_by(tp);
+
+        for (i = 0; i < 50000; i++) {
+                x = RTL_R8(tp, Cfg9346);
+
+                if (x & Cfg9346_EEDO) {
+                        udelay(RTL_CLOCK_RATE * 2 * 3);
+                        return 0;
+                }
+                udelay(1);
+        }
+
+        return -1;
+}
+
+//-------------------------------------------------------------------
+//rtl8125_eeprom_read_sc():
+//  read one word from eeprom
+//-------------------------------------------------------------------
+u16 rtl8125_eeprom_read_sc(struct rtl8125_private *tp, u16 reg)
+{
+        int addr_sz = 6;
+        u8 x;
+        u16 data;
+
+        if(tp->eeprom_type == EEPROM_TYPE_NONE) {
+                return -1;
+        }
+
+        if (tp->eeprom_type==EEPROM_TYPE_93C46)
+                addr_sz = 6;
+        else if (tp->eeprom_type==EEPROM_TYPE_93C56)
+                addr_sz = 8;
+
+        x = Cfg9346_EEM1 | Cfg9346_EECS;
+        RTL_W8(tp, Cfg9346, x);
+
+        rtl8125_shift_out_bits(tp, RTL_EEPROM_READ_OPCODE, 3);
+        rtl8125_shift_out_bits(tp, reg, addr_sz);
+
+        data = rtl8125_shift_in_bits(tp);
+
+        rtl8125_eeprom_cleanup(tp);
+
+        RTL_W8(tp, Cfg9346, 0);
+
+        return data;
+}
+
+//-------------------------------------------------------------------
+//rtl8125_eeprom_write_sc():
+//  write one word to a specific address in the eeprom
+//-------------------------------------------------------------------
+void rtl8125_eeprom_write_sc(struct rtl8125_private *tp, u16 reg, u16 data)
+{
+        u8 x;
+        int addr_sz = 6;
+        int w_dummy_addr = 4;
+
+        if(tp->eeprom_type == EEPROM_TYPE_NONE) {
+                return ;
+        }
+
+        if (tp->eeprom_type==EEPROM_TYPE_93C46) {
+                addr_sz = 6;
+                w_dummy_addr = 4;
+        } else if (tp->eeprom_type==EEPROM_TYPE_93C56) {
+                addr_sz = 8;
+                w_dummy_addr = 6;
+        }
+
+        x = Cfg9346_EEM1 | Cfg9346_EECS;
+        RTL_W8(tp, Cfg9346, x);
+
+        rtl8125_shift_out_bits(tp, RTL_EEPROM_EWEN_OPCODE, 5);
+        rtl8125_shift_out_bits(tp, reg, w_dummy_addr);
+        rtl8125_stand_by(tp);
+
+        rtl8125_shift_out_bits(tp, RTL_EEPROM_ERASE_OPCODE, 3);
+        rtl8125_shift_out_bits(tp, reg, addr_sz);
+        if (rtl8125_eeprom_cmd_done(tp) < 0) {
+                return;
+        }
+        rtl8125_stand_by(tp);
+
+        rtl8125_shift_out_bits(tp, RTL_EEPROM_WRITE_OPCODE, 3);
+        rtl8125_shift_out_bits(tp, reg, addr_sz);
+        rtl8125_shift_out_bits(tp, data, 16);
+        if (rtl8125_eeprom_cmd_done(tp) < 0) {
+                return;
+        }
+        rtl8125_stand_by(tp);
+
+        rtl8125_shift_out_bits(tp, RTL_EEPROM_EWDS_OPCODE, 5);
+        rtl8125_shift_out_bits(tp, reg, w_dummy_addr);
+
+        rtl8125_eeprom_cleanup(tp);
+        RTL_W8(tp, Cfg9346, 0);
+}
+
+void rtl8125_raise_clock(struct rtl8125_private *tp, u8 *x)
+{
+        *x = *x | Cfg9346_EESK;
+        RTL_W8(tp, Cfg9346, *x);
+        udelay(RTL_CLOCK_RATE);
+}
+
+void rtl8125_lower_clock(struct rtl8125_private *tp, u8 *x)
+{
+
+        *x = *x & ~Cfg9346_EESK;
+        RTL_W8(tp, Cfg9346, *x);
+        udelay(RTL_CLOCK_RATE);
+}
+
+void rtl8125_shift_out_bits(struct rtl8125_private *tp, int data, int count)
+{
+        u8 x;
+        int  mask;
+
+        mask = 0x01 << (count - 1);
+        x = RTL_R8(tp, Cfg9346);
+        x &= ~(Cfg9346_EEDI | Cfg9346_EEDO);
+
+        do {
+                if (data & mask)
+                        x |= Cfg9346_EEDI;
+                else
+                        x &= ~Cfg9346_EEDI;
+
+                RTL_W8(tp, Cfg9346, x);
+                udelay(RTL_CLOCK_RATE);
+                rtl8125_raise_clock(tp, &x);
+                rtl8125_lower_clock(tp, &x);
+                mask = mask >> 1;
+        } while(mask);
+
+        x &= ~Cfg9346_EEDI;
+        RTL_W8(tp, Cfg9346, x);
+}
+
+u16 rtl8125_shift_in_bits(struct rtl8125_private *tp)
+{
+        u8 x;
+        u16 d, i;
+
+        x = RTL_R8(tp, Cfg9346);
+        x &= ~(Cfg9346_EEDI | Cfg9346_EEDO);
+
+        d = 0;
+
+        for (i = 0; i < 16; i++) {
+                d = d << 1;
+                rtl8125_raise_clock(tp, &x);
+
+                x = RTL_R8(tp, Cfg9346);
+                x &= ~Cfg9346_EEDI;
+
+                if (x & Cfg9346_EEDO)
+                        d |= 1;
+
+                rtl8125_lower_clock(tp, &x);
+        }
+
+        return d;
+}
+
+void rtl8125_stand_by(struct rtl8125_private *tp)
+{
+        u8 x;
+
+        x = RTL_R8(tp, Cfg9346);
+        x &= ~(Cfg9346_EECS | Cfg9346_EESK);
+        RTL_W8(tp, Cfg9346, x);
+        udelay(RTL_CLOCK_RATE);
+
+        x |= Cfg9346_EECS;
+        RTL_W8(tp, Cfg9346, x);
+}
+
+void rtl8125_set_eeprom_sel_low(struct rtl8125_private *tp)
+{
+        RTL_W8(tp, Cfg9346, Cfg9346_EEM1);
+        RTL_W8(tp, Cfg9346, Cfg9346_EEM1 | Cfg9346_EESK);
+
+        udelay(20);
+
+        RTL_W8(tp, Cfg9346, Cfg9346_EEM1);
+}
Index: kernel-rockchip/drivers/net/ethernet/realtek/r8125/rtl_eeprom.h
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/net/ethernet/realtek/r8125/rtl_eeprom.h
@@ -0,0 +1,53 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2022 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+//EEPROM opcodes
+#define RTL_EEPROM_READ_OPCODE      06
+#define RTL_EEPROM_WRITE_OPCODE     05
+#define RTL_EEPROM_ERASE_OPCODE     07
+#define RTL_EEPROM_EWEN_OPCODE      19
+#define RTL_EEPROM_EWDS_OPCODE      16
+
+#define RTL_CLOCK_RATE  3
+
+void rtl8125_eeprom_type(struct rtl8125_private *tp);
+void rtl8125_eeprom_cleanup(struct rtl8125_private *tp);
+u16 rtl8125_eeprom_read_sc(struct rtl8125_private *tp, u16 reg);
+void rtl8125_eeprom_write_sc(struct rtl8125_private *tp, u16 reg, u16 data);
+void rtl8125_shift_out_bits(struct rtl8125_private *tp, int data, int count);
+u16 rtl8125_shift_in_bits(struct rtl8125_private *tp);
+void rtl8125_raise_clock(struct rtl8125_private *tp, u8 *x);
+void rtl8125_lower_clock(struct rtl8125_private *tp, u8 *x);
+void rtl8125_stand_by(struct rtl8125_private *tp);
+void rtl8125_set_eeprom_sel_low(struct rtl8125_private *tp);
Index: kernel-rockchip/drivers/net/ethernet/realtek/r8125/rtltool.c
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/net/ethernet/realtek/r8125/rtltool.c
@@ -0,0 +1,260 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2022 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/pci.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <linux/in.h>
+#include <linux/ethtool.h>
+#include <asm/uaccess.h>
+#include "r8125.h"
+#include "rtl_eeprom.h"
+#include "rtltool.h"
+
+int rtl8125_tool_ioctl(struct rtl8125_private *tp, struct ifreq *ifr)
+{
+        struct rtltool_cmd my_cmd;
+        int ret;
+
+        if (copy_from_user(&my_cmd, ifr->ifr_data, sizeof(my_cmd)))
+                return -EFAULT;
+
+        ret = 0;
+        switch (my_cmd.cmd) {
+        case RTLTOOL_READ_MAC:
+                if (my_cmd.len==1)
+                        my_cmd.data = readb(tp->mmio_addr+my_cmd.offset);
+                else if (my_cmd.len==2)
+                        my_cmd.data = readw(tp->mmio_addr+(my_cmd.offset&~1));
+                else if (my_cmd.len==4)
+                        my_cmd.data = readl(tp->mmio_addr+(my_cmd.offset&~3));
+                else {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+                break;
+
+        case RTLTOOL_WRITE_MAC:
+                if (my_cmd.len==1)
+                        writeb(my_cmd.data, tp->mmio_addr+my_cmd.offset);
+                else if (my_cmd.len==2)
+                        writew(my_cmd.data, tp->mmio_addr+(my_cmd.offset&~1));
+                else if (my_cmd.len==4)
+                        writel(my_cmd.data, tp->mmio_addr+(my_cmd.offset&~3));
+                else {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+
+                break;
+
+        case RTLTOOL_READ_PHY:
+                my_cmd.data = rtl8125_mdio_prot_read(tp, my_cmd.offset);
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+
+                break;
+
+        case RTLTOOL_WRITE_PHY:
+                rtl8125_mdio_prot_write(tp, my_cmd.offset, my_cmd.data);
+                break;
+
+        case RTLTOOL_READ_EPHY:
+                my_cmd.data = rtl8125_ephy_read(tp, my_cmd.offset);
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+
+                break;
+
+        case RTLTOOL_WRITE_EPHY:
+                rtl8125_ephy_write(tp, my_cmd.offset, my_cmd.data);
+                break;
+
+        case RTLTOOL_READ_ERI:
+                my_cmd.data = 0;
+                if (my_cmd.len==1 || my_cmd.len==2 || my_cmd.len==4) {
+                        my_cmd.data = rtl8125_eri_read(tp, my_cmd.offset, my_cmd.len, ERIAR_ExGMAC);
+                } else {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+
+                break;
+
+        case RTLTOOL_WRITE_ERI:
+                if (my_cmd.len==1 || my_cmd.len==2 || my_cmd.len==4) {
+                        rtl8125_eri_write(tp, my_cmd.offset, my_cmd.len, my_cmd.data, ERIAR_ExGMAC);
+                } else {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+                break;
+
+        case RTLTOOL_READ_PCI:
+                my_cmd.data = 0;
+                if (my_cmd.len==1)
+                        pci_read_config_byte(tp->pci_dev, my_cmd.offset,
+                                             (u8 *)&my_cmd.data);
+                else if (my_cmd.len==2)
+                        pci_read_config_word(tp->pci_dev, my_cmd.offset,
+                                             (u16 *)&my_cmd.data);
+                else if (my_cmd.len==4)
+                        pci_read_config_dword(tp->pci_dev, my_cmd.offset,
+                                              &my_cmd.data);
+                else {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+                break;
+
+        case RTLTOOL_WRITE_PCI:
+                if (my_cmd.len==1)
+                        pci_write_config_byte(tp->pci_dev, my_cmd.offset,
+                                              my_cmd.data);
+                else if (my_cmd.len==2)
+                        pci_write_config_word(tp->pci_dev, my_cmd.offset,
+                                              my_cmd.data);
+                else if (my_cmd.len==4)
+                        pci_write_config_dword(tp->pci_dev, my_cmd.offset,
+                                               my_cmd.data);
+                else {
+                        ret = -EOPNOTSUPP;
+                        break;
+                }
+
+                break;
+
+        case RTLTOOL_READ_EEPROM:
+                my_cmd.data = rtl8125_eeprom_read_sc(tp, my_cmd.offset);
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+
+                break;
+
+        case RTLTOOL_WRITE_EEPROM:
+                rtl8125_eeprom_write_sc(tp, my_cmd.offset, my_cmd.data);
+                break;
+
+        case RTL_READ_OOB_MAC:
+                rtl8125_oob_mutex_lock(tp);
+                my_cmd.data = rtl8125_ocp_read(tp, my_cmd.offset, 4);
+                rtl8125_oob_mutex_unlock(tp);
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+                break;
+
+        case RTL_WRITE_OOB_MAC:
+                if (my_cmd.len == 0 || my_cmd.len > 4)
+                        return -EOPNOTSUPP;
+
+                rtl8125_oob_mutex_lock(tp);
+                rtl8125_ocp_write(tp, my_cmd.offset, my_cmd.len, my_cmd.data);
+                rtl8125_oob_mutex_unlock(tp);
+                break;
+
+        case RTL_ENABLE_PCI_DIAG:
+                tp->rtk_enable_diag = 1;
+
+                dprintk("enable rtk diag\n");
+                break;
+
+        case RTL_DISABLE_PCI_DIAG:
+                tp->rtk_enable_diag = 0;
+
+                dprintk("disable rtk diag\n");
+                break;
+
+        case RTL_READ_MAC_OCP:
+                if (my_cmd.offset % 2)
+                        return -EOPNOTSUPP;
+
+                my_cmd.data = rtl8125_mac_ocp_read(tp, my_cmd.offset);
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+                break;
+
+        case RTL_WRITE_MAC_OCP:
+                if ((my_cmd.offset % 2) || (my_cmd.len != 2))
+                        return -EOPNOTSUPP;
+
+                rtl8125_mac_ocp_write(tp, my_cmd.offset, (u16)my_cmd.data);
+                break;
+
+        case RTL_DIRECT_READ_PHY_OCP:
+                my_cmd.data = rtl8125_mdio_prot_direct_read_phy_ocp(tp, my_cmd.offset);
+                if (copy_to_user(ifr->ifr_data, &my_cmd, sizeof(my_cmd))) {
+                        ret = -EFAULT;
+                        break;
+                }
+
+                break;
+
+        case RTL_DIRECT_WRITE_PHY_OCP:
+                rtl8125_mdio_prot_direct_write_phy_ocp(tp, my_cmd.offset, my_cmd.data);
+                break;
+
+        default:
+                ret = -EOPNOTSUPP;
+                break;
+        }
+
+        return ret;
+}
Index: kernel-rockchip/drivers/net/ethernet/realtek/r8125/rtltool.h
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/net/ethernet/realtek/r8125/rtltool.h
@@ -0,0 +1,86 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+################################################################################
+#
+# r8125 is the Linux device driver released for Realtek 2.5Gigabit Ethernet
+# controllers with PCI-Express interface.
+#
+# Copyright(c) 2022 Realtek Semiconductor Corp. All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by the Free
+# Software Foundation; either version 2 of the License, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+# more details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, see <http://www.gnu.org/licenses/>.
+#
+# Author:
+# Realtek NIC software team <nicfae@realtek.com>
+# No. 2, Innovation Road II, Hsinchu Science Park, Hsinchu 300, Taiwan
+#
+################################################################################
+*/
+
+/************************************************************************************
+ *  This product is covered by one or more of the following patents:
+ *  US6,570,884, US6,115,776, and US6,327,625.
+ ***********************************************************************************/
+
+#ifndef _LINUX_RTLTOOL_H
+#define _LINUX_RTLTOOL_H
+
+#define SIOCRTLTOOL		SIOCDEVPRIVATE+1
+
+enum rtl_cmd {
+        RTLTOOL_READ_MAC=0,
+        RTLTOOL_WRITE_MAC,
+        RTLTOOL_READ_PHY,
+        RTLTOOL_WRITE_PHY,
+        RTLTOOL_READ_EPHY,
+        RTLTOOL_WRITE_EPHY,
+        RTLTOOL_READ_ERI,
+        RTLTOOL_WRITE_ERI,
+        RTLTOOL_READ_PCI,
+        RTLTOOL_WRITE_PCI,
+        RTLTOOL_READ_EEPROM,
+        RTLTOOL_WRITE_EEPROM,
+
+        RTL_READ_OOB_MAC,
+        RTL_WRITE_OOB_MAC,
+
+        RTL_ENABLE_PCI_DIAG,
+        RTL_DISABLE_PCI_DIAG,
+
+        RTL_READ_MAC_OCP,
+        RTL_WRITE_MAC_OCP,
+
+        RTL_DIRECT_READ_PHY_OCP,
+        RTL_DIRECT_WRITE_PHY_OCP,
+
+        RTLTOOL_INVALID
+};
+
+struct rtltool_cmd {
+        __u32	cmd;
+        __u32	offset;
+        __u32	len;
+        __u32	data;
+};
+
+enum mode_access {
+        MODE_NONE=0,
+        MODE_READ,
+        MODE_WRITE
+};
+
+#ifdef __KERNEL__
+int rtl8125_tool_ioctl(struct rtl8125_private *tp, struct ifreq *ifr);
+#endif
+
+#endif /* _LINUX_RTLTOOL_H */
Index: kernel-rockchip/drivers/net/ethernet/realtek/realtek_pgtool/Makefile
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/net/ethernet/realtek/realtek_pgtool/Makefile
@@ -0,0 +1 @@
+obj-m	 := pgdrv.o
\ No newline at end of file
Index: kernel-rockchip/drivers/net/ethernet/realtek/realtek_pgtool/pgdrv.c
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/net/ethernet/realtek/realtek_pgtool/pgdrv.c
@@ -0,0 +1,586 @@
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/cdev.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/fs.h>		// struct file_operations
+#include <linux/mm.h>		// mmap
+#include <linux/slab.h>		// kmalloc
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,4,0)
+#include <linux/pci-aspm.h>
+#endif
+#include <asm/io.h>
+#include <asm/uaccess.h>		// copy_to_user
+#include <linux/uaccess.h>		// copy_to_user
+#include <asm/byteorder.h>
+
+#include "pgdrv.h"
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+#warning KERNEL_VERSION < 2.6.11
+#endif
+
+static DEV_INFO		dev_info[MAX_DEV_NUM];
+static atomic_t		dev_num;
+static spinlock_t	module_lock;
+static int		major = 0;
+static unsigned long	mmio = 0;
+
+module_param(major, int, S_IRUGO|S_IWUSR);
+module_param(mmio, ulong, S_IRUGO|S_IWUSR);
+
+//static int dev_IoctlFun(struct inode *inode, struct file *pFile,unsigned int cmd, unsigned long arg)
+static long dev_IoctlFun(struct file *pFile,unsigned int cmd, unsigned long arg)
+{
+	PPGDEV	mydev;
+	int	result;
+
+	if (_IOC_TYPE(cmd) != RTL_IOC_MAGIC)
+	{
+		DbgFunPrint("Invalid command!!!");
+		return -ENOTTY;
+	}
+
+	mydev = (PPGDEV)pFile->private_data;
+	result = 0;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+	if (down_interruptible(&mydev->dev_sem))
+	{
+		DbgFunPrint("lock fail");
+		return -ERESTARTSYS;
+	}
+#else
+	if (mutex_lock_interruptible(&mydev->dev_mutex))
+	{
+		DbgFunPrint("lock fail");
+		return -ERESTARTSYS;
+	}
+#endif
+
+	switch(cmd)
+	{
+		case IOC_PCI_CONFIG:
+		{
+			PCI_CONFIG_RW	pci_config;
+
+			if (copy_from_user(&pci_config, (void __user *)arg, sizeof(PCI_CONFIG_RW)))
+			{
+				DbgFunPrint("copy_from_user fail");
+				result = -EFAULT;
+				break;
+			}
+
+
+			if (pci_config.bRead==TRUE)
+			{
+				if (pci_config.size==1)
+				{
+					result = pci_read_config_byte(mydev->pdev, pci_config.addr, &pci_config.byte);
+				}
+				else if (pci_config.size==2)
+				{
+					result = pci_read_config_word(mydev->pdev, pci_config.addr, &pci_config.word);
+				}
+				else if (pci_config.size==4)
+				{
+					result = pci_read_config_dword(mydev->pdev, pci_config.addr, &pci_config.dword);
+				}
+				else
+				{
+					result = -EINVAL;
+				}
+
+				if (result)
+				{
+					DbgFunPrint("Read PCI fail:%d",result);
+					break;
+				}
+
+				if (copy_to_user((void __user *)arg , &pci_config, sizeof(PCI_CONFIG_RW)))
+				{
+					DbgFunPrint("copy_from_user fail");
+					result = -EFAULT;
+					break;
+				}
+			}
+			else // write
+			{
+				if (pci_config.size==1)
+				{
+					result = pci_write_config_byte(mydev->pdev, pci_config.addr, pci_config.byte);
+				}
+				else if (pci_config.size==2)
+				{
+					result = pci_write_config_word(mydev->pdev, pci_config.addr, pci_config.word);
+				}
+				else if (pci_config.size==4)
+				{
+					result = pci_write_config_dword(mydev->pdev, pci_config.addr, pci_config.dword);
+				}
+				else
+				{
+					result = -EINVAL;
+				}
+
+				if (result)
+				{
+					DbgFunPrint("Write PCI fail:%d",result);
+					break;
+				}
+			}
+#if 0
+			DebugPrint("bRead=%u, size=%d, addr=0x%02x , data=0x%08x",
+				pci_config.bRead, pci_config.size,
+				pci_config.addr, pci_config.dword);
+#endif
+			break;
+		}
+
+		case IOC_IOMEM_OFFSET:
+			if ( put_user(mydev->offset,(unsigned int __user *)arg) )
+			{
+				DbgFunPrint("put_user fail");
+				result = -EFAULT;
+				break;
+			}
+			break;
+
+		case IOC_DEV_FUN:
+			if ( put_user(mydev->pdev->devfn,(unsigned int __user *)arg) )
+			{
+				DbgFunPrint("put_user fail");
+				result = -EFAULT;
+				break;
+			}
+			break;
+
+		default:
+			DbgFunPrint("Command not support!!!");
+			result = -ENOTTY;
+			break;
+	}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+	up(&mydev->dev_sem);
+#else
+	mutex_unlock(&mydev->dev_mutex);
+#endif
+	return result;
+}
+
+ssize_t dev_read(struct file *filp, char __user *buffer, size_t count, loff_t *f_pos)
+{
+	PPGDEV	mydev;
+	BYTE	*buf;
+	ssize_t	readcount;
+
+	DbgFunPrint("count=%zd",count);
+	mydev = (PPGDEV)filp->private_data;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+	if (down_interruptible(&mydev->dev_sem))
+	{
+		DbgFunPrint("lock fail");
+		return 0;
+	}
+#else
+	if (mutex_lock_interruptible(&mydev->dev_mutex))
+	{
+		DbgFunPrint("lock fail");
+		return 0;
+	}
+#endif
+
+	// To Do:
+	if (count > 0x100)
+	{
+		count = 0x100;
+//		return 0;
+	}
+	else
+	{
+		count &= ~0x3;
+	}
+	buf = kmalloc(count,GFP_KERNEL);
+	if (!buf)
+	{
+		return -ENOMEM;
+	}
+
+	for (readcount=0;readcount<count;readcount+=4)
+	{
+		if (pci_read_config_dword(mydev->pdev,readcount,(u32 *)&buf[readcount]))
+		{
+			break;
+		}
+	}
+
+	if (copy_to_user(buffer,buf,readcount))
+	{
+		readcount = 0;
+	}
+	*f_pos += readcount;
+
+	kfree(buf);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+	up(&mydev->dev_sem);
+#else
+	mutex_unlock(&mydev->dev_mutex);
+#endif
+	return readcount;
+}
+
+static int dev_Open(struct inode *inode, struct file *pFile)
+{
+	PPGDEV	mydev;
+
+	mydev = container_of(inode->i_cdev, PGDEV, cdev);
+	DbgFunPrint("mydev=%p",mydev);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+	atomic_inc(&mydev->count);
+	if (atomic_read(&mydev->count) > 1)
+	{
+		atomic_dec(&mydev->count);
+		DbgFunPrint("Busy");
+		return -EMFILE;
+	}
+#else
+	if (atomic_inc_return(&mydev->count) > 1)
+	{
+		atomic_dec(&mydev->count);
+		DbgFunPrint("Busy");
+		return -EMFILE;
+	}
+#endif
+
+	pFile->private_data = mydev;
+
+	return 0;
+}
+
+static int dev_Close(struct inode *inode, struct file *pFile)
+{
+	PPGDEV	mydev;
+
+	mydev = container_of(inode->i_cdev, PGDEV, cdev);
+	DbgFunPrint("mydev=%p",mydev);
+	pFile->private_data = NULL;
+
+	atomic_dec(&mydev->count);
+
+	return 0;
+}
+
+static void dev_vma_open(struct vm_area_struct *vma)
+{
+	DebugPrint("dev_vma_open");
+//	DbgFunPrint("vma=0x%08x, vm_start=0x%08x, vm_end=0x%08x, vm_pgoff=%d\n",
+//			(DWORD)vma, (DWORD)vma->vm_start, (DWORD)vma->vm_end,
+//			(DWORD)vma->vm_pgoff);
+}
+
+static void dev_vma_close(struct vm_area_struct *vma)
+{
+	DebugPrint("dev_vma_close");
+//	DbgFunPrint("vma=0x%08x, vm_start=0x%08x, vm_end=0x%08x, vm_pgoff=%d\n",
+//			(DWORD)vma, (DWORD)vma->vm_start, (DWORD)vma->vm_end,
+//			(DWORD)vma->vm_pgoff);
+}
+
+static struct vm_operations_struct dev_vma_ops = {
+	.open =		dev_vma_open,
+	.close = 	dev_vma_close,
+};
+
+static int dev_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	PPGDEV		mydev;
+
+	mydev = (PPGDEV)filp->private_data;
+
+	if (!mydev)
+	{
+		DbgFunPrint("NULL pointer");
+		return -EFAULT;
+	}
+	DbgFunPrint("\nvma=%p, vm_start=0x%08x, vm_end=0x%08x\nvm_pgoff=%d, vm_flags=0x%x, mydev=%p\n",
+			vma, (DWORD)vma->vm_start, (DWORD)vma->vm_end,
+			(DWORD)vma->vm_pgoff,(DWORD)vma->vm_flags,
+			mydev);
+
+	if (!mydev || !mydev->base_phyaddr)
+	{
+		DbgFunPrint("Invalid base_phyaddr=0x%08x",(DWORD)mydev->base_phyaddr);
+		return -ENXIO;
+	}
+
+	switch(mydev->deviceID)
+	{
+		case 0x8167:
+		case 0x8169:
+		{
+			unsigned int iomem;
+			pci_read_config_dword(mydev->pdev, 0x14, &iomem);
+			if (!iomem)
+			{
+				DbgFunPrint("Invalid iomem=0x%08x, base_phyaddr=0x%08x",iomem,(DWORD)mydev->base_phyaddr);
+				pci_write_config_dword(mydev->pdev, 0x14, (DWORD)mydev->base_phyaddr);
+			}
+			break;
+		}
+
+		default:
+			break;
+	}
+
+	vma->vm_flags |= VM_IO;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+	if (remap_page_range(vma, vma->vm_start, mydev->base_phyaddr, vma->vm_end-vma->vm_start, vma->vm_page_prot))
+	{
+		DbgFunPrint("remap_page_range fail!!!");
+		return -EAGAIN;
+	}
+#else
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	if (remap_pfn_range(vma, vma->vm_start, mydev->base_phyaddr>>PAGE_SHIFT, vma->vm_end-vma->vm_start, vma->vm_page_prot))
+	{
+		DbgFunPrint("remap_pfn_range fail!!!");
+		return -EAGAIN;
+	}
+#endif
+	vma->vm_ops = &dev_vma_ops;
+	dev_vma_open(vma);
+	return 0;
+}
+
+static struct file_operations pg_fops = {
+	.owner			= THIS_MODULE,
+	.read			= dev_read,
+//	.write			= NsmWriteFun,
+	.mmap			= dev_mmap,
+	.unlocked_ioctl		= dev_IoctlFun,
+	.open			= dev_Open,
+	.release		= dev_Close,
+};
+
+static int __devinit pgdrv_prob(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	PPGDEV		mydev;
+	dev_t		devno;
+	int		pg_minor, result, i;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+        pci_disable_link_state(pdev, PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1 |
+                               PCIE_LINK_STATE_CLKPM);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+	atomic_inc(&dev_num);
+	if (atomic_read(&dev_num) > MAX_DEV_NUM)
+	{
+		atomic_dec(&dev_num);
+		DbgFunPrint("Too Many Device");
+		return -EFAULT;
+	}
+#else
+	if (atomic_inc_return(&dev_num) > MAX_DEV_NUM)
+	{
+		atomic_dec(&dev_num);
+		DbgFunPrint("Too Many Device");
+		return -EFAULT;
+	}
+#endif
+
+	mydev = kmalloc(sizeof(PGDEV),GFP_KERNEL);
+	if (!mydev)
+	{
+		DebugPrint("Allocate dev fail");
+		return -ENOMEM;
+	}
+	memset(mydev, 0, sizeof(PGDEV));
+
+	pg_minor = -1;
+	devno = 0;
+	spin_lock(&module_lock);
+	for (i = 0; i < MAX_DEV_NUM; i++)
+	{
+		if (dev_info[i].bUsed == FALSE)
+		{
+			dev_info[i].bUsed = TRUE;
+			devno = dev_info[i].devno;
+			mydev->index = i;
+			break;
+		}
+	}
+	spin_unlock(&module_lock);
+
+	mydev->pdev = pdev;
+	atomic_set(&mydev->count, 0);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+	init_MUTEX(&mydev->dev_sem);
+#else
+	mutex_init(&mydev->dev_mutex);
+#endif
+
+	pg_minor = MINOR(devno);
+	DbgFunPrint("mydev=%p, major=%u, minor=%u",mydev,major,pg_minor);
+
+	cdev_init(&mydev->cdev, &pg_fops);
+	mydev->cdev.owner = THIS_MODULE;
+	result = cdev_add(&mydev->cdev, devno, 1);
+	if (result)
+	{
+		DebugPrint("cdev_add fault");
+		spin_lock(&module_lock);
+		dev_info[mydev->index].bUsed = FALSE;
+		spin_unlock(&module_lock);
+		kfree(mydev);
+		return result;
+	}
+
+	pci_set_drvdata(pdev, mydev);
+
+	result = pci_enable_device(mydev->pdev);
+	if (result<0)
+	{
+		DbgFunPrint("pci_enable_device fail");
+		return result;
+	}
+
+	result = pci_request_regions(mydev->pdev, MODULENAME);
+	if (result<0)
+	{
+		DbgFunPrint("pci_request_regions fail");
+		goto error_2;
+	}
+
+	pci_set_master(mydev->pdev);
+
+	if (mmio) {
+		mydev->base_phyaddr = mmio;
+	} else {
+		switch(id->device) {
+		case 0x8167:
+		case 0x8169:
+			mydev->base_phyaddr = pci_resource_start(mydev->pdev, 1);
+			break;
+		default:
+			mydev->base_phyaddr = pci_resource_start(mydev->pdev, 2);
+			break;
+		}
+	}
+
+	if (!mydev->base_phyaddr) {
+		DbgFunPrint("Invalid phyaddress");
+		result = -EFAULT;
+		goto error_1;
+	}
+	mydev->deviceID = id->device;
+	mydev->offset = mydev->base_phyaddr & ((1 << PAGE_SHIFT) - 1);
+	DbgFunPrint("ID=0x%04x base_phyaddr=0x%08x, offset=0x%08x",
+		    mydev->deviceID , (DWORD)mydev->base_phyaddr,
+		    mydev->offset);
+
+	return 0;
+
+error_1:
+	pci_release_regions(mydev->pdev);
+error_2:
+	pci_disable_device(mydev->pdev);
+	cdev_del(&mydev->cdev);
+	kfree(mydev);
+	return result;
+}
+
+static void __devexit pgdrv_remove(struct pci_dev *pdev)
+{
+	PPGDEV	mydev;
+
+	mydev = pci_get_drvdata(pdev);
+	DbgFunPrint("mydev=%p",mydev);
+
+	mydev->base_phyaddr = 0;
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+
+	cdev_del(&mydev->cdev);
+	spin_lock(&module_lock);
+	dev_info[mydev->index].bUsed = FALSE;
+	spin_unlock(&module_lock);
+	kfree(mydev);
+	pci_set_drvdata(pdev, NULL);
+	atomic_dec(&dev_num);
+}
+
+static struct pci_device_id pgdrv_id_table[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x8125), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x8136), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x8161), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x8162), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x8167), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x8168), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x8169), },
+	{0,},
+};
+
+MODULE_DEVICE_TABLE(pci, pgdrv_id_table);
+
+static struct pci_driver pgdrv_pci_driver = {
+	.name		= MODULENAME,
+	.id_table	= pgdrv_id_table,
+	.probe		= pgdrv_prob,
+	.remove		= __devexit_p(pgdrv_remove),
+};
+
+static int __init pgdrv_init(void)
+{
+	int	result, i;
+	dev_t	devno;
+
+	memset(dev_info, 0, sizeof(dev_info));
+	atomic_set(&dev_num,0);
+	spin_lock_init(&module_lock);
+
+	if (!major)
+	{
+		result = alloc_chrdev_region(&devno, 0, MAX_DEV_NUM, MODULENAME);
+		major = MAJOR(devno);
+	}
+	else
+	{
+		devno = MKDEV(major, 0);
+		result = register_chrdev_region(devno, MAX_DEV_NUM, MODULENAME);
+	}
+
+	if (result < 0)
+	{
+		DebugPrint("Can't get major %d", major);
+		return result;
+	}
+	DbgFunPrint("Major : %d",major);
+
+	for (i=0; i<MAX_DEV_NUM; i++)
+	{
+		dev_info[i].devno = MKDEV(major, i);
+	}
+
+	return pci_register_driver(&pgdrv_pci_driver);
+}
+
+static void __exit pgdrv_exit(void)
+{
+	DbgFunPrint();
+	pci_unregister_driver(&pgdrv_pci_driver);
+	unregister_chrdev_region(MKDEV(major, 0), MAX_DEV_NUM);
+}
+
+module_init(pgdrv_init);
+module_exit(pgdrv_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Network Interface Controllers crew <nicfae@realtek.com>");
+MODULE_VERSION("1.00.00");
+MODULE_DESCRIPTION("RealTek driver of Ethernet PG tool");
Index: kernel-rockchip/drivers/net/ethernet/realtek/realtek_pgtool/pgdrv.h
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/net/ethernet/realtek/realtek_pgtool/pgdrv.h
@@ -0,0 +1,90 @@
+#ifndef _PG_DRV_H
+#define _PG_DRV_H
+
+#define BYTE	__u8
+#define WORD	__u16
+#define DWORD	__u32
+#define DWORD64	__u64
+#define BOOLEAN	int
+typedef void *	PVOID;
+typedef BYTE *	PBYTE;
+typedef WORD *	PWORD;
+typedef DWORD *	PDWORD;
+
+#ifndef TRUE
+	#define TRUE	1
+	#define FALSE	0
+#endif
+
+#define PRINT_LEVEL					KERN_NOTICE
+
+#ifdef DEBUG
+#define DebugPrint(fmt,args...)				printk(PRINT_LEVEL "[RTNICPG]" fmt "\n",## args)
+#define DbgFunPrint(fmt,args...)			printk(PRINT_LEVEL "[RTNICPG]" "%s %i: " fmt "\n",__FUNCTION__,__LINE__,## args)
+#else
+#define DebugPrint(fmt,args...)				//printk(PRINT_LEVEL fmt "\n",## args)
+#define DbgFunPrint(fmt,args...)			//printk(PRINT_LEVEL "%s %i: " fmt "\n",__FUNCTION__,__LINE__,## args)
+#endif
+
+/*******************************************************************************
+*******************************************************************************/
+#define Writel(Address,Data)			writel(Data,(void *)(Address))
+#define Readl(Address)				readl((void *)(Address))
+#define Writew(Address,Data)			writew(Data,(void *)(Address))
+#define Readw(Address)				readw((void *)(Address))
+#define Writeb(Address,Data)			writeb(Data,(void *)(Address))
+#define Readb(Address)				readb((void *)(Address))
+
+#define MODULENAME				"pgtool"
+#define MAX_DEV_NUM				10
+#define MAX_IO_SIZE				0x100
+
+typedef struct _DEV_INFO_
+{
+	dev_t					devno;
+	bool					bUsed;
+}DEV_INFO,*PDEV_INFO;
+
+typedef struct _PG_DEV_
+{
+	struct cdev				cdev;
+	struct pci_dev				*pdev;
+	unsigned long				base_phyaddr;
+	unsigned int				offset;
+	unsigned int				deviceID;
+	atomic_t				count;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
+	struct semaphore			dev_sem;
+#else
+	struct mutex				dev_mutex;
+#endif
+	unsigned int				index;
+}PGDEV,*PPGDEV;
+
+typedef struct _PCI_CONFIG_RW_
+{
+	union
+	{
+		unsigned char	byte;
+		unsigned short	word;
+		unsigned int	dword;
+	};
+	unsigned int		bRead:1;
+	unsigned int		size:7;
+	unsigned int		addr:8;
+	unsigned int		reserve:16;
+}PCI_CONFIG_RW,*PPCI_CONFIG_RW;
+
+#define RTL_IOC_MAGIC					0x95
+
+#define IOC_PCI_CONFIG					_IOWR(RTL_IOC_MAGIC, 0, PCI_CONFIG_RW)
+#define IOC_IOMEM_OFFSET				_IOR(RTL_IOC_MAGIC, 1, unsigned int)
+#define IOC_DEV_FUN					_IOR(RTL_IOC_MAGIC, 2, unsigned int)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0)
+#define __devinit
+#define __devexit
+#define __devexit_p(func)   func
+#endif
+
+#endif // end of #ifndef _PG_DRV_H
Index: kernel-rockchip/scripts/dtc/fdtoverlay.c
===================================================================
--- /dev/null
+++ kernel-rockchip/scripts/dtc/fdtoverlay.c
@@ -0,0 +1,208 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2017 Konsulko Group Inc. All rights reserved.
+ *
+ * Author:
+ *	 Pantelis Antoniou <pantelis.antoniou@konsulko.com>
+ */
+
+#include <assert.h>
+#include <ctype.h>
+#include <getopt.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <inttypes.h>
+
+#include <libfdt.h>
+
+#include "util.h"
+
+#define BUF_INCREMENT	65536
+
+/* Usage related data. */
+static const char usage_synopsis[] =
+	"apply a number of overlays to a base blob\n"
+	"	fdtoverlay <options> [<overlay.dtbo> [<overlay.dtbo>]]\n"
+	"\n"
+	USAGE_TYPE_MSG;
+static const char usage_short_opts[] = "i:o:v" USAGE_COMMON_SHORT_OPTS;
+static struct option const usage_long_opts[] = {
+	{"input",            required_argument, NULL, 'i'},
+	{"output",	     required_argument, NULL, 'o'},
+	{"verbose",	           no_argument, NULL, 'v'},
+	USAGE_COMMON_LONG_OPTS,
+};
+static const char * const usage_opts_help[] = {
+	"Input base DT blob",
+	"Output DT blob",
+	"Verbose messages",
+	USAGE_COMMON_OPTS_HELP
+};
+
+int verbose = 0;
+
+static void *apply_one(char *base, const char *overlay, size_t *buf_len,
+		       const char *name)
+{
+	char *tmp = NULL;
+	char *tmpo;
+	int ret;
+
+	/*
+	 * We take a copies first, because a a failed apply can trash
+	 * both the base blob and the overlay
+	 */
+	tmpo = xmalloc(fdt_totalsize(overlay));
+
+	do {
+		tmp = xrealloc(tmp, *buf_len);
+		ret = fdt_open_into(base, tmp, *buf_len);
+		if (ret) {
+			fprintf(stderr,
+				"\nFailed to make temporary copy: %s\n",
+				fdt_strerror(ret));
+			goto fail;
+		}
+
+		memcpy(tmpo, overlay, fdt_totalsize(overlay));
+
+		ret = fdt_overlay_apply(tmp, tmpo);
+		if (ret == -FDT_ERR_NOSPACE) {
+			*buf_len += BUF_INCREMENT;
+		}
+	} while (ret == -FDT_ERR_NOSPACE);
+
+	if (ret) {
+		fprintf(stderr, "\nFailed to apply '%s': %s\n",
+			name, fdt_strerror(ret));
+		goto fail;
+	}
+
+	free(base);
+	free(tmpo);
+	return tmp;
+
+fail:
+	free(tmpo);
+	if (tmp)
+		free(tmp);
+
+	return NULL;
+}
+static int do_fdtoverlay(const char *input_filename,
+			 const char *output_filename,
+			 int argc, char *argv[])
+{
+	char *blob = NULL;
+	char **ovblob = NULL;
+	size_t buf_len;
+	int i, ret = -1;
+
+	blob = utilfdt_read(input_filename, &buf_len);
+	if (!blob) {
+		fprintf(stderr, "\nFailed to read '%s'\n", input_filename);
+		goto out_err;
+	}
+	if (fdt_totalsize(blob) > buf_len) {
+		fprintf(stderr,
+ "\nBase blob is incomplete (%lu / %" PRIu32 " bytes read)\n",
+			(unsigned long)buf_len, fdt_totalsize(blob));
+		goto out_err;
+	}
+
+	/* allocate blob pointer array */
+	ovblob = xmalloc(sizeof(*ovblob) * argc);
+	memset(ovblob, 0, sizeof(*ovblob) * argc);
+
+	/* read and keep track of the overlay blobs */
+	for (i = 0; i < argc; i++) {
+		size_t ov_len;
+		ovblob[i] = utilfdt_read(argv[i], &ov_len);
+		if (!ovblob[i]) {
+			fprintf(stderr, "\nFailed to read '%s'\n", argv[i]);
+			goto out_err;
+		}
+		if (fdt_totalsize(ovblob[i]) > ov_len) {
+			fprintf(stderr,
+"\nOverlay '%s' is incomplete (%lu / %" PRIu32 " bytes read)\n",
+				argv[i], (unsigned long)ov_len,
+				fdt_totalsize(ovblob[i]));
+			goto out_err;
+		}
+	}
+
+	buf_len = fdt_totalsize(blob);
+
+	/* apply the overlays in sequence */
+	for (i = 0; i < argc; i++) {
+		blob = apply_one(blob, ovblob[i], &buf_len, argv[i]);
+		if (!blob)
+			goto out_err;
+	}
+
+	fdt_pack(blob);
+	ret = utilfdt_write(output_filename, blob);
+	if (ret)
+		fprintf(stderr, "\nFailed to write '%s'\n",
+			output_filename);
+
+out_err:
+	if (ovblob) {
+		for (i = 0; i < argc; i++) {
+			if (ovblob[i])
+				free(ovblob[i]);
+		}
+		free(ovblob);
+	}
+	free(blob);
+
+	return ret;
+}
+
+int main(int argc, char *argv[])
+{
+	int opt, i;
+	char *input_filename = NULL;
+	char *output_filename = NULL;
+
+	while ((opt = util_getopt_long()) != EOF) {
+		switch (opt) {
+		case_USAGE_COMMON_FLAGS
+
+		case 'i':
+			input_filename = optarg;
+			break;
+		case 'o':
+			output_filename = optarg;
+			break;
+		case 'v':
+			verbose = 1;
+			break;
+		}
+	}
+
+	if (!input_filename)
+		usage("missing input file");
+
+	if (!output_filename)
+		usage("missing output file");
+
+	argv += optind;
+	argc -= optind;
+
+	if (argc <= 0)
+		usage("missing overlay file(s)");
+
+	if (verbose) {
+		printf("input  = %s\n", input_filename);
+		printf("output = %s\n", output_filename);
+		for (i = 0; i < argc; i++)
+			printf("overlay[%d] = %s\n", i, argv[i]);
+	}
+
+	if (do_fdtoverlay(input_filename, output_filename, argc, argv))
+		return 1;
+
+	return 0;
+}
Index: kernel-rockchip/scripts/Makefile.lib
===================================================================
--- kernel-rockchip.orig/scripts/Makefile.lib
+++ kernel-rockchip/scripts/Makefile.lib
@@ -100,7 +100,9 @@ extra-$(CONFIG_OF_ALL_DTBS)	+= $(dtb-)
 
 ifneq ($(CHECK_DTBS),)
 extra-y += $(patsubst %.dtb,%.dt.yaml, $(dtb-y))
+extra-y += $(patsubst %.dtbo,%.dt.yaml, $(dtb-y))
 extra-$(CONFIG_OF_ALL_DTBS) += $(patsubst %.dtb,%.dt.yaml, $(dtb-))
+extra-$(CONFIG_OF_ALL_DTBS) += $(patsubst %.dtbo,%.dt.yaml, $(dtb-))
 endif
 
 # Add subdir path
@@ -332,6 +334,9 @@ ifeq ($(CONFIG_DTC_OMIT_EMPTY),y)
 DTC_FLAGS += -Wnode_empty
 endif
 
+# Overlay support
+DTC_FLAGS += -@ -Wno-unit_address_format -Wno-simple_bus_reg
+
 # Disable noisy checks by default
 ifeq ($(findstring 1,$(KBUILD_EXTRA_WARN)),)
 DTC_FLAGS += $(call dtc-option,-Wno-unit_address_vs_reg) \
@@ -380,6 +385,9 @@ cmd_dtc = $(HOSTCC) -E $(dtc_cpp_flags)
 $(obj)/%.dtb: $(src)/%.dts $(DTC) FORCE
 	$(call if_changed_dep,dtc)
 
+$(obj)/%.dtbo: $(src)/%.dts $(DTC) FORCE
+	$(call if_changed_dep,dtc)
+
 DT_CHECKER ?= dt-validate
 DT_BINDING_DIR := Documentation/devicetree/bindings
 # DT_TMP_SCHEMA may be overridden from Documentation/devicetree/bindings/Makefile
@@ -396,6 +404,17 @@ endef
 $(obj)/%.dt.yaml: $(src)/%.dts $(DTC) $(DT_TMP_SCHEMA) FORCE
 	$(call if_changed_rule,dtc,yaml)
 
+quiet_cmd_dtco = DTCO    $@
+cmd_dtco = mkdir -p $(dir ${dtc-tmp}) ; \
+	$(CPP) $(dtc_cpp_flags) -x assembler-with-cpp -o $(dtc-tmp) $< ; \
+	$(DTC) -O dtb -o $@ -b 0 \
+		-i $(dir $<) $(DTC_FLAGS) \
+		-d $(depfile).dtc.tmp $(dtc-tmp) ; \
+	cat $(depfile).pre.tmp $(depfile).dtc.tmp > $(depfile)
+
+$(obj)/%.dtbo: $(src)/%.dts FORCE
+	$(call if_changed_dep,dtco)
+
 dtc-tmp = $(subst $(comma),_,$(dot-target).dts.tmp)
 
 # Bzip2
Index: kernel-rockchip/scripts/Makefile.dtbinst
===================================================================
--- kernel-rockchip.orig/scripts/Makefile.dtbinst
+++ kernel-rockchip/scripts/Makefile.dtbinst
@@ -18,9 +18,11 @@ include scripts/Kbuild.include
 include $(src)/Makefile
 
 dtbs    := $(addprefix $(dst)/, $(dtb-y) $(if $(CONFIG_OF_ALL_DTBS),$(dtb-)))
+dtbos   := $(addprefix $(dst)/, $(dtbo-y))
+readmes := $(addprefix $(dst)/, $(dtbotxt-y))
 subdirs := $(addprefix $(obj)/, $(subdir-y) $(subdir-m))
 
-__dtbs_install: $(dtbs) $(subdirs)
+__dtbs_install: $(dtbs) $(dtbos) $(readmes) $(subdirs)
 	@:
 
 quiet_cmd_dtb_install = INSTALL $@
@@ -29,6 +31,12 @@ quiet_cmd_dtb_install = INSTALL $@
 $(dst)/%.dtb: $(obj)/%.dtb
 	$(call cmd,dtb_install)
 
+$(dst)/%.dtbo: $(obj)/%.dtbo
+	$(call cmd,dtb_install)
+
+$(dst)/README.rockchip-overlays: $(src)/README.rockchip-overlays
+	$(call cmd,dtb_install)
+
 PHONY += $(subdirs)
 $(subdirs):
 	$(Q)$(MAKE) $(dtbinst)=$@ dst=$(patsubst $(obj)/%,$(dst)/%,$@)
Index: kernel-rockchip/Makefile
===================================================================
--- kernel-rockchip.orig/Makefile
+++ kernel-rockchip/Makefile
@@ -1475,6 +1475,8 @@ ifneq ($(dtstree),)
 
 %.dtb: include/config/kernel.release scripts_dtc
 	$(Q)$(MAKE) $(build)=$(dtstree) $(dtstree)/$@
+%.dtb: include/config/kernel.release scripts_dtc
+	$(Q)$(MAKE) $(build)=$(dtstree) $(dtstree)/$@
 
 PHONY += dtbs dtbs_install dtbs_check
 dtbs: include/config/kernel.release scripts_dtc
@@ -1940,7 +1942,7 @@ clean: $(clean-dirs)
 	@find $(if $(KBUILD_EXTMOD), $(KBUILD_EXTMOD), .) $(RCS_FIND_IGNORE) \
 		\( -name '*.[aios]' -o -name '*.ko' -o -name '.*.cmd' \
 		-o -name '*.ko.*' \
-		-o -name '*.dtb' -o -name '*.dtb.S' -o -name '*.dt.yaml' \
+		-o -name '*.dtb' -o -name '*.dtbo' -o -name '*.dtb.S' -o -name '*.dt.yaml' \
 		-o -name '*.dwo' -o -name '*.lst' \
 		-o -name '*.su' -o -name '*.mod' \
 		-o -name '.*.d' -o -name '.*.tmp' -o -name '*.mod.c' \
Index: kernel-rockchip/scripts/dtc/dtc.c
===================================================================
--- kernel-rockchip.orig/scripts/dtc/dtc.c
+++ kernel-rockchip/scripts/dtc/dtc.c
@@ -122,6 +122,8 @@ static const char *guess_type_by_name(co
 		return "dts";
 	if (!strcasecmp(s, ".yaml"))
 		return "yaml";
+	if (!strcasecmp(s, ".dtbo"))
+		return "dtb";
 	if (!strcasecmp(s, ".dtb"))
 		return "dtb";
 	return fallback;
@@ -357,6 +359,8 @@ int main(int argc, char *argv[])
 #endif
 	} else if (streq(outform, "dtb")) {
 		dt_to_blob(outf, dti, outversion);
+	} else if (streq(outform, "dtbo")) {
+		dt_to_blob(outf, dti, outversion);
 	} else if (streq(outform, "asm")) {
 		dt_to_asm(outf, dti, outversion);
 	} else if (streq(outform, "null")) {
Index: kernel-rockchip/drivers/thermal/rockchip_thermal.c
===================================================================
--- kernel-rockchip.orig/drivers/thermal/rockchip_thermal.c
+++ kernel-rockchip/drivers/thermal/rockchip_thermal.c
@@ -342,6 +342,10 @@ struct tsadc_table {
 	int temp;
 };
 
+#ifdef CONFIG_KHADAS_MCU
+static struct rockchip_thermal_sensor  *g_tsensor_data_ptr = NULL;
+#endif
+
 static const struct tsadc_table rv1106_code_table[] = {
 	{0, MIN_TEMP},
 	{363, MIN_TEMP},
@@ -2120,6 +2124,23 @@ static int rockchip_thermal_get_temp(voi
 	return retval;
 }
 
+#ifdef CONFIG_KHADAS_MCU
+int rk_get_temperature(void)
+{
+  int temp;
+  int ret;
+  if (!g_tsensor_data_ptr)
+		return -ENODEV;
+  ret = rockchip_thermal_get_temp(g_tsensor_data_ptr, &temp);
+    if (ret) {
+      pr_debug("rk_get_temp failed!\n");
+      return ret;
+    }
+       return temp / 1000;
+}
+EXPORT_SYMBOL(rk_get_temperature);
+#endif
+
 static const struct thermal_zone_of_device_ops rockchip_of_thermal_ops = {
 	.get_temp = rockchip_thermal_get_temp,
 	.set_trips = rockchip_thermal_set_trips,
@@ -2516,7 +2537,9 @@ static int rockchip_thermal_probe(struct
 	thermal->panic_nb.notifier_call = rockchip_thermal_panic;
 	atomic_notifier_chain_register(&panic_notifier_list,
 				       &thermal->panic_nb);
-
+#ifdef CONFIG_KHADAS_MCU
+  g_tsensor_data_ptr = &thermal->sensors[0];
+#endif
 	dev_info(&pdev->dev, "tsadc is probed successfully!\n");
 
 	return 0;
Index: kernel-rockchip/drivers/net/ethernet/realtek/Kconfig
===================================================================
--- kernel-rockchip.orig/drivers/net/ethernet/realtek/Kconfig
+++ kernel-rockchip/drivers/net/ethernet/realtek/Kconfig
@@ -126,4 +126,21 @@ config R8169
 	  To compile this driver as a module, choose M here: the module
 	  will be called r8169.  This is recommended.
 
+config R8125
+  tristate "Realtek 8125 10/100/1000M/2.5G Ethernet support"
+  depends on PCI
+  select REALTEK_PHY
+  help
+    Say Y here if you have a RTL8125 10/100/1000M/2.5G Ethernet adapter.
+
+    To compile this driver as a module, choose M here: the module
+    will be called r8125.  This is recommended.
+
+config REALTEK_PGTOOL
+  tristate "Realtek PG Tool"
+  depends on PCI
+  select REALTEK_PHY
+  help
+    Realtek PG Tool.
+
 endif # NET_VENDOR_REALTEK
Index: kernel-rockchip/drivers/net/ethernet/realtek/Makefile
===================================================================
--- kernel-rockchip.orig/drivers/net/ethernet/realtek/Makefile
+++ kernel-rockchip/drivers/net/ethernet/realtek/Makefile
@@ -9,3 +9,6 @@ obj-$(CONFIG_ATP) += atp.o
 obj-$(CONFIG_R8168) += r8168/
 r8169-objs += r8169_main.o r8169_firmware.o r8169_phy_config.o
 obj-$(CONFIG_R8169) += r8169.o
+
+obj-${CONFIG_R8125} += r8125/
+obj-${CONFIG_REALTEK_PGTOOL} += realtek_pgtool/
