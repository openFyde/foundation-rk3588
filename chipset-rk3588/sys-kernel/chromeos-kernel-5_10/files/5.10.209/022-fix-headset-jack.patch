Index: kernel-rockchip/sound/soc/rockchip/rockchip_multicodecs.c
===================================================================
--- kernel-rockchip.orig/sound/soc/rockchip/rockchip_multicodecs.c
+++ kernel-rockchip/sound/soc/rockchip/rockchip_multicodecs.c
@@ -42,6 +42,9 @@
 #define WAIT_CARDS	(SNDRV_CARDS - 1)
 #define DEFAULT_MCLK_FS	256
 
+#define VOLUME_ON 1
+#define VOLUME_OFF 0
+#define VOLUME_DELAY_TIME 200
 struct adc_keys_button {
 	u32 voltage;
 	u32 keycode;
@@ -65,6 +68,9 @@ struct multicodecs_data {
 	struct iio_channel *adc;
 	struct extcon_dev *extcon;
 	struct delayed_work handler;
+  struct delayed_work hp_blast_handler;
+  bool hp_on_stream;
+  bool sp_on_stream;
 	unsigned int mclk_fs;
 	bool codec_hp_det;
 	u32 num_keys;
@@ -210,6 +216,13 @@ static int mc_keys_load_keymap(struct de
 	return 0;
 }
 
+static void hp_blast_handler(struct work_struct *work) {
+  struct multicodecs_data *mc_data = container_of(to_delayed_work(work),
+    struct multicodecs_data, hp_blast_handler);
+  if (extcon_get_state(mc_data->extcon, EXTCON_JACK_HEADPHONE))
+    gpiod_set_value_cansleep(mc_data->hp_ctl_gpio, VOLUME_ON);
+}
+
 static void adc_jack_handler(struct work_struct *work)
 {
 	struct multicodecs_data *mc_data = container_of(to_delayed_work(work),
@@ -231,6 +244,7 @@ static void adc_jack_handler(struct work
 	}
 	if (!mc_data->adc) {
 		/* no ADC, so is headphone */
+    gpiod_set_value_cansleep(mc_data->hp_ctl_gpio, VOLUME_OFF);
 		snd_soc_jack_report(jack_headset, SND_JACK_HEADPHONE, SND_JACK_HEADSET);
 		extcon_set_state_sync(mc_data->extcon, EXTCON_JACK_HEADPHONE, true);
 		extcon_set_state_sync(mc_data->extcon, EXTCON_JACK_MICROPHONE, false);
@@ -239,11 +253,13 @@ static void adc_jack_handler(struct work
 	ret = iio_read_channel_processed(mc_data->adc, &adc);
 	if (ret < 0) {
 		/* failed to read ADC, so assume headphone */
+    gpiod_set_value_cansleep(mc_data->hp_ctl_gpio, VOLUME_OFF);
 		snd_soc_jack_report(jack_headset, SND_JACK_HEADPHONE, SND_JACK_HEADSET);
 		extcon_set_state_sync(mc_data->extcon, EXTCON_JACK_HEADPHONE, true);
 		extcon_set_state_sync(mc_data->extcon, EXTCON_JACK_MICROPHONE, false);
 
 	} else {
+    gpiod_set_value_cansleep(mc_data->hp_ctl_gpio, VOLUME_OFF);
 		snd_soc_jack_report(jack_headset,
 				    snd_soc_jack_get_type(jack_headset, adc),
 				    SND_JACK_HEADSET);
@@ -261,7 +277,7 @@ static irqreturn_t headset_det_irq_threa
 {
 	struct multicodecs_data *mc_data = (struct multicodecs_data *)data;
 
-	queue_delayed_work(system_power_efficient_wq, &mc_data->handler, msecs_to_jiffies(200));
+	mod_delayed_work(system_power_efficient_wq, &mc_data->handler, msecs_to_jiffies(500));
 
 	return IRQ_HANDLED;
 };
@@ -274,10 +290,13 @@ static int mc_hp_event(struct snd_soc_da
 
 	switch (event) {
 	case SND_SOC_DAPM_POST_PMU:
-		gpiod_set_value_cansleep(mc_data->hp_ctl_gpio, 1);
+    mc_data->hp_on_stream = true;
+    queue_delayed_work(system_power_efficient_wq,
+               &mc_data->hp_blast_handler, msecs_to_jiffies(VOLUME_DELAY_TIME));
 		break;
 	case SND_SOC_DAPM_PRE_PMD:
-		gpiod_set_value_cansleep(mc_data->hp_ctl_gpio, 0);
+    mc_data->hp_on_stream = false;
+		gpiod_set_value_cansleep(mc_data->hp_ctl_gpio, VOLUME_OFF);
 		break;
 	default:
 		return 0;
@@ -295,9 +314,11 @@ static int mc_spk_event(struct snd_soc_d
 
 	switch (event) {
 	case SND_SOC_DAPM_POST_PMU:
+    mc_data->sp_on_stream = true;
 		gpiod_set_value_cansleep(mc_data->spk_ctl_gpio, 1);
 		break;
 	case SND_SOC_DAPM_PRE_PMD:
+    mc_data->sp_on_stream = false;
 		gpiod_set_value_cansleep(mc_data->spk_ctl_gpio, 0);
 		break;
 	default:
@@ -570,8 +591,38 @@ static int wait_locked_card(struct devic
 	return ret;
 }
 
+static void rk_test_shutdown(struct snd_pcm_substream *substream)
+{
+    struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+    struct multicodecs_data *mc_data = snd_soc_card_get_drvdata(rtd->card);
+
+    gpiod_set_value_cansleep(mc_data->spk_ctl_gpio, VOLUME_OFF);
+    gpiod_set_value_cansleep(mc_data->hp_ctl_gpio, VOLUME_OFF);
+}
+
+static int rk_test_startup(struct snd_pcm_substream *substream)
+{
+  struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+  struct multicodecs_data *mc_data = snd_soc_card_get_drvdata(rtd->card);
+
+  /*fix double startup process when headphone is plugged in.*/
+  if (extcon_get_state(mc_data->extcon, EXTCON_JACK_HEADPHONE)) {
+    if (mc_data->hp_on_stream) {
+      //return -ENOTSUPP;
+      pr_info("hp_on_stream\n");
+    }
+  } else {
+    if (mc_data->sp_on_stream) {
+      pr_info("sp_on_stream\n");
+    }
+  }
+  return 0;
+}
+
 static struct snd_soc_ops rk_ops = {
 	.hw_params = rk_multicodecs_hw_params,
+  .shutdown = rk_test_shutdown,
+  .startup = rk_test_startup,
 };
 
 static int rk_multicodecs_probe(struct platform_device *pdev)
@@ -757,6 +808,7 @@ static int rk_multicodecs_probe(struct p
 	}
 
 	INIT_DEFERRABLE_WORK(&mc_data->handler, adc_jack_handler);
+  INIT_DEFERRABLE_WORK(&mc_data->hp_blast_handler, hp_blast_handler);
 
 	mc_data->spk_ctl_gpio = devm_gpiod_get_optional(&pdev->dev,
 							"spk-con",
@@ -811,6 +863,7 @@ static int rk_multicodec_remove(struct p
 	struct multicodecs_data *mc_data = snd_soc_card_get_drvdata(card);
 
 	cancel_delayed_work_sync(&mc_data->handler);
+  cancel_delayed_work_sync(&mc_data->hp_blast_handler);
 
 	return 0;
 }
@@ -821,6 +874,7 @@ static void rk_multicodec_shutdown(struc
 	struct multicodecs_data *mc_data = snd_soc_card_get_drvdata(card);
 
 	cancel_delayed_work_sync(&mc_data->handler);
+  cancel_delayed_work_sync(&mc_data->hp_blast_handler);
 }
 
 static const struct of_device_id rockchip_multicodecs_of_match[] = {
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-12c.dtsi
===================================================================
--- kernel-rockchip.orig/arch/arm64/boot/dts/rockchip/rk3588s-12c.dtsi
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-12c.dtsi
@@ -27,23 +27,9 @@
 			sound-dai = <&hdmi0>;
 		};
 	};
-/*
-    dp0_sound: dp0-sound {
-        compatible = "simple-audio-card";
-        simple-audio-card,name = "rockchip-dp-sound";
-
-        simple-audio-card,cpu {
-            sound-dai = <&spdif_tx2>;
-        };
-
-        simple-audio-card,codec {
-            sound-dai = <&dp0 1>;
-        };
-    };
-*/
 
   dp0_sound: dp0-sound {
-      status = "disabled";
+      status = "okay";
       compatible = "rockchip,hdmi";
       rockchip,card-name = "HDMI/DP-rockchip-0";
       rockchip,mclk-fs = <512>;
@@ -176,15 +162,19 @@
 		pinctrl-0 = <&cam_power_en>;
 	};
 
-	sdmmc_power: sdmmc-power {
-		compatible = "regulator-fixed";
-		regulator-name = "sdmmc_power";
-		regulator-boot-on;
-		enable-active-high;
-		gpio = <&gpio4 RK_PB4 GPIO_ACTIVE_HIGH>;
-		pinctrl-names = "default";
-		pinctrl-0 = <&sdmmc_power_en>;
-	};
+  vcc_3v3_sd_s0: vcc-3v3-sd-s0 {
+    compatible = "regulator-fixed";
+    regulator-name = "vcc_3v3_sd_s0";
+    regulator-min-microvolt = <3300000>;
+    regulator-max-microvolt = <3300000>;
+    gpios = <&gpio4 RK_PB4 GPIO_ACTIVE_HIGH>;
+    enable-active-high;
+    regulator-boot-on;
+    vin-supply = <&vcc_3v3_s3>;
+    regulator-state-mem {
+      regulator-off-in-suspend;
+    };
+  };
 
 	vcc_lcd_en: vcc-lcd-en {
 		compatible = "regulator-fixed";
@@ -233,7 +223,7 @@
   			rockchip,pins = <3 RK_PB1 RK_FUNC_GPIO &pcfg_pull_none>;
   		};
   		sdmmc_power_en: sdmmc-power-en {
-  			rockchip,pins = <4 RK_PB4 RK_FUNC_GPIO &pcfg_pull_none>;
+  			rockchip,pins = <4 RK_PB4 RK_FUNC_GPIO &pcfg_pull_up>;
   		};
   		vcc_headset_mic: vcc-headset-mic {
   			rockchip,pins = <1 RK_PC1 RK_FUNC_GPIO &pcfg_pull_none>;
@@ -348,6 +338,13 @@
 	status = "okay";
 };
 
+&av1d {
+  status = "okay";
+};
+
+&av1d_mmu {
+  status = "okay";
+};
 &rga3_1_mmu {
 	status = "okay";
 };
@@ -428,18 +425,17 @@
 };
 
 &sdmmc {
-	max-frequency = <150000000>;
-	no-sdio;
-	no-mmc;
-  /*broken-cd;*/
-	bus-width = <4>;
-	cap-mmc-highspeed;
-	cap-sd-highspeed;
-	disable-wp;
-	sd-uhs-sdr104;
-	pinctrl-0 = <&sdmmc_clk &sdmmc_cmd &sdmmc_bus4>;
-	vmmc-supply = <&sdmmc_power>;
-	vqmmc-supply = <&vccio_sd_s0>;
+  max-frequency = <150000000>;
+  no-sdio;
+  no-mmc;
+  cap-sd-highspeed;
+  cap-mmc-highspeed;
+ // clock-frequency = <100000000>;
+  disable-wp;
+ // sd-uhs-sdr104;
+  cd-gpios = <&gpio0 RK_PA4 0>;
+  card-detect-delay = <800>;
+  vmmc-supply = <&vcc_3v3_sd_s0>;
 	status = "okay";
 };
 
@@ -538,25 +534,45 @@
 };
 
 &vp0 {
-  /delete-property/ rockchip,plane-mask;
-  /delete-property/ rockchip,primary-plane;
+  cursor-win-id=<ROCKCHIP_VOP2_ESMART0>;
+  rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0)>;
+  rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER0>;
 };
 
 &vp1 {
   cursor-win-id=<ROCKCHIP_VOP2_ESMART1>;
-  rockchip,plane-mask = <( 1 << ROCKCHIP_VOP2_CLUSTER0 | 1 << ROCKCHIP_VOP2_ESMART0 |
-        1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>;
+  rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER1 | 1 << ROCKCHIP_VOP2_ESMART1)>;
   rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER1>;
 };
 
 &vp2 {
   cursor-win-id=<ROCKCHIP_VOP2_ESMART2>;
-  rockchip,plane-mask = <( 1 << ROCKCHIP_VOP2_CLUSTER2 | 1 << ROCKCHIP_VOP2_ESMART2 |
-        1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>;
+  rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER2 | 1 << ROCKCHIP_VOP2_ESMART2)>;
   rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER2>;
 };
 
 &vp3 {
-  /delete-property/ rockchip,plane-mask;
-  /delete-property/ rockchip,primary-plane;
+  cursor-win-id=<ROCKCHIP_VOP2_ESMART3>;
+  rockchip,plane-mask = <(1 << ROCKCHIP_VOP2_CLUSTER3 | 1 << ROCKCHIP_VOP2_ESMART3)>;
+  rockchip,primary-plane = <ROCKCHIP_VOP2_CLUSTER3>;
+};
+
+
+&sdmmc_bus4 {
+	rockchip,pins =
+        <4 RK_PD0 1 &pcfg_pull_up_drv_level_12>,
+        <4 RK_PD1 1 &pcfg_pull_up_drv_level_12>,
+        <4 RK_PD2 1 &pcfg_pull_up_drv_level_12>,
+        <4 RK_PD3 1 &pcfg_pull_up_drv_level_12>;
 };
+
+&sdmmc_clk {
+   rockchip,pins =
+        <4 RK_PD5 1 &pcfg_pull_up_drv_level_12>;
+};
+
+&sdmmc_cmd {
+  rockchip,pins =
+        <4 RK_PD4 1 &pcfg_pull_up_drv_level_12>;
+};
+
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-tablet-12c.dtsi
===================================================================
--- kernel-rockchip.orig/arch/arm64/boot/dts/rockchip/rk3588s-tablet-12c.dtsi
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-tablet-12c.dtsi
@@ -84,6 +84,7 @@
 		compatible = "regulator-fixed";
 		regulator-name = "combophy_avdd0v85";
 		regulator-boot-on;
+  //  regulator-always-on;
 		regulator-min-microvolt = <850000>;
 		regulator-max-microvolt = <850000>;
 		vin-supply = <&vdd_0v85_s0>;
@@ -157,7 +158,7 @@
     dmic: dmic {
         status = "okay";
         compatible = "simple-audio-card";
-        simple-audio-card,name = "rockchip,dmic";
+        simple-audio-card,name = "rockchip-dmic";
 
         simple-audio-card,dai-link@0 {
             format = "pdm";
@@ -185,8 +186,8 @@
 		pinctrl-0 = <&uart9m2_rtsn>, <&bt_reset_gpio>, <&bt_wake_gpio>, <&bt_wake_host_irq>;
 		pinctrl-1 = <&uart9_gpios>;
 		BT,power_gpio    = <&gpio0 RK_PD4 GPIO_ACTIVE_HIGH>;
-		//BT,wake_gpio     = <&gpio0 RK_PC6 GPIO_ACTIVE_HIGH>;
-		//BT,wake_host_irq = <&gpio0 RK_PC5 GPIO_ACTIVE_HIGH>;
+		BT,wake_gpio     = <&gpio0 RK_PC6 GPIO_ACTIVE_HIGH>;
+		BT,wake_host_irq = <&gpio0 RK_PC5 GPIO_ACTIVE_HIGH>;
 		status = "okay";
 	};
 
@@ -234,10 +235,6 @@
 };
 
 &dp0_sound {
-  /*
-  pinctrl-0 = <&cc_int0_hpdin_l>;
-  hpd-gpios = <&gpio0 RK_PC4 GPIO_ACTIVE_HIGH>;
-  */
   status = "okay";
 };
 
@@ -393,7 +390,7 @@
 				vactive = <2560>;
 				hfront-porch = <60>;
 				hsync-len = <20>;
-				hback-porch = <40>;
+				hback-porch = <20>;
 				vfront-porch = <112>;
 				vsync-len = <4>;
 				vback-porch = <18>;
@@ -468,6 +465,7 @@
         himax,irq-gpio = <&gpio1 RK_PB5 GPIO_ACTIVE_HIGH>;
         himax,rst-gpio = <&gpio1 RK_PB4 GPIO_ACTIVE_HIGH>;
         report_type = <1>;
+        panel = <&dsi0_panel>;
 	};
 };
 
@@ -496,7 +494,7 @@
 		interrupts = <RK_PC4 IRQ_TYPE_LEVEL_LOW>;
 		pinctrl-names = "default";
 		pinctrl-0 = <&usbc0_int>;
-		vbus-supply = <&vbus_typec>;
+		vbus-supply = <&vbus5v0_typec>;
 		status = "okay";
 
 		ports {
@@ -584,38 +582,38 @@
 		status = "disabled";
 	};
 
-    sc8886: sc8886@6b {
-        status = "okay";
-        compatible = "southchip,sc8886";
-        reg = <0x6b>;
-        ti,usb-charger-detection = <&usbc0>;
-
-        interrupt-parent = <&gpio0>;
-        interrupts = <RK_PD5 IRQ_TYPE_LEVEL_LOW>;
-        otg-mode-en-gpios = <&gpio4 RK_PA6 GPIO_ACTIVE_HIGH>;
-        pinctrl-names = "default";
-        pinctrl-0 = <&charger_ok>;
-        extcon = <&usbc0>;
-        ti,battery = <&battery>;
-        ti,charge-current = <2500000>;
-        ti,max-input-voltage = <20000000>;
-        ti,max-input-current = <5000000>;
-        ti,max-charge-voltage = <13200000>;
-        ti,input-current = <3000000>;
-        ti,input-current-sdp = <3000000>;
-        ti,input-current-dcp = <3000000>;
-        ti,input-current-cdp = <3000000>;
-        ti,minimum-sys-voltage = <9216000>;
-        ti,otg-voltage = <5000000>;
-        ti,otg-current = <3000000>;
-        pd-charge-only = <0>;
-        regulators {
-            vbus5v0_typec: vbus5v0-typec {
-            regulator-compatible = "otg-vbus";
-            regulator-name = "vbus5v0_typec";
-			};
-        };
-    };
+  sc8886: sc8886@6b {
+      status = "okay";
+      compatible = "southchip,sc8886";
+      reg = <0x6b>;
+      ti,usb-charger-detection = <&usbc0>;
+
+      interrupt-parent = <&gpio0>;
+      interrupts = <RK_PD5 IRQ_TYPE_LEVEL_LOW>;
+      otg-mode-en-gpios = <&gpio4 RK_PA6 GPIO_ACTIVE_HIGH>;
+      pinctrl-names = "default";
+      pinctrl-0 = <&charger_ok>;
+      extcon = <&usbc0>;
+      ti,battery = <&battery>;
+      ti,charge-current = <2500000>;
+      ti,max-input-voltage = <20000000>;
+      ti,max-input-current = <5000000>;
+      ti,max-charge-voltage = <13200000>;
+      ti,input-current = <3000000>;
+      ti,input-current-sdp = <3000000>;
+      ti,input-current-dcp = <3000000>;
+      ti,input-current-cdp = <3000000>;
+      ti,minimum-sys-voltage = <9216000>;
+      ti,otg-voltage = <5000000>;
+      ti,otg-current = <3000000>;
+      pd-charge-only = <0>;
+      regulators {
+          vbus5v0_typec: vbus5v0-typec {
+          regulator-compatible = "otg-vbus";
+          regulator-name = "vbus5v0_typec";
+		};
+      };
+  };
 };
 
 &i2c7 {
@@ -699,7 +697,8 @@
 &pinctrl {
 	charger {
 		charger_ok: charger_ok {
-			rockchip,pins = <0 RK_PD5 RK_FUNC_GPIO &pcfg_pull_up>;
+			rockchip,pins = <0 RK_PD5 RK_FUNC_GPIO &pcfg_pull_up>,
+                      <4 RK_PA6 RK_FUNC_GPIO &pcfg_pull_none>;
 		};
 	};
 
@@ -816,13 +815,6 @@
               rockchip,pins = <1 RK_PD3 RK_FUNC_GPIO &pcfg_pull_up>;
       };
   };
-/*
-  vga {
-    cc_int0_hpdin_l: cc-int0-hpdin-l {
-      rockchip,pins = <0 RK_PC4 RK_FUNC_GPIO &pcfg_pull_none>;
-    };
-  };
-  */
 };
 
 &pwm14 {
@@ -871,6 +863,10 @@
 	status = "okay";
 };
 
+&vepu {
+  status = "okay";
+};
+
 &rockchip_suspend {
 	status = "okay";
 	rockchip,sleep-debug-en = <1>;
@@ -892,28 +888,24 @@
 	status = "okay";
 };
 
-&spi2 {
-	status = "okay";
-};
-
+&spi3 {
+  status = "okay";
+  assigned-clocks = <&cru CLK_SPI3>;
+  assigned-clock-rates = <200000000>;
+  pinctrl-names = "default";
+  pinctrl-0 = <&spi3m1_cs0 &spi3m1_pins>;
+  num-cs = <1>;
+  madev@0 {
+    status = "okay";
+    compatible = "microarray,microarray-fp";
+    fingerprint,touch-int-gpio = <&gpio3 RK_PB0 IRQ_TYPE_EDGE_RISING>;
+    pinctrl-names = "default";
 
-&spi0 {
-	status = "disabled";
-	assigned-clocks = <&cru CLK_SPI0>;
-	assigned-clock-rates = <200000000>;
-	pinctrl-names = "default";
-	pinctrl-0 = <&spi0m2_cs0 &spi0m2_pins>;
-	num-cs = <1>;
-    madev@0 {
-		status = "okay";
-		compatible = "microarray,microarray-fp";
-		/*irq-gpio = <&gpio3 RK_PB0 IRQ_TYPE_EDGE_RISING>;*/
-        fingerprint,touch-int-gpio = <&gpio3 RK_PB0 IRQ_TYPE_EDGE_RISING>;
-		reg = <0>;
-		spi-max-frequency = <6000000>;
-		spi-cpha;
-		spi-cpol;
-	};
+    reg = <0>;
+    spi-max-frequency = <6000000>;
+    spi-cpha;
+    spi-cpol;
+  };
 };
 
 &tsadc {
@@ -930,23 +922,25 @@
 	rockchip,typec-vbus-det;
 };
 
+/*
 &u2phy2_host {
-	//phy-supply = <&vcc5v0_host_en>;
+	phy-supply = <&vcc5v0_host_en>;
 };
 
 &u2phy3_host {
-	//phy-supply = <&vcc5v0_host_en>;
+	phy-supply = <&vcc5v0_host_en>;
 };
-
+*/
 &usbdp_phy0 {
 	orientation-switch;
 	svid = <0xff01>;
 	sbu1-dc-gpios = <&gpio4 RK_PA0 GPIO_ACTIVE_HIGH>;
 	sbu2-dc-gpios = <&gpio4 RK_PA1 GPIO_ACTIVE_HIGH>;
+/*
+  keep-dp-normal;
 	pinctrl-names = "default";
 	pinctrl-0 = <&sbu1_dc &sbu2_dc>;
-  keep-dp-normal;
-
+*/
 	port {
 		#address-cells = <1>;
 		#size-cells = <0>;
@@ -983,8 +977,6 @@
 	status = "disabled";
 };
 
-
-
 &vdpu {
 	status = "okay";
 };
Index: kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-12c-rk806-single.dtsi
===================================================================
--- kernel-rockchip.orig/arch/arm64/boot/dts/rockchip/rk3588s-12c-rk806-single.dtsi
+++ kernel-rockchip/arch/arm64/boot/dts/rockchip/rk3588s-12c-rk806-single.dtsi
@@ -6,7 +6,21 @@
 
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/pinctrl/rockchip.h>
-
+/*
+&pinctrl {
+  rk860x {
+    vdd_cpu_big0_pins: vdd-cpu-big0-pins {
+      rockchip,pins = <0 RK_PA3 0 &pcfg_pull_none>;
+    };
+    vdd_cpu_big1_pins: vdd-cpu-big1-pins {
+      rockchip,pins = <0 RK_PD6 0 &pcfg_pull_none>;
+    };
+    vdd_npu_pins: vdd-npu-pins {
+      rockchip,pins = <0 RK_PC1 0 &pcfg_pull_none>;
+    };
+  };
+};
+*/
 &i2c0 {
 	status = "okay";
 	pinctrl-names = "default";
@@ -25,7 +39,6 @@
 		regulator-always-on;
 		regulator-state-mem {
 			regulator-off-in-suspend;
-      regulator-suspend-microvolt = <550000>;
 		};
 	};
 
@@ -43,7 +56,6 @@
 		regulator-always-on;
 		regulator-state-mem {
 			regulator-off-in-suspend;
-      regulator-suspend-microvolt = <550000>;
 		};
 	};
 };
@@ -219,6 +231,7 @@
 				regulator-max-microvolt = <950000>;
 				regulator-ramp-delay = <12500>;
 				regulator-name = "vdd_gpu_s0";
+        regulator-enable-ramp-delay = <400>;
 				regulator-state-mem {
 					regulator-off-in-suspend;
 				};
@@ -244,7 +257,7 @@
 				regulator-ramp-delay = <12500>;
 				regulator-name = "vdd_log_s0";
 				regulator-state-mem {
-					regulator-on-in-suspend;
+					regulator-off-in-suspend;
 				};
 			};
 
@@ -290,8 +303,7 @@
 				regulator-max-microvolt = <2000000>;
 				regulator-name = "vdd_2v0_pldo_s3";
 				regulator-state-mem {
-					regulator-on-in-suspend;
-					regulator-suspend-microvolt = <2000000>;
+					regulator-off-in-suspend;
 				};
 			};
 
@@ -303,6 +315,7 @@
 				regulator-name = "vcc_3v3_s3";
 				regulator-state-mem {
 					regulator-on-in-suspend;
+          regulator-suspend-microvolt = <3300000>;
 				};
 			};
 
@@ -323,7 +336,7 @@
 				regulator-name = "vcc_1v8_s3";
 				regulator-state-mem {
 					regulator-on-in-suspend;
-					regulator-suspend-microvolt = <1800000>;
+          regulator-suspend-microvolt = <1800000>;
 				};
 			};
 
@@ -346,7 +359,7 @@
 				regulator-name = "vcc_1v8_s0";
 				regulator-state-mem {
 					regulator-off-in-suspend;
-					regulator-suspend-microvolt = <1800000>;
+          regulator-suspend-microvolt = <1800000>;
 				};
 			};
 
Index: kernel-rockchip/drivers/usb/typec/tcpm/tcpci_husb311.c
===================================================================
--- kernel-rockchip.orig/drivers/usb/typec/tcpm/tcpci_husb311.c
+++ kernel-rockchip/drivers/usb/typec/tcpm/tcpci_husb311.c
@@ -177,6 +177,11 @@ static int husb311_probe(struct i2c_clie
 			return ret;
 	}
 
+  if (regulator_get_mode(chip->vbus) == REGULATOR_MODE_INVALID) {
+          pr_info("[DEBUG] husb311 -> vbus = NULL\n");
+          chip->vbus = NULL;
+  }
+
 	ret = husb311_sw_reset(chip);
 	if (ret < 0) {
 		dev_err(chip->dev, "fail to soft reset, ret = %d\n", ret);
Index: kernel-rockchip/drivers/power/supply/bq25700_charger.c
===================================================================
--- kernel-rockchip.orig/drivers/power/supply/bq25700_charger.c
+++ kernel-rockchip/drivers/power/supply/bq25700_charger.c
@@ -25,7 +25,7 @@
 #include <linux/gpio.h>
 #include <linux/of_gpio.h>
 
-static int dbg_enable;
+static int dbg_enable = 0;
 module_param_named(dbg_level, dbg_enable, int, 0644);
 
 #define DBG(args...) \
@@ -50,6 +50,9 @@ module_param_named(dbg_level, dbg_enable
 #define MIN_OTGVOLTAGE			4280000
 #define MAX_OTGCURRENT			6350000
 
+#define DELAY_TIME 60000 //60 seconds
+#define SHORT_DELAY_TIME 5000 // 3 seconds
+
 enum bq25700_fields {
 	EN_LWPWR, WDTWR_ADJ, IDPM_AUTO_DISABLE,
 	EN_OOA, PWM_FREQ, EN_LEARN, IADP_GAIN, IBAT_GAIN,
@@ -199,6 +202,19 @@ struct bq25700_device {
 	int				pd_charge_only;
 	unsigned int			bc_event;
 	bool				usb_bc;
+  bool        ready;
+  struct power_supply *battery;
+  struct delayed_work init_charger_current;
+  bool delay_charge_current;
+  u32 target_current;
+  u32 target_input_current;
+  u32 target_input_vol;
+};
+
+struct bq25700_data {
+  const struct regmap_config *regmap_config;
+  const struct reg_field *reg_fields;
+  const int reg_fields_num;
 };
 
 static const struct reg_field bq25700_reg_fields[] = {
@@ -604,6 +620,14 @@ static void bq25700_disable_charge(struc
 
 static struct bq25700_device *bq25700_charger;
 
+static void bq25700_notify_battery(struct bq25700_device *charger) {
+  struct power_supply *battery = charger->battery;
+  if (IS_ERR_OR_NULL(battery) ||
+      IS_ERR_OR_NULL(battery->desc->external_power_changed))
+    return;
+ // battery->desc->external_power_changed(battery);
+}
+
 static int bq25700_field_read(struct bq25700_device *charger,
 			      enum bq25700_fields field_id)
 {
@@ -814,6 +838,32 @@ static int bq25703_dump_regs(struct bq25
 	return 0;
 }
 
+  static void bq25700_delay_work_func(struct work_struct *work) {
+    int ret;
+    struct bq25700_state state;
+    struct bq25700_device *charger = container_of(work,
+                                             struct bq25700_device,
+                                             init_charger_current.work);
+    charger->delay_charge_current = false;
+    DBG("Enable charge, set charge current idx:%u, input_current:%u, input_vol:%u\n",
+        charger->target_current, charger->target_input_current, charger->target_input_vol);
+    ret = bq25700_field_write(charger, MAX_CHARGE_VOLTAGE, charger->init_data.max_chg_vol);
+    if (ret < 0) {
+      DBG("failed to set charge voltage, ret:%d\n",ret);
+    }
+    bq25700_field_write(charger, INPUT_CURRENT, charger->target_input_current);
+    bq25700_field_write(charger, INPUT_VOLTAGE, charger->target_input_vol);
+    ret = bq25700_field_write(charger, CHARGE_CURRENT, charger->target_current);
+    if (ret <0) {
+      DBG("failed to set current, ret:%d\n",ret);
+    }
+    bq25700_get_chip_state(charger, &state);
+    charger->state = state;
+    power_supply_changed(charger->supply_charger);
+    if (bq25700_field_read(charger, AC_STAT))
+        bq25700_notify_battery(charger);
+  }
+
 static ssize_t bq25700_charge_info_show(struct device *dev,
 				 struct device_attribute *attr, char *buf)
 {
@@ -872,12 +922,18 @@ void bq25700_charger_set_current(unsigne
 	switch (event) {
 	case CHARGER_CURRENT_EVENT:
 		idx = bq25700_find_idx(current_value, TBL_ICHG);
-		bq25700_field_write(bq25700_charger, CHARGE_CURRENT, idx);
+    if (bq25700_charger->delay_charge_current)
+      bq25700_charger->target_current = idx;
+    else
+		  bq25700_field_write(bq25700_charger, CHARGE_CURRENT, idx);
 		break;
 
 	case INPUT_CURRENT_EVENT:
 		idx = bq25700_find_idx(current_value, TBL_INPUTCUR);
-		bq25700_field_write(bq25700_charger, INPUT_CURRENT, idx);
+    if (bq25700_charger->delay_charge_current)
+      bq25700_charger->target_input_current = idx;
+    else
+		  bq25700_field_write(bq25700_charger, INPUT_CURRENT, idx);
 		break;
 
 	default:
@@ -980,23 +1036,36 @@ static int bq25700_hw_init(struct bq2570
 	int ret;
 	int i;
 	struct bq25700_state state;
+  union power_supply_propval capacity;
+  unsigned long delay;
 
-	const struct {
+	struct {
 		enum bq25700_fields id;
 		u32 value;
 	} init_data[] = {
-		{CHARGE_CURRENT,	 charger->init_data.ichg},
-		{MAX_CHARGE_VOLTAGE,	 charger->init_data.max_chg_vol},
+    {CHARGE_CURRENT,   charger->init_data.ichg},
+    {MAX_CHARGE_VOLTAGE,   charger->init_data.max_chg_vol},
 		{MIN_SYS_VOTAGE,	 charger->init_data.sys_min_voltage},
 		{OTG_VOLTAGE,	 charger->init_data.otg_voltage},
 		{OTG_CURRENT,	 charger->init_data.otg_current},
 	};
-
+  ret = charger->battery->desc->get_property(charger->battery,
+                                             POWER_SUPPLY_PROP_CAPACITY,
+                                             &capacity);
+  dev_info(charger->dev, "Battery capacity:%d, ret:%d\n", capacity.intval, ret);
+  if (charger->delay_charge_current) {
+    init_data[0].value = 0;
+    init_data[1].value = 0;
+    if (ret < 0 || capacity.intval < 5)
+      delay = msecs_to_jiffies(DELAY_TIME);
+    else
+      delay = msecs_to_jiffies(SHORT_DELAY_TIME);
+    schedule_delayed_work(&charger->init_charger_current, delay);
+  }
 	/* disable watchdog */
 	ret = bq25700_field_write(charger, WDTWR_ADJ, 0);
 	if (ret < 0)
 		return ret;
-
 	/* initialize currents/voltages and other parameters */
 	for (i = 0; i < ARRAY_SIZE(init_data); i++) {
 		ret = bq25700_field_write(charger, init_data[i].id,
@@ -1015,6 +1084,7 @@ static int bq25700_hw_init(struct bq2570
 	    bq25700_field_read(charger, INPUT_CURRENT) * 50);
 	DBG("	 MIN_SYS_VOTAGE: %dmV\n",
 	    1024 + bq25700_field_read(charger, MIN_SYS_VOTAGE) * 256);
+  DBG("  EN_OOA:%d\n", bq25700_field_read(charger, EN_OOA));
 
 	/* Configure ADC for continuous conversions. This does not enable it. */
 
@@ -1092,7 +1162,6 @@ static int bq25700_hw_init(struct bq2570
 
 	bq25700_get_chip_state(charger, &state);
 	charger->state = state;
-
 	return 0;
 }
 
@@ -1110,6 +1179,11 @@ static int bq25700_fw_probe(struct bq257
 static void bq25700_enable_charger(struct bq25700_device *charger,
 				   u32 input_current)
 {
+  if (charger->delay_charge_current) {
+    charger->target_current = charger->init_data.ichg;
+    charger->target_input_current = input_current;
+    return;
+  }
 	bq25700_field_write(charger, INPUT_CURRENT, input_current);
 	bq25700_field_write(charger, CHARGE_CURRENT, charger->init_data.ichg);
 }
@@ -1240,8 +1314,8 @@ static int bq25700_power_supply_init(str
 {
 	struct power_supply_config psy_cfg = { .drv_data = charger, };
 
-	psy_cfg.supplied_to = bq25700_charger_supplied_to;
-	psy_cfg.num_supplicants = ARRAY_SIZE(bq25700_charger_supplied_to);
+ 	psy_cfg.supplied_to = bq25700_charger_supplied_to;
+  psy_cfg.num_supplicants = ARRAY_SIZE(bq25700_charger_supplied_to);
 	psy_cfg.of_node = charger->dev->of_node;
 
 	charger->supply_charger =
@@ -1285,6 +1359,7 @@ static int bq2570x_pd_notifier_call(stru
 	if (prop.intval == 0) {
 		queue_delayed_work(bq->usb_charger_wq, &bq->discnt_work,
 				   msecs_to_jiffies(10));
+    bq25700_notify_battery(bq);
 		return NOTIFY_OK;
 	}
 
@@ -1304,15 +1379,24 @@ static int bq2570x_pd_notifier_call(stru
 			return NOTIFY_OK;
 		chr_idx = bq25700_find_idx(prop.intval, TBL_ICHG);
 
-		bq25700_field_write(bq, INPUT_CURRENT, cur_idx);
-		bq25700_field_write(bq, INPUT_VOLTAGE, vol_idx);
-		bq25700_field_write(bq, CHARGE_CURRENT, chr_idx);
+  	if (bq->delay_charge_current) {
+      DBG("delay charge,cur:%d\n", chr_idx);
+  		bq->target_current = chr_idx;
+      bq->target_input_current = cur_idx;
+      bq->target_input_vol = vol_idx;
+    } else {
+		  bq25700_field_write(bq, INPUT_CURRENT, cur_idx);
+		  bq25700_field_write(bq, INPUT_VOLTAGE, vol_idx);
+      bq25700_field_write(bq, CHARGE_CURRENT, chr_idx);
+    }
 		dev_info(bq->dev, "INPUT_CURRENT:%d, INPUT_VOLTAGE:%d, CHARGE_CURRENT:%d\n",
 			 cur_idx, vol_idx, chr_idx);
 
 		bq25700_get_chip_state(bq, &state);
 		bq->state = state;
 		power_supply_changed(bq->supply_charger);
+    if (bq25700_field_read(bq, AC_STAT))
+      bq25700_notify_battery(bq);
 	}
 	return NOTIFY_OK;
 }
@@ -1336,6 +1420,7 @@ static irqreturn_t bq25700_irq_handler_t
 		charger->typec0_status = USB_STATUS_NONE;
 		charger->typec1_status = USB_STATUS_NONE;
 	}
+  bq25700_notify_battery(charger);
 	irq_set_irq_type(irq, irq_flag | IRQF_ONESHOT);
 
 	return IRQ_HANDLED;
@@ -1507,11 +1592,15 @@ static int bq25700_charger_evt_notifier1
 
 static void bq25700_set_otg_vbus(struct bq25700_device *charger, bool enable)
 {
+  u32 value;
 	DBG("OTG %s\n", enable ? "enable" : "disable");
-
+  value = enable ? charger->init_data.otg_voltage :
+                   bq25700_find_idx(MIN_OTGVOLTAGE, TBL_OTGVOL);
 	if (!IS_ERR_OR_NULL(charger->otg_mode_en_io))
 		gpiod_direction_output(charger->otg_mode_en_io, enable);
-	bq25700_field_write(charger, EN_OTG, enable);
+  bq25700_field_write(charger,OTG_VOLTAGE,value);
+  bq25700_field_write(charger, EN_OTG, enable);
+  bq25700_notify_battery(charger);
 }
 
 static void bq25700_host_evt_worker(struct work_struct *work)
@@ -1720,6 +1809,14 @@ static int bq25700_register_pd_nb(struct
 
 		cur_idx = bq25700_find_idx(prop.intval, TBL_INPUTCUR);
 		vol_idx = bq25700_find_idx((prop.intval - 1280000 - 3200000), TBL_INPUTVOL);
+    if (charger->delay_charge_current) {
+      charger->target_current = charger->init_data.ichg;
+      charger->target_input_current = cur_idx;
+      charger->target_input_vol = vol_idx;
+      DBG("delay charge, input_current:%d, input_voltage:%d, charge_current:%d\n",
+        cur_idx, vol_idx, charger->init_data.ichg);
+      return 0;
+    }
 		bq25700_field_write(charger, INPUT_CURRENT, cur_idx);
 		bq25700_field_write(charger, INPUT_VOLTAGE, vol_idx);
 		bq25700_field_write(charger, CHARGE_CURRENT,
@@ -1772,7 +1869,8 @@ static int bq25700_otg_vbus_enable(struc
 {
 	struct bq25700_device *charger = rdev_get_drvdata(dev);
 
-	bq25700_set_otg_vbus(charger, true);
+  if (charger->ready)
+	  bq25700_set_otg_vbus(charger, true);
 
 	return 0;
 }
@@ -1781,7 +1879,8 @@ static int bq25700_otg_vbus_disable(stru
 {
 	struct bq25700_device *charger = rdev_get_drvdata(dev);
 
-	bq25700_set_otg_vbus(charger, false);
+  if (charger->ready)
+	  bq25700_set_otg_vbus(charger, false);
 
 	return 0;
 }
@@ -1799,10 +1898,17 @@ static int bq25700_otg_vbus_is_enabled(s
 	return val && gpio_status ? 1 : 0;
 }
 
+static unsigned int bq25700_otg_vbus_status(struct regulator_dev *dev)
+{
+  struct bq25700_device *charger = rdev_get_drvdata(dev);
+	return charger->ready ? REGULATOR_MODE_NORMAL : REGULATOR_MODE_INVALID;
+}
+
 static const struct regulator_ops bq25700_otg_vbus_ops = {
 	.enable = bq25700_otg_vbus_enable,
 	.disable = bq25700_otg_vbus_disable,
 	.is_enabled = bq25700_otg_vbus_is_enabled,
+  .get_mode = bq25700_otg_vbus_status,
 };
 
 static const struct regulator_desc bq25700_otg_vbus_desc = {
@@ -1948,20 +2054,21 @@ static int bq25700_parse_dt(struct bq257
 	return 0;
 }
 
-static int bq25700_probe(struct i2c_client *client,
-			 const struct i2c_device_id *id)
+static int probe_cnt = 0;
+
+static int bq25700_register(struct i2c_client *client,
+			 const struct bq25700_data *bq25700_data)
 {
 	struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
 	struct device *dev = &client->dev;
 	struct bq25700_device *charger;
-	struct device_node *charger_np;
 	int ret = 0;
 	u32 i = 0;
 	int irq_flag;
 
 	if (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA))
 		return -EIO;
-
+	probe_cnt++;
 	charger = devm_kzalloc(&client->dev, sizeof(*charger), GFP_KERNEL);
 	if (!charger)
 		return -EINVAL;
@@ -1969,51 +2076,26 @@ static int bq25700_probe(struct i2c_clie
 	charger->client = client;
 	charger->dev = dev;
 
-	charger_np = of_find_compatible_node(NULL, NULL, "ti,bq25700");
-	if (!charger_np)
-		charger_np = of_find_compatible_node(NULL, NULL, "southchip,sc8885");
-	if (charger_np) {
-		charger->regmap = devm_regmap_init_i2c(client,
-						       &bq25700_regmap_config);
-		if (IS_ERR(charger->regmap)) {
-			dev_err(&client->dev, "Failed to initialize regmap\n");
-			return -EINVAL;
-		}
-
-		for (i = 0; i < ARRAY_SIZE(bq25700_reg_fields); i++) {
-			const struct reg_field *reg_fields = bq25700_reg_fields;
-
-			charger->rmap_fields[i] =
-				devm_regmap_field_alloc(dev,
-							charger->regmap,
-							reg_fields[i]);
-			if (IS_ERR(charger->rmap_fields[i])) {
-				dev_err(dev, "cannot allocate regmap field\n");
-				return PTR_ERR(charger->rmap_fields[i]);
-			}
-		}
-	} else {
-		charger->regmap = devm_regmap_init_i2c(client,
-						       &bq25703_regmap_config);
-
-		if (IS_ERR(charger->regmap)) {
-			dev_err(&client->dev, "Failed to initialize regmap\n");
-			return -EINVAL;
-		}
+	charger->regmap = devm_regmap_init_i2c(client,
+					       bq25700_data->regmap_config);
+	if (IS_ERR(charger->regmap)) {
+		dev_err(&client->dev, "Failed to initialize regmap\n");
+		return -EINVAL;
+	}
 
-		for (i = 0; i < ARRAY_SIZE(bq25703_reg_fields); i++) {
-			const struct reg_field *reg_fields = bq25703_reg_fields;
+	for (i = 0; i < bq25700_data->reg_fields_num ; i++) {
+		const struct reg_field *reg_fields = bq25700_data->reg_fields;
 
-			charger->rmap_fields[i] =
-				devm_regmap_field_alloc(dev,
-							charger->regmap,
-							reg_fields[i]);
-			if (IS_ERR(charger->rmap_fields[i])) {
-				dev_err(dev, "cannot allocate regmap field\n");
-				return PTR_ERR(charger->rmap_fields[i]);
-			}
+		charger->rmap_fields[i] =
+			devm_regmap_field_alloc(dev,
+						charger->regmap,
+						reg_fields[i]);
+		if (IS_ERR(charger->rmap_fields[i])) {
+			dev_err(dev, "cannot allocate regmap field\n");
+			return PTR_ERR(charger->rmap_fields[i]);
 		}
 	}
+
 	i2c_set_clientdata(client, charger);
 
 	/*read chip id. Confirm whether to support the chip*/
@@ -2023,7 +2105,6 @@ static int bq25700_probe(struct i2c_clie
 		dev_err(dev, "Cannot read chip ID.\n");
 		return charger->chip_id;
 	}
-
 	if (!dev->platform_data) {
 		ret = bq25700_fw_probe(charger);
 		if (ret < 0) {
@@ -2033,21 +2114,27 @@ static int bq25700_probe(struct i2c_clie
 	} else {
 		return -ENODEV;
 	}
-
+  charger->ready = false;
+  INIT_DELAYED_WORK(&charger->init_charger_current, bq25700_delay_work_func);
+  charger->delay_charge_current = false;
 	/*
 	 * Make sure battery online, otherwise, writing INPUT_CURRENT and
 	 * CHARGE_CURRENT would make system power off
 	 */
-	if (of_parse_phandle(charger->dev->of_node, "ti,battery", 0)) {
-		if (IS_ERR_OR_NULL(power_supply_get_by_phandle(
-						charger->dev->of_node,
-						"ti,battery"))) {
-			dev_info(charger->dev, "No battery found\n");
-			return -EPROBE_DEFER;
-		}
-		dev_info(charger->dev, "Battery found\n");
-	}
-
+  charger->battery = power_supply_get_by_phandle(
+                  dev->of_node,
+                  "ti,battery");
+	if (IS_ERR_OR_NULL(charger->battery)) {
+		dev_warn(charger->dev, "No battery found\n");
+		if (probe_cnt > 3) {
+			dev_info(charger->dev, "typec vbus registered anyway\n");
+			return bq25700_register_otg_vbus_regulator(charger);
+		}
+		return -EPROBE_DEFER;
+	}
+	dev_info(charger->dev, "Battery found\n");
+  charger->delay_charge_current = true;
+	charger->ready = true;
 	ret = bq25700_hw_init(charger);
 	if (ret < 0) {
 		dev_err(dev, "Cannot initialize the chip.\n");
@@ -2090,6 +2177,8 @@ static void bq25700_shutdown(struct i2c_
 {
 	int vol_idx;
 	struct bq25700_device *charger = i2c_get_clientdata(client);
+  if (charger->delay_charge_current)
+    cancel_delayed_work(&charger->init_charger_current);
 
 	vol_idx = bq25700_find_idx(DEFAULT_INPUTVOL, TBL_INPUTVOL);
 	bq25700_field_write(charger, INPUT_VOLTAGE, vol_idx);
@@ -2129,12 +2218,24 @@ static const struct i2c_device_id bq2570
 };
 MODULE_DEVICE_TABLE(i2c, bq25700_i2c_ids);
 
+static const struct bq25700_data bq25700_driver_data = {
+  .regmap_config = &bq25700_regmap_config,
+  .reg_fields = bq25700_reg_fields,
+  .reg_fields_num = ARRAY_SIZE(bq25700_reg_fields),
+};
+
+static const struct bq25700_data bq25703_driver_data = {
+  .regmap_config = &bq25703_regmap_config,
+  .reg_fields = bq25703_reg_fields,
+  .reg_fields_num = ARRAY_SIZE(bq25703_reg_fields),
+};
+
 #ifdef CONFIG_OF
 static const struct of_device_id bq25700_of_match[] = {
-	{ .compatible = "ti,bq25700", },
-	{ .compatible = "ti,bq25703", },
-	{ .compatible = "southchip,sc8885", },
-	{ .compatible = "southchip,sc8886", },
+	{ .compatible = "ti,bq25700", .data = &bq25700_driver_data },
+	{ .compatible = "ti,bq25703", .data = &bq25703_driver_data },
+	{ .compatible = "southchip,sc8885", .data = &bq25700_driver_data },
+	{ .compatible = "southchip,sc8886", .data = &bq25703_driver_data },
 	{ },
 };
 MODULE_DEVICE_TABLE(of, bq25700_of_match);
@@ -2144,6 +2245,15 @@ static const struct of_device_id bq25700
 };
 #endif
 
+static int bq25700_probe(struct i2c_client *client,
+       const struct i2c_device_id *id) {
+  const struct bq25700_data *bq25700_data;
+  const struct of_device_id *match;
+  match = of_match_node(bq25700_of_match, client->dev.of_node);
+  bq25700_data = match->data;
+  return bq25700_register(client, bq25700_data);
+}
+
 static struct i2c_driver bq25700_driver = {
 	.probe		= bq25700_probe,
 	.shutdown	= bq25700_shutdown,
Index: kernel-rockchip/drivers/cpufreq/Kconfig
===================================================================
--- kernel-rockchip.orig/drivers/cpufreq/Kconfig
+++ kernel-rockchip/drivers/cpufreq/Kconfig
@@ -5,8 +5,8 @@ config CPU_FREQ
 	bool "CPU Frequency scaling"
 	select SRCU
 	help
-	  CPU Frequency scaling allows you to change the clock speed of 
-	  CPUs on the fly. This is a nice method to save power, because 
+	  CPU Frequency scaling allows you to change the clock speed of
+	  CPUs on the fly. This is a nice method to save power, because
 	  the lower the CPU clock speed, the less power the CPU consumes.
 
 	  Note that this driver doesn't automatically change the CPU
@@ -72,7 +72,7 @@ config CPU_FREQ_DEFAULT_GOV_USERSPACE
 	select CPU_FREQ_GOV_USERSPACE
 	help
 	  Use the CPUFreq governor 'userspace' as default. This allows
-	  you to set the CPU frequency manually or when a userspace 
+	  you to set the CPU frequency manually or when a userspace
 	  program shall be able to set the CPU dynamically without having
 	  to enable the userspace governor manually.
 
@@ -152,7 +152,7 @@ config CPU_FREQ_GOV_USERSPACE
 	help
 	  Enable this cpufreq governor when you either want to set the
 	  CPU frequency manually or when a userspace program shall
-	  be able to set the CPU dynamically, like on LART 
+	  be able to set the CPU dynamically, like on LART
 	  <http://www.lartmaker.nl/>.
 
 	  To compile this driver as a module, choose M here: the
@@ -167,11 +167,11 @@ config CPU_FREQ_GOV_ONDEMAND
 	select CPU_FREQ_GOV_COMMON
 	help
 	  'ondemand' - This driver adds a dynamic cpufreq policy governor.
-	  The governor does a periodic polling and 
+	  The governor does a periodic polling and
 	  changes frequency based on the CPU utilization.
 	  The support for this governor depends on CPU capability to
 	  do fast frequency switching (i.e, very low latency frequency
-	  transitions). 
+	  transitions).
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called cpufreq_ondemand.
@@ -242,6 +242,17 @@ config CPU_FREQ_GOV_INTERACTIVE
 
 	  If in doubt, say N.
 
+config CPU_BOOST
+  tristate "Input event based short term CPU freq booster"
+  depends on INPUT
+  help
+    This driver monitors events from input devices, such as
+    touchscreen, trackpad, keyboard, etc., and boosts frequency
+    of all CPUs in the system in response to user interacting with
+    the device.
+
+    If in doubt, say N.
+
 comment "CPU frequency scaling drivers"
 
 config CPUFREQ_DT
Index: kernel-rockchip/drivers/cpufreq/Makefile
===================================================================
--- kernel-rockchip.orig/drivers/cpufreq/Makefile
+++ kernel-rockchip/drivers/cpufreq/Makefile
@@ -17,6 +17,7 @@ obj-$(CONFIG_CPU_FREQ_GOV_CONSERVATIVE)
 obj-$(CONFIG_CPU_FREQ_GOV_INTERACTIVE)	+= cpufreq_interactive.o
 obj-$(CONFIG_CPU_FREQ_GOV_COMMON)		+= cpufreq_governor.o
 obj-$(CONFIG_CPU_FREQ_GOV_ATTR_SET)	+= cpufreq_governor_attr_set.o
+obj-$(CONFIG_CPU_BOOST)     += cpu-boost.o
 
 obj-$(CONFIG_CPUFREQ_DT)		+= cpufreq-dt.o
 obj-$(CONFIG_CPUFREQ_DT_PLATDEV)	+= cpufreq-dt-platdev.o
Index: kernel-rockchip/drivers/cpufreq/cpu-boost.c
===================================================================
--- /dev/null
+++ kernel-rockchip/drivers/cpufreq/cpu-boost.c
@@ -0,0 +1,306 @@
+/*
+ * Copyright (C) 2014 Google, Inc.
+ *
+ * Loosely based on cpu-boost.c from Android tree
+ * Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/cpufreq.h>
+#include <linux/cpu.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/notifier.h>
+#include <linux/pm_qos.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+
+static unsigned int cpuboost_input_boost_freq_percent;
+module_param_named(input_boost_freq_percent,
+		   cpuboost_input_boost_freq_percent, uint, 0644);
+MODULE_PARM_DESC(input_boost_freq_percent,
+		 "Percentage of max frequency of CPU to be used as boost frequency");
+
+static unsigned int cpuboost_input_boost_ms = 40;
+module_param_named(input_boost_ms,
+		   cpuboost_input_boost_ms, uint, 0644);
+MODULE_PARM_DESC(input_boost_ms, "Duration of input boost (msec)");
+
+static unsigned int cpuboost_input_boost_interval_ms = 150;
+module_param_named(input_boost_interval_ms,
+		   cpuboost_input_boost_interval_ms, uint, 0644);
+MODULE_PARM_DESC(input_boost_interval_ms,
+		 "Interval between input events to reactivate input boost (msec)");
+
+DEFINE_MUTEX(cpuboost_mutex);
+
+static bool cpuboost_boost_active;
+
+static LIST_HEAD(cpuboost_policy_list);
+
+struct cpuboost_policy_node {
+	struct list_head policy_list;
+	struct freq_qos_request qos_req;
+	struct cpufreq_policy *policy;
+};
+
+static int cpuboost_policy_notifier(struct notifier_block *nb,
+				    unsigned long val, void *data)
+{
+	struct cpufreq_policy *policy = data;
+	struct cpuboost_policy_node *node;
+	int ret;
+	bool found;
+
+	switch (val) {
+	case CPUFREQ_CREATE_POLICY:
+		node = kzalloc(sizeof(*node), GFP_KERNEL);
+		if (!node)
+			break;
+
+		node->policy = policy;
+
+		/*
+		 * Always init to no boost and we'll get the boost the next
+		 * time input comes in.
+		 */
+		ret = freq_qos_add_request(&policy->constraints,
+					   &node->qos_req, FREQ_QOS_MIN, 0);
+		if (ret < 0) {
+			pr_warn("Failed to add input boost: %d\n", ret);
+			kfree(node);
+			break;
+		}
+
+		mutex_lock(&cpuboost_mutex);
+		list_add(&node->policy_list, &cpuboost_policy_list);
+		mutex_unlock(&cpuboost_mutex);
+
+		return NOTIFY_OK;
+
+	case CPUFREQ_REMOVE_POLICY:
+		mutex_lock(&cpuboost_mutex);
+		found = false;
+		list_for_each_entry(node, &cpuboost_policy_list, policy_list) {
+			if (node->policy == policy) {
+				found = true;
+				break;
+			}
+		}
+
+		if (!found) {
+			pr_warn("Couldn't find input boost for policy\n");
+			mutex_unlock(&cpuboost_mutex);
+			break;
+		}
+		list_del(&node->policy_list);
+		mutex_unlock(&cpuboost_mutex);
+
+		ret = freq_qos_remove_request(&node->qos_req);
+		kfree(node);
+		if (ret < 0) {
+			pr_warn("Failed to remove input boost: %d\n", ret);
+			break;
+		}
+
+		return NOTIFY_OK;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block cpuboost_policy_nb = {
+	.notifier_call = cpuboost_policy_notifier,
+};
+
+static void cpuboost_toggle_boost(bool boost_active)
+{
+	struct cpuboost_policy_node *node;
+	int ret;
+	s32 freq = 0;
+
+	mutex_lock(&cpuboost_mutex);
+	cpuboost_boost_active = boost_active;
+	list_for_each_entry(node, &cpuboost_policy_list, policy_list) {
+		if (boost_active)
+			freq = node->policy->cpuinfo.max_freq / 100 *
+			       cpuboost_input_boost_freq_percent;
+		ret = freq_qos_update_request(&node->qos_req, freq);
+		if (ret < 0)
+			pr_warn("Error updating cpuboost request: %d\n", ret);
+	}
+	mutex_unlock(&cpuboost_mutex);
+}
+
+static void cpuboost_cancel_input_boost(struct work_struct *work)
+{
+	cpuboost_toggle_boost(false);
+}
+static DECLARE_DELAYED_WORK(cpuboost_cancel_boost_work,
+			    cpuboost_cancel_input_boost);
+
+static void cpuboost_do_input_boost(struct work_struct *work)
+{
+	mod_delayed_work(system_wq, &cpuboost_cancel_boost_work,
+			 msecs_to_jiffies(cpuboost_input_boost_ms));
+
+	cpuboost_toggle_boost(true);
+}
+static DECLARE_WORK(cpuboost_input_boost_work, cpuboost_do_input_boost);
+
+static void cpuboost_input_event(struct input_handle *handle,
+				 unsigned int type, unsigned int code,
+				 int value)
+{
+	static unsigned long last_event_time;
+	unsigned long now = jiffies;
+	unsigned int threshold;
+
+	if (!cpuboost_input_boost_freq_percent)
+		return;
+
+	threshold = msecs_to_jiffies(cpuboost_input_boost_interval_ms);
+	if (time_after(now, last_event_time + threshold))
+		queue_work(system_highpri_wq, &cpuboost_input_boost_work);
+
+	last_event_time = now;
+}
+
+static int cpuboost_input_connect(struct input_handler *handler,
+				  struct input_dev *dev,
+				  const struct input_device_id *id)
+{
+	struct input_handle *handle;
+	int error;
+
+	handle = kzalloc(sizeof(struct input_handle), GFP_KERNEL);
+	if (!handle)
+		return -ENOMEM;
+
+	handle->dev = dev;
+	handle->handler = handler;
+	handle->name = "cpu-boost";
+
+	error = input_register_handle(handle);
+	if (error)
+		goto err2;
+
+	error = input_open_device(handle);
+	if (error)
+		goto err1;
+
+	return 0;
+
+err1:
+	input_unregister_handle(handle);
+err2:
+	kfree(handle);
+	return error;
+}
+
+static void cpuboost_input_disconnect(struct input_handle *handle)
+{
+	input_close_device(handle);
+	input_unregister_handle(handle);
+	kfree(handle);
+}
+
+static const struct input_device_id cpuboost_ids[] = {
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
+			 INPUT_DEVICE_ID_MATCH_ABSBIT,
+		.evbit = { BIT_MASK(EV_ABS) },
+		.absbit = { [BIT_WORD(ABS_MT_POSITION_X)] =
+			    BIT_MASK(ABS_MT_POSITION_X) |
+			    BIT_MASK(ABS_MT_POSITION_Y) },
+	}, /* multi-touch touchscreen */
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT,
+		.evbit = { BIT_MASK(EV_ABS) },
+		.absbit = { [BIT_WORD(ABS_X)] = BIT_MASK(ABS_X) }
+
+	}, /* stylus or joystick device */
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT,
+		.evbit = { BIT_MASK(EV_KEY) },
+		.keybit = { [BIT_WORD(BTN_LEFT)] = BIT_MASK(BTN_LEFT) },
+	}, /* pointer (e.g. trackpad, mouse) */
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT,
+		.evbit = { BIT_MASK(EV_KEY) },
+		.keybit = { [BIT_WORD(KEY_ESC)] = BIT_MASK(KEY_ESC) },
+	}, /* keyboard */
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
+				INPUT_DEVICE_ID_MATCH_KEYBIT,
+		.evbit = { BIT_MASK(EV_KEY) },
+		.keybit = {[BIT_WORD(BTN_JOYSTICK)] = BIT_MASK(BTN_JOYSTICK) },
+	}, /* joysticks not caught by ABS_X above */
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_EVBIT |
+				INPUT_DEVICE_ID_MATCH_KEYBIT,
+		.evbit = { BIT_MASK(EV_KEY) },
+		.keybit = { [BIT_WORD(BTN_GAMEPAD)] = BIT_MASK(BTN_GAMEPAD) },
+	}, /* gamepad */
+	{ },
+};
+
+static struct input_handler cpuboost_input_handler = {
+	.event          = cpuboost_input_event,
+	.connect        = cpuboost_input_connect,
+	.disconnect     = cpuboost_input_disconnect,
+	.name           = "cpu-boost",
+	.id_table       = cpuboost_ids,
+};
+
+static int __init cpuboost_init(void)
+{
+	int error;
+
+	error = cpufreq_register_notifier(&cpuboost_policy_nb,
+					  CPUFREQ_POLICY_NOTIFIER);
+	if (error) {
+		pr_err("failed to register input handler: %d\n", error);
+		return error;
+	}
+
+	error = input_register_handler(&cpuboost_input_handler);
+	if (error) {
+		pr_err("failed to register input handler: %d\n", error);
+		cpufreq_unregister_notifier(&cpuboost_policy_nb,
+					    CPUFREQ_POLICY_NOTIFIER);
+		return error;
+	}
+
+	return 0;
+}
+module_init(cpuboost_init);
+
+static void __exit cpuboost_exit(void)
+{
+	input_unregister_handler(&cpuboost_input_handler);
+
+	flush_work(&cpuboost_input_boost_work);
+	cancel_delayed_work_sync(&cpuboost_cancel_boost_work);
+
+	cpufreq_unregister_notifier(&cpuboost_policy_nb,
+				    CPUFREQ_POLICY_NOTIFIER);
+}
+module_exit(cpuboost_exit);
+
+MODULE_DESCRIPTION("Input event based short term CPU frequency booster");
+MODULE_LICENSE("GPL v2");
Index: kernel-rockchip/sound/soc/soc-generic-dmaengine-pcm.c
===================================================================
--- kernel-rockchip.orig/sound/soc/soc-generic-dmaengine-pcm.c
+++ kernel-rockchip/sound/soc/soc-generic-dmaengine-pcm.c
@@ -15,7 +15,7 @@
 
 #include <sound/dmaengine_pcm.h>
 
-static unsigned int prealloc_buffer_size_kbytes = 512;
+static unsigned int prealloc_buffer_size_kbytes = 1024;
 module_param(prealloc_buffer_size_kbytes, uint, 0444);
 MODULE_PARM_DESC(prealloc_buffer_size_kbytes, "Preallocate DMA buffer size (KB).");
 
Index: kernel-rockchip/drivers/power/supply/sbs-battery.c
===================================================================
--- kernel-rockchip.orig/drivers/power/supply/sbs-battery.c
+++ kernel-rockchip/drivers/power/supply/sbs-battery.c
@@ -51,6 +51,8 @@ enum {
 	REG_CHARGE_VOLTAGE,
 };
 
+#define SBS_POLL_TIME_OUT 5000
+
 #define REG_ADDR_SPEC_INFO		0x1A
 #define SPEC_INFO_VERSION_MASK		GENMASK(7, 4)
 #define SPEC_INFO_VERSION_SHIFT		4
@@ -72,6 +74,7 @@ enum sbs_capacity_mode {
 
 /* manufacturer access defines */
 #define MANUFACTURER_ACCESS_STATUS	0x0006
+#define MANUFACTURER_ACCESS_SHIP  0x0010
 #define MANUFACTURER_ACCESS_SLEEP	0x0011
 
 /* battery status value bits */
@@ -201,6 +204,7 @@ struct sbs_info {
 	struct delayed_work		work;
 	struct mutex			mode_lock;
 	u32				flags;
+  struct timer_list timer;
 };
 
 static char model_name[I2C_SMBUS_BLOCK_MAX + 1];
@@ -617,13 +621,6 @@ static int sbs_get_battery_property(stru
 
 		sbs_status_correct(client, &val->intval);
 
-		if (chip->poll_time == 0)
-			chip->last_state = val->intval;
-		else if (chip->last_state != val->intval) {
-			cancel_delayed_work_sync(&chip->work);
-			power_supply_changed(chip->power_supply);
-			chip->poll_time = 0;
-		}
 	} else {
 		if (psp == POWER_SUPPLY_PROP_STATUS)
 			val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
@@ -635,6 +632,13 @@ static int sbs_get_battery_property(stru
 		else
 			val->intval = 0;
 	}
+	if (chip->poll_time == 0)
+		chip->last_state = val->intval;
+	else if (chip->last_state != val->intval) {
+		cancel_delayed_work_sync(&chip->work);
+		power_supply_changed(chip->power_supply);
+		chip->poll_time = 0;
+	}
 
 	return 0;
 }
@@ -811,6 +815,8 @@ static int sbs_get_chemistry(struct i2c_
 		val->intval = POWER_SUPPLY_TECHNOLOGY_NiMH;
   else if (!strncasecmp(chemistry, "3613", 4))
     val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
+  else if (!strncasecmp(chemistry, "1550", 4))
+    val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
 	else
 		val->intval = POWER_SUPPLY_TECHNOLOGY_UNKNOWN;
 
@@ -998,10 +1004,14 @@ static void sbs_supply_changed(struct sb
 	struct power_supply *battery = chip->power_supply;
 	int ret;
 
-	ret = gpiod_get_value_cansleep(chip->gpio_detect);
-	if (ret < 0)
-		return;
-	sbs_update_presence(chip, ret);
+  if (chip->gpio_detect) {
+  	ret = gpiod_get_value_cansleep(chip->gpio_detect);
+  	if (ret < 0)
+  		return;
+	  sbs_update_presence(chip, ret);
+  }else {
+    sbs_update_presence(chip, 1);
+  }
 	power_supply_changed(battery);
 }
 
@@ -1071,6 +1081,58 @@ static const struct power_supply_desc sb
 	.external_power_changed = sbs_external_power_changed,
 };
 
+void sbs_timed_poll(struct timer_list * t) {
+  struct sbs_info *chip = from_timer(chip, t, timer);
+  sbs_external_power_changed(chip->power_supply);
+  mod_timer(t, jiffies + msecs_to_jiffies(SBS_POLL_TIME_OUT));
+}
+
+static inline void sbs_timed_poll_start(struct sbs_info *chip) {
+  timer_setup(&chip->timer, sbs_timed_poll, 0);
+  mod_timer(&chip->timer, jiffies + msecs_to_jiffies(SBS_POLL_TIME_OUT));
+}
+
+static inline void sbs_timed_poll_stop(struct sbs_info *chip) {
+  del_timer_sync(&chip->timer);
+}
+
+ssize_t shipping_mode_show(struct device *dev, struct device_attribute *attr,
+      char *buf) {
+  struct i2c_client *client = to_i2c_client(dev);
+  return sprintf(buf, "%d\n", sbs_read_word_data(client, sbs_data[REG_MANUFACTURER_DATA].addr));
+}
+
+ssize_t shipping_mode_store(struct device *dev, struct device_attribute *attr,
+       const char *buf, size_t count) {
+  struct i2c_client *client = to_i2c_client(dev);
+  int new_state, ret;
+  ret = kstrtoint(buf, 10, &new_state);
+  if (!ret && new_state == 16) {
+    dev_info(dev, "(%d), enter shipping mode.\n", new_state);
+    ret = sbs_write_word_data(client, sbs_data[REG_MANUFACTURER_DATA].addr, MANUFACTURER_ACCESS_SHIP);
+    if (!ret) {
+      return count;
+    }
+  }
+  dev_err(dev, "invalid parameter. %d\n", ret);
+  return count;
+}
+
+static struct device_attribute sbs_bat_attr[] = {
+  __ATTR_RW(shipping_mode),
+};
+
+static void sbs_init_sysfs(struct sbs_info *chip) {
+  int i, ret;
+  for (i = 0; i < ARRAY_SIZE(sbs_bat_attr); i++) {
+    ret = sysfs_create_file(&chip->client->dev.kobj,
+      &sbs_bat_attr[i].attr);
+    if (ret)
+      dev_err(&chip->client->dev, "create bat node(%s) error\n",
+        sbs_bat_attr[i].attr.name);
+  }
+}
+
 static int sbs_probe(struct i2c_client *client)
 {
 	struct sbs_info *chip;
@@ -1177,7 +1239,9 @@ skip_gpio:
 		rc = PTR_ERR(chip->power_supply);
 		goto exit_psupply;
 	}
-
+  if (!chip->gpio_detect)
+    sbs_timed_poll_start(chip);
+  sbs_init_sysfs(chip);
 	dev_info(&client->dev,
 		"%s: battery gas gauge device registered\n", client->name);
 
@@ -1190,7 +1254,8 @@ exit_psupply:
 static int sbs_remove(struct i2c_client *client)
 {
 	struct sbs_info *chip = i2c_get_clientdata(client);
-
+  if (!chip->gpio_detect)
+    sbs_timed_poll_stop(chip);
 	cancel_delayed_work_sync(&chip->work);
 
 	return 0;
